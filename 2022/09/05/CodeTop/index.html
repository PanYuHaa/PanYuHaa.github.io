

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon1.png">
  <link rel="icon" href="/img/favicon1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Peter Pan">
  <meta name="keywords" content="">
  
    <meta name="description" content="EASY206. 反转链表Given the head of a singly linked list, reverse the list, and return the reversed list. 123456789101112func reverseList(head *ListNode) *ListNode &amp;#123;    return help(nil, head)&amp;#125;fun">
<meta property="og:type" content="article">
<meta property="og:title" content="CodeTop">
<meta property="og:url" content="http://example.com/2022/09/05/CodeTop/index.html">
<meta property="og:site_name" content="PPStudy">
<meta property="og:description" content="EASY206. 反转链表Given the head of a singly linked list, reverse the list, and return the reversed list. 123456789101112func reverseList(head *ListNode) *ListNode &amp;#123;    return help(nil, head)&amp;#125;fun">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png">
<meta property="article:published_time" content="2022-09-05T01:27:12.000Z">
<meta property="article:modified_time" content="2022-10-13T01:04:26.838Z">
<meta property="article:author" content="Peter Pan">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png">
  
  
  <title>CodeTop - PPStudy</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="CodeTop">
              
                CodeTop
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-09-05 09:27" pubdate>
        September 5, 2022 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      51k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      426 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">CodeTop</h1>
            
            <div class="markdown-body">
              <h1 id="EASY"><a href="#EASY" class="headerlink" title="EASY"></a>EASY</h1><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> help(<span class="hljs-literal">nil</span>, head)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">help</span><span class="hljs-params">(pre, cur *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> cur == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> pre<br>    &#125;<br>    next := cur.Next<br>    cur.Next = pre<br>    <span class="hljs-keyword">return</span> help(cur, next)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="207-最大子序和"><a href="#207-最大子序和" class="headerlink" title="207. 最大子序和"></a>207. 最大子序和</h2><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p>
<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    mx := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        dp[i] = max(dp[i<span class="hljs-number">-1</span>]+nums[i], nums[i])<br>        <span class="hljs-keyword">if</span> dp[i] &gt; mx &#123;<br>            mx = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mx<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>dp[i]只有两个方向可以推出来：</p>
<ul>
<li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li>
<li>nums[i]，即：从头开始计算当前连续子序列和</li>
</ul>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>
<p>You may assume that each input would have <strong><em>exactly\</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>
<p>You can return the answer in any order.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用map方式解题，降低时间复杂度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> index, val := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> preIndex, exist := m[target-val]; exist &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;preIndex, index&#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            m[val] = index<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h2><p>Given two non-negative integers, <code>num1</code> and <code>num2</code> represented as string, return <em>the sum of</em> <code>num1</code> <em>and</em> <code>num2</code> <em>as a string</em>.</p>
<p>You must solve the problem without using any built-in library for handling large integers (such as <code>BigInteger</code>). You must also not convert the inputs to integers directly.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addStrings</span><span class="hljs-params">(String num1, String num2)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(); <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> num1.length() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记遍历到 num1 的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> num2.length() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记遍历到 num2 的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span><br>        <span class="hljs-keyword">while</span> (p1 &gt;= <span class="hljs-number">0</span> || p2 &gt;= <span class="hljs-number">0</span> || carry != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// num1 没遍历完，或 num2 没遍历完，或进位不为 0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">digit1</span> <span class="hljs-operator">=</span> p1 &gt;= <span class="hljs-number">0</span> ? num1.charAt(p1) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前 num1 的取值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">digit2</span> <span class="hljs-operator">=</span> p2 &gt;= <span class="hljs-number">0</span> ? num2.charAt(p2) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前 num2 的取值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> digit1 + digit2 + carry; <span class="hljs-comment">// 当前位置相加的结果</span><br>            carry = add &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">// 是否有进位</span><br>            add = add &gt;= <span class="hljs-number">10</span> ? add - <span class="hljs-number">10</span> : add; <span class="hljs-comment">// 去除进位后留下的数字</span><br>            res.append(add); <span class="hljs-comment">// 把去除进位后留下的数字拼接到结果中</span><br>            p1 --; <span class="hljs-comment">// 遍历到 num1 的位置向左移动</span><br>            p2 --; <span class="hljs-comment">// 遍历到 num2 的位置向左移动</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res.reverse().toString(); <span class="hljs-comment">// 把结果反转并返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>「<strong>求加法</strong>」系列题目都不难，其实就是 <strong>「列竖式」</strong> 计算。</li>
<li>需要注意的是：<ol>
<li>while循环结束条件；</li>
<li>遍历两个「加数」不要越界；</li>
<li>进位。</li>
<li>最后的结果需要翻转</li>
</ol>
</li>
</ol>
<h2 id="121-最佳时间买卖股票"><a href="#121-最佳时间买卖股票" class="headerlink" title="121. 最佳时间买卖股票"></a>121. 最佳时间买卖股票</h2><p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>
<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 贪心</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    low := math.MaxInt32<br>    rlt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> prices&#123;<br>        low = min(low, prices[i])<br>        rlt = max(rlt, prices[i]-low)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> rlt<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	length:=<span class="hljs-built_in">len</span>(prices)<br>	<span class="hljs-keyword">if</span> length==<span class="hljs-number">0</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>	dp:=<span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,length)<br>	<span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;length;i++&#123;<br>		dp[i]=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">2</span>)<br>	&#125;<br>	<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=-prices[<span class="hljs-number">0</span>]<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;length;i++&#123;<br>		dp[i][<span class="hljs-number">0</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],-prices[i])<br>		dp[i][<span class="hljs-number">1</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+prices[i])<br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[length<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a&gt;b&#123;<br>        <span class="hljs-keyword">return</span> a <br>    &#125;<br>    <span class="hljs-keyword">return</span> b <br>&#125;<br></code></pre></td></tr></table></figure>
<p>贪心就是找最小的做差</p>
<p>dp的方法就是用两个状态，买和卖，分别做推导，因为卖出状态有两个状态（前一天卖出和一直没买过）</p>
<p>如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</li>
<li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</li>
</ul>
<p>那么dp[i] [0]应该选所得现金最大的，所以dp[i] [0] = max(dp[i - 1] [0], -prices[i]);</p>
<p>如果第i天不持有股票即dp[i] [1]， 也可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</li>
<li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1] [0]</li>
</ul>
<p>细节：注意最后是用卖出的最后一天作为结果，因为卖出一定有更多的钱。</p>
<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code>exists, then return its index. Otherwise, return <code>-1</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l, r := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        mid := l + (r-l)&gt;&gt;<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>            r = mid<span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l = mid+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="94-二叉树中序遍历"><a href="#94-二叉树中序遍历" class="headerlink" title="94. 二叉树中序遍历"></a>94. 二叉树中序遍历</h2><p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// LNR</span><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    scan(root, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scan</span><span class="hljs-params">(root *TreeNode, res *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    <br>    scan(root.Left, res)<br>    *res = <span class="hljs-built_in">append</span>(*res, root.Val)<br>    scan(root.Right, res)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>
<p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    max := <span class="hljs-number">0</span><br>    depth := <span class="hljs-number">1</span><br>    dfs(root, depth, &amp;max)<br>    <span class="hljs-keyword">return</span> max<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, depth <span class="hljs-type">int</span>, max *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> depth &gt; *max &#123;<br>            *max = depth<br>        &#125;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        depth += <span class="hljs-number">1</span><br>        dfs(root.Left, depth, max)<br>        depth -= <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        depth += <span class="hljs-number">1</span><br>        dfs(root.Right, depth, max)<br>        depth -= <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于我们需要知道所有分支末端的结果，所以采用dfs+回溯的手法获取所有末枝的结果。</p>
<h2 id="509-斐波那契数列"><a href="#509-斐波那契数列" class="headerlink" title="509. 斐波那契数列"></a>509. 斐波那契数列</h2><p>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">F(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>, F(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br>F(n) = F(n - <span class="hljs-number">1</span>) + F(n - <span class="hljs-number">2</span>), <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">1.</span><br></code></pre></td></tr></table></figure>
<p>Given <code>n</code>, calculate <code>F(n)</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// dp</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n+<span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]<br>    &#125;<br>    <span class="hljs-comment">// fmt.Println(dp)</span><br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br><br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;<br>    <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最基本的dp和递归的展现</p>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> dfs(root)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    tmp := root.Right<br>    root.Right = dfs(root.Left)<br>    root.Left = dfs(tmp)<br>    <br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重点在于用tmp暂时存储，要不会出现内存重叠导致的分支重复。</p>
<p>我们不需要考虑叶子结点，只要是nil返回就ok</p>
<h2 id="144-二叉树前序遍历"><a href="#144-二叉树前序遍历" class="headerlink" title="144. 二叉树前序遍历"></a>144. 二叉树前序遍历</h2><p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(root, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, arr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    *arr = <span class="hljs-built_in">append</span>(*arr, root.Val)<br>    dfs(root.Left, arr)<br>    dfs(root.Right, arr)<br>    <br>    <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="283-移动0"><a href="#283-移动0" class="headerlink" title="283. 移动0"></a>283. 移动0</h2><p>Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    slow := <span class="hljs-number">0</span><br>    fast := <span class="hljs-number">0</span><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">0</span> &#123;<br>            fast++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums[slow], nums[fast] = nums[fast], nums[slow]<br>            slow++<br>            fast++<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 简单版本</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    slow := <span class="hljs-number">0</span><br>    fast := <span class="hljs-number">0</span><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] != <span class="hljs-number">0</span> &#123;<br>            nums[slow], nums[fast] = nums[fast], nums[slow]<br>            slow++     <br>        &#125;<br>        fast++<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 究极简单版本</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    slow := <span class="hljs-number">0</span><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> fast := <span class="hljs-number">0</span>; fast &lt; n; fast++ &#123;<br>        <span class="hljs-keyword">if</span> nums[fast] != <span class="hljs-number">0</span> &#123;<br>            nums[slow], nums[fast] = nums[fast], nums[slow]<br>            slow++     <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>else里面都++是因为要保持slow和fast之间的差距，要让fast指向最新，slow指向第一个0的位置。</p>
<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p>
<p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p>
<p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p>
<p><strong>Custom Judge:</strong></p>
<p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p>
<ul>
<li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li>
<li><code>listA</code> - The first linked list.</li>
<li><code>listB</code> - The second linked list.</li>
<li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li>
<li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li>
</ul>
<p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">//boundary check</span><br>	<span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> || headB == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>    <br>    curA := headA<br>	curB := headB<br>    <br>    <span class="hljs-comment">//if a &amp; b have different len, then we will stop the loop after second iteration</span><br>	<span class="hljs-keyword">for</span> curA != curB &#123;<br>		<span class="hljs-comment">//for the end of first iteration, we just reset the pointer to the head of another linkedlist</span><br>		<span class="hljs-keyword">if</span> curA == <span class="hljs-literal">nil</span> &#123;<br>			curA = headB<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			curA = curA.Next<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> curB == <span class="hljs-literal">nil</span> &#123;<br>			curB = headA<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			curB = curB.Next<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> curA<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这道题的思路其实类似链表找环。</p>
<p>给定的 2 个链表的长度如果一样长，都从头往后扫即可。如果不一样长，需要先“拼成”一样长。把 B 拼接到 A 后面，把 A 拼接到 B 后面。这样 2 个链表的长度都是 A + B。再依次扫描比较 2 个链表的结点是否相同。</p>
<p>第二次迭代，重复了845，说白了就是如果不齐，就将头对齐变成尾部对齐。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] <span class="hljs-string">&quot; &quot;</span> [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] <span class="hljs-string">&quot; &quot;</span> [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure>
<p>这种解法投机取巧，默认有一样的后面都相同。单纯的尾部对齐。</p>
<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	prefix := strs[<span class="hljs-number">0</span>]<br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(strs); i++ &#123;<br>		<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(prefix); j++ &#123;<br>			<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(strs[i]) &lt;= j || strs[i][j] != prefix[j] &#123;<br>				prefix = prefix[<span class="hljs-number">0</span>:j]<br>				<span class="hljs-keyword">break</span><br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> prefix<br>&#125;<br></code></pre></td></tr></table></figure>
<p>默认第一个为前缀。如果第一个是长度最小的串，那么其他的串不影响只会从j被截断。如果是长度最长的，他会因为<code>len(strs[i]) &lt;= j</code>而截断。剩下截断prefix的方式，就是如果有串内的元素对应位置是不同于prefix的话，那么就踢出当前重复串中。</p>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> isMirror(root.Left, root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isMirror</span><span class="hljs-params">(left, right *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> (left.Val == right.Val) &amp;&amp; (isMirror(left.Left, right.Right)) &amp;&amp; (isMirror(left.Right, right.Left))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>dfs的时候，先处理左右节点为空，或者有空的情况，再考虑左右节点的情况。说白了，confirm一下当前节点不为空，那么才可以深入，要不会出现空指针的情况。</p>
<h1 id="MIDDLE"><a href="#MIDDLE" class="headerlink" title="MIDDLE"></a>MIDDLE</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br>	<span class="hljs-keyword">var</span> freq [<span class="hljs-number">127</span>]<span class="hljs-type">int</span><br>	result, left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span><br><br>	<span class="hljs-keyword">for</span> left &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>		<span class="hljs-keyword">if</span> right+<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(s) &amp;&amp; freq[s[right+<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span> &#123;<br>			freq[s[right+<span class="hljs-number">1</span>]]++<br>			right++<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			freq[s[left]]--<br>			left++<br>		&#125;<br>		result = max(result, right-left+<span class="hljs-number">1</span>)<br>	&#125;<br>	<span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>滑动窗口的右边界不断的右移，只要没有重复的字符，就持续向右扩大窗口边界。一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界，然后继续移动滑动窗口的右边界。以此类推，每次移动需要计算当前长度，并判断是否需要更新最大长度，最终最大的值就是题目中的所求。</p>
<h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a>146. LRU缓存机制</h2><p>Design a data structure that follows the constraints of a <strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">Least Recently Used (LRU) cache</a></strong>.</p>
<p>Implement the <code>LRUCache</code> class:</p>
<ul>
<li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li>
<li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li>
<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li>
</ul>
<p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>    Head, Tail *Node<br>    Keys       <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Node<br>    Cap        <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    Key, Val    <span class="hljs-type">int</span><br>    Prev, Next  *Node<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>    <span class="hljs-keyword">return</span> LRUCache&#123;Keys: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Node), Cap: capacity&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cache *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> node, ok := cache.Keys[key]; ok &#123;<br>        cache.Remove(node) <span class="hljs-comment">// 从队伍里面剔除</span><br>        cache.Add(node) <span class="hljs-comment">// 放到队尾，重新插入更新一下</span><br>        <span class="hljs-keyword">return</span> node.Val<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cache *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-keyword">if</span> node, ok := cache.Keys[key]; ok &#123;<br>		node.Val = value <span class="hljs-comment">// 找到，更新key对应的value</span><br>		cache.Remove(node)<br>		cache.Add(node)<br>		<span class="hljs-keyword">return</span><br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		node = &amp;Node&#123;Key: key, Val: value&#125; <span class="hljs-comment">// 创建一个新的节点</span><br>		cache.Keys[key] = node <span class="hljs-comment">// 更新map</span><br>		cache.Add(node) <span class="hljs-comment">// 插入队尾</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cache.Keys) &gt; cache.Cap &#123; <span class="hljs-comment">// 如果超过容量了</span><br>		<span class="hljs-built_in">delete</span>(cache.Keys, cache.Tail.Key) <span class="hljs-comment">// 删除map中对应的k-v</span><br>		cache.Remove(cache.Tail) <span class="hljs-comment">// 删除队头的node</span><br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cache *LRUCache)</span></span> Add(node *Node) &#123;<br>    node.Prev = <span class="hljs-literal">nil</span><br>    node.Next = cache.Head <span class="hljs-comment">// 左边是队尾，右边是队头</span><br>    <span class="hljs-keyword">if</span> cache.Head != <span class="hljs-literal">nil</span> &#123;<br>        cache.Head.Prev = node <span class="hljs-comment">// Prev在右边，Next在左边</span><br>    &#125;<br>    cache.Head = node <span class="hljs-comment">// 更新head</span><br>    <br>    <span class="hljs-keyword">if</span> cache.Tail == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 当存储为空的时候，才如此更新，保证Tail有值，后续才好插入。</span><br>        cache.Tail = node<br>        cache.Tail.Next = <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cache *LRUCache)</span></span> Remove(node *Node) &#123;<br>    <span class="hljs-keyword">if</span> node == cache.Head &#123; <span class="hljs-comment">// 如果要移除的节点在Head（右边）</span><br>        cache.Head = node.Next <br>        node.Next = <span class="hljs-literal">nil</span> <br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> node == cache.Tail &#123; <span class="hljs-comment">// 如果要移除的节点在Tail（左边）</span><br>        cache.Tail = node.Prev<br>        node.Prev.Next = <span class="hljs-literal">nil</span><br>        node.Prev = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    node.Prev.Next = node.Next<br>    node.Next.Prev = node.Prev<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(capacity);</span><br><span class="hljs-comment"> * param_1 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p>主体结构就是map来做查询，双向链表来存储。</p>
<p>GET PUT方法中包含，add和remove，add都是对尾部的增加，remove都是对头部的剔除</p>
<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>largest element in the array</em>.</p>
<p>Note that it is the <code>kth</code> largest element in the sorted order, not the <code>kth</code> distinct element.</p>
<p>You must solve it in <code>O(n)</code> time complexity.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>		sort.Ints(nums)<br>	  <span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">len</span>(nums)-k]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>[][]<span class="hljs-type">int</span>&#123;<br>	sort.Ints(nums)<br>	res:=[][]<span class="hljs-type">int</span>&#123;&#125;<br>	<br>	<span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>;i++&#123;<br>		n1:=nums[i]<br>		<span class="hljs-keyword">if</span> n1&gt;<span class="hljs-number">0</span>&#123; <span class="hljs-comment">// 排序后如果第一个元素已经大于0后面都没有意义了</span><br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span>&amp;&amp;n1==nums[i<span class="hljs-number">-1</span>]&#123; <span class="hljs-comment">// 如果当前位和前一位是一样的，代表重复，如果和后面的一样的话等于是a不给b选择的机会了</span><br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		l,r:=i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>		<span class="hljs-keyword">for</span> l&lt;r&#123;<br>			n2,n3:=nums[l],nums[r]<br>			<span class="hljs-keyword">if</span> n1+n2+n3==<span class="hljs-number">0</span>&#123;<br>				res=<span class="hljs-built_in">append</span>(res,[]<span class="hljs-type">int</span>&#123;n1,n2,n3&#125;)<br>				<span class="hljs-keyword">for</span> l&lt;r&amp;&amp;nums[l]==n2&#123; <span class="hljs-comment">// 一直往后找找到不一样为止</span><br>					l++<br>				&#125;<br>				<span class="hljs-keyword">for</span> l&lt;r&amp;&amp;nums[r]==n3&#123; <span class="hljs-comment">// 一直往前找找到不一样为止</span><br>					r--<br>				&#125;<br>			&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n1+n2+n3&lt;<span class="hljs-number">0</span>&#123;<br>				l++<br>			&#125;<span class="hljs-keyword">else</span> &#123;<br>				r--<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>去重逻辑的思考</strong></p>
<p><strong>a的去重</strong></p>
<p>说道去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]</p>
<p>a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。</p>
<p>但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。</p>
<p>有同学可能想，这不都一样吗。</p>
<p>其实不一样！</p>
<p>都是和 nums[i]进行比较，是比较它的前一个，还是比较他的后一个。</p>
<p>如果我们的写法是 这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重操作</span><br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那就我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p>
<p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p>
<p>所以这里是有两个重复的维度。</p>
<p>那么应该这么写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。</p>
<p>这是一个非常细节的思考过程。</p>
<h2 id="912-快速排序"><a href="#912-快速排序" class="headerlink" title="912. 快速排序"></a>912. 快速排序</h2><p>Given an array of integers <code>nums</code>, sort the array in ascending order.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quick</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, start, end <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> start &lt; end &#123; <br>        pivot := nums[start]<br>        i, j := start + <span class="hljs-number">1</span>, end<br>        <br>        <span class="hljs-keyword">for</span> i &lt;= j &#123;<br>            <span class="hljs-keyword">if</span> nums[i] &lt;= pivot &#123; <span class="hljs-comment">// left smaller then the pivot, continue</span><br>                i++<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[j] &gt;= pivot &#123; <span class="hljs-comment">// right bigger than the pivot, continue</span><br>                j--<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums[j], nums[i] = nums[i], nums[j]<br>                j--<br>                i++<br>            &#125;<br>        &#125;<br>        <br>        nums[j], nums[start] = nums[start], nums[j] <span class="hljs-comment">// i meet j, then exchange</span><br>        <br>        quick(nums, start, j - <span class="hljs-number">1</span>)<br>        quick(nums, j + <span class="hljs-number">1</span>, end)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    quick(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> nums<br>&#125; <br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 交换的新写法</span><br>a := <span class="hljs-number">0</span><br>b := <span class="hljs-number">1</span><br>a, b = b, a<br></code></pre></td></tr></table></figure>
<ol>
<li>找到标兵</li>
<li>排序，要求左边都比标兵小，右边都比标兵大，交换</li>
<li>递归下一层，直到start和end相遇</li>
</ol>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 解法一 BFS</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>	&#125;<br>	queue := []*TreeNode&#123;root&#125;<br>	res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>	<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>		l := <span class="hljs-built_in">len</span>(queue)<br>		tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, l)<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l; i++ &#123;<br>            node := queue[i]<br>			<span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>				queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>			&#125;<br>			<span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>				queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>			&#125;<br>			tmp = <span class="hljs-built_in">append</span>(tmp, queue[i].Val)<br>		&#125;<br>		queue = queue[l:]<br>		res = <span class="hljs-built_in">append</span>(res, tmp)<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>队列不为空</li>
<li>用一个循环清空队列弄好新的队列</li>
<li>直到所有的队列清空，结束</li>
</ol>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h2><p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong>values).</p>
<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p>
<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>	&#125;<br>	low, high := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>	<span class="hljs-keyword">for</span> low &lt;= high &#123;<br>		mid := low + (high-low)&gt;&gt;<span class="hljs-number">1</span><br>		<span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>			<span class="hljs-keyword">return</span> mid<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; nums[low] &#123; <span class="hljs-comment">// 在数值大的一部分区间里</span><br>			<span class="hljs-keyword">if</span> nums[low] &lt;= target &amp;&amp; target &lt; nums[mid] &#123;<br>				high = mid - <span class="hljs-number">1</span><br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				low = mid + <span class="hljs-number">1</span><br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; nums[high] &#123; <span class="hljs-comment">// 在数值小的一部分区间里</span><br>			<span class="hljs-keyword">if</span> nums[mid] &lt; target &amp;&amp; target &lt;= nums[high] &#123;<br>				low = mid + <span class="hljs-number">1</span><br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				high = mid - <span class="hljs-number">1</span><br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果落在了low或者high上，low右移，high左移</span><br>			<span class="hljs-keyword">if</span> nums[low] == nums[mid] &#123;<br>				low++<br>			&#125;<br>			<span class="hljs-keyword">if</span> nums[high] == nums[mid] &#123;<br>				high--<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个和普通的二分查找有什么不一样呢？</p>
<p>因为二分的前提是本身有序，所以这个相当于用一个断点打乱了你的排序。你需要做的就是识别这个断点，由于要求O(logN)所以说不能先找到，而是要在查找的过程中识别断点。</p>
<p>左边一定比右边的大，然后low代表的大区域，high代表小区域</p>
<h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a>165. 比较版本号</h2><p>Given two version numbers, <code>version1</code> and <code>version2</code>, compare them.</p>
<p>Version numbers consist of <strong>one or more revisions</strong> joined by a dot <code>&#39;.&#39;</code>. Each revision consists of <strong>digits</strong> and may contain leading <strong>zeros</strong>. Every revision contains <strong>at least one character</strong>. Revisions are <strong>0-indexed from left to right</strong>, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example <code>2.5.33</code> and <code>0.1</code> are valid version numbers.</p>
<p>To compare version numbers, compare their revisions in <strong>left-to-right order</strong>. Revisions are compared using their <strong>integer value ignoring any leading zeros</strong>. This means that revisions <code>1</code> and <code>001</code> are considered <strong>equal</strong>. If a version number does not specify a revision at an index, then <strong>treat the revision as <code>0</code></strong>. For example, version <code>1.0</code> is less than version <code>1.1</code> because their revision 0s are the same, but their revision 1s are <code>0</code> and <code>1</code> respectively, and <code>0 &lt; 1</code>.</p>
<p><em>Return the following:</em></p>
<ul>
<li>If <code>version1 &lt; version2</code>, return <code>-1</code>.</li>
<li>If <code>version1 &gt; version2</code>, return <code>1</code>.</li>
<li>Otherwise, return <code>0</code>.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	x, y, i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span><br><br>	<span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(version1) || j &lt; <span class="hljs-built_in">len</span>(version2) &#123;<br>		x, i = readInt(version1, i+<span class="hljs-number">1</span>)<br>		y, j = readInt(version2, j+<span class="hljs-number">1</span>)<br><br>		<span class="hljs-keyword">switch</span> &#123;<br>		<span class="hljs-keyword">case</span> x &lt; y:<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>		<span class="hljs-keyword">case</span> y &lt; x:<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readInt</span><span class="hljs-params">(s <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>	result := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> ; index &lt; <span class="hljs-built_in">len</span>(s) &amp;&amp; s[index] != <span class="hljs-string">&#x27;.&#x27;</span>; index++ &#123;<br>		result = result*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(s[index]-<span class="hljs-string">&#x27;0&#x27;</span>)<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> result, index<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们要分区的思考这个问题，先找到对应的区域。<code>int(s[index]-&#39;0&#39;)</code>来转换成int，如果是英文字母的话就用<code>-&#39;a&#39;</code>来转换。这样我们对于数据的处理就是，比如12.04就是1*10 + 2，如果1的位置是0的话，则不会成为整数。</p>
<p>我们readInt函数有两个作用，一个是找到对应区间的数的整数，第二个作用是找到对应的下一个出发的index。我们不用对应位去比较，而是全部提出来然后直接比整数的大小。</p>
<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    used := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>    dfs(used, c, nums, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(used <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, c, nums []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> ok, _ := used[nums[i]]; ok &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            used[nums[i]] = <span class="hljs-literal">true</span><br>            c = <span class="hljs-built_in">append</span>(c, nums[i])<br>            dfs(used, c, nums, res)<br>            used[nums[i]] = <span class="hljs-literal">false</span><br>            c = c[:<span class="hljs-built_in">len</span>(c)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先把所有的情况都写出来，再慢慢减枝</p>
<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.</p>
<p>A string is called a palindrome string if the reverse of that string is the same as the original string.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    max := <span class="hljs-number">0</span><br>    left := <span class="hljs-number">0</span><br>    length := <span class="hljs-number">0</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(s))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(s))<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; <span class="hljs-built_in">len</span>(s); j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                <span class="hljs-keyword">if</span> j-i &lt;= <span class="hljs-number">1</span> &#123;<br>                    length = j-i<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] &#123;<br>                    length = j-i<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> length &gt; max &#123;<br>                max = length<br>                left = i<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s[left:left+max+<span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>返回主要靠记录起点和长度的结合。</p>
<p>不想等的情况肯定是不能匹配，想等的时候分三种情况，如果相差相遇等于1直接就是ok的，如果是大于的话就由他前一个状态推导出来。</p>
<h2 id="129-求根到叶子结点数字之和"><a href="#129-求根到叶子结点数字之和" class="headerlink" title="129. 求根到叶子结点数字之和"></a>129. 求根到叶子结点数字之和</h2><p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p>
<p>Each root-to-leaf path in the tree represents a number.</p>
<ul>
<li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li>
</ul>
<p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>
<p>A <strong>leaf</strong> node is a node with no children.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// solution1</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    dfs(root, root.Val, &amp;sum)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, tmp <span class="hljs-type">int</span>, sum *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        *sum += tmp<br>      	<span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        tmp = tmp*<span class="hljs-number">10</span> + root.Left.Val<br>        dfs(root.Left, tmp, sum)<br>        tmp = (tmp-root.Left.Val)/<span class="hljs-number">10</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        tmp = tmp*<span class="hljs-number">10</span> + root.Right.Val<br>        dfs(root.Right, tmp, sum)<br>        tmp = (tmp-root.Right.Val)/<span class="hljs-number">10</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// solution2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    dfs(root, root.Val, &amp;sum)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, tmpSum <span class="hljs-type">int</span>, sum *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        *sum += tmpSum<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>            dfs(root.Left, tmpSum*<span class="hljs-number">10</span> + root.Left.Val, sum)<br>        &#125;<br>        <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>            dfs(root.Right, tmpSum*<span class="hljs-number">10</span> + root.Right.Val, sum)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我这里是写成了回溯，其实是写麻烦了，并不需要回溯，我只需要知道顺着下来以后的分支总和是多少就ok。</p>
<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>
<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    result := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> grid &#123;<br>        <span class="hljs-keyword">for</span> j, value := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> value == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                visit(&amp;grid, i, j)<br>                result += <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">visit</span><span class="hljs-params">(grid *[][]<span class="hljs-type">byte</span>, i <span class="hljs-type">int</span>, j <span class="hljs-type">int</span>)</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(*grid), <span class="hljs-built_in">len</span>((*grid)[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) || (i &gt;= m) || (j &lt; <span class="hljs-number">0</span>) || (j &gt;= n) || ((*grid)[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    (*grid)[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>    <br>    visit(grid, i<span class="hljs-number">-1</span>, j)<br>    visit(grid, i+<span class="hljs-number">1</span>, j)<br>    visit(grid, i, j<span class="hljs-number">-1</span>)<br>    visit(grid, i, j+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>要求找出地图中的孤岛。孤岛的含义是四周被海水包围的岛。</li>
<li>这一题可以按照第 79 题的思路进行搜索，只要找到为 “1” 的岛以后，从这里开始搜索这周连通的陆地，也都标识上访问过。每次遇到新的 “1” 且没有访问过，就相当于遇到了新的岛屿了。</li>
</ul>
<p>DFS的题</p>
<p>两种思路，上述思路是直接将海岛变成海水，还有一个思路就是标记浏览过哪个。</p>
<p>相当于我进入一个岛屿，只要他是岛屿我就感染他变成，海水。这样剩下的大循环去找也不能发现多余的岛屿了。一种类似于感染的思想。</p>
<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h2><p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spiralOrder</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(matrix)<br>    n := <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    idx, sum := <span class="hljs-number">0</span>, m*n<br>    arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m*n)<br>    <br>    top := <span class="hljs-number">0</span><br>    bottom := m<span class="hljs-number">-1</span><br>    left := <span class="hljs-number">0</span><br>    right := n<span class="hljs-number">-1</span><br>    <br>    <span class="hljs-keyword">for</span> idx &lt; sum &#123;<br>        <span class="hljs-keyword">for</span> i := left; i &lt;= right &amp;&amp; idx &lt; sum; i++ &#123;<br>            arr[idx] = matrix[top][i]<br>            idx++<br>        &#125;<br>        top++<br><br>        <span class="hljs-keyword">for</span> i := top; i &lt;= bottom &amp;&amp; idx &lt; sum; i++ &#123;<br>            arr[idx] = matrix[i][right]<br>            idx++<br>        &#125;<br>        right--<br><br>        <span class="hljs-keyword">for</span> i := right; i &gt;= left &amp;&amp; idx &lt; sum; i-- &#123;<br>            arr[idx] = matrix[bottom][i]<br>            idx++<br>        &#125;<br>        bottom--<br><br>        <span class="hljs-keyword">for</span> i := bottom; i &gt;= top &amp;&amp; idx &lt; sum; i-- &#123;<br>            arr[idx] = matrix[i][left]<br>            idx++<br>        &#125;<br>        left++<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意循环的区间一定要：有idx&lt;sum防止，加完idx还往后继续走。所以外层一个判断，内层一个判断。</p>
<h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h2><p>Given an integer array <code>nums</code>, return the length of the longest strictly increasing subsequence.</p>
<p>A <strong>subsequence</strong> is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, <code>[3,6,2,7]</code> is a subsequence of the array <code>[0,3,1,6,2,2,7]</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划求解</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// dp数组的定义 dp[i]表示取第i个元素的时候，表示子序列的长度，其中包括 nums[i] 这个元素</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br><br>    <span class="hljs-comment">// 初始化，所有的元素都应该初始化为1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-number">1</span><br>    &#125;<br><br>    ans := dp[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[j] &#123;<br>                dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> dp[i] &gt; ans &#123;<br>            ans = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>    &#125;<br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br>    dfs(n, n, <span class="hljs-string">&quot;&quot;</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(lindex, rindex <span class="hljs-type">int</span>, str <span class="hljs-type">string</span>, res *[]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> lindex == <span class="hljs-number">0</span> &amp;&amp; rindex == <span class="hljs-number">0</span> &#123;<br>        *res = <span class="hljs-built_in">append</span>(*res, str)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> lindex &gt; <span class="hljs-number">0</span> &#123;<br>        dfs(lindex<span class="hljs-number">-1</span>, rindex, str+<span class="hljs-string">&quot;(&quot;</span>, res)<br>    &#125;<br>    <span class="hljs-keyword">if</span> rindex &gt; <span class="hljs-number">0</span> &amp;&amp; lindex &lt; rindex &#123;<br>        dfs(lindex, rindex<span class="hljs-number">-1</span>, str+<span class="hljs-string">&quot;)&quot;</span>, res)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们的思路是dfs，因为是个组合问题，现在着眼于这么实现呢？我们设定lindex和rindex作为左右括号的储备库，然后进行匹配，只要库里面还有储备就排列进去，然后注意右括号一定是在左括号小于左括号数量的时候进行匹配，要不然会出现左括号不匹配右括号的。</p>
<h2 id="19-删除倒数第k个节点"><a href="#19-删除倒数第k个节点" class="headerlink" title="19. 删除倒数第k个节点"></a>19. 删除倒数第k个节点</h2><p>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>	fakeHead := &amp;ListNode&#123;Next: head&#125;<br>	preSlow, slow, fast := fakeHead, head, head<br>	<span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> &#123;<br>			preSlow = slow<br>			slow = slow.Next<br>		&#125;<br>		n--<br>		fast = fast.Next<br>	&#125;<br>	preSlow.Next = slow.Next<br>	<span class="hljs-keyword">return</span> fakeHead.Next<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这道题比较简单，先循环一次拿到链表的总长度，然后循环到要删除的结点的前一个结点开始删除操作。需要注意的一个特例是，有可能要删除头结点，要单独处理。</p>
<p>这道题有一种特别简单的解法。设置 2 个指针，一个指针距离前一个指针 n 个距离。同时移动 2 个指针，2 个指针都移动相同的距离。当一个指针移动到了终点，那么前一个指针就是倒数第 n 个节点了。</p>
<h2 id="322-零钱交换"><a href="#322-零钱交换" class="headerlink" title="322. 零钱交换"></a>322. 零钱交换</h2><p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>
<p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>	<span class="hljs-comment">// 初始化dp[0]</span><br>	dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>	<span class="hljs-comment">// 遍历背包,从1开始</span><br>	<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= amount; j++ &#123;<br>		<span class="hljs-comment">// 初始化为math.MaxInt32</span><br>		dp[j] = math.MaxInt32<br>		<span class="hljs-comment">// 遍历物品</span><br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(coins); i++ &#123;<br>			<span class="hljs-keyword">if</span> j &gt;= coins[i]&#123;<br>				<span class="hljs-comment">// 推导公式</span><br>				dp[j] = min(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>)<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 没找到能装满背包的, 就返回-1</span><br>	<span class="hljs-keyword">if</span> dp[amount] == math.MaxInt32 &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>初始化为amount+1是因为是从0开始算的，但是最终背包的容量是amount</p>
<p>遍历物品放入背包中，只要是当前的币值没有大于最终amount就可以有资格放入（因为我们追求更大的币值，更少的币数）。这时进行递推两种状态，状态一：不放入币；状态二：放入币（找前一个状态），我们尽可能放入更少的硬币满足当前的币值。最终迭代到最后，发现只要dp[amount]==math.MaxInt32的话，那么代表他没有被更新，代表容量并没有被装满肯定是错误的返回-1。</p>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p>Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//先从小到大排序</span><br>    sort.Slice(intervals,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>]&lt;intervals[j][<span class="hljs-number">0</span>]<br>    &#125;)<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-comment">//再弄重复的</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(intervals)<span class="hljs-number">-1</span>;i++&#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">1</span>]&gt;=intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&#123;<br>            intervals[i][<span class="hljs-number">1</span>]=max(intervals[i][<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<span class="hljs-comment">//赋值最大值</span><br>            intervals=<span class="hljs-built_in">append</span>(intervals[:i+<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">2</span>:]...)<br>            i--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> intervals<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a&gt;b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>1、先将区间按照左起点的顺序排序。</p>
<p>2、从第一个区间开始遍历，如果前者的右边界大于等于了后者的左边界，那就可以进行合并。将前者的右边界更新为（前者右边界或后者后边界的最大值）。</p>
<p>3、剔除后者区间（让前者append上后者的后者），再i—归档</p>
<h2 id="695-最大岛屿数量"><a href="#695-最大岛屿数量" class="headerlink" title="695. 最大岛屿数量"></a>695. 最大岛屿数量</h2><p>You are given an <code>m x n</code> binary matrix <code>grid</code>. An island is a group of <code>1</code>‘s (representing land) connected <strong>4-directionally</strong> (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>The <strong>area</strong> of an island is the number of cells with a value <code>1</code> in the island.</p>
<p>Return <em>the maximum <strong>area</strong> of an island in</em> <code>grid</code>. If there is no island, return <code>0</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> grid &#123;<br>        <span class="hljs-keyword">for</span> j, value := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> value == <span class="hljs-number">1</span> &#123;<br>                count := <span class="hljs-number">0</span><br>                dfs(&amp;grid, &amp;count, &amp;res, i, j)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid *[][]<span class="hljs-type">int</span>, count, res *<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(*grid), <span class="hljs-built_in">len</span>((*grid)[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) || (i &gt;= m) || (j &lt; <span class="hljs-number">0</span>) || (j &gt;= n) || ((*grid)[i][j] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    (*grid)[i][j] = <span class="hljs-number">0</span><br>    *count++<br>    <span class="hljs-keyword">if</span> *count &gt; *res &#123;*res = *count&#125;<br>    <br>    dfs(grid, count, res, i+<span class="hljs-number">1</span>, j)<br>    dfs(grid, count, res, i<span class="hljs-number">-1</span>, j)<br>    dfs(grid, count, res, i, j+<span class="hljs-number">1</span>)<br>    dfs(grid, count, res, i, j<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>这一题和第 200 题，第 1254 题解题思路是一致的。DPS 深搜。这不过这一题需要多处理 2 件事情，一个是注意靠边缘的岛屿不能计算在内，二是动态维护岛屿的最大面积。</li>
<li>注意count一定要是指针，要不然当他有两个分支的时候count不是累加而是单纯的增加一</li>
</ul>
<h2 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a>103. 二叉树的锯齿形层次遍历</h2><p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes’ values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;&#125;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    queue := []*TreeNode&#123;root&#125;<br>    flag := <span class="hljs-literal">true</span> <span class="hljs-comment">// flag true = l to r, flag false = r to l</span><br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        l := <span class="hljs-built_in">len</span>(queue)<br>		tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, l)<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l; i++ &#123;<br>            node := queue[i]<br>			<span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>				queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>			&#125;<br>			<span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>				queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>			&#125;<br>            <span class="hljs-keyword">if</span> flag &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, queue[i].Val)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, queue[l-i<span class="hljs-number">-1</span>].Val)<br>            &#125;<br>		&#125;<br>		queue = queue[l:]<br>    flag =!flag<br>		res = <span class="hljs-built_in">append</span>(res, tmp)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<p>之前顺序弄的不好，想的是反向放入，其实反向提取更好理解。</p>
<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h2><p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(target <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	left, sum, res := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span><br>	<span class="hljs-keyword">for</span> right, v := <span class="hljs-keyword">range</span> nums &#123;<br>		sum += v<br>		<span class="hljs-keyword">for</span> sum &gt;= target &#123;<br>			res = min(res, right-left+<span class="hljs-number">1</span>)<br>			sum -= nums[left]<br>			left++<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> res == <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> a &gt; b &#123;<br>		<span class="hljs-keyword">return</span> b<br>	&#125;<br>	<span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p>滑动窗口思想，排好序列的，还有连续子序列的都考虑滑动窗口。</p>
<h2 id="718-最长重复子序列"><a href="#718-最长重复子序列" class="headerlink" title="718. 最长重复子序列"></a>718. 最长重复子序列</h2><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>the maximum length of a subarray that appears in <strong>both</strong> arrays</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLength</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(nums1)<br>    n := <span class="hljs-built_in">len</span>(nums2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> dp[i][j] &gt; res &#123;<br>                res = dp[i][j]<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//fmt.Println(dp[i][1:])</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<p>根据dp[i] [j]的定义，dp[i] [j]的状态只能由dp[i - 1] [j - 1]推导出来。</p>
<p>即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] = dp[i - 1] [j - 1] + 1;</p>
<p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p>
<h2 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384. 打乱数组"></a>384. 打乱数组</h2><p>Given an integer array <code>nums</code>, design an algorithm to randomly shuffle the array. All permutations of the array should be <strong>equally likely</strong> as a result of the shuffling.</p>
<p>Implement the <code>Solution</code> class:</p>
<ul>
<li><code>Solution(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>
<li><code>int[] reset()</code> Resets the array to its original configuration and returns it.</li>
<li><code>int[] shuffle()</code> Returns a random shuffling of the array.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Solution <span class="hljs-keyword">struct</span> &#123;<br>    nums []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> Solution &#123;<br>    <span class="hljs-keyword">return</span> Solution&#123;<br>		nums: nums,<br>	&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Solution)</span></span> Reset() []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.nums<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Solution)</span></span> Shuffle() []<span class="hljs-type">int</span> &#123;<br>  arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(this.nums))<br>	<span class="hljs-built_in">copy</span>(arr, this.nums)<br>	rand.Shuffle(<span class="hljs-built_in">len</span>(arr), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>		arr[i], arr[j] = arr[j], arr[i]<br>	&#125;)<br>	<span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用rand.Shuffle()函数。</p>
<p>用copy复制新空间的数组，不会破坏本身对象自己的数组。</p>
<h2 id="62-独一无二的路径"><a href="#62-独一无二的路径" class="headerlink" title="62. 独一无二的路径"></a>62. 独一无二的路径</h2><p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>
<p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>
<p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>		dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>		dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>	&#125;<br>    <br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只能向下后或者向右，所以初始化希望是纵列和横列全都初始化为1</p>
<p>当前位置就是由上一个状态推出来的，并且上一个状态都来自于上边或者左边。</p>
<h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a>93. 复原IP地址</h2><p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p>
<ul>
<li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li>
</ul>
<p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into</em> <code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br>		<span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>	&#125;<br>	res, ip := []<span class="hljs-type">string</span>&#123;&#125;, []<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ip, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s <span class="hljs-type">string</span>, start, cut <span class="hljs-type">int</span>, ip []<span class="hljs-type">int</span>, res *[]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> cut == <span class="hljs-number">4</span> &amp;&amp; start == <span class="hljs-built_in">len</span>(s) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ip))<br>        <span class="hljs-built_in">copy</span>(tmp, ip)<br>        resIp := getIp(tmp)<br>        *res = <span class="hljs-built_in">append</span>(*res, resIp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> cut &gt; <span class="hljs-number">4</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        sub := s[start : i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> isValid(sub) &#123;<br>            tmp, _ := strconv.Atoi(sub)<br>            ip = <span class="hljs-built_in">append</span>(ip, tmp)<br>            cut++<br>            dfs(s, i + <span class="hljs-number">1</span>, cut, ip, res)<br>            ip = ip[:<span class="hljs-built_in">len</span>(ip) - <span class="hljs-number">1</span>]<br>            cut--<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; <span class="hljs-built_in">len</span>(s) != <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 0开头的不可以</span><br>    tmp, _ := strconv.Atoi(s)<br>    <span class="hljs-keyword">if</span> (tmp &gt; <span class="hljs-number">255</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIp</span><span class="hljs-params">(ip []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    resIp := strconv.Itoa(ip[<span class="hljs-number">0</span>])<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(ip); i++ &#123;<br>		resIp += <span class="hljs-string">&quot;.&quot;</span> + strconv.Itoa(ip[i])<br>	&#125;<br>	<span class="hljs-keyword">return</span> resIp<br>&#125;<br></code></pre></td></tr></table></figure>
<p>getIp函数用来组装ip</p>
<p>isValid用来校验是否合法（开头不能是0，并且不能大于255）</p>
<p>合法并且总共遍历完成了就算是一个结果，每次存的都是一个数。</p>
<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>Implement the <code>MinStack</code> class:</p>
<ul>
<li><code>MinStack()</code> initializes the stack object.</li>
<li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>
<li><code>void pop()</code> removes the element on the top of the stack.</li>
<li><code>int top()</code> gets the top element of the stack.</li>
<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>
</ul>
<p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MinStack define</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>	elements, min []<span class="hljs-type">int</span><br>	l             <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">/** initialize your data structure here. */</span><br><br><span class="hljs-comment">// Constructor define</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>	<span class="hljs-keyword">return</span> MinStack&#123;<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// Push define</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>	this.elements = <span class="hljs-built_in">append</span>(this.elements, x)<br>	<span class="hljs-keyword">if</span> this.l == <span class="hljs-number">0</span> &#123;<br>		this.min = <span class="hljs-built_in">append</span>(this.min, x)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		min := this.GetMin()<br>		<span class="hljs-keyword">if</span> x &lt; min &#123;<br>			this.min = <span class="hljs-built_in">append</span>(this.min, x)<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			this.min = <span class="hljs-built_in">append</span>(this.min, min)<br>		&#125;<br>	&#125;<br>	this.l++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop() &#123;<br>	this.l--<br>	this.min = this.min[:this.l]<br>	this.elements = this.elements[:this.l]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">return</span> this.elements[this.l<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">return</span> this.min[this.l<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只是加入了最小值属性的栈。</p>
<p>为什么一定要用min的数组呢，是为了pop函数而考虑的，因为你pop以后如果min是当前弹出的数值，那么你的min就错误了，所以保证min弹出以后还是有替补的，就需要有个min数组保证替补。min记录的是当前数值进入时候的最小值状态，所以可以实现。</p>
<h2 id="105-从前序与中序遍历序列构建二叉树"><a href="#105-从前序与中序遍历序列构建二叉树" class="headerlink" title="105. 从前序与中序遍历序列构建二叉树"></a>105. 从前序与中序遍历序列构建二叉树</h2><p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// preorder N L R</span><br><span class="hljs-comment">// inorder  L N R</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    root := &amp;TreeNode&#123;Val: preorder[<span class="hljs-number">0</span>]&#125;<br>    <span class="hljs-keyword">for</span> pos, node := <span class="hljs-keyword">range</span> inorder &#123;<br>		<span class="hljs-keyword">if</span> node == root.Val &#123; <span class="hljs-comment">// 找到inorder中的 L N R 中的N，从他的左右分开，进行递归进入深一层。</span><br>			root.Left = buildTree(preorder[<span class="hljs-number">1</span>:pos+<span class="hljs-number">1</span>], inorder[:pos])<br>			root.Right = buildTree(preorder[pos+<span class="hljs-number">1</span>:], inorder[pos+<span class="hljs-number">1</span>:])<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>preorder要从1开始因为N已经被我提取出来了。</p>
<p>核心就是N就是同一个N</p>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;<br>	fakehead := &amp;ListNode&#123;Val: <span class="hljs-number">0</span>&#125;<br>	n1, n2, carry, current := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, fakehead<br>	<span class="hljs-keyword">for</span> l1 != <span class="hljs-literal">nil</span> || l2 != <span class="hljs-literal">nil</span> || carry != <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">if</span> l1 == <span class="hljs-literal">nil</span> &#123;<br>			n1 = <span class="hljs-number">0</span><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			n1 = l1.Val<br>			l1 = l1.Next<br>		&#125;<br>		<span class="hljs-keyword">if</span> l2 == <span class="hljs-literal">nil</span> &#123;<br>			n2 = <span class="hljs-number">0</span><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			n2 = l2.Val<br>			l2 = l2.Next<br>		&#125;<br>		current.Next = &amp;ListNode&#123;Val: (n1 + n2 + carry) % <span class="hljs-number">10</span>&#125; <span class="hljs-comment">// 获取个位</span><br>		current = current.Next<br>		carry = (n1 + n2 + carry) / <span class="hljs-number">10</span> <span class="hljs-comment">// 获取进位</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fakehead.Next<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了处理方法统一，可以先建立一个虚拟头结点，这个虚拟头结点的 Next 指向真正的 head，这样 head 不需要单独处理，直接 while 循环即可。另外判断循环终止的条件不用是 p.Next ！= nil，这样最后一位还需要额外计算，循环终止条件应该是 p != nil。</p>
<p>负负得正，只是加法方向从左往右走了。</p>
<h2 id="64-最短路径和"><a href="#64-最短路径和" class="headerlink" title="64. 最短路径和"></a>64. 最短路径和</h2><p>Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p>
<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 解法一 原地 DP，无辅助空间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>		grid[i][<span class="hljs-number">0</span>] += grid[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]<br>	&#125;<br>	<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>		grid[<span class="hljs-number">0</span>][j] += grid[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>]<br>	&#125;<br>  <br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>		<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>			grid[i][j] += min(grid[i<span class="hljs-number">-1</span>][j], grid[i][j<span class="hljs-number">-1</span>])<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不能用dfs的枚举法要不然会报错，超时。只能用dp来减少重复路径的计算。</p>
<h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h2><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>
<p><strong>Note:</strong> You must not use any built-in BigInteger library or convert the inputs to integer directly.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiply</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">if</span> num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span><br>	&#125;<br>	b1, b2, tmp := []<span class="hljs-type">byte</span>(num1), []<span class="hljs-type">byte</span>(num2), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(num1)+<span class="hljs-built_in">len</span>(num2))<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(b1); i++ &#123;<br>		<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(b2); j++ &#123;<br>			tmp[i+j+<span class="hljs-number">1</span>] += <span class="hljs-type">int</span>(b1[i]-<span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-type">int</span>(b2[j]-<span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-comment">//fmt.Println(tmp)</span><br>		&#125;<br>	&#125;<br>    <span class="hljs-comment">//fmt.Println()</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(tmp) - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>		tmp[i<span class="hljs-number">-1</span>] += tmp[i] / <span class="hljs-number">10</span><br>		tmp[i] = tmp[i] % <span class="hljs-number">10</span><br>        <span class="hljs-comment">//fmt.Println(tmp)</span><br>	&#125;<br>  <span class="hljs-comment">// 消除最高位没有进位的情况。</span><br>	<span class="hljs-keyword">if</span> tmp[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &#123;<br>		tmp = tmp[<span class="hljs-number">1</span>:]<br>	&#125;<br>  <span class="hljs-comment">// int 转 byte</span><br>	res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(tmp))<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmp); i++ &#123;<br>		res[i] = <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-type">byte</span>(tmp[i])<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(res)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>用数组模拟乘法。创建一个数组长度为 <code>len(num1) + len(num2)</code> 的数组用于存储乘积。对于任意 <code>0 ≤ i &lt; len(num1)</code>，<code>0 ≤ j &lt; len(num2)</code>，<code>num1[i] * num2[j]</code> 的结果位于 <code>tmp[i+j+1]</code>，如果 <code>tmp[i+j+1]≥10</code>，则将进位部分加到 <code>tmp[i+j]</code>。最后，将数组 <code>tmp</code> 转成字符串，如果最高位是 0 则舍弃最高位。</li>
</ul>
<p>首先经过测试</p>
<p>[0 81 162 243 170 1]<br>[0 81 162 260 0 1]<br>[0 81 188 0 0 1]<br>[0 99 8 0 0 1]<br>[9 9 8 0 0 1]</p>
<p>999 <em> 999 最高只是998001，所以说不会出现最高位超过10的情况。长度定为 len(num1) + len(num2) 也是经过测试的最高长度。如果是100 </em> 100 最低位也得有 len(num1) + len(num2) - 1个有效位。</p>
<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h2><p>You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p>
<p>You have to rotate the image <strong>in-place</strong>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span>  &#123;<br>    length := <span class="hljs-built_in">len</span>(matrix)<br>    <span class="hljs-comment">// rotate by diagonal 对角线变换</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br>		<span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; length; j++ &#123;<br>			matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>		&#125;<br>	&#125;<br>    <span class="hljs-comment">// rotate by vertical centerline 竖直轴对称翻转</span><br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; (length/<span class="hljs-number">2</span>); col++ &#123;<br>        <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; length; row++ &#123;<br>            matrix[row][col], matrix[row][length-col<span class="hljs-number">-1</span>] = matrix[row][length-col<span class="hljs-number">-1</span>], matrix[row][col]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>[1,2,3]<br>[4,5,6]<br>[7,8,9]</p>
<p>[1,4,7]<br>[2,5,8]<br>[3,6,9]</p>
<p>[7,4,1]<br>[8,5,2]<br>[9,6,3]</p>
<p>先对角线翻转，再左右翻转</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br>		<span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; length; j++ &#123;<br>			matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>
<p>经典对角线互换。</p>
<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h2><p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rightSideView</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>	&#125;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br>	queue := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        length := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> i == length<span class="hljs-number">-1</span> &#123;<br>                res = <span class="hljs-built_in">append</span>(res, node.Val)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>	<span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>		<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>	&#125;<br>	<span class="hljs-comment">// dp[i] 代表抢 nums[0...i] 房子的最大价值</span><br>	dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>	dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>], max(nums[<span class="hljs-number">1</span>], nums[<span class="hljs-number">0</span>])<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>		dp[i] = max(dp[i<span class="hljs-number">-1</span>], nums[i]+dp[i<span class="hljs-number">-2</span>])<br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>非常牛！潘潘，你识别出来了dp，并且有个很牛的一点，你递推公式差点成功了，这次是欠考虑要找0 to i区间的最大值，而写的是前两个，他其实找的是当前前面所有中最大的。总之是很不错的。</p>
<h2 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h2><p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *Node)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    queue := []*Node&#123;root&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        length := <span class="hljs-built_in">len</span>(queue) <br>        tmp := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            tmp = <span class="hljs-built_in">append</span>(tmp, node.Val) <br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <br>            m := <span class="hljs-built_in">len</span>(node.Children)<br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Children[i])<br>            &#125;<br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, tmp)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<p>跟二叉树的层序遍历差不多。</p>
<h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h2><p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>
<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code>will be separated by at least one space.</p>
<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>
<p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 调用外部工具版本</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords151</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	ss := strings.Fields(s)<br>	reverse151(&amp;ss, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(ss)<span class="hljs-number">-1</span>)<br>	<span class="hljs-keyword">return</span> strings.Join(ss, <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse151</span><span class="hljs-params">(m *[]<span class="hljs-type">string</span>, i <span class="hljs-type">int</span>, j <span class="hljs-type">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">for</span> i &lt;= j &#123;<br>		(*m)[i], (*m)[j] = (*m)[j], (*m)[i]<br>		i++<br>		j--<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 自己写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    b := []<span class="hljs-type">byte</span>(s)<br>    b = trim(b)<br>    b = reverse(b)<br>    b = findWordAndReverse(b)<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(b)<br>&#125;<br><br><span class="hljs-keyword">const</span> SPACE = <span class="hljs-type">byte</span>(<span class="hljs-type">rune</span>(<span class="hljs-string">&#x27; &#x27;</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trim</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    <span class="hljs-comment">//trim start space</span><br>    <span class="hljs-keyword">for</span> s[<span class="hljs-number">0</span>] == SPACE &#123;<br>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i&lt;<span class="hljs-built_in">len</span>(s);i++ &#123;<br>            s[i<span class="hljs-number">-1</span>] = s[i]<br>        &#125;<br>        s = s[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]<br>    &#125;<br>    <br>    <span class="hljs-comment">//trim mid space</span><br>    <br>    l := <span class="hljs-number">1</span><br>    swap :=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;        <br>        <span class="hljs-keyword">if</span> s[i] == SPACE &amp;&amp; s[i<span class="hljs-number">-1</span>] == SPACE &#123;<br>            swap++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> i!=l &#123;<br>                s[l] = s[i]<br>            &#125;<br>            l++  <br>        &#125;<br>    &#125;<br>    s = s[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(s)-swap]<br>    <br>    <br>    <span class="hljs-comment">//trim end space</span><br>    l = <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> ; l &gt; <span class="hljs-number">0</span>; l-- &#123;<br>        <span class="hljs-keyword">if</span> s[l] != SPACE &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125; <br><br>    <span class="hljs-keyword">return</span> s[<span class="hljs-number">0</span>:l+<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s)-i; i++ &#123;<br>        s[i], s[<span class="hljs-built_in">len</span>(s)-i<span class="hljs-number">-1</span>] = s[<span class="hljs-built_in">len</span>(s)-i<span class="hljs-number">-1</span>], s[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findWordAndReverse</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    prev := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span>  i == <span class="hljs-built_in">len</span>(s) || s[i] == SPACE &#123;<br>            reverse(s[prev:i])<br>            prev = i+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;  <br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先剪枝，两次反转，反转全部+反转每个单词。</p>
<h2 id="19-删除链表倒数第N个节点"><a href="#19-删除链表倒数第N个节点" class="headerlink" title="19. 删除链表倒数第N个节点"></a>19. 删除链表倒数第N个节点</h2><p>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    fakeHead := &amp;ListNode&#123;Next: head&#125;<br>    slow := fakeHead<br>    fast := head<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        fast = fast.Next<br>    &#125;<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next<br>    &#125;<br>    slow.Next = slow.Next.Next<br>    <span class="hljs-keyword">return</span> fakeHead.Next<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h2><p>A <strong>permutation</strong> of an array of integers is an arrangement of its members into a sequence or linear order.</p>
<ul>
<li>For example, for <code>arr = [1,2,3]</code>, the following are all the permutations of <code>arr</code>: <code>[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]</code>.</li>
</ul>
<p>The <strong>next permutation</strong> of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the <strong>next permutation</strong> of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).</p>
<ul>
<li>For example, the next permutation of <code>arr = [1,2,3]</code> is <code>[1,3,2]</code>.</li>
<li>Similarly, the next permutation of <code>arr = [2,3,1]</code> is <code>[3,1,2]</code>.</li>
<li>While the next permutation of <code>arr = [3,2,1]</code> is <code>[1,2,3]</code> because <code>[3,2,1]</code> does not have a lexicographical larger rearrangement.</li>
</ul>
<p>Given an array of integers <code>nums</code>, <em>find the next permutation of</em> <code>nums</code>.</p>
<p>The replacement must be in place and use only constant extra memory.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>		<span class="hljs-keyword">if</span> nums[i] &lt; nums[i+<span class="hljs-number">1</span>] &#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">for</span> j = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; j &gt; i; j-- &#123;<br>			<span class="hljs-keyword">if</span> nums[j] &gt; nums[i] &#123;<br>				<span class="hljs-keyword">break</span><br>			&#125;<br>		&#125;<br>		swap(&amp;nums, i, j)<br>	&#125;<br>    <br>    <span class="hljs-comment">// 如果没有找到，跳过前两步，只需要反转全部即可。如果找到了后面（i+1）的区间一定是降序的</span><br>    reverse(&amp;nums, i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(nums *[]<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">for</span> i &lt; j &#123;<br>		swap(nums, i, j)<br>		i++<br>		j--<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(nums *[]<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>	(*nums)[i], (*nums)[j] = (*nums)[j], (*nums)[i]<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>题目有 3 个问题需要解决。如何找到下一个排列。不存在下一个排列的时候如何生成最小的排列。如何原地修改。先解决第一个问题，如何找到下一个排列。下一个排列是找到一个大于当前排序的字典序，且变大的幅度最小。那么只能将较小的数与较大数做一次原地交换。并且较小数的下标要尽量靠右，较大数也要尽可能小。原地交换以后，还需要将较大数右边的数按照升序重新排列。这样交换以后，才能生成下一个排列。以排列 [8,9,6,10,7,2] 为例：能找到的符合条件的一对「较小数」与「较大数」的组合为 6 与 7，满足「较小数」尽量靠右，而「较大数」尽可能小。当完成交换后排列变为 [8,9,7,10,6,2]，此时我们可以重排「较小数」右边的序列，序列变为 [8,9,7,2,6,10]。</li>
<li>第一步：在 <code>nums[i]</code> 中找到 <code>i</code> 使得 <code>nums[i] &lt; nums[i+1]</code>，此时较小数为 <code>nums[i]</code>，并且 <code>[i+1, n)</code> 一定为下降区间。第二步：如果找到了这样的 <code>i</code> ，则在下降区间 <code>[i+1, n)</code> 中从后往前找到第一个 <code>j</code> ，使得 <code>nums[i] &lt; nums[j]</code> ，此时较大数为 <code>nums[j]</code>。第三步，交换 <code>nums[i]</code> 和 <code>nums[j]</code>，此时区间 <code>[i+1, n)</code> 一定为降序区间。最后原地交换 <code>[i+1, n)</code> 区间内的元素，使其变为升序，无需对该区间进行排序。（n为数组的长度）</li>
<li>如果第一步找不到符合条件的下标 <code>i</code>，说明当前序列已经是一个最大的排列。那么应该直接执行第三步，生成最小的排列。</li>
</ul>
<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// stop</span><br>    <span class="hljs-keyword">if</span> root == p || root == q || root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <br>    <span class="hljs-comment">// left</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br>    <span class="hljs-comment">// right</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br>    <br>    <span class="hljs-comment">// root</span><br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们从下往上找，如果说此节点的左子树和右子树中同时都找到了p和q那么就返回此节点（为什么一定是呢？因为是二叉树，所以左右都有就可以。）如果增加这个题的难度，那么就是多叉树怎么做呢，一样的只要判断能同时找到多个节点的节点，就是公共祖先。</p>
<h1 id="HARD"><a href="#HARD" class="headerlink" title="HARD"></a>HARD</h1><h2 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25. K个一组翻转链表"></a>25. K个一组翻转链表</h2><p>Given the <code>head</code> of a linked list, reverse the nodes of the list <code>k</code> at a time, and return <em>the modified list</em>.</p>
<p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.</p>
<p>You may not alter the values in the list’s nodes, only nodes themselves may be changed.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>	curr := head<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>		<span class="hljs-keyword">if</span> curr == <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> head<br>		&#125;<br>		curr = curr.Next<br>	&#125;<br>	newHead := reverse(head, curr) <span class="hljs-comment">// curr此时是下一个的开头</span><br>	head.Next = reverseKGroup(curr, k)<br>	<span class="hljs-keyword">return</span> newHead<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(first *ListNode, last *ListNode)</span></span> *ListNode &#123;<br>    curr := first<br>	prev := last<br>	<span class="hljs-keyword">for</span> curr != last &#123;<br>		tmp := curr.Next<br>		curr.Next = prev<br>		prev = curr<br>		curr = tmp<br>	&#125;<br>	<span class="hljs-keyword">return</span> prev<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum:=<span class="hljs-number">0</span><br>    n:=<span class="hljs-built_in">len</span>(height)<br>    lh:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)<br>    rh:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)<br>    lh[<span class="hljs-number">0</span>]=height[<span class="hljs-number">0</span>]<br>    rh[n<span class="hljs-number">-1</span>]=height[n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;<br>        lh[i]=max(lh[i<span class="hljs-number">-1</span>],height[i])<br>    &#125;<br>    <span class="hljs-keyword">for</span> i:=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;<br>        rh[i]=max(rh[i+<span class="hljs-number">1</span>],height[i])<br>    &#125;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++&#123;<br>        h:=min(rh[i],lh[i])-height[i]<br>        <span class="hljs-keyword">if</span> h&gt;<span class="hljs-number">0</span>&#123;<br>            sum+=h<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a&gt;b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a&lt;b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上一节的双指针解法中，我们可以看到只要记录左边柱子的最高高度 和 右边柱子的最高高度，就可以计算当前位置的雨水面积，这就是通过列来计算。</p>
<p>当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。</p>
<p>为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight）。这样就避免了重复计算，这就用到了动态规划。</p>
<p>当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。</p>
<p>即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);</p>
<p>从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);</p>
<p>总体思路就是拆开看：</p>
<p>1、我们需要知道每个位置其左边和右边最高的高度是多少，所以先init两个数组。dp的思想，分别记录左右位置的其左边最高的高度和其右边最高的高度。细节就是我们要注意左边是从下标1开始，右边要从下标n-2开始都要留出一个空间，因为</p>
<p>2、这时候准备工作做好了我们就要用dp的思想将所有的雨水记录出来，用 <strong>min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度</strong> 来进行计算。</p>
<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><p>Given an unsorted integer array <code>nums</code>, return the smallest missing positive integer.</p>
<p>You must implement an algorithm that runs in <code>O(n)</code> time and uses constant extra space.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        m[v] = v<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>; i++ &#123; <span class="hljs-comment">// 比如 7,8,9,11,12 最后输出1</span><br>        <span class="hljs-keyword">if</span> _, exist := m[i]; !exist &#123;<br>            <span class="hljs-keyword">return</span> i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span> <span class="hljs-comment">// 比如 0,1,2 最后是 3</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了减少时间复杂度，可以把 input 数组都装到 map 中，然后 i 循环从 1 开始，依次比对 map 中是否存在 i，只要不存在 i 就立即返回结果，即所求。</p>
<h2 id="124-二叉树的最大路径和"><a href="#124-二叉树的最大路径和" class="headerlink" title="124. 二叉树的最大路径和"></a>124. 二叉树的最大路径和</h2><p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>
<p>The <strong>path sum</strong> of a path is the sum of the node’s values in the path.</p>
<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br>	max := math.MinInt32<br>	getPathSum(root, &amp;max)<br>	<span class="hljs-keyword">return</span> max<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getPathSum</span><span class="hljs-params">(root *TreeNode, maxSum *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> math.MinInt32<br>	&#125;<br>	left := getPathSum(root.Left, maxSum)<br>	right := getPathSum(root.Right, maxSum)<br><br>	currMax := max(max(left+root.Val, right+root.Val), root.Val)<br>	*maxSum = max(*maxSum, max(currMax, left+right+root.Val))<br>	<span class="hljs-keyword">return</span> currMax<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为有负数，所有用math.MinInt32</p>
<p>对于当前节点，每次比较走左边，还是走右边，还是走在当前节点不走了。再让这个和最大值进行比较。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/algorithm/">algorithm</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/LeetCode/">LeetCode</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/14/html-css-js/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">html+css+js</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/26/redis-study/">
                        <span class="hidden-mobile">redis-study</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> & <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
