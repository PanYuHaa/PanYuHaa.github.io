

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon1.png">
  <link rel="icon" href="/img/favicon1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Peter Pan">
  <meta name="keywords" content="">
  
    <meta name="description" content="Java集合Collection体系  Map体系  ListarrayList底层实现是数组，扩容每次扩为之前的1.5倍长，初始默认为10的长度  ArrayList和LinkedList区别？   Map HashMap  key可以为null 扩容：超过临界值（负载因子*容量），扩容后容量为之前的两倍 无序的map jdk1.7 使用的是数组+链表；jdk1.8 使用的是数组+链表+红黑树（">
<meta property="og:type" content="article">
<meta property="og:title" content="INTERVIEW">
<meta property="og:url" content="http://example.com/2022/11/17/INTERVIEW/index.html">
<meta property="og:site_name" content="PPStudy">
<meta property="og:description" content="Java集合Collection体系  Map体系  ListarrayList底层实现是数组，扩容每次扩为之前的1.5倍长，初始默认为10的长度  ArrayList和LinkedList区别？   Map HashMap  key可以为null 扩容：超过临界值（负载因子*容量），扩容后容量为之前的两倍 无序的map jdk1.7 使用的是数组+链表；jdk1.8 使用的是数组+链表+红黑树（">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part01/Collection%E4%BD%93%E7%B3%BB.jpeg?raw=true">
<meta property="og:image" content="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part01/Map%E4%BD%93%E7%B3%BB.jpeg?raw=true">
<meta property="og:image" content="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part06/LinkedList%20%E4%B8%8E%20ArrayList%20%E7%9A%84%E5%8C%BA%E5%88%AB.jpeg?raw=true">
<meta property="og:image" content="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part10/HashSet%E4%B8%8EHashMap%E5%8C%BA%E5%88%AB.jpeg?raw=true">
<meta property="og:image" content="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part11/LinkedHashSet%E4%B8%8ELinkedHashMap%E5%8C%BA%E5%88%AB.jpeg?raw=true">
<meta property="og:image" content="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part12/TreeSet%E3%80%81HashSet%E3%80%81LinkedHashSet%E5%8C%BA%E5%88%AB.jpeg?raw=true">
<meta property="og:image" content="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part13/fail-fast%20%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0.jpeg?raw=true">
<meta property="og:image" content="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8%E7%B1%BB.jpeg?raw=true">
<meta property="og:image" content="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part14/ConcurrentHashMap%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB.jpeg?raw=true">
<meta property="og:image" content="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part15/%E4%B8%BA%E4%BB%80%E4%B9%88%20ConcurrentHashMap%20%E5%8F%AA%E7%BB%99%E5%A4%B4%E8%8A%82%E7%82%B9%E5%8A%A0%E9%94%81%EF%BC%9F.jpeg?raw=true">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2020/33b193457c928ae02217480f994814b6.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-22%20at%2010.25.43.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-22%20at%2010.20.52.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-23%20at%2010.42.21.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-23%20at%2010.46.01.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-23%20at%2010.54.38.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202023-03-03%20at%2010.56.43.png">
<meta property="og:image" content="https://javaguide.cn/assets/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.c1fbd0fe.jpeg">
<meta property="og:image" content="https://javaguide.cn/assets/90984624.e8c186ae.png">
<meta property="og:image" content="https://javaguide.cn/assets/94057049.22c58294.png">
<meta property="og:image" content="https://javaguide.cn/assets/jvm-gc-roots.d187e957.png">
<meta property="og:image" content="https://i0.hdslb.com/bfs/note/04baa862823da3d5ea2df01ba879988d73fe0d75.jpg">
<meta property="og:image" content="https://i0.hdslb.com/bfs/note/cf2cffb5590810cd82e9e70f77bc6395963be4fd.jpg">
<meta property="og:image" content="https://i0.hdslb.com/bfs/note/37fd151db56d98aa1e362f4ae988d531e600b7d8.jpg">
<meta property="og:image" content="https://i0.hdslb.com/bfs/note/d86056c29cdae4dc880651b28d3dc5d9fde5e35a.jpg">
<meta property="og:image" content="http://example.com/Users/peterpan/Desktop/Screen%20Shot%202022-12-22%20at%2015.22.04.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-12-22%20at%2015.27.54.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-12-22%20at%2015.31.06.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-12-22%20at%2015.34.15.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-12-22%20at%2015.35.48.png">
<meta property="og:image" content="https://cdn.jsdeliver.net/gh/PanyuHaa/PicGo/img/Screen%20Shot%202022-11-17%20at%2018.21.29.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-18%20at%2019.48.37.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-18%20at%2020.05.31.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-18%20at%2020.20.25.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Desktop/Screen%20Shot%202022-11-18%20at%2020.21.36.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-18%20at%2020.27.21.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-19%20at%2012.06.52.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-21%20at%2009.52.25.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-21%20at%2009.53.46.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-21%20at%2009.54.41.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-21%20at%2009.55.31.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-21%20at%2010.00.27.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-23%20at%2010.26.02.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202023-03-01%20at%2015.19.08.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/ACID.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/AID-%3EC.png">
<meta property="og:image" content="https://javaguide.cn/assets/concurrency-consistency-issues-dirty-reading.ee15b0b9.png">
<meta property="og:image" content="https://javaguide.cn/assets/concurrency-consistency-issues-missing-modifications.5b2e2bd8.png">
<meta property="og:image" content="https://javaguide.cn/assets/concurrency-consistency-issues-unrepeatable-read.ff9186e1.png">
<meta property="og:image" content="https://javaguide.cn/assets/concurrency-consistency-issues-phantom-read.7cba7a85.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202023-03-02%20at%2015.32.06.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation.png">
<meta property="og:image" content="data:image/png;base64,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">
<meta property="og:image" content="https://javaguide.cn/assets/horizontal-slicing-database.53fbc43a.png">
<meta property="og:image" content="https://javaguide.cn/assets/two-forms-of-sub-table.3475ce44.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-19%20at%2016.05.43.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/image-20221119162231298.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979614062-f3219a07-0815-4b0d-9b63-750219d9e59c.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979628031-1ccb8eb9-5da0-46d5-a16a-01f6724c2ee1.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979639394-8eb65a8f-5905-473d-90d8-47cba7c58ae5.png">
<meta property="og:image" content="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fredis-cluster%2Fredis-cluster-shard.png&amp;sign=33a67ec08ad62aa857bafa46a651b091322094cb5ebd49722d3e45d87d76a619">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979614062-f3219a07-0815-4b0d-9b63-750219d9e59c.png">
<meta property="og:image" content="https://raw.githubusercontent.com/csunny/etcd-from-arch-to-souce-code/master/_asserts/images/cap.jpg">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-20%20at%2010.34.25.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202022-11-20%20at%2010.34.51.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-2d62ba265be486cb94ab531912aa3b9c_1440w.jpg">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202023-02-27%20at%2015.25.58.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210715220241939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092004.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202023-02-27%20at%2019.53.11.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202023-02-27%20at%2019.55.48.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202023-02-27%20at%2020.15.19.png">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202023-02-28%20at%2020.38.38.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/11151952-d757d59ad721ba00.png?imageMogr2/auto-orient/strip|imageView2/2/w/855">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/443934/201912/443934-20191212153101669-1128929789.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-waves-four-times.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/464291/201707/464291-20170703113844956-354755333.jpg">
<meta property="og:image" content="http://example.com/Users/peterpan/Library/Application%20Support/typora-user-images/Screen%20Shot%202023-03-10%20at%2014.07.40.png">
<meta property="article:published_time" content="2022-11-17T02:21:22.000Z">
<meta property="article:modified_time" content="2023-03-10T09:45:01.189Z">
<meta property="article:author" content="Peter Pan">
<meta property="article:tag" content="Back-End Engineer">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part01/Collection%E4%BD%93%E7%B3%BB.jpeg?raw=true">
  
  
  <title>INTERVIEW - PPStudy</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="INTERVIEW">
              
                INTERVIEW
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-11-17 10:21" pubdate>
        November 17, 2022 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      32k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      266 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">INTERVIEW</h1>
            
            <div class="markdown-body">
              <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><strong>Collection体系</strong></p>
<p><img src="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part01/Collection%E4%BD%93%E7%B3%BB.jpeg?raw=true" srcset="/img/loading.gif" lazyload alt="Collection体系.jpeg"></p>
<p><strong>Map体系</strong></p>
<p><img src="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part01/Map%E4%BD%93%E7%B3%BB.jpeg?raw=true" srcset="/img/loading.gif" lazyload alt="Map体系.jpeg"></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>arrayList底层实现是数组，扩容每次扩为之前的1.5倍长，初始默认为10的长度</p>
<ul>
<li>ArrayList和LinkedList区别？</li>
</ul>
<p><img src="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part06/LinkedList%20%E4%B8%8E%20ArrayList%20%E7%9A%84%E5%8C%BA%E5%88%AB.jpeg?raw=true" srcset="/img/loading.gif" lazyload alt="LinkedList 与 ArrayList 的区别.jpeg"></p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>HashMap</li>
</ul>
<p>key可以为null</p>
<p>扩容：超过临界值（负载因子*容量），扩容后容量为之前的两倍</p>
<p>无序的map</p>
<p>jdk1.7 使用的是数组+链表；jdk1.8 使用的是数组+链表+红黑树（拉链法短用链，长用树）</p>
<ul>
<li>LinkedHashMap</li>
</ul>
<p>有序的map，在HashMap基础上双向链表实现</p>
<ul>
<li>TreeMap</li>
</ul>
<p>key不可以为null</p>
<p>可以排序的map</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li>HashSet</li>
</ul>
<p>底层是HashMap</p>
<p><img src="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part10/HashSet%E4%B8%8EHashMap%E5%8C%BA%E5%88%AB.jpeg?raw=true" srcset="/img/loading.gif" lazyload alt="HashSet与HashMap区别.jpeg"></p>
<ul>
<li>LinkedHashSet</li>
</ul>
<p>有序的HashSet和LinkedHashMap同理</p>
<p><img src="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part11/LinkedHashSet%E4%B8%8ELinkedHashMap%E5%8C%BA%E5%88%AB.jpeg?raw=true" srcset="/img/loading.gif" lazyload alt="LinkedHashSet与LinkedHashMap区别.jpeg"></p>
<ul>
<li>TreeSet</li>
</ul>
<p><img src="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part12/TreeSet%E3%80%81HashSet%E3%80%81LinkedHashSet%E5%8C%BA%E5%88%AB.jpeg?raw=true" srcset="/img/loading.gif" lazyload alt="TreeSet、HashSet、LinkedHashSet区别.jpeg"></p>
<h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>获取迭代器的时候先获取modcount，然后执行之前先看modcount是否变化了，变化了就爆线程的错误。</p>
<p><img src="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part13/fail-fast%20%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0.jpeg?raw=true" srcset="/img/loading.gif" lazyload alt="fail-fast 快速失败机制概述.jpeg"></p>
<p><img src="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8%E7%B1%BB.jpeg?raw=true" srcset="/img/loading.gif" lazyload alt="线程安全容器类.jpeg"></p>
<p><img src="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part14/ConcurrentHashMap%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB.jpeg?raw=true" srcset="/img/loading.gif" lazyload alt="ConcurrentHashMap与HashMap的区别.jpeg"></p>
<p><img src="https://github.com/gorhaf/2021-Java-Collection-Tutorial/blob/main/part15/%E4%B8%BA%E4%BB%80%E4%B9%88%20ConcurrentHashMap%20%E5%8F%AA%E7%BB%99%E5%A4%B4%E8%8A%82%E7%82%B9%E5%8A%A0%E9%94%81%EF%BC%9F.jpeg?raw=true" srcset="/img/loading.gif" lazyload alt="为什么 ConcurrentHashMap 只给头节点加锁？.jpeg"></p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul>
<li><p>JAVA IO模型</p>
<ul>
<li>BIO</li>
</ul>
<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" lazyload alt="图源：《深入拆解Tomcat &amp; Jetty》"></p>
<ul>
<li>NIO（Non-blocking/New I/O）</li>
</ul>
<p>它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p><strong>同步非阻塞</strong>和HTTP1.1很像他没有阻塞你顺序访问，但他还是顺序执行，减少了等待结束的时延。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" lazyload alt="图源：《深入拆解Tomcat &amp; Jetty》"></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
</li>
</ul>
<p>  <strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>
<p>  Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
<p>  选择器会选择一个已经数据从内核准备好的线程发起read请求。所以NIO不是同步非阻塞模型而是IO多路复用模型</p>
<p>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>AIO（Asynchronous I/O）</li>
</ul>
<p>​        异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p>​        <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>总结</strong>：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2020/33b193457c928ae02217480f994814b6.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-22 at 10.25.43.png" srcset="/img/loading.gif" lazyload alt="jvm"></p>
<p><strong>堆（heap）</strong>：线程的公共空间，进程中最大的一块内存，存放实例化后的对象。</p>
<p><strong>栈（stack）</strong>：线程的私有空间</p>
<p><strong>本地方法栈</strong>：本地方法的栈，其他语言编写，java来运行的方法，使用native关键字定义的</p>
<p><strong>程序计数器（pc register)</strong>：多线程情况下，会切换线程，记录程序的线程执行到哪里，跟计算机组成原理中的切换线程时候保存现场一样。</p>
<p><strong>方法区</strong>：运行时常量池，类信息。</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-22 at 10.20.52.png" srcset="/img/loading.gif" lazyload alt="方法区"></p>
<p>方法区是jvm抽象的规范。</p>
<p>永久代（permgen）是堆空间的一部分</p>
<p><strong>1.8以后</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" srcset="/img/loading.gif" lazyload alt="Java 运行时数据区域（JDK1.8 之后）"></p>
<p>元空间（metaspcae）独立出来空间，使用的本地内存，理论上系统内存有多大元空间就多大。</p>
<p><strong>本地方法栈（native method stack）</strong>：本地方法，其他语言编写的，java运行的。native关键字标记的，比如<code>thread.sleep()</code>。</p>
<p>【一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)\</strong>资源，但是每个线程有自己的*<em>程序计数器<strong>、</strong>虚拟机栈<strong> 和 </strong>本地方法栈*</em>】</p>
<h2 id="Java中jvm虚拟机栈"><a href="#Java中jvm虚拟机栈" class="headerlink" title="Java中jvm虚拟机栈"></a>Java中jvm虚拟机栈</h2><p>jvm以方法作为最基本的执行单位。</p>
<p>jvm内存结构</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-23 at 10.42.21.png" srcset="/img/loading.gif" lazyload alt="jvm虚拟机栈"></p>
<p>虚拟机栈</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-23 at 10.46.01.png" srcset="/img/loading.gif" lazyload alt="栈"></p>
<p>对象方法之间的调用通过栈，这样弹出栈顶（也就是gc不要的对象），所以jvm以方法作为最基本的执行单位，一个方法对应一个栈帧。</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-23 at 10.54.38.png" srcset="/img/loading.gif" lazyload alt="对应解释"></p>
<p>具体看视频例子<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ET4y1Z711/?spm_id_from=333.999.0.0&amp;vd_source=77c4f2aaa0a307827d6898104835a353">https://www.bilibili.com/video/BV1ET4y1Z711/?spm_id_from=333.999.0.0&amp;vd_source=77c4f2aaa0a307827d6898104835a353</a></p>
<p><strong>局部变量表</strong>：答题卡，最终确定的参数。</p>
<p><strong>操作数栈</strong>：草稿纸，计算的过程。</p>
<p><strong>动态链接</strong>：算一些复杂的计算时候，借用的别的方法。</p>
<p><strong>方法出口</strong>：下一步要去的地址和方法。</p>
<h2 id="理解1-1的过程"><a href="#理解1-1的过程" class="headerlink" title="理解1+1的过程"></a>理解1+1的过程</h2><p>虚拟机栈</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2023-03-03 at 10.56.43.png" srcset="/img/loading.gif" lazyload alt="虚拟机栈"></p>
<p>局部变量表用来存放我们定义的变量，操作栈用来表示这些变量计算的计算过程。动态链接，调用常量池（方法区）中的方法。</p>
<h2 id="堆内存与GC"><a href="#堆内存与GC" class="headerlink" title="堆内存与GC"></a>堆内存与GC</h2><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>
<ul>
<li><p>堆内存分代</p>
<ul>
<li>新生代：伊甸园（eden）区+2个幸存者（survivor）区</li>
<li>老年代：</li>
</ul>
<p>垃圾回收（两者一起进行就是 full gc）：</p>
<ul>
<li>minor gc（young gc）：先判断eden区新产生的对象是不是垃圾，是就清理；不是的话进入survivor区，然后每次minor gc都会判断一次，大概会来回判断15次。【直接进入老年代】大对象和动态对象年龄判定（对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中）</li>
<li>major gc（old gc）：判断老年代的对象是不是垃圾</li>
</ul>
</li>
</ul>
<p>通过minor gc去处理朝生夕灭的对象，再一个大范围且低频的major gc去处理难以消亡的对象。</p>
<ul>
<li><p>标记清除理论</p>
<ul>
<li><p>标记清除</p>
<p><img src="https://javaguide.cn/assets/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.c1fbd0fe.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p>
</li>
<li><p>标记复制</p>
</li>
</ul>
<p><img src="https://javaguide.cn/assets/90984624.e8c186ae.png" srcset="/img/loading.gif" lazyload alt="复制算法"></p>
<ul>
<li>标记整理</li>
</ul>
</li>
</ul>
<p><img src="https://javaguide.cn/assets/94057049.22c58294.png" srcset="/img/loading.gif" lazyload alt="标记-整理算法 "></p>
<p>GC的清楚标记分为四步：初始标记、并发标记、重新标记、并发删除</p>
<p>GC判断垃圾的方式：可达性分析</p>
<p><img src="https://javaguide.cn/assets/jvm-gc-roots.d187e957.png" srcset="/img/loading.gif" lazyload alt="可达性分析算法"></p>
<p>从gc-root开始遍历整个对象引用图（三色标记法：黑色，已标记；灰色，正标记；白色，未标记），某对象没有在图中，那就是垃圾。</p>
<p>我们new一个对象的时候，<code>Object obj = new Object()</code>里面的obj就在栈中有了一个引用，也就是gc-root</p>
<p><strong>哪些对象可以作为 GC Roots 呢？</strong></p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p><img src="https://i0.hdslb.com/bfs/note/04baa862823da3d5ea2df01ba879988d73fe0d75.jpg" srcset="/img/loading.gif" lazyload alt="bean1"></p>
<p>首先主要目的是帮助大哥妥善管理和使用这些，会经历三个阶段：<strong>生产、使用、销毁</strong>。生产最复杂。加载Bean定义“loadBeanDefinitions方法。找到并放在Bean定义合集中。</p>
<p>拿取构造方法，先拿带有@Autowired注解的构造方法。优先拿无入参的，通过”三级缓存“机制进行填充。</p>
<p><img src="https://i0.hdslb.com/bfs/note/cf2cffb5590810cd82e9e70f77bc6395963be4fd.jpg" srcset="/img/loading.gif" lazyload alt="bean2"></p>
<p>初始化第一步是初始化容器相关信息。注意信息感知接口，感知并获取对应信息。</p>
<p><img src="https://i0.hdslb.com/bfs/note/37fd151db56d98aa1e362f4ae988d531e600b7d8.jpg" srcset="/img/loading.gif" lazyload alt="bean3"></p>
<p> 最后执行关闭睡觉的时候，销毁之前执行”销毁处理器“，通destroyBeans方法逐一销毁。</p>
<p><img src="https://i0.hdslb.com/bfs/note/d86056c29cdae4dc880651b28d3dc5d9fde5e35a.jpg" srcset="/img/loading.gif" lazyload alt="bean4"></p>
<p><strong>核心点创建对象：</strong></p>
<p><strong>构造对象：</strong></p>
<ul>
<li>获取构造方法：优先级 带@Autowired &gt; 无入参 ，如果都带注解活着都有相同的参数则会报错，并且不建议带多个构造方法，可读性低。</li>
<li>准备参数：单例池中 类查找（根据参数的class类查找） &gt; 参数名查找（如果参数有多个实例就会根据参数名匹配），如果都没有找到则会认为构造信息不完整，报错。</li>
<li>构造对象：通过反射class的类名找到对应构造方法（第一步进行获取）进行构造。</li>
</ul>
<p><strong>填充属性：</strong>三级缓存机制进行属性的填充。（依赖注入）</p>
<p><strong>初始化实例：</strong></p>
<ul>
<li>invokeAwareMethods()【执行 信息感知 方法】进行实例化，为实现了各种Aware接口（信息感知接口）的Bean设置诸如beanName、beanFactory等容器信息。</li>
<li>invokeInitMethods()【执行 初始化 方法】执行Bean的初始化方法，通过实现InitializingBean接口而实现的afterPropertiesSet方法（bean填充属性后执行）其前后会穿插bean的前后置处理器。</li>
</ul>
<p><strong>注册销毁：</strong>上述三个步骤bean已经可以用了</p>
<ul>
<li>registerDisposableBean()【注册 可销毁的 Bean对象】将实现了销毁接口DisposableBean的Bean进行注册。</li>
<li>注册销毁后进行销毁</li>
</ul>
<p><strong>Bean容器里面包含：</strong></p>
<p>beanDefinitionMap：bean的定义map用来存储我们定义的bean。</p>
<p>singletonObjects：生成后的bean单例池。</p>
<p><strong>销毁：</strong></p>
<ul>
<li>postProcessBeforeDestrction()【前处理器 销毁之前】：这里执行@PreDestroy注解</li>
<li>destroyBeans()【销毁 Bean对象】：销毁对象</li>
<li>invokeCustomDestroyMethod()【执行 客户自定义 销毁方法】：自定义销毁</li>
</ul>
<h2 id="Spring-Boot-启动流程"><a href="#Spring-Boot-启动流程" class="headerlink" title="Spring Boot 启动流程"></a>Spring Boot 启动流程</h2><p><img src="/Users/peterpan/Desktop/Screen Shot 2022-12-22 at 15.22.04.png" srcset="/img/loading.gif" lazyload alt="spring boot1"></p>
<p>run()以后会执行一下四个步骤：服务构建、环境准备、容器创建、填充容器</p>
<p><strong>服务构建：</strong></p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-12-22 at 15.27.54.png" srcset="/img/loading.gif" lazyload alt="spring boot2"></p>
<p><strong>环境准备：</strong></p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-12-22 at 15.31.06.png" srcset="/img/loading.gif" lazyload alt="spring boot3"></p>
<p>上下文、无输入设备启动、元数据不佳在、banner设置、环境变量（系统变量，properties，jvm系统属性）</p>
<p><strong>容器创建：</strong></p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-12-22 at 15.34.15.png" srcset="/img/loading.gif" lazyload alt="spring boot4"></p>
<p><strong>填充容器：</strong></p>
<p>包含了之前讲的bean生命周期</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-12-22 at 15.35.48.png" srcset="/img/loading.gif" lazyload alt="spring boot5"></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="原理-结构"><a href="#原理-结构" class="headerlink" title="原理+结构"></a>原理+结构</h2><h3 id="MySql的系统框架"><a href="#MySql的系统框架" class="headerlink" title="MySql的系统框架"></a>MySql的系统框架</h3><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>起初：通过对接模块和连接驱动进行连接，然后频繁的断开和连接相当于网络的疯狂IO，非常浪费资源。</p>
<p>后来：连接池的出现解决了这个问题，可以设置最大连接数量，单词最大数据报文。</p>
<h4 id="SQL解析-优化"><a href="#SQL解析-优化" class="headerlink" title="SQL解析/优化"></a>SQL解析/优化</h4><p>SQL接口：接受sql文件。</p>
<p>SQL解析器：解析sql语句。</p>
<p>SQL优化器：调整sql语句执行顺序，配合索引等进行优化。</p>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>MyISAM或者InnoDB，sql5.7版本以后开始默认为InnoDB。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>安全、恢复、集群、缓存</p>
<h3 id="MySql数据写入原理"><a href="#MySql数据写入原理" class="headerlink" title="MySql数据写入原理"></a>MySql数据写入原理</h3><p>InnoDB引擎简介：事务控制、读写效率、多用户并发、索引搜索等众方面均很优秀。</p>
<p>通过内部的执行器对内存和磁盘中的数据进行写入或读取。</p>
<p>1、sql语句优化，将优化后的执行计划传送给存储引擎</p>
<p>2、执行器按照命令执行。内存的IO速度远大于磁盘，所以操作都在内存中执行，这个内存缓存区叫buffer pool。（为了方便回滚，将这些指令记录到Undo Log中。）</p>
<p>写入分为两部分：提高写入速度（buffer pool），保证写入可靠性（redo log）</p>
<p>总结：主要涉及到四大部分：执行器 <strong>—&gt;</strong> 内存（Buffer Pool，IO 线程， Redo Log Buffer） <strong>—&gt;</strong> 操作系统 &amp; 指令 <strong>—&gt;</strong> 磁盘（磁盘文件.ibd，Redo Log，Undo Log）</p>
<h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><p>作为一个数据的缓冲区提高读写效率，然后再用另外一个IO线程统一写入磁盘文件，以.ibd为结尾。</p>
<h4 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h4><p>会将“更新写入信息”放入内存中的另一个区域<strong>Redo Log Buffer</strong>，在进行刷盘，刷盘策略有三种。这个Redo Log Buffer就是用户态内存？然后所以需要先写入到系统内存中再操作磁盘文件。</p>
<ul>
<li><strong>0</strong> ：设置为 0 的时候，表示每次事务<strong>提交时不进行</strong>刷盘操作</li>
</ul>
<p>​                为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。（事务没有提交，但因为后台刷新还是会刷出来redo log，出现数据不一致）</p>
<p>​                （依靠后台线程刷盘）</p>
<ul>
<li><strong>1</strong> ：设置为 1 的时候，表示每次事务<strong>提交时都将进行</strong>刷盘操作（<strong>默认值</strong>）</li>
</ul>
<p>​                为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>​                如果事务执行期间<code>MySQL</code>挂了或宕机，这部分<strong>日志丢了，但是事务并没有提交</strong>，所以日志丢了也不会有损失。</p>
<p>​                （事务执行就直接刷盘，没执行完成就不刷盘，只能解决运行时出现的问题）</p>
<ul>
<li><strong>2</strong> ：设置为 2 的时候，表示每次事务<strong>提交时都只把 redo log buffer 内容写入 page cache</strong></li>
</ul>
<p>​                为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>
<p>​                如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p>
<p>​                （不主动刷盘，只记录在了文件系统缓冲中，所以不宕机就还能继续又后台线程刷盘写入）</p>
<p>整体分为，提交事务后做动作（1和2），和不提交事务也提交。1和2的区别是策略2是提交的时候先放入buffer中，这样降低了数据的损失为1s，降低了提交事务后的数据的丢失。而1不能够解决事务提交之后的数据损失，只能解决事务运行时的。</p>
<h4 id="Bin-Log"><a href="#Bin-Log" class="headerlink" title="Bin Log"></a>Bin Log</h4><p><img src="https://cdn.jsdeliver.net/gh/PanyuHaa/PicGo/img/Screen%20Shot%202022-11-17%20at%2018.21.29.png" srcset="/img/loading.gif" lazyload alt="执行原理"></p>
<p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了<strong>崩溃恢复</strong>能力。</p>
<p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据<strong>一致性</strong>。</p>
<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以<strong>基本的事务为单位</strong>，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>
<h3 id="MySql的存储结构"><a href="#MySql的存储结构" class="headerlink" title="MySql的存储结构"></a>MySql的存储结构</h3><p>主要在磁盘和内存中，使用内存的原因是为了提升读写速度。</p>
<p>创建文件，t.frm 存储表结构等信息，t.ibd 表空间（存储数据和索引），5.7以后才生成独立表空间。独立表空间可以传输和压缩。</p>
<p><strong>页</strong>，InnoDB中内存和磁盘交互的最小存储单元。页内部的地址是连续的，因为通常要查的数据都会连续存在（固定大小16KB，与B+树的索引对应）。页是核心存储结构，其他的都是在他的基础上进行划分。</p>
<p><strong>行</strong>，记录数据行的具体数据，最大8KB。</p>
<p>这个特别像是操作系统中的段页式结构。</p>
<p>跨页读取，可能会遇到跨磁道读取，造成磁头移动，这个速度相当慢。</p>
<p><strong>区</strong>，为1M = 64 * 16KB = 1024KB，弄一个区来存64个页避免磁头移动，降低io速度。</p>
<p>避免浪费空间，新创建表的时候只会创建6个页，16*6 共 96KB，8.0版本后会创建7个页，零散的页会放在表空间中一个叫碎片区的地方，前四个分别记录了表空间和区组条目信息，Change buffer相关信息，段信息，索引根信息，后两个页为空闲页（可用页）。经典到容量一半的时候进行扩容，增加一个完整的区。</p>
<p><strong>组</strong>，管理256个区，即256M，区中的前四个信息页都是记录基础信息。</p>
<p><strong>段</strong>，逻辑分区，区分不同功能的区和在碎片区中的页，就是段页式存储的那个段，叶子结点段（存储和管理实际数据），非叶子结点段（存储和管理索引树）。非叶子结点段+叶子结点段组成独立表空间，即t.ibd</p>
<h3 id="MySql的执行原理"><a href="#MySql的执行原理" class="headerlink" title="MySql的执行原理"></a>MySql的执行原理</h3><h4 id="发出请求"><a href="#发出请求" class="headerlink" title="发出请求"></a>发出请求</h4><p>连接驱动（ORM）和连接池之间是半双工的。查询语句如果超过了mysql连接池设定的数据包上限，那么就会拒绝接受。</p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>Map结构，key是sql语句，value是查询结果。5.7版本默认关闭，8.0版本直接删除了。每次都要先查询一下缓存，命中率低的话就会占用很多空间，还有速度慢，反而效率降低。</p>
<h4 id="SQL解析器"><a href="#SQL解析器" class="headerlink" title="SQL解析器"></a>SQL解析器</h4><p>词法分析 sql/sql_lex.cc。拆分成关键字和非关键字。</p>
<p>bison语法分析器 sql/sql_yacc.cc。sql就被解析成一颗语法树。</p>
<h4 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h4><p>提交SQL模版语句，提交参数进行执行。这样可以复用模版，一种多路复用的思想。</p>
<h4 id="SQL优化器"><a href="#SQL优化器" class="headerlink" title="SQL优化器"></a>SQL优化器</h4><p>CBO，运用成本最低的方式执行sql语句。成本指的是体内的数据表、数据量、索引等等信息算出来SQL语句对应的IO成本消耗值和CPU成本消耗值。</p>
<p>有个优化轨迹的工具Optimizer_trace，展示任意一条语句的优化，记得关闭。</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>执行器为每一个表创建一个Handler实例。优化器根据实例来获取表的信息。将执行计划送给存储引擎，然后返回结果</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-18 at 19.48.37.png" srcset="/img/loading.gif" lazyload alt="Screen Shot 2022-11-18 at 19.48.37"></p>
<h3 id="MySql的运行原理"><a href="#MySql的运行原理" class="headerlink" title="MySql的运行原理"></a>MySql的运行原理</h3><h4 id="存储引擎InnoDB"><a href="#存储引擎InnoDB" class="headerlink" title="存储引擎InnoDB"></a>存储引擎InnoDB</h4><p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-18 at 20.05.31.png" srcset="/img/loading.gif" lazyload alt="mysql运行原理"></p>
<h3 id="Mysql“页”结构解析"><a href="#Mysql“页”结构解析" class="headerlink" title="Mysql“页”结构解析"></a>Mysql“页”结构解析</h3><p>数据页（索引页）</p>
<h4 id="页头、页尾"><a href="#页头、页尾" class="headerlink" title="页头、页尾"></a>页头、页尾</h4><p><strong>页头</strong>（校验和、页号、上页页号、下页页号、页类型、表空间ID，【最近一次修改的LSN，已被刷到磁盘的LSN，（日志序列号）】），里面包含了页之间关系，页自己的属性，还有具体存储的逻辑表空间的ID。</p>
<p>ps：日志序号(LSN) <strong>表示从数据库日志文件开头开始计算的日志记录的位移（以字节计）</strong>。</p>
<p><strong>页尾</strong>（校验和、最近一次修改的LSN）</p>
<p>crc32作为校验和来拯救一些没有写入完成的数据。</p>
<p>页头和页尾巴分别占用38字节和8字节，总计46字节。</p>
<p>数据行与真实的表数据一行行对应。</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-18 at 20.20.25.png" srcset="/img/loading.gif" lazyload alt="数据行"></p>
<p><img src="/Users/peterpan/Desktop/Screen Shot 2022-11-18 at 20.21.36.png" srcset="/img/loading.gif" lazyload alt="Screen Shot 2022-11-18 at 20.21.36"></p>
<p>最小行和最大行用来制作一个可控的循环链表。</p>
<p>数据区分为用户区和空闲区。</p>
<h4 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a>页目录</h4><p>这部分建议看原视频。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pG4y1o7n3/?spm_id_from=333.788&amp;vd_source=77c4f2aaa0a307827d6898104835a353">https://www.bilibili.com/video/BV1pG4y1o7n3/?spm_id_from=333.788&amp;vd_source=77c4f2aaa0a307827d6898104835a353</a></p>
<h4 id="数据页头"><a href="#数据页头" class="headerlink" title="数据页头"></a>数据页头</h4><p>用来记录该页的所有基础信息，实时统计。</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-18 at 20.27.21.png" srcset="/img/loading.gif" lazyload alt="数据页头"></p>
<h3 id="Mysql-行结构"><a href="#Mysql-行结构" class="headerlink" title="Mysql 行结构"></a>Mysql 行结构</h3><p>行数据dynamic类型，分为额外信息和真实数据。</p>
<p>null值列表用8位为单位去统计对应行列的信息，看起来是倒置的因为低位在右侧。</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-19 at 12.06.52.png" srcset="/img/loading.gif" lazyload alt="dynamic数据行"> </p>
<p>剩下的看原视频</p>
<h3 id="MySql-为什么要有索引"><a href="#MySql-为什么要有索引" class="headerlink" title="MySql 为什么要有索引"></a>MySql 为什么要有索引</h3><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>首先我们采用红黑树（一种自适应平衡二叉树）来构造索引，那么我们索引值就很容易了，从原来的4000次变成了log2（4000）= 11次的IO操作。二分查找的时间复杂度就是log2^(N)。</p>
<p>为了减少IO操作所造成的磁头转换让资源开销变大，使用了B树或者B+树（多插树）来存储可以降低很多层。少了层树就减少了IO开销。</p>
<p>B树有顺序，所以内部每一层也是用的二叉树。</p>
<p>B树有个缺点就是</p>
<ul>
<li>无法批量查找</li>
<li>查询效率不稳定</li>
<li>树高度还有下降空间</li>
</ul>
<h3 id="MySql-B-树索引"><a href="#MySql-B-树索引" class="headerlink" title="MySql B+树索引"></a>MySql B+树索引</h3><h4 id="磁盘原理"><a href="#磁盘原理" class="headerlink" title="磁盘原理"></a>磁盘原理</h4><p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-21 at 09.52.25.png" srcset="/img/loading.gif" lazyload alt="磁盘原理"></p>
<p>因为频繁的利用数据所以我们不一次提取4kb，而一次提取8kb，这样效率更高。</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-21 at 09.53.46.png" srcset="/img/loading.gif" lazyload alt="Screen Shot 2022-11-21 at 09.53.46"></p>
<h4 id="树节点-“页”"><a href="#树节点-“页”" class="headerlink" title="树节点 = “页”"></a>树节点 = “页”</h4><p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-21 at 09.54.41.png" srcset="/img/loading.gif" lazyload alt="树节点为页"></p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-21 at 09.55.31.png" srcset="/img/loading.gif" lazyload alt="实际数据"></p>
<h4 id="B-树的由来"><a href="#B-树的由来" class="headerlink" title="B+树的由来"></a>B+树的由来</h4><p>B树有个缺点就是</p>
<ul>
<li>无法批量查找</li>
<li>查询效率不稳定</li>
<li>树高度还有下降空间</li>
</ul>
<p><strong>无法批量查找：</strong></p>
<p>叶子结点统一链接，形成单向链表。</p>
<p><strong>查询效率不稳定：</strong></p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-21 at 10.00.27.png" srcset="/img/loading.gif" lazyload alt="查询效率不稳定"></p>
<p>是由于每次查找结束后都会返回头节点从新开始下一次搜索，这样你搜索的节点有可能在头也可能在叶子，效率很不稳定。</p>
<p>解决办法：我们都将非叶子结点的数据都往下冗余一层，这样的话可以保证叶子结点包含所有的数据，查询都要到达底层。空间方面，我们在非叶子结点之间只存储指向下一个页的地址。</p>
<p><strong>树高度还有下降空间：</strong></p>
<p>解决办法：非叶子结点（目录结点）不再存储真实数据信息了，所以我们有了更多空间存储key和下一页地址空间，这样就变相的降低了树高。通常情况，一个16KB的”页“可以存储300～400个key和下一页地址空间的行。即使是2000w的数据，log以400为底，2000万的对数，log400（2000w）= 2.69 最多也就需要3层。  </p>
<h3 id="MySql中“聚簇索引”不是索引？"><a href="#MySql中“聚簇索引”不是索引？" class="headerlink" title="MySql中“聚簇索引”不是索引？"></a>MySql中“聚簇索引”不是索引？</h3><p>如果表里没有主键，则将表里第一个唯一索引作为主键。如果都没有那么会自动弄一个自增序列作为聚簇索引。</p>
<h2 id="MySql高频面试题"><a href="#MySql高频面试题" class="headerlink" title="MySql高频面试题"></a>MySql高频面试题</h2><h3 id="Q001-varchar字段长度有上限吗？为什么是奇怪的16383？"><a href="#Q001-varchar字段长度有上限吗？为什么是奇怪的16383？" class="headerlink" title="Q001. varchar字段长度有上限吗？为什么是奇怪的16383？"></a>Q001. varchar字段长度有上限吗？为什么是奇怪的16383？</h3><p>除了text、blob等无长度限制字段之外，其他列长度加起来不能超过64KB，即65535字节。</p>
<p>按最大4字节一个字符算65535/4 = 16383个字符。</p>
<p><strong>一个页也就16KB，一行数据就要占用4个页吗？</strong></p>
<p>每个数据行不能超过页大小16KB的一半，大概8000多字节，多出来的放在溢出页（只针对个别字段）。</p>
<p>每个页至少有两行。</p>
<p>官网规定每个表最多4096个字段（列）。</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-23 at 10.26.02.png" srcset="/img/loading.gif" lazyload alt="最多4096个字段"></p>
<h2 id="📕-面试常见题目"><a href="#📕-面试常见题目" class="headerlink" title="📕 面试常见题目"></a>📕 面试常见题目</h2><h3 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="MySQL 基础架构"></a>MySQL 基础架构</h3><ul>
<li>mysql基础架构？</li>
</ul>
<p>​        <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>​        用户先通过连接器连接mysql，然后通过sql接口操作mysql，经过解析器（分析sql语句，具体做什么），优化器（分配sql执行的顺序），执行器（操作引擎执行相应的sql操作）。</p>
<h3 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h3><ul>
<li>MySQL支持哪些存储引擎？默认的存储引擎是什么呢？</li>
</ul>
<p>​        MySQL支持多种存储引擎，可以通过<code>show engines</code>来查看。MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎，InnoDB是支持事务的。</p>
<ul>
<li>MySQL存储引擎架构了解吗？</li>
</ul>
<p>​        MySQL的存储引擎架构是<strong>插件式架构</strong>，支持多种存储引擎，存储引擎是基于表的（也就是说是操作表的），而不是针对数据库的。</p>
<ul>
<li>MyISAM 和 InnoDB 有什么区别？</li>
</ul>
<p>​        MyISAM 和 InnoDB 最大的区别就是 MyISAM 不支持行级锁和事务。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">MyISAM</th>
<th style="text-align:center">InnoDB</th>
<th style="text-align:center">差异</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">只有表级锁，一锁整个表都被锁住，并发性能差</td>
<td style="text-align:center">支持表级锁和行级锁，并发性能高</td>
<td style="text-align:center">是否支持行级锁</td>
</tr>
<tr>
<td style="text-align:center">不支持事务</td>
<td style="text-align:center">支持事务，四个隔离级别解决常见的并发问题（脏读，不可重复读，幻读）：读未提交、读已提交、可重复读、序列化</td>
<td style="text-align:center">是否支持事务</td>
</tr>
<tr>
<td style="text-align:center">不支持安全恢复</td>
<td style="text-align:center">支持安全恢复，通过redo log实现，redo log保证了数据写入可靠性</td>
<td style="text-align:center">是否支持数据库异常崩溃后的安全恢复</td>
</tr>
<tr>
<td style="text-align:center">不支持MVCC</td>
<td style="text-align:center">支持MVCC</td>
<td style="text-align:center">是否支持MVCC</td>
</tr>
<tr>
<td style="text-align:center">叶子结点存储的是数据的地址</td>
<td style="text-align:center">叶子结点存储的就是数据</td>
<td style="text-align:center">索引实现不同（都是B+树）</td>
</tr>
<tr>
<td style="text-align:center">较差</td>
<td style="text-align:center">较好</td>
<td style="text-align:center">性能不同</td>
</tr>
</tbody>
</table>
</div>
<p>行级锁、事务、异常恢复（健壮性）、MVCC、索引实现、性能</p>
<h3 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="MySQL 日志"></a>MySQL 日志</h3><ul>
<li>常见的日志都有什么用？（针对InnoDB存储引擎）</li>
</ul>
<p>​        <strong>错误日志 (error log)</strong> ：对MySQL的启动、运行、关闭过程进行记录。</p>
<p>​        <strong>二进制日志 (binary log, binlog)</strong> ：主要记录更改数据库数据的SQL语句。</p>
<p>​        <strong>一般查询日志 (general query log)</strong> ：</p>
<p>​        <strong>慢查询日志 (slow query log)</strong> ：执行时间超过 <code>long_query_time</code> 秒钟的查询，解决SQL慢查询的问题用到。</p>
<p>​        <strong>事务日志 (redo log, undo log)</strong> ：redo log 是重做日志，undo log 是回滚日志。</p>
<p>​        <strong>中继日志 (relay log)</strong> ：和bin log差不多不过是针对主从复制中的从库。</p>
<p>​        <strong>DDL日志 (metadata log)</strong> ：DDL语句执行的元数据操作</p>
<p>​        </p>
<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志记录了执行时间超过 <code>long_query_time</code> （默认10s，通常设置1s）所有查询语句，解决SQL执行时间长的问题，找到以后可以用 <code>EXPLAIN</code>命令进行分析。</p>
<h4 id="binlog（二进制日志）"><a href="#binlog（二进制日志）" class="headerlink" title="binlog（二进制日志）"></a>binlog（二进制日志）</h4><ul>
<li>binlog是什么？</li>
</ul>
<p>​        binlog是一个<strong>二进制格式</strong>的文件（使用<strong>mysqlbinlog</strong>查看），记录了所有对MySQL数据库执行了更改的所有操作（数据库执行的所有DDL和DML语句），包括表结构变更（CREATE、DROP TABLE）、表数据变更（INSERT、UPDATE、DELETE…），不包括查询语句（SELECT、SHOW）。内容是sql语句并且还包含了语句发生时间，执行时长、操作数据等。</p>
<ul>
<li>binlog格式有几种？</li>
</ul>
<p>​        Statement模式：每一条修改数据的sql都记录在binlog中（记录原生的sql），性能好于row但准确性差。</p>
<p>​        Row模式（推荐）：每一行的具体变更事件都被记录在binlog中（记录数据行的更改情况），主从复制模式下可靠性最好</p>
<p>​        Mixed模式：前两种的结合，MySql会根据实际情况来选择row还是staement的模式</p>
<ul>
<li>binlog的作用？</li>
</ul>
<p>​        binlog的主要应用场景是主从复制，主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</p>
<p><strong>STEP</strong>：</p>
<div class="code-wrapper"><pre><code class="hljs">            1. 主库将数据库中数据的变化写入binlog
            1. 从库连接主库
            1. 从库会创建一个I/O线程向主库请求更新的binlog
            1. 主库会创建一个 binlog dump 线程来发送 binlog，从库中的 I/O 线程负责接收
            1. 从库的 I/O 线程将接受的binlog写入到 relay log 中
            1. 从库的SQL线程读取 relay log 同步数据本地（也就是再执行一遍SQL）
</code></pre></div><p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2023-03-01 at 15.19.08.png" srcset="/img/loading.gif" lazyload alt="Screen Shot 2023-03-01 at 15.19.08"></p>
<p>​        整体流程大概就是，先写入binlog，然后连接，从库想要更新的binlog，主库给他binlog dump，然后从库先记录到relay log中，再按照relay log写sql。</p>
<p>​        binlog还可以进行数据恢复。</p>
<ul>
<li><p>binlog的刷盘时间如何选择？</p>
<p> InnoDB存储引擎而言，事务在执行过程中，</p>
</li>
</ul>
<p>​        通过 <code>sync_binlog</code> 参数控制binlog的刷盘时机，取值范围是 0-N，默认为0</p>
<p>​        0: 不去强制要求，由系统自行判断何时写入磁盘；</p>
<p>​        1: 每次提交事务的时候都要将binlog写入磁盘；</p>
<p>​        N：每N个事务，才会将binlog写入磁盘；</p>
<p>​        5.7之前默认为0，之后默认为1；</p>
<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以<strong>基本的事务为单位</strong>，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>
<ul>
<li>什么情况下会重新生成binlog？</li>
</ul>
<p>​        当遇到一下三种情况时，MySQL会重新生成一个新的日志文件，文件序号递增：</p>
<p>​        MySQL服务器停止或者重启</p>
<p>​        使用 <code>flush logs</code> 命令后（刷盘）</p>
<p>​        binlog 文件大小超过 <code>max_binlog_size</code> 变量的阈值后</p>
<h4 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h4><p>buffer pool是真实写数据用的缓存，redo log buffer是给redo log用的作为buffer pool保障的另一个缓存。</p>
<p><strong>前言</strong>：InnoDB引擎是以页为单位来管理存储空间的，为了减少磁盘IO开销，还有一个叫做 Buffer Pool（缓冲池）的区域，存在于内存中，如果我们要找的页不在buffer pool中，就是做了一个一级缓存。但是如果一个事务提交之后，我们对 buffer pool 中对应的页的修改可能还未持久化到磁盘，这时候宕机了事务更改就消失了，事务的持久性就没了？所以我们有了<strong>redo log</strong>来保证事务的<strong>持久性</strong>（准确的事保证buffer pool中的缓存不丢失。</p>
<p>redo log 记录的就是页的修改，包含了表空间号、数据页号、偏移量、具体修改的数据等。事务提交时，我们会将 redo log 按照刷盘策略刷到磁盘上去，这样即使 MySQL 宕机了重启之后也能继续写入，redo log是在事务开启过程中就一直在记录。</p>
<ul>
<li>redo log 如何保证事务的持久性？</li>
</ul>
<p>​        事务执行 <strong>—&gt;</strong> redo log buffer 刷新到 <strong>文件系统缓存（Page Cache）</strong> <strong>—&gt;</strong> 调用 <code>sync()</code> 刷盘到磁盘上</p>
<p>​        设置 <code>innodb_flush_log_at_trx_commit</code> 的默认值为1，设置为1的时候不会产生数据丢失，为保证持久性必须设置为1。</p>
<p>​        0: （依靠后台线程刷盘）还是宕机会丢失1s的数据</p>
<p>​        1【默认】: （事务完成就直接刷盘，没执行完成就不刷盘，只能解决运行时出现的问题）还是宕机会丢失数据，但哥们本身事务也没完成，所以无所谓啦。是同步调用 sync() 操作。</p>
<p>​        2: （不主动刷盘，只记录在了文件系统缓冲（内存）中，所以不宕机就还能继续由后台线程刷盘写入）。异步调用 sync() 操作，可以在os没有宕机只有mysql宕机的基础上保证持久性）</p>
<p>小结：0，害怕<strong>所有 os 和 mysql 宕机情况</strong>，只要宕机就丢1s的数据；1，不怕事务<strong>执行期间</strong> os 和 mysql 的宕机；2，不怕事务执行期间<strong>mysql的宕机</strong>行为。</p>
<p>​        </p>
<p>​        redo log 采用的是循环写的方式，大小固定，有一个Check Point机制可以帮助不覆盖。</p>
<ul>
<li>页修改之后为什么不直接刷盘？</li>
</ul>
<p>​        页大小16kb，刷一次就要刷16kb的IO操作，性能很差。</p>
<ul>
<li>binlog 和 redolog 有什么区别？</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">binlog</th>
<th style="text-align:center">redolog</th>
<th style="text-align:center">差异</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用于数据库还原，数据级别的数据恢复</td>
<td style="text-align:center">保证事务持久性，事务级别的数据恢复</td>
<td style="text-align:center">用途</td>
</tr>
<tr>
<td style="text-align:center">所有引擎共有的，MySQL的Server层实现的</td>
<td style="text-align:center">InnoDB引擎特有的</td>
<td style="text-align:center">引擎</td>
</tr>
<tr>
<td style="text-align:center">逻辑日志，记录执行语句</td>
<td style="text-align:center">物理日志，记录某个页的修改</td>
<td style="text-align:center">日志类型</td>
</tr>
<tr>
<td style="text-align:center">追加方式写入，大小不固定</td>
<td style="text-align:center">循环写入，大小固定</td>
<td style="text-align:center">文件大小</td>
</tr>
</tbody>
</table>
</div>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><ul>
<li>undo log 如何保证原子性？</li>
</ul>
<p>​        undo log 属于逻辑日志，记录的是sql语句，比如事务执行一条 delete 语句，undo log就会记录一个相应的insert语句</p>
<ul>
<li>除了保证事务的原子性，undo log 还有什么用？</li>
</ul>
<p>​        MVCC的实现用到了undo log。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过 undo log 读取之前的行版本信息，一次实现非锁定读取。        </p>
<h3 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h3><ul>
<li>何为事务？</li>
</ul>
<p>​        逻辑上的一组操作，要么都执行，要么都不执行。</p>
<ul>
<li>何为数据库事务？</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"># 开启一个事务<br><span class="hljs-keyword">START</span> TRANSACTION;<br># 多条 <span class="hljs-keyword">SQL</span> 语句<br>SQL1,SQL2...<br>## 提交事务<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure>
<p>​        数据库的事务要不全部执行成功，要么执行不成功。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="数据库事务示意图"></p>
<p>​        事务的特性ACID：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/ACID.png" srcset="/img/loading.gif" lazyload alt="ACID"></p>
<p>​        原子性（Atomicity）：事务是最小的执行单位，原子性指的是事务要么全部完成，要么完全不起作用。</p>
<p>​        一致性（Consistency）：事务执行前后，数据保持一致，比如转账，A给B转账成功后，A和B的金额总和不变。</p>
<p>​        隔离性（Isolation）：并发访问数据库时，一个用户的事务不会被其他的事务所干扰，各并发的事务是独立的。</p>
<p>​        持久性（Durability）：一个事务被提交后，他对数据库中数据的改变是持久的，发生故障也不应该有任何影响，通过redo log保障。</p>
<p>​        <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/AID-%3EC.png" srcset="/img/loading.gif" lazyload alt="AID-&gt;C"></p>
<p>​        另说一嘴，一致性是应用程序的属性，依赖原子性和隔离属性来实现一致性，但这并不仅取决于数据库。</p>
<ul>
<li>并发事务带来的问题？</li>
</ul>
<p>​        <strong>脏读</strong>：<img src="https://javaguide.cn/assets/concurrency-consistency-issues-dirty-reading.ee15b0b9.png" srcset="/img/loading.gif" lazyload alt="脏读"></p>
<p>​        （读到了别的事务未提交的数据）</p>
<p>​        <strong>丢失修改</strong>：<img src="https://javaguide.cn/assets/concurrency-consistency-issues-missing-modifications.5b2e2bd8.png" srcset="/img/loading.gif" lazyload alt="丢失修改"></p>
<p>​        （修改了别的事务未修改完成的数据，导致丢失修改）</p>
<p>​        </p>
<p>​        <strong>不可重复读</strong>：<img src="https://javaguide.cn/assets/concurrency-consistency-issues-unrepeatable-read.ff9186e1.png" srcset="/img/loading.gif" lazyload alt="不可重复读"></p>
<p>​        （对某一行数据重复读的时候，数据会变，数据出现了不一致）</p>
<p>​        </p>
<p>​        <strong>幻读</strong>：<img src="https://javaguide.cn/assets/concurrency-consistency-issues-phantom-read.7cba7a85.png" srcset="/img/loading.gif" lazyload alt="幻读"></p>
<p>​        （事务1插入了一个数据，导致事务2读取某个表的时候，数据的数量出现了不一致的情况）</p>
<ul>
<li>不可重复读和幻读的区别？</li>
</ul>
<p>​        不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</p>
<p>​        幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</p>
<p>​        幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p>
<p>​        </p>
<p>​        <strong>举个例子</strong>：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于<strong>记录锁（Record Lock）</strong>只能锁住已经存在的记录，为了避免插入新记录，需要依赖<strong>间隙锁（Gap Lock）</strong>。也就是说执行 <code>insert</code> 操作的时候需要依赖 <strong>Next-Key Lock（Record Lock+Gap Lock）</strong> 进行加锁来保证不出现幻读。</p>
<ul>
<li>并发事务的控制有哪些方法？</li>
</ul>
<p>​        对于MySQL并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，mvcc看作乐观控制的模式。</p>
<p>​        <strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p>
<p>​        <strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</p>
<p>​        <strong>排他锁（X 锁）</strong> ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</p>
<p>​        按粒度可以分成：行级锁和表级锁。</p>
<p>​        表级锁：加锁快，不会死锁。表级锁和存储引擎无关。针对非索引字段加的锁，对当前操作的整张表加锁。</p>
<p>​        行级锁：开销也最大，加锁慢，会出现死锁。MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。是存储引擎实现的。</p>
<p>​        </p>
<p>​        <strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p>
<p>​        MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p>
<p>​                <strong>undo log</strong> : undo log 用于记录某行数据的多个版本的数据。</p>
<p>​                <strong>read view</strong> 和 <strong>隐藏字段</strong> : 用来判断当前版本数据的可见性。</p>
<p>​        </p>
<ul>
<li>SQL定义了哪些事务隔离级别？        </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ-UNCOMMITTED</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">READ-COMMITTED</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">REPEATABLE-READ</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">SERIALIZABLE</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
</div>
<p>​        默认可重复读！！</p>
<ul>
<li>MySQL的隔离级别基于锁实现的嘛？</li>
</ul>
<p>​        MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。</p>
<ul>
<li>InnoDB有几类行锁</li>
</ul>
<p>​        InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>
<p>​        <strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</p>
<p>​        <strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</p>
<p>​        <strong>临键锁（Next-Key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</p>
<p>​        在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</p>
<ul>
<li>意向锁的作用？</li>
</ul>
<p>​        如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p>
<ul>
<li>当前读和快照读？</li>
</ul>
<p>​        <strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句</p>
<p>​        <strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p>
<ul>
<li>MVCC怎么判断的？</li>
</ul>
<p>​        <img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2023-03-02 at 15.32.06.png" srcset="/img/loading.gif" lazyload alt="mvcc"></p>
<p>事务每增删一次就会生成一个undo log的数据行。</p>
<p><strong>trx_id</strong>：当前事务版本id</p>
<p><strong>m_ids</strong>：当前活跃的事务集合（举例90、100、200）</p>
<p><strong>min_trx_id</strong>：版本链尾的事务id，未提交的（举例90）</p>
<p><strong>max_trx_id</strong>：版本链头的事务id+1（举例201）</p>
<p><strong>creator_trx_id</strong>：read review事务id，快照？</p>
<p>查找规则（四步查找，链表头开始）：</p>
<ol>
<li>判断<strong>trx_id</strong>是否等于<strong>creator_trx_id</strong>，若等于，即当前版本是当前事务创建，直接使用。</li>
<li>判断<strong>trx_id</strong>是否小于<strong>min_trx_id</strong>，若小于，即当前版本在读视图生成之前已经提交，直接使用。</li>
<li>判断<strong>trx_id</strong>是否大于<strong>max_trx_id</strong>，若大于，即当前版本在读视图生成之后才开启，肯定不能被当前事务访问。</li>
<li>判断<strong>trx_id</strong>是否在<strong>max_trx_id</strong>和<strong>min_trx_id</strong>之间，并且不在<strong>m_ids</strong>里面，在创建读视图的时候，该版本已经被提交，可以直接访问。</li>
</ol>
<p>白话：读视图分为一个活跃事务列表、待提交的事务id上限（头）、待提交事务id下限（尾）、当前创建的读视图（undo log链的快照）。判断规则大概就是说先判断这最新的一条是不是你增删的，你增删的就直接读就行；不是的话我就看看是不是之前的人干的，找视图链的下限id，如果小于了下限id说明你读的时候已经都有更新的提交了，直接读就行（读到的就是最新的提交）；还不是的话我们就找上限，如果还是越界了说明你这事务读的太新（链头），我没法确定当前的版本是否没被别人用着呢；第四步查看最新的未提交是不是被用着呢，没有的话你可以用，成为最新的活跃。</p>
<p>在可重复读中，MVCC为这次事务创建一个固定的快照读视图，这样每次查的就都一样了，相当于有一个固定的查询边界。</p>
<p>在读已提交中，MVCC每次查询都会为事务创建一个快照读视图，这样可以读到已经提交的，且每次都会更新变化，就会造成不可重复读。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别/读取和更新</th>
<th>读取数据</th>
<th>更新数据</th>
<th>出现问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交</td>
<td>读undo log版本链中最新的数据</td>
<td>共享行锁，事务结束前，别人可以读但不能改这行数据</td>
<td>脏读、不可重复读、幻读</td>
</tr>
<tr>
<td>读已提交</td>
<td>MVCC中的快照读，每次读请求都生成一个读视图</td>
<td>独占行锁，事务结束前，其他事务不能修改和读这行数据</td>
<td>不可重复读、幻读</td>
</tr>
<tr>
<td>可重复读</td>
<td>MVCC中的快照读，但只生成一个读视图</td>
<td>Next-key行锁，事务结束前，其他事务不能够操作这行数据解决部分幻读问题</td>
<td>幻读</td>
</tr>
<tr>
<td>串行读</td>
<td>共享表锁，读取版本链中最新版本</td>
<td>独占表锁，解决所有问题</td>
<td>无（暴力锁表）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>总结</strong>：</p>
<p>并发处理的方法是通过 锁（共享和排他这种乐观锁，写写隔离） 和 MVCC（InnoDB引擎分配的悲观锁，读写隔离）</p>
<p>锁从粒度分为，行级锁和表级锁</p>
<p>锁从类别分为：共享锁和排他锁（主动加锁，一般在查询的时候）</p>
<p>行级锁又分为：记录锁、间隔锁、记录+间隔 = 临键锁（引擎自带的锁，为了实现不同的隔离级别）。</p>
<p>默认的可重复读隔离级别是用临键锁。如果操作的是唯一索引或主键，会降级成记录锁提高性能。</p>
<p>意向锁是判断表中是否有行级的读/写锁的。</p>
<p>MVCC是解决丢失修改和不可重复读的问题。MVCC的实现是基于 <strong>undo log版本链</strong> + <strong>read review读视图</strong>。</p>
<h3 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h3><ul>
<li>索引为什么是用B+树呢？</li>
</ul>
<p>​        二叉查找树（BST）：不平衡导致时间复杂度容易从 O(log2N) 走向 O(N) ，即二叉树成链表了。</p>
<p>​        平衡二叉树（AVL）：插入和删除因为需要平衡而产生树的旋转，而旋转耗时间。虽然他的时间复杂度无论是查找、插入还是删除都是 O(log2N)。</p>
<p>​        红黑树：只比AVL性能好一点点，树的平衡性差，造成和BST一样的树高问题。</p>
<p>​        B树：与二叉树相比，B树的非叶子结点可以有多个子树，且非叶子结点存储信息，当总结点数量相同时，树高远远小于二叉树，磁盘的IO次数大大下降。</p>
<p>​        B+树：多路平衡查找树，与B树相比，叶子结点存储信息，非叶子结点不存储信息，并且叶子结点之间用单向链表相连。这样结构的好处有三点：<strong>更少的IO次数</strong>（多叉树，因为每一个页存储的是下一个地址，非叶子结点可以有更多的子结点，层数就更低）、<strong>更适用范围查找</strong>（叶子结点单向链表结构）、<strong>更稳定的查询效率</strong>（B树的查询效率在1到树高之间，分别对应记录在根结点和叶子结点；而B+树全部都在叶子结点）。</p>
<h3 id="MySQL-优化"><a href="#MySQL-优化" class="headerlink" title="MySQL 优化"></a>MySQL 优化</h3><ul>
<li>读写分离了解嘛？</li>
</ul>
<p>​        <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation.png" srcset="/img/loading.gif" lazyload alt="读写分离示意图"></p>
<p>​        一般情况下都是一主多从的方案，主负责写，从负责读。</p>
<ul>
<li>读写分离的问题？解决方案？</li>
</ul>
<p>​        主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 <strong>主从同步延迟</strong> 。</p>
<p>​        可以应用在实时性不用特别高的场景，比如说评论。</p>
<ul>
<li>分库分表？</li>
</ul>
<p>​        读写分离主要应对的是数据库【读并发】，没有解决数据库【存储问题】。试想一下：<strong>如果 MySQL 一张表的数据量过大怎么办?</strong></p>
<p>​        换言之，<strong>我们该如何解决 MySQL 的存储压力呢？</strong></p>
<p>​        答案之一就是 <strong>分库分表</strong>。</p>
<p>​        <strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p>
<p>​        <strong>垂直分库</strong> 就是把单一数据库按照业务进行划分，进而将一个数据库的压力分担到多个数据库。</p>
<p>​        <img src="data:image/png;base64,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" srcset="/img/loading.gif" lazyload alt="垂直分库">        </p>
<p>​        <strong>水平分库</strong> 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p>
<p>​        <img src="https://javaguide.cn/assets/horizontal-slicing-database.53fbc43a.png" srcset="/img/loading.gif" lazyload alt="水平分库"></p>
<ul>
<li>什么是分表？</li>
</ul>
<p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>
<p><strong>垂直分表</strong> 是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p>
<p><strong>水平分表</strong> 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p>
<p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p>水平拆分只能解决单表数据量大的问题，为了提升性能，我们通常会选择将拆分后的多张表放在不同的数据库中。也就是说，水平分表通常和水平分库同时出现。</p>
<p><img src="https://javaguide.cn/assets/two-forms-of-sub-table.3475ce44.png" srcset="/img/loading.gif" lazyload alt="分表"></p>
<ul>
<li>什么时候分库分表？</li>
</ul>
<p>遇到下面几种场景可以考虑分库分表：</p>
<ul>
<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢。</li>
<li>数据库中的数据占用的空间越来越大，备份时间越来越长。</li>
<li>应用的并发量太大。</li>
</ul>
<p><strong>总结</strong>：</p>
<p>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。</p>
<p>读写分离基于主从复制，MySQL 主从复制是依赖于 binlog 。</p>
<p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上。<strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>
<p>引入分库分表之后，需要系统解决事务（事务需要涉及多个数据库中的表）、分布式 id（自增主键没有一致性的问题，水平分表和水平分库出现的问题）、无法 join 操作问题（组合数据的问题，垂直分表容易出现的问题）。</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis缓存管理机制"><a href="#Redis缓存管理机制" class="headerlink" title="Redis缓存管理机制"></a>Redis缓存管理机制</h2><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>由于缓存是有上限的，所以有了淘汰机制，最简单的淘汰机制就是定时删除。</p>
<p>惰性删除，只有在查询到的时候才删除。</p>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。 </p>
<p>避免还是无法合理的解决这个缓存的问题，我们提出了8种内存淘汰策略。避免撑满空间。</p>
<h3 id="Redis-生产问题"><a href="#Redis-生产问题" class="headerlink" title="Redis 生产问题"></a>Redis 生产问题</h3><p><strong>缓存击穿</strong>：redis中都没有缓存的key，突然请求直接大面积打到mysql，让mysql崩溃 </p>
<p>解决方案：用布隆过滤器解决。</p>
<p><strong>缓存雪崩</strong>：redis中热点key突然大面积失效，突然请求直接大面积打到mysql，让mysql崩溃。比如秒杀商品都设置固定12h，结果都失效了，还在被请求。</p>
<p>解决方案：随机设置热点key的过期时间，让它们不一致；设置永久不过期，比如双11期间这些热点商品keyID都不过期。</p>
<h2 id="Redis持久化存储机制"><a href="#Redis持久化存储机制" class="headerlink" title="Redis持久化存储机制"></a>Redis持久化存储机制</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><strong>什么是 AOF 持久化？</strong></p>
<p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendonly <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。（AOF很像是binlog）</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendfsync always    <span class="hljs-comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br>appendfsync everysec  <span class="hljs-comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘</span><br>appendfsync no        <span class="hljs-comment">#让操作系统决定何时进行同步</span><br></code></pre></td></tr></table></figure>
<p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>AOF日志如何实现？</strong></p>
<p>关系型数据库（如MySQL）通常都是<strong>执行命令之前</strong>记录日志（方便故障恢复），而 Redis AOF 持久化机制是在<strong>执行完命令之后</strong>再记录日志。（对比binlog和undo log 说的）</p>
<p><strong>AOF重写</strong></p>
<p>重写开始的时候记录一个快照，最后整理完的对比现在aof_buf里面的，多出来的直接添加到重写过的aof的后面。</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-19 at 16.05.43.png" srcset="/img/loading.gif" lazyload alt="AOF重写"></p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>压缩二进制的备份，然后可以自定义备份的周期时间。</p>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 主线程执行，会阻塞主线程；</li>
<li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>RDB 比 AOF 优秀的地方</strong> ：</p>
<ul>
<li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复（RDB更像是redo log，记录的是压缩后的二进制的真实数据）。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li>
<li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li>
</ul>
<p>（1、RDB是经过二进制压缩的，只保存时间戳+数据集，文件小，适合做备份和灾难恢复；2、直接还原数据就行，而AOF需要逐条指令写入）</p>
<p><strong>AOF 比 RDB 优秀的地方</strong> ：</p>
<ul>
<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>
</ul>
<p>（1、RDB记录的是数据，虽然恢复容易，但是记录的时候很占用cpu和内存的资源，比如AOF的秒级持久化安全；2、RDB是特定的二进制格式保存的，所以序列化的方式可能不同，有多个版本的RDB，存在老版本的Redis服务不兼容新版本的RDB格式的问题；3、AOF的分析很直观，都是语句）</p>
<h2 id="Redis的高可用和哨兵机制"><a href="#Redis的高可用和哨兵机制" class="headerlink" title="Redis的高可用和哨兵机制"></a>Redis的高可用和哨兵机制</h2><p>通过主从模式，主节点负责写数据，从节点要负责度数据，然后做好数据同步，读写分离提高性能。另外主节点崩溃了，从节点就顶上去，还可以实现高可用。</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/image-20221119162231298.png" srcset="/img/loading.gif" lazyload alt="image-20221119162231298"></p>
<p><strong>Sentinel有什么作用？</strong></p>
<ul>
<li>监控：监控所有redis的（包括自己）状态是否正常。</li>
<li>故障转移：如果一个master出现故障，Sentinel会帮助我们实现故障转移，自动将某一台slave升级为master，确保整个Redis系统的可用性。</li>
<li>通知：通知slave新的master连接信息，让他们执行replicaof成为新的matser的slave。</li>
<li>配置提供：客户端链接sentinel请求master的地址，如果发生故障转移，sentinel会通知新的master连接信息给客户端。</li>
</ul>
<p>Redis Sentinel  本身设计的就是一个分布式系统，建议多个sentinel节点协作运行。这样做的好处是：</p>
<ul>
<li>多个sentinel节点通过投票的方式来确定sentinel节点是否真的不可用，避免误判（比如网络问题可能会导致误判）</li>
<li>Sentinel自身就是高可用</li>
</ul>
<p>如果想要实现高可用，建议将哨兵 Sentinel 配置成单数且大于等于 3 台。高可用是系统不间断的运行的能力。</p>
<p><strong>Sentinel如何检测节点是否下线？</strong></p>
<ul>
<li>主观下线：哨兵节点认为某个Redis节点已经下线了，但还不是很确定，<strong>需要其他sentinel节点的投票</strong>。</li>
<li>客观下线：法定数量过半认为某个redis节点下线了，那就是真的下线了，<strong>被动下线</strong>。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979614062-f3219a07-0815-4b0d-9b63-750219d9e59c.png" srcset="/img/loading.gif" lazyload alt="redis-master-slave-sentinel-ping.png"></p>
<p>有效回复不一定是PONG，可以是-LOADING或者-MASTERDOWN。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979628031-1ccb8eb9-5da0-46d5-a16a-01f6724c2ee1.png" srcset="/img/loading.gif" lazyload alt="redis-master-slave-sentinel-ping-sdown.png"></p>
<p><strong>slave下线对redis集群影响不大，但是master认定主观下线就不一样了</strong>，sentinel整体还要对其进行进一步核实，确保master是真的下线了。</p>
<p>master 才被判定客观下线。当法定数量（通常为过半）的sentinel节点认定master已经下线，裁判定下线。这样做的目的是为了<strong>防止误判</strong>，毕竟故障转移的开销比较大，这也是为什么Redis官方推荐部署多个sentinel节点。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979639394-8eb65a8f-5905-473d-90d8-47cba7c58ae5.png" srcset="/img/loading.gif" lazyload alt="redis-master-slave-sentinel-ping-odown.png"></p>
<p>哨兵中会有一个Leader的角色来负责故障转移，自动从slave中选出一个新的master并执行完相关的一些工作（比如通知slave新的master连接信息，让它们执行replicaof成为新的master的slave）。</p>
<p>如果没有足够数量的sentinel节点认定master已经下线的话，当master能对sentinel的PING命令进行有效回复之后，master也就不再被认定为主观下线，回归正常。</p>
<p>高可用的根本就是要求我们总有个redis在工作，不会挂掉。单纯的集群并不能够有高可用，因为集群无法保证其本身高可用，若你坏掉一个master，里面的缓存就全部丢了，其实还是资源浪费还是很大的，很可能出现缓存击穿，甚至是雪崩。所以我们需要集群和高可用哨兵共同解决高可用和负载均衡的问题。</p>
<h2 id="Redis的集群"><a href="#Redis的集群" class="headerlink" title="Redis的集群"></a>Redis的集群</h2><p>集群就是多个master</p>
<p>1、缓存的数据量太大，不够放的。</p>
<p>2、并发量要求太大。</p>
<p>核心思想就是分摊压力，同样的效能给两个能干活的人一定是压力减半的。</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fredis-cluster%2Fredis-cluster-shard.png&amp;sign=33a67ec08ad62aa857bafa46a651b091322094cb5ebd49722d3e45d87d76a619" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="📕面试常见题目"><a href="#📕面试常见题目" class="headerlink" title="📕面试常见题目"></a>📕面试常见题目</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>
<p><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</p>
<hr>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li>为什么Redis不采用c语言的字符串直接做具体实现？</li>
</ul>
<p>​        O(n)复杂度获取长度 <strong>—&gt;</strong> O(1)</p>
<p>​        没有较好的扩容机制 <strong>—&gt;</strong> 减少扩容引起拌匀次数</p>
<p>​        特殊字符无法处理 <strong>—&gt;</strong> 更加复杂二进制数据</p>
<p>​        sds（simple dynamic string，简单动态字符串）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// before 3.0</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len; <span class="hljs-comment">// 使用长度</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>; <span class="hljs-comment">// 未使用长度</span><br>  <span class="hljs-type">char</span> buf[];<br>&#125;<br><br><span class="hljs-comment">// after 3.0</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len; <span class="hljs-comment">// 使用长度</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc; <span class="hljs-comment">// 分配给sds的长度</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags; <span class="hljs-comment">// sds的类型，可以分支为sdshdr8、sdshdr16、sdshdr32、sdshdr64</span><br>  <span class="hljs-type">char</span> buf[]<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>​        双向链表</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>redis用拉链法作为hash表的实现，拉链法（重复就连在同一个hash地址的链表尾端）</p>
<ul>
<li>redis中哈希表的数据结构？</li>
</ul>
<p>​        dictht。单纯表示一个哈希表</p>
<p>​        dictEntry。哈希表的一项，看作kv对</p>
<p>​        dict。redis给外层调用的哈希表结构，包含两个dictht</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br> 	dictEntry **table; <span class="hljs-comment">// hash表数组</span><br> 	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size; <span class="hljs-comment">// hash表大小</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask; <span class="hljs-comment">// hash掩码解决溢出问题</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used; <span class="hljs-comment">// hash表已使用的大小</span><br>&#125; dictht;<br></code></pre></td></tr></table></figure>
<p>负载因子（越低查找速度越快）：used/size</p>
<h4 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h4><ul>
<li>普通集合和整数集合？</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 整数集合</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br>  <span class="hljs-type">uint32_t</span> encoding; <span class="hljs-comment">// 编码方式，int16_t……</span><br>  <span class="hljs-type">uint32_t</span> length; <span class="hljs-comment">// 集合长度</span><br>  <span class="hljs-type">int8_t</span> contents[]; <span class="hljs-comment">// 元素数组</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h4><p>元素有序，查找任意元素复杂度为O(n)，O(n) —&gt; O(logn)，二分查找，用跳表做索引</p>
<ul>
<li><p>ZSet业务场景：利用redis实现 微博热搜TopK</p>
<p>按之前map结构实现：k存储热搜标题，v存储当前标题热度</p>
<p>针对该TopK排序，选取热度为TopK的作为返回值，时间复杂度为O(nlogn)</p>
</li>
</ul>
<p>​       如果我们map结构本身就是有序的（Zset），复杂度降为O(k)</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>redis是内存型数据库</p>
<p>优点：内存读取速度更快</p>
<p>缺点：数据易失性，断电后内存数据消失</p>
<p>解决办法：RDB（redis data base）【存快照】，AOF（append only file）【存指令，复现指令追加文件到老文件后面】</p>
<h4 id="RDB-1"><a href="#RDB-1" class="headerlink" title="RDB"></a>RDB</h4><p>把目前redis内存中的数据，生成一个快照（RDB文件），保存在硬盘中。若发生事故，redis可以通过RDB文件，进行文件读取，并将数据重新载入内存中。【全量备份】</p>
<ul>
<li>RDB的触发条件？</li>
</ul>
<p>压缩二进制的备份，然后可以自定义备份的周期时间。</p>
<p>（手动）Redis 提供了两个命令来生成 RDB 快照文件：</p>
<p>​        <code>save</code> : 主线程执行，会阻塞主线程；</p>
<p>​        <code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</p>
<p>（自动）配置文件中写入save m n，代表m秒内发生n次变化时，会执行bgsave</p>
<h4 id="AOF-1"><a href="#AOF-1" class="headerlink" title="AOF"></a>AOF</h4><p>记录之后所有对Redis数据进行修改的操作</p>
<p>如果发生事故，redis通过AOF文件，将文件中的数据修改命令全部执行一遍，一次恢复数据</p>
<ul>
<li>指令太多AOF文件太大？</li>
</ul>
<p>​        AOF的重写与恢复，文件重写策略，创建新的AOF文件，以替代原有的冗余AOF文件。</p>
<p>​        触发条件：</p>
<p>​        （手动）bgrewriteaof</p>
<p>​        （自动）配置文件中设置appendonly yes开启。三种写入策略：<strong>always</strong>，同步写回，执行完毕就写入，可靠性好，但性能差；<strong>Everysec</strong>【默认】，每秒写回，先写完的命令进入缓冲区跟redo log刷盘模式2一样，后台每秒刷入磁盘；<strong>No</strong>，全部写入buffer中，何时刷盘由os决定。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="缓存淘汰"><a href="#缓存淘汰" class="headerlink" title="缓存淘汰"></a>缓存淘汰</h4><ul>
<li>先进先出FIFO</li>
<li>最近最少使用LRU</li>
<li>最不经常使用LFU</li>
</ul>
<h4 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h4><ul>
<li>主动删除</li>
</ul>
<p>​        设置好时间间隔，指定时间到了主动删除。</p>
<p>​        优点：易于理解，设置合理时间间隔后不会使内村占用超标</p>
<p>​        缺点：当redis比较忙时，设置删除时间碰巧到期了，主动删除会增加redis的负担</p>
<ul>
<li>惰性删除</li>
</ul>
<p>​        程序取值时查看该数据是否已经过期，如果没过期，则返回，过期了就删除</p>
<p>​        优点：服务器运算资源占用小</p>
<p>​        缺点：容易造成某些数据长期霸占在内存中，不被删除（比如非热点数据）        </p>
<ul>
<li>定期删除</li>
</ul>
<p>​        主动+惰性。每隔一段时间跑主动，不跑主动时就是惰性。</p>
<h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><ul>
<li>Cache Aside（旁路缓存）核心思想：当缓存的数据有更新值了，他采用的不是更新缓存数据，而是删除缓存数据。<ul>
<li>模式一：先删除缓存，再修改数据库的数据（容易出问题，写请求慢于读请求，可能在修改数据库的期间被别人读到了）[延迟双删，删除后读的脏缓存]</li>
<li>模式二：先修改数据库的数据，再删除缓存</li>
</ul>
</li>
</ul>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><ul>
<li><strong>缓存穿透</strong>：缓存和数据库都没查到数据</li>
<li>解决方案：拦截非法查询请求（id都大于0，他查小于0）、缓存空对象、布隆过滤器解决</li>
</ul>
<p>​        布隆过滤器：【设计思路】设计k个hash映射函数，这k个映射函数各不相同，把在数据库中的有效数据通过这个映射函数得到数组指定位置，并置为1。【查询思路】输入查询数据，通过这一系列hash函数，判断对应位置是否全为1。如果是，大概率是有效请求，如果有0，则一定是无效请求。（有点像深度学习，取特征然后对比）</p>
<h4 id="缓存击穿（单点）"><a href="#缓存击穿（单点）" class="headerlink" title="缓存击穿（单点）"></a>缓存击穿（单点）</h4><ul>
<li><p><strong>缓存击穿</strong>：redis中都没有缓存的key，突然请求直接大面积打到mysql，让mysql崩溃 </p>
</li>
<li><p>解决方案：用布隆过滤器解决、设置热点数据永不过期。</p>
</li>
</ul>
<h4 id="缓存雪崩（多点）"><a href="#缓存雪崩（多点）" class="headerlink" title="缓存雪崩（多点）"></a>缓存雪崩（多点）</h4><ul>
<li><p><strong>缓存雪崩</strong>：redis中热点key突然大面积失效，突然请求直接大面积打到mysql，让mysql崩溃。比如秒杀商品都设置固定12h，结果都失效了，还在被请求。</p>
</li>
<li><p>解决方案：随机设置热点key的过期时间，让它们不一致；设置永久不过期，比如双11期间这些热点商品keyID都不过期。</p>
</li>
</ul>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>跟mysql一样，主写，从读。主从进行数据同步。</p>
<p>全量复制：初次复制后的同步</p>
<ol>
<li>主库执行BGSAVE生成对应的RDB文件，同时开辟缓冲区，记录在RDB文件实行过程中，收到的新数据命令。</li>
<li>RDB文件产生后，主库发送给从库，从库通过RDB恢复数据</li>
</ol>
<p>断线后重复制：断线后再连接后的复制</p>
<ol>
<li>服务器运行ID：唯一确定主库身份</li>
<li>复制偏移量：代表主节点传输了的字节数</li>
<li>复制积压缓冲区：复制积压缓冲区是一个先进先出（FIFO）队列，存储了最近主节点的数据修改命令。</li>
<li>【判断流程】先看看是否是之前的主库；再根据偏移量判断复制积压缓冲区可以否进行复制；可以就用断线后重复制，不可以就全量</li>
</ol>
<p><strong>STEP</strong>：</p>
<ul>
<li>主从库上线后先进行握手通信，信息验证</li>
<li>从库发送PSYNC（同步命令）给主库，开始数据同步过程，并发送主库ID（确定之前主库身份），复制的进度偏移量offset（之前同步的位置）</li>
<li>主库根据从库发送的信息进行逻辑判断，告诉从库要进行的是全量复制/断线后重复制</li>
</ul>
<p>缺点：主库挂了就全乱了。</p>
<h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><p>哨兵机制：新建哨兵组，对主库从库统一进行监控，如果主库坏了，哨兵组进行投票，从从库中重新选出主库</p>
<p>本质上，从代码层面上讲，哨兵是一个不提供数据服务的redis服务器</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979614062-f3219a07-0815-4b0d-9b63-750219d9e59c.png" srcset="/img/loading.gif" lazyload alt="redis-master-slave-sentinel-ping.png"></p>
<p><strong>有效回复不一定是PONG，可以是-LOADING或者-MASTERDOWN。</strong></p>
<p>一台主库三台从库，哨兵系统监控着这四台机器。每个机器都会向哨兵一定时间（10s）发送心跳检测。哨兵系统如果一定时间收不到回复，就默认机器断连。</p>
<ul>
<li><p>判断下线的逻辑是：</p>
<ul>
<li>当某个哨兵发现主库连接不上，会将其标注为<strong>主观下线</strong>，并通知其他哨兵连接下主库试试</li>
<li>超过半数的哨兵确定连接不上后，就会标记该主库为<strong>客观下线</strong>，并执行故障转移（在从库中选出新的主库）</li>
</ul>
</li>
<li><p>故障转移：</p>
<ul>
<li>在故障转移中，会通过选举协议，从所有哨兵中选择一个节点，作为老大，主持负责新主库的选举工作（先选主哨兵负责新选举）</li>
<li>选取完成后，哨兵会对这个从库发送slave of no one，此时从库就变成主库了（再进行从库的挑选）</li>
<li>同时向其他slave发送新主库的IP端口</li>
<li>如果此时主库重新上线，他就会被哨兵系统降级为从库，从属于新的主库</li>
</ul>
</li>
</ul>
<p>高可用的根本就是要求我们总有个redis在工作，不会挂掉。单纯的集群并不能够有高可用，因为集群无法保证其本身高可用，若你坏掉一个master，里面的缓存就全部丢了，其实还是资源浪费还是很大的，很可能出现缓存击穿，甚至是雪崩。所以我们需要集群和高可用哨兵共同解决高可用和负载均衡的问题。</p>
<h4 id="集群-1"><a href="#集群-1" class="headerlink" title="集群"></a>集群</h4><p>集群就是多个master</p>
<p>1、缓存的数据量太大，不够放的。</p>
<p>2、并发量要求太大。</p>
<p>核心思想就是分摊压力，同样的效能给两个能干活的人一定是压力减半的。</p>
<p><strong>Cluster</strong>：redis提供的分布式数据库解决方案</p>
<ul>
<li>自动将你的数据切分给多个节点存储</li>
<li>即使这些节点中一部分宕机，也可以继续执行数据操作</li>
</ul>
<p><strong>分区策略</strong>：采用虚拟槽，所有键通过CRC16校验函数，对16384取模，决定数据分配到哪个槽位。每个redis的cluster节点负责一部分槽数据的存储。并且该节点可以结合之前讲到的主从复制模式，将分配给它的数据进行复制。</p>
<p><strong>查询策略</strong>：每个节点都会存储整个集群节点信息，这些信息也被称为元信息</p>
<p>这个节点存储的元数据包括在该节点视角下：</p>
<ol>
<li>各节点存储的slot数据</li>
<li>各节点的master和slave状态</li>
<li><p>各节点是否存活</p>
<p>………</p>
</li>
</ol>
<p><strong>元数据的信息的传播</strong>：gossip协议，每个节点都把自己的数据信息通过这个协议散布出去</p>
<p>具体过程：</p>
<ol>
<li>Gossip协议是周期性的，每隔一定时间，执行一次</li>
<li>所有被感染节点选择k个邻接节点散布信息</li>
</ol>
<p><strong>cluster的扩容和缩容</strong>：</p>
<ol>
<li>节点判断数据是否还存在于本节点（是：返回预期数据；否：执行2）</li>
<li>判断数据所在槽是否在迁移（是：返回ASK错误，重定向新节点位置；否：key不存在）</li>
</ol>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><h2 id="CAP基础"><a href="#CAP基础" class="headerlink" title="CAP基础"></a>CAP基础</h2><p><strong>一致性（Consistency）</strong>：等同于所有结点访问<strong>同一份</strong>【最新】的数据副本</p>
<p><strong>可用性（Availability）</strong>：每次请求都能获取到<strong>非错</strong>的响应——但<strong>不能</strong>保证获取的数据为最新数据</p>
<p><strong>分区容错性（Partition Tolerance）</strong>：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。（简单解释：分区容忍性就是尽管任意数量的消息被节点间的网络<strong>丢失或延迟</strong>，系统仍然正常运行。</p>
<p>对于一个分布式系统不可能同时满足以上三点。</p>
<p><img src="https://raw.githubusercontent.com/csunny/etcd-from-arch-to-souce-code/master/_asserts/images/cap.jpg" srcset="/img/loading.gif" lazyload alt="CAP理论- ETCD源码剖析"></p>
<p><strong>Q1:CAP的C和事务中的ACID的C一样吗？</strong></p>
<p>A：不一样，因为CAP的C强调的是所有的分布式结点访问的都是<strong>最新</strong>的<strong>同一份</strong>数据。而事务中的ACID的C指的是事务前后的状态是一致的，比如说A转账给B，转移前后他俩的金钱总额不会改变。</p>
<p><strong>一写（A可用性得到了保证）</strong></p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-20 at 10.34.25.png" srcset="/img/loading.gif" lazyload alt="一写"></p>
<p><strong>三写（C一致性得到了保证）</strong></p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-11-20 at 10.34.51.png" srcset="/img/loading.gif" lazyload alt="三写"></p>
<h2 id="CAP的现实用例"><a href="#CAP的现实用例" class="headerlink" title="CAP的现实用例"></a>CAP的现实用例</h2><p><strong>在分布式环境下，P一定是存在的，一旦出现了网络分区，那么一致性和可用性就一定要抛弃一个。</strong></p>
<p>对于NoSql数据库，更加注重可用性，比如redis，所以这是一个AP系统。</p>
<p>对于分布式关系行数据库，必须要保证一致性，比如mysql，所以这是一个CP系统。</p>
<p>但分布式关系型数据库仍有高可用性需求，虽然达不到CAP理论中的100%可用性，但一般都具备五个9（99.999%）以上的高可用。</p>
<p>我们可以把分布式关系型数据库看作<strong>CP+HA</strong>的系统（CP就是一致性数据库，HA就是高可用性集群，如哨兵机制实现的主从关系）。由此产生了两个广泛应用的指标。</p>
<p><strong>RPO（Recovery Point Objective）</strong>：恢复点目标，指数据库在灾难发生后会丢失多长时间的数据。分布式关系型数据库RPO=0。</p>
<p><strong>RTO（Recovery Time Objective）</strong>：恢复时间目标，指数据库在灾难发生后到整个系统恢复正常所需要的时间。分布式关系行数据库RTO&lt;几分钟。</p>
<h2 id="CAP视角看较成熟的分布式方案"><a href="#CAP视角看较成熟的分布式方案" class="headerlink" title="CAP视角看较成熟的分布式方案"></a>CAP视角看较成熟的分布式方案</h2><p><strong>Quorum Replication</strong> </p>
<p>详解 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/232351178">https://zhuanlan.zhihu.com/p/232351178</a></p>
<ul>
<li>N（副本数），W（写入成功副本数），R（读取成功副本数）</li>
<li>W + R &gt; N，永远都有一个副本是最新且正确的，即最少的情况是 W + R = N + 1，这个1就是至少多出来的，如果说没有重合的地方，那么他们就不会大于N。</li>
<li>N = 3， W = 1， R = 3（写可用AP，读一致CP）</li>
<li>N = 3， W = 3， R = 1（写一致CP，读可用AP）</li>
</ul>
<p><strong>共识算法</strong></p>
<ul>
<li><p>副本之间有交互，leader提供读写，leader宕了选一个新leader，只有选举的短暂过程不可用</p>
</li>
<li><p>CP + HA</p>
</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><p><strong>TCP/IP模型</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-2d62ba265be486cb94ab531912aa3b9c_1440w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>一般我们分成五层，（自上而下）<strong>应用层、传输层、网络层、数据链路层、物理层</strong></p>
<h2 id="HTTP篇"><a href="#HTTP篇" class="headerlink" title="HTTP篇"></a>HTTP篇</h2><h3 id="HTTP-常见面试题"><a href="#HTTP-常见面试题" class="headerlink" title="HTTP 常见面试题"></a>HTTP 常见面试题</h3><p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2023-02-27 at 15.25.58.png" srcset="/img/loading.gif" lazyload alt="面试常见题"></p>
<p><strong>1. HTTP基本概念</strong></p>
<ul>
<li>http是什么？</li>
</ul>
<p>​        超文本传输协议，一种网络间通信的协议</p>
<ul>
<li>HTTP常见的状态码有哪些？</li>
</ul>
<p>​        <strong>1xx</strong>：提示信息</p>
<p>​        <strong>2xx</strong>：服务器成功处理了请求</p>
<p>​        <strong>3xx</strong>：客户端请求的资源发生了重新定向，用新的URL重新发送请求获取资源</p>
<p>​        <strong>4xx</strong>：客户端发送报文有错误，服务端无法处理。（客户端发生错误）</p>
<p>​        <strong>5xx</strong>：服务端发生错误。</p>
<ul>
<li>HTTP的常见字段？</li>
</ul>
<p>​        <strong>Host</strong>：域名</p>
<p>​        <strong>Content-Length</strong>：服务端返回数据的长度</p>
<p>​        <strong>Connection</strong>：HTTP/1.1 版本的默认链接都是持久连接，兼容老版本的HTTP，指定Connection字段的值为Keep-Alive</p>
<p>​        <strong>Content-Type</strong>：text/html；charset=utf-8 代表发送的是网页，编码是UTF-8</p>
<p>​        <strong>Content-Encoding</strong>：字段说明数据的压缩方法。客户端需要用<code>Accept-Encoding：gzip，deflate</code>字段说明自己可以接受哪些压缩方法</p>
<p><strong>2. GET 与 POST</strong></p>
<ul>
<li>GET和POST的区别？</li>
</ul>
<p>​        <strong>GET</strong>：从服务器获取资源</p>
<p>​        <strong>POST</strong>：相反操作，向URI指定的资源提交数据，数据就放在报文的body里</p>
<p>​        </p>
<ul>
<li>GET和POST都是安全的且幂等的嘛？（安全：请求方法不会破坏服务器上的资源；幂等：多次执行相同的操作结果相同</li>
</ul>
<p>​        GET是安全且幂等的，他是只读操作</p>
<p>​        POST是新增或提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，不是幂等的。</p>
<p><strong>3. HTTP 特性</strong></p>
<ul>
<li>HTTP/1.1 优点有哪些，怎么体现？</li>
</ul>
<p>​        <strong>简单</strong>：报文格式都是 header + body，头部信息是 kv 简单文本的形式</p>
<p>​        <strong>灵活和易于扩展</strong>：HTTP工作在应用层（OSI 第七层），下层可以随意变化。HTTP协议里各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。</p>
<p>​        <strong>应用广泛和跨平台</strong></p>
<p>​        缺点：无状态、明文传输，同时还有一个大缺点，不安全。无状态恶心的是，你需要每一步都要验证身份。通过cookie来添加验证信息</p>
<ul>
<li>HTTP/1.1 的性能如何？</li>
</ul>
<p>​        HTTP协议是基于 TCP/IP，并且使用了【请求-应答】的通信模式。</p>
<p>​        <strong>长连接</strong>：http/1.0性能有很大问题，每次连接都要进行TCP三握手，且是串行请求，做了多余的TCP连接和断开。1.1提出了长连接方式，只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p>
<p>​        <strong>管道网络传输</strong>：HTTP/1.1 采用了长连接的方式，使得管道网络传输成为了可能。管道机制允许B请求不必等待A请求响应后就发送请求。但是响应还是按照顺序响应。但是如果A的回应特别慢，后面的请求响应就会排队形成，【队头阻塞】</p>
<p>​        <strong>队头阻塞</strong>：很容易造成性能瓶颈，所以1.1也很一般，后续的2和3都是在优化HTTP的性能。</p>
<p><strong>4. HTTPS 与 HTTP</strong></p>
<ul>
<li>HTTPS和HTTP有哪些区别？</li>
</ul>
<p>​        HTTP是明文的，HTTPS是加密传输的</p>
<p>​        HTTP只需要三握手，而HTTPS需要三握手之后再进行 SSL / TLS 的握手过程</p>
<p>​        HTTP的端口号是80，HTTPS的端口号是443</p>
<p>​        HTTPS需要向CA申请证书</p>
<ul>
<li>HTTPS解决了HTTP的哪些问题？</li>
</ul>
<p>​        安全方面：窃听风险（偷看数据），篡改风险（修改数据），冒充风险（利用数据身份操作）</p>
<p>​        解决方案：信息加密（混合加密的方式实现信息通信的机密性）、校验机制（摘要算法实现独一无二的身份信息）、身份证书（防止身份伪造）</p>
<p>​        信息加密：采用的混合加密的方式，即对称加密和非对称加密，先使用非对称加密使得客户端的对称密钥发送给服务端（过程是安全的，因为非对称加密是无法破解的，解密和加密都是由服务端完成）。然后后续都用客户端的那个密钥进行加密通信就安全了。唯一不安全的就是这个CA证书是假的，但这个概率非常的低，因为CA是由第三方验证的！</p>
<p><img src="https://img-blog.csdnimg.cn/20210715220241939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="HTTPS过程"></p>
<ul>
<li>HTTPS是如何建立连接的？</li>
</ul>
<p>​        客户端索要并验证服务器的公钥</p>
<p>​        双方协商生产【会话密钥】</p>
<p>​        双方采用【会话密钥】进行加密通话</p>
<p>​        说白了在会话的前两步（请求和获得公钥的过程）中，确保了用户的唯一性和证书的唯一性，保证请求的人没变，证书也是对的证书。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092004.png" srcset="/img/loading.gif" lazyload alt="SSL"></p>
<p><strong>5. HTTP/1.1、HTTP/2、HTTP/3 演变</strong></p>
<ul>
<li>HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</li>
</ul>
<p>​        使用<strong>长连接</strong>改善了 HTTP/1.0 短连接造成的性能开销</p>
<p>​        使用<strong>管道传输</strong>减少了整体的时延</p>
<p>​        <strong>性能瓶颈</strong>：</p>
<p>​        Header无法压缩，只能压缩Body部分</p>
<p>​        Header很大的话，互相交流使用的Header也很大</p>
<p>​        会造成<strong>队头阻塞</strong></p>
<ul>
<li>HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？</li>
</ul>
<p>​        HTTP/2使用的是HTTPS所以安全是有保障的</p>
<p>​        <strong>头部压缩</strong>，通过<code>HPACK</code>算法：在客户端和服务端维护同一个头的信息表，所有字段会存入这个表，生成一个索引号。</p>
<p>​        <strong>二进制格式</strong>，头信息和数据体都是二进制，统称为帧：头信息帧和数据帧。因为是二进制所以传输效率很高。<img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2023-02-27 at 19.53.11.png" srcset="/img/loading.gif" lazyload alt="Screen Shot 2023-02-27 at 19.53.11"></p>
<p>​        <strong>数据流</strong>，数据是流的形式，数据包的传输是没有固定顺序的，但都有自己的编号，客户端发出的都是奇数，服务端发出的都是偶数，客户端还可以指定数据流的优先级。</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2023-02-27 at 19.55.48.png" srcset="/img/loading.gif" lazyload alt="Screen Shot 2023-02-27 at 19.55.48"></p>
<p>​        <strong>多路复用</strong>，HTTP/2 是可以在一个连接中并发多个请求和回应，不用按顺序一一对应。不是串行的了，所以不会有队头阻塞的问题出现。</p>
<p>​        <strong>服务器推送</strong>，改善了传统的请求-应答模式，服务器可以主动在服务端请求html的时候推送静态资源。</p>
<ul>
<li>HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？</li>
</ul>
<p>​        HTTP/2 虽然多个HTTP请求复用一个TCP连接，但是如果出现了一个丢包，那么所有的请求都要等待，一样会发生阻塞。TCP传输层的问题，所以HTTP/3把下层的TCP换成UDP</p>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2023-02-27 at 20.15.19.png" srcset="/img/loading.gif" lazyload alt="HTTP/3"></p>
<p>​        虽然UDP不可靠，但是基于UDP的QUIC协议是可靠的。QUIC只会阻塞发生错误的流，其次他把三握手和TLS三握手合并了，变成了总共三握手，这样减少了交互次数。</p>
<p>​        如何优化 HTTP/1.1 通过<strong>缓存技术避免发送HTTP请求</strong>；<strong>减少HTTP请求的次数</strong>；<strong>压缩响应资源，降低传输资源的大小</strong></p>
<p>​        HTTPS的优化：TLS协议握手过程、握手后的对称加密报文传输。四个方向：硬件优化，计算密集型（好的CPU）；软件优化，操作系统；协议优化，对称加密算法；证书优化。</p>
<ul>
<li>HTTP/2 牛逼在哪里？</li>
</ul>
<p>​    解决HTTP/1.1 性能瓶颈问题（对应后面的并发传输），兼容HTTP/1.1，头部压缩，二进制帧，并发传输，服务器主动推送资源</p>
<ul>
<li>HTTP/2 的缺点？</li>
</ul>
<p>​    队头阻塞，TCP（三握手）与TLS（四握手）的握手时延，网络迁移需要重新连接（基于TCP的通病，因为TCP必须先于目标建立连接）</p>
<p>​        </p>
<h2 id="TCP篇"><a href="#TCP篇" class="headerlink" title="TCP篇"></a>TCP篇</h2><h3 id="TCP-基本认识"><a href="#TCP-基本认识" class="headerlink" title="TCP 基本认识"></a>TCP 基本认识</h3><ul>
<li>TCP的头格式</li>
</ul>
<p>​        序列号：用来解决网络包乱序的问题</p>
<p>​        确认应答号：用来确定接收到了不丢包</p>
<p>​        控制位：</p>
<ul>
<li>为什么需要TCP协议？TCP工作在哪一层？</li>
</ul>
<p>​        IP层是不可靠的，他不保证网络包中数据的完整性，所以需要TCP或者UDP作为上游的传输层来保证可靠性。</p>
<ul>
<li>什么是TCP？</li>
</ul>
<p>​        TCP是<strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>基于字节流</strong>的传输层通信协议</p>
<p>​        面向连接：一对一</p>
<p>​        可靠的：TCP可以保证一定到达接收端</p>
<p>​        字节流：消息是没有边界的</p>
<ul>
<li>什么是TCP连接？</li>
</ul>
<p>​        用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</p>
<p>​        Socket：由IP地址和端口号组成</p>
<p>​        序列号：用来解决乱序问题等</p>
<p>​        窗口大小：用来做流量控制</p>
<ul>
<li>如何唯一确定一个TCP连接呢？</li>
</ul>
<p>​        TCP的四元组：<strong>源地址</strong>、<strong>源端口</strong>、<strong>目的地址</strong>、<strong>目的端口</strong></p>
<ul>
<li>有一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？</li>
</ul>
<p>​        最大的连接数 = 客户端的IP数 * 客户端的端口数</p>
<p>​        现实中最大并发TCP连接数远不能达到理论上限</p>
<ul>
<li>UDP和TCP有什么区别？分别的应用场景是？</li>
</ul>
<p>​        <strong>连接</strong>：TCP是面向连接的传输层协议，传输数据前先要建立连接。UDP是不需要连接</p>
<p>​        <strong>服务对象</strong>：TCP是一对一。UDP是一对一、一对多、多对多的交互通信</p>
<p>​        <strong>可靠性</strong>：TCP是可靠的。UDP是不可靠的、尽力交付</p>
<p>​        <strong>拥塞控制</strong>、<strong>流量控制</strong>：TCP有拥塞控制和流量控制机制，保证数据传输的安全性。UDP网络拥塞也不影响</p>
<p>​        <strong>首部开销</strong>：TCP首部是20字节（确认交付所以TCP有序列号和应答号），打开选项以后，可以更长。UDP首部只有8个字节并且固定不变。</p>
<p>​        <strong>传输方式</strong>：TCP流式传输，没有边界。UDP是一个包一个包的传输有边界，会丢包和乱序。</p>
<p>​        <strong>分片不同</strong>：</p>
<p>​        <strong>应用场景</strong>：TCP是FTP文件传输，HTTP和HTTPS。UDP是无连接的，比如DNS和视频。</p>
<ul>
<li>为什么UDP头部有包长度字段，而TCP头部则没有包长度字段呢？</li>
</ul>
<p>​        TCP数据的长度 = IP总长度 - IP首部长度 - TCP首部长度</p>
<h3 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h3><ul>
<li>TCP 三次握手过程和状态变迁</li>
</ul>
<p>​        TCP是面向连接的协议，所以使用TCP前必须先建立连接，而<strong>建立连接是通过三次握手进行的</strong>。</p>
<p>​        第三次握手是可以携带数据的，前两次握手是不可以携带数据的。</p>
<ul>
<li>如何在linux系统中查看TCP状态？</li>
</ul>
<p>​        TCP的连接状态查看，在linux可以通过 <code>netstat -napt</code> 命令查看</p>
<ul>
<li>为什么是三次握手？不是两次、四次？</li>
</ul>
<p>​        三次握手才可以阻止重复历史连接的初始化（主要原因），白话就是客户端发送之前layback的请求重新更新了连接。</p>
<p>​        三次握手才可以同步双方的初始序列号</p>
<p>​        三次握手才可以避免资源浪费</p>
<p>​        先确认客户端请求，服务端应答请求，此时客户端回应保持自己的请求</p>
<h3 id="TCP-连接断开"><a href="#TCP-连接断开" class="headerlink" title="TCP 连接断开"></a>TCP 连接断开</h3><ul>
<li>TCP 四次挥手过程和状态变迁？</li>
</ul>
<p>​        确认客户端的断开请求，确认服务端的关闭接受请求。</p>
<h3 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h3><ul>
<li>针对 TCP 应该如何 Socket 编程？</li>
</ul>
<p>​        <strong>一个简易的 Server 的流程如下：</strong></p>
<p>​        1.建立连接，接受一个客户端连接。</p>
<p>​        2.接受请求，从网络中读取一条 HTTP 请求报文。</p>
<p>​        3.处理请求，访问资源。</p>
<p>​        4.构建响应，创建带有 header 的 HTTP 响应报文。</p>
<p>​        5.发送响应，传给客户端。</p>
<p>​        <strong>省略流程 3，大体的程序与调用的函数逻辑如下：</strong></p>
<p>​        socket() 创建套接字</p>
<p>​        bind() 分配套接字地址</p>
<p>​        listen() 等待连接请求</p>
<p>​        accept() 允许连接请求</p>
<p>​        read()/write() 数据交换</p>
<p>​        close() 关闭连接</p>
<p>​        <img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2023-02-28 at 20.38.38.png" srcset="/img/loading.gif" lazyload alt="socket编程"></p>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><ul>
<li>TCP重传、滑动窗口、流量控制、拥塞控制</li>
</ul>
<h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>​        TCP实现可靠传输的方式之一，是通过序列号与确认应答。服务端返回应答号确认收到消息。</p>
<p>​        重传：基于时间驱动的<strong>超时重传</strong>，基于数据驱动的重传（RTO略微大于RTT）。基于数据驱动重传的快速重传。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11151952-d757d59ad721ba00.png?imageMogr2/auto-orient/strip|imageView2/2/w/855" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>（RTT：网络从一段到另一端所用的时间，也就是数据包往返的时间）</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><ul>
<li>窗口的大小是哪一方决定的？</li>
</ul>
<p>​        TCP的头里面有一个window，接收端告诉发送端还有多少缓冲区可以接受数据。</p>
<ul>
<li>发送方的窗口？</li>
</ul>
<p>​        <a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/443934/201912/443934-20191212153101669-1128929789.png"><img src="https://img2018.cnblogs.com/blog/443934/201912/443934-20191212153101669-1128929789.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>程序是如何表示发送方的四个部分呢？</li>
</ul>
<p>​        四个指针（其中一个是组合指针）：<strong>SND.WND</strong>（接收方定的窗口长度）; <strong>SND.UNA</strong>（#2的第一个字节）; <strong>SND.NXT</strong>（#3的第一个字节）; <strong>SND.UNA</strong> + <strong>SND.WND</strong>（#4的第一个字节）</p>
<p>​        可用窗口的大小：SND.WND - (SND.NXT - SND.UNA)</p>
<ul>
<li>接收方的窗口？</li>
</ul>
<p>​        #1 + #2 是已成功接收并确认的数据（等待应用程序读取）</p>
<p>​        #3是未收到但可以接收的数据</p>
<p>​        #4是未收到且不能接收的数据</p>
<ul>
<li>接收和发送的窗口大小一样吗？</li>
</ul>
<p>​        接受约等于发送的窗口。</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>发送方不能无脑的发送数据，要考虑对方的接收能力，超过接收能力就会出发重传机制。</p>
<p>TCP提供一种机制让发送方根据接收方的实际接收能力控制发送的数据量，就是流量控制。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul>
<li>为什么要有拥塞控制，不是有流量控制了吗？</li>
</ul>
<p>​        就像是堵车如果没有疏散的措施，流量保持不变的话就会一直出现局部阻塞，在网络中就是拥塞了。避免发送方发送的数据填满整个网络，定义了一个拥塞控制，通过拥塞窗口cwnd来控制。</p>
<p>拥塞控制的规则：</p>
<ol>
<li>只要网络中没有出现拥塞，cwnd就会一直增加</li>
<li>网络中出现了拥塞，cwnd就会减少</li>
</ol>
<ul>
<li>如何知道当前网络是否出现了拥塞？</li>
</ul>
<p>​        只要发生了超时重传就是拥塞了。</p>
<ul>
<li><p>拥塞控制的算法？</p>
<ul>
<li><p>慢启动</p>
<p>发送方每收到一个ACK，拥塞窗口cwnd的大小就加1（发包的个数指数性增长），涨到门限ssthresh就停止。</p>
<p>cwnd &lt; ssthresh 慢启动；cwnd &gt;= ssthresh 拥塞避免 </p>
</li>
<li><p>拥塞避免</p>
<p>由指数变成线性增长</p>
</li>
<li><p>拥塞发生</p>
<p>出现拥塞，发生数据包的重传。</p>
</li>
<li><p>快速恢复</p>
<p>收到三个重复的ACK后，cwnd变为原来的一半，cwnd = ssthresh + 3</p>
</li>
</ul>
</li>
</ul>
<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" srcset="/img/loading.gif" lazyload alt="TCP 三次握手图解"></p>
<p><strong>一次握手</strong>:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</p>
<p><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong>状态</p>
<p><strong>三次握手</strong>:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</p>
<ul>
<li>为什么要三次握手？不三次握手为什么不行？</li>
</ul>
<ol>
<li><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<p>如果只有两次握手，在”已失效的连接请求报文段“的影响下，会重复建立TCP连接，浪费不必要的资源。</p>
<h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-waves-four-times.png" srcset="/img/loading.gif" lazyload alt="TCP 四次挥手图解"></p>
<ol>
<li><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ=X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。</li>
<li><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包-&gt;客户端 </li>
<li><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端请求关闭连接</li>
<li><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。</li>
</ol>
<ul>
<li>为什么要四次挥手？</li>
</ul>
<p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<ul>
<li>为什么服务端响应不能把ACK和FIN合并？</li>
</ul>
<p>客户端发送的FIN请求只是不再发送更多的消息，但消息可能还有在缓冲区中未送达，如果此时合并了ACK和FIN请求，将会丢失数据</p>
<h2 id="IP篇"><a href="#IP篇" class="headerlink" title="IP篇"></a>IP篇</h2><h3 id="IP-的基本认识"><a href="#IP-的基本认识" class="headerlink" title="IP 的基本认识"></a>IP 的基本认识</h3><p>IP在网络层：实现主机和主机之间的通信，也叫点对点通信。</p>
<ul>
<li>网络层与数据链路层有什么关系呢？</li>
</ul>
<p>​        IP（网络层）和MAC（数据链路层）之间的区别和关系，MAC直连两个设备之间的通信，IP没有直接链接两个网络之间的通信。mac是物理上的通信，IP是逻辑上的通信。</p>
<h3 id="IP-地址的基础知识"><a href="#IP-地址的基础知识" class="headerlink" title="IP 地址的基础知识"></a>IP 地址的基础知识</h3><p>IPv4地址由32位正整数表示，IP地址在计算机是以二进制的方式处理的。每8位为一组，共分为4组。</p>
<ul>
<li>什么是A、B、C类地址？</li>
</ul>
<p>​        对于A、B、C类地址分为两部分，分别是网络号和主机号</p>
<ul>
<li>广播地址用于什么？</li>
</ul>
<p>​        广播地址用于在同一个链路中相互连接的主机之间发送数据包。在本网络内广播的叫做本地广播，在不同网络之间的广播叫做直接广播。</p>
<ul>
<li>多播地址用于什么？</li>
</ul>
<p>​        多播用于将包发送给特定组内的所有主机。</p>
<ul>
<li>怎么划分网络号和主机号？</li>
</ul>
<p>​        表示形式<code>a.b.c.d/x</code>其中<code>/x</code>表示前x位属于网络号，x的范围是0-32。比如10.100.122.2/24这种形式就是CIDR（无分类地址），/24表示前24位是网络号，剩余的8位是主机号。</p>
<ul>
<li>为什么分离网络号和主机号？</li>
</ul>
<p>​        两台计算机要通讯，首先判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明可以直接发送数据包（因为在同一个网段内）</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul>
<li>域名解析的流程</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/464291/201707/464291-20170703113844956-354755333.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>1、本地DNS服务器是否有缓存</p>
<p>2、本地DNS服务器回去问根域名服务器</p>
<p>3、根DNS收到来自本地DNS的请求后，判别尾部是什么区域，返回对应的顶级域名服务器的地址给本地DNS。</p>
<p>4、本地DNS收到以后继续向顶级域名服务器发送请求，然后回应给他具体域名的权威DNS服务器的地址。</p>
<p>5、本地DNS收到后直接找权威DNS服务器的询问ip。</p>
<p>6、权威DNS服务器给予回应。</p>
<p>本地DNS —&gt; 根域名服务器 —&gt; 顶级域名服务器 —&gt; 权威DNS服务器</p>
<ul>
<li>ARP？</li>
</ul>
<p>​        由于主机的路由表中可以找到下一跳的IP地址，所以可以通过ARP协议，求得下一跳的MAC地址。ARP协议解析IP变成MAC地址。ARP是通过广播的方式告知其他主机各自的MAC地址。先通过ARP解析IP地址然后再根据MAC表查找目的地。</p>
<ul>
<li>ICMP功能都有啥？</li>
</ul>
<p>ICMP主要的功能包括：确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置等。</p>
<h2 id="网络综合篇"><a href="#网络综合篇" class="headerlink" title="网络综合篇"></a>网络综合篇</h2><ul>
<li>输入网址到网页显示，期间发生了什么？</li>
</ul>
<ol>
<li>解析URL，分析我们请求了啥，从而发送给Web服务器的请求信息。</li>
<li>确定web服务器和文件名，生成HTTP请求信息</li>
<li>发送之前，查询服务器域名对应的IP地址。</li>
<li>通过DNS获取到IP后，把HTTP的传输工作交给os中的协议栈。</li>
<li>……</li>
</ol>
<ul>
<li>linux系统是如何收发网络包的？</li>
</ul>
<p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2023-03-10 at 14.07.40.png" srcset="/img/loading.gif" lazyload alt="网络层级结构"></p>
<ul>
<li>传输层，给应用数据前面增加了TCP头</li>
<li>网络层，给TCP数据包前面增加了IP头</li>
<li>网络接口层，给IP数据包前后分别增加了帧头和帧尾</li>
</ul>
<p>由于在我们的因特网中，物理链路不能传输任意大小的数据包，在以太网中规定了一个包的最大长度MTU是1500字节。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Back-End-Engineer/">Back-End Engineer</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Back-End-Engineer/">Back-End Engineer</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/11/22/community-project/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">community-project</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/11/%E5%B0%8F%E8%AF%B4%E6%B8%B8%E5%9B%AD%E4%BC%9A%E9%A1%B9%E7%9B%AE/">
                        <span class="hidden-mobile">小说游园会 study</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> & <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
