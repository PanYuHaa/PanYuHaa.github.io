

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon1.png">
  <link rel="icon" href="/img/favicon1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Peter Pan">
  <meta name="keywords" content="">
  
    <meta name="description" content="Web框架 - Gee0.1 基本的net包建立tcp连接的步骤(server端)  设置tcp地址 设立监听对象 建立连接  1234567tcpAddr, _ :&#x3D; net.ResolveTCPAddr(&quot;tcp&quot;, &quot;:8888&quot;)listener, _ :&#x3D; net.ListenTCP(&quot;tcp&quot;, tcpAddr)conn, e">
<meta property="og:type" content="article">
<meta property="og:title" content="Gee系列实现">
<meta property="og:url" content="http://example.com/2022/06/29/Gee%E7%B3%BB%E5%88%97%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="PPStudy">
<meta property="og:description" content="Web框架 - Gee0.1 基本的net包建立tcp连接的步骤(server端)  设置tcp地址 设立监听对象 建立连接  1234567tcpAddr, _ :&#x3D; net.ResolveTCPAddr(&quot;tcp&quot;, &quot;:8888&quot;)listener, _ :&#x3D; net.ListenTCP(&quot;tcp&quot;, tcpAddr)conn, e">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-29T04:14:31.000Z">
<meta property="article:modified_time" content="2022-07-17T08:20:28.283Z">
<meta property="article:author" content="Peter Pan">
<meta property="article:tag" content="TCP, UDP">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>Gee系列实现 - PPStudy</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Gee系列实现">
              
                Gee系列实现
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-06-29 12:14" pubdate>
        June 29, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      140 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Gee系列实现</h1>
            
            <div class="markdown-body">
              <h1 id="Web框架-Gee"><a href="#Web框架-Gee" class="headerlink" title="Web框架 - Gee"></a>Web框架 - Gee</h1><h2 id="0-1-基本的net包"><a href="#0-1-基本的net包" class="headerlink" title="0.1 基本的net包"></a>0.1 基本的net包</h2><p>建立tcp连接的步骤(server端)</p>
<ol>
<li>设置tcp地址</li>
<li>设立监听对象</li>
<li>建立连接</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs go">tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>listener, _ := net.ListenTCP(<span class="hljs-string">&quot;tcp&quot;</span>, tcpAddr)<br>conn, err := listener.AcceptTCP()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-comment">// 创建好一个tcp的服务端</span><br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>优化，循环链接，要处理很多tcp请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>    listener, _ := net.ListenTCP(<span class="hljs-string">&quot;tcp&quot;</span>, tcpAddr)<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.AcceptTCP()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>          fmt.Println(err)<br>          <span class="hljs-keyword">return</span><br>          <span class="hljs-comment">// handle error</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> handleConnection(conn)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn *net.TCPConn)</span></span> &#123;<br>		<span class="hljs-keyword">for</span> &#123;<br>		buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>		n, err := conn.Read(buf)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>        <span class="hljs-keyword">break</span><br>		&#125;<br>		fmt.Println(conn.RemoteAddr().String() + <span class="hljs-type">string</span>(buf[<span class="hljs-number">0</span> : n])) <span class="hljs-comment">// 获取连接进来的地址 + 字符串</span><br>		str := <span class="hljs-string">&quot;received success! message: &quot;</span> + <span class="hljs-type">string</span>(buf[<span class="hljs-number">0</span> : n])<br>		conn.Write([]<span class="hljs-type">byte</span>(str))<br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>(dial端)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>    conn, _ := net.DialTCP(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-literal">nil</span>, tcpAddr)<br>    reader := bufio.NewReader(os.Stdin)<br>    <span class="hljs-keyword">for</span> &#123;<br>        bytes, _, _ := reader.ReadLine()<br>        conn.Write(bytes)<br>        rb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>        rn, _ := conn.Read(rb)<br>        fmt.Println(<span class="hljs-type">string</span>(rb[<span class="hljs-number">0</span> : rn])) <span class="hljs-comment">// string处理要不就是ASCII码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="0-2-Http包"><a href="#0-2-Http包" class="headerlink" title="0.2 Http包"></a>0.2 Http包</h2><p><strong>Get请求的实现</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;<br>		res.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;我收到了给你返回&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/test&quot;</span>, handler)<br>    server := http.Server&#123;<br>      Addr: <span class="hljs-string">&quot;:8080&quot;</span>,<br>      Handler: <span class="hljs-literal">nil</span>,<br>    &#125;<br>    server.ListenAndServe()<br>    <span class="hljs-comment">// http.ListenAndServe(&quot;:8080&quot;, nil)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>为什么不用判断req的方法就可以实现呢get呢？因为默认是get请求？</p>
<p>其中为什么前者response不是指针，而后者request是指针呢？因为request是外部传来的（这个有待以后check源码）</p>
<p><strong>server</strong> 服务，包含地址、端口、处理器等等</p>
<p><strong>conn</strong> 链接，用户请求来的</p>
<p><strong>response</strong> 返回信息</p>
<p><strong>request</strong> 用户的请求信息</p>
<p><strong>Handle</strong> 对于接收的信息进行处理并且返回的一个处理器</p>
<p>Step：</p>
<p>1、通过 Header() 来设置头map</p>
<p>2、通过 WriteHeader(code) 来设置状态码</p>
<p>3、通过 Write 写入这个io.writer 来控制返回值</p>
<p>4、通过 req.Body 以请求过来的body内容</p>
<p>5、剩下的就是组装，e.g. 一个内置的方法，把路径当静态显示</p>
<p>http.Handle(“/“, http.FileServer(http.dir(“/“)))</p>
<p>res是我们要返回的值，req是前端传给我们的值。</p>
<pre><code class=" mermaid">graph LR;
	http请求 --&gt; DefaultServeMux;
	DefaultServeMux --&gt; Handler1;
	DefaultServeMux --&gt; Handler2;
	DefaultServeMux --&gt; ......;
	DefaultServeMux --&gt; Handler3;
</code></pre>
<p>有自定义的handler的话就是这个样子。</p>
<pre><code class=" mermaid">graph LR;
	http请求 --&gt; myHandler;
</code></pre>
<p>Multiplexer（多路复用器）</p>
<p>他也是一个handler</p>
<p><strong>url通用格式</strong></p>
<p>Scheme : // [ userinfo@ ] host / path [ ?query ] [ #fragment ]</p>
<p>如果从浏览器发出的请求，那么你无法提取处 Fragment 字段的值（浏览器在发送请求时会把 fragment 部分去掉）</p>
<h3 id="FORM-表单"><a href="#FORM-表单" class="headerlink" title="FORM 表单"></a>FORM 表单</h3><h4 id="表单的-enctype-属性"><a href="#表单的-enctype-属性" class="headerlink" title="表单的 enctype 属性"></a>表单的 enctype 属性</h4><ul>
<li>如果 enctype 是 application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。例如：</li>
</ul>
<p>​            frist_name=peter&amp;last_name=pan</p>
<ul>
<li><p>如果 enctype 是 multipart/form-data，那么</p>
<p>​     每一个 name-value 对都会被转换为一个MIME消息部分</p>
<p>​     每一个部分都有自己的 Content Type 和 Content Dispostion</p>
</li>
</ul>
<p><strong>如何选择呢？</strong></p>
<p>简单文本：表单URL编码</p>
<p>大量数据，例如上传文件：multipart-MIME</p>
<p>​        甚至可以把二进制数据通过base64编码，来当作文本进行发送</p>
<h4 id="FORM-字段"><a href="#FORM-字段" class="headerlink" title="FORM 字段"></a>FORM 字段</h4><p>提取Request上的字段有三个，Form，PostForm，MultipartForm</p>
<p>通常做法调用 ParseForm 或 ParseMultipartForm 来解析 Request，然后相应的访问 Form、PostForm 或 MultipartForm 字段</p>
<h4 id="PostForm-字段"><a href="#PostForm-字段" class="headerlink" title="PostForm 字段"></a>PostForm 字段</h4><p>由于表单和 URL 里有同样的 Key，那么他们都会放在一个 slice 里面，（表单在前面，url的在后面）。如果只想要表单的 key - value 对，不要 URL 的，可以使用PostForm 字段</p>
<p>PostForm 和 Form 只支持 application/x-www-form-urlencoded</p>
<p>MultipartForm 字段支持 multipart key-value 对，返回类型是个 struct 不是 map。1⃣️ key—-string，value—-[]string 2⃣️ 空的（key—-string，value—-文件）所以这个是用来传输文件的</p>
<p>FormValue 方法会返回 Form 字段中指定 key 对应的第一个 value，无需调用ParseForm（无需解析）</p>
<p>PostFromValue 相同，但如果 enctype 设为 multipart/form-data</p>
<h4 id="FromFile方法"><a href="#FromFile方法" class="headerlink" title="FromFile方法"></a>FromFile方法</h4><p>上传文件还有一个简便方法：FormFile（例子）</p>
<p>​        无需调用 ParseMultipartForm 方法</p>
<p>​        返回指定 key 对应的第一个 value</p>
<p>​        同时返回 File 和FileHeader，以及错误信息</p>
<p>​        如果只上传一个文件，那么这种方式会快一些        </p>
<h3 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a>ResponseWriter</h3><p>从服务器向客户端返回响应需要使用 ResponseWriter</p>
<p>ResponseWriter 是一个接口，handler 用它来返回响应</p>
<p>真正支撑 ResponseWriter 的幕后 struct 是非导出的 http.response</p>
<p><strong>Q：为什么 Handler 的 ServeHTTP(w ResponseWriter, r *Request)，只有一个是指针类型？而 w 是按值传递的吗？</strong></p>
<p><strong>A：</strong>ResponseWriter是一个接口它代表了一个指针，w 和 r 都是按照引用传递的</p>
<h4 id="Header-方法"><a href="#Header-方法" class="headerlink" title="Header 方法"></a>Header 方法</h4><p>Header 方法返回 headers 的 map，可以进行修改</p>
<p>修改后的 headers 将会体现在返回给客户端的 HTTP 响应里</p>
<h4 id="Write-方法"><a href="#Write-方法" class="headerlink" title="Write 方法"></a>Write 方法</h4><p>写入body</p>
<h4 id="WriteHeader-方法"><a href="#WriteHeader-方法" class="headerlink" title="WriteHeader 方法"></a>WriteHeader 方法</h4><p>WriteHeader 方法接受一个整数类型（HTTP 状态码）作为参数，并把它作为 HTTP 响应的状态码返回</p>
<p>如果该方法没有显式调用，那么在第一次调用 Write 方法前，会隐式的调用 WriteHeader（http.StatusOK）</p>
<p>​        所以 WriteHeader 主要用来发送错误类的 HTTP 状态码</p>
<p>调用完 WriteHeader 方法之后，仍然可以写入到 ResponseWriter，但无法再修改 header 了</p>
<h4 id="内置的-Response"><a href="#内置的-Response" class="headerlink" title="内置的 Response"></a>内置的 Response</h4><p>NotFound 函数，404 + 额外的信息</p>
<p>ServeFile 函数，从文件系统提供文件，返回给请求者</p>
<p>ServeContent 函数，可以请求range内的内容</p>
<p>Redirect 函数，重定向</p>
<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><pre><code class=" mermaid">graph LR;
	模版 --&gt; 模版引擎;
	数据 --&gt; 模版引擎;
	模版引擎 --&gt; HTML
</code></pre>
<p>两种理想的模版引擎：1、无逻辑模版引擎 2、逻辑嵌入模版引擎</p>
<p>go使用的是text/template，HTML相关部分用的是html/template，是混合体</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="controller的角色"><a href="#controller的角色" class="headerlink" title="controller的角色"></a>controller的角色</h4><p>main()：设置类工作</p>
<p>controller：</p>
<p>​        静态资源</p>
<p>​        把不同的请求送到不同的controller进行处理</p>
<pre><code class=" mermaid">graph LR;
		前置controller --&gt; home_handler;
		前置controller --&gt; page1_handler;
		前置controller --&gt; page2_handler;
</code></pre>
<h4 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h4><p>静态路由：一个路径对应一个页面</p>
<p>/home</p>
<p>/about</p>
<p>带参数的路由：根据路由参数，创建出一族不同的页面</p>
<p>/companies/123</p>
<p>/companies/Microsoft</p>
<h4 id="第三方路由器"><a href="#第三方路由器" class="headerlink" title="第三方路由器"></a>第三方路由器</h4><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><p>Marshal和Unmarshal</p>
<p>Marshal（编码）：把 go struct 转化为 json 格式</p>
<p>​        MarshalIndent，（内容，换行，缩进）</p>
<p>Unmarshal（解码）：把 json 转化为 go struct</p>
<p><strong>针对 string 或 bytes：</strong></p>
<p>​        Marshal =&gt; String</p>
<p>​        Unmarshal &lt;= String</p>
<p><strong>针对stream：</strong></p>
<p>​        Encode =&gt; Stream，把数据写入到 io.Writer</p>
<p>​        Decode &lt;= Stream，从 io.Reader 读取数据</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>创建中间件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyMiddleware <span class="hljs-keyword">struct</span> &#123;<br>  	Next http.Handler<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyMiddleware)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>  	<span class="hljs-comment">// 在 next handler之前做一些事情</span><br>  	m.Next.ServeHTTP(w,r)<br>  	<span class="hljs-comment">// 在 next handler之后做一些事情（处理一些响应里面的内容）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="中间件的用途"><a href="#中间件的用途" class="headerlink" title="中间件的用途"></a>中间件的用途</h4><ul>
<li><p>Logging 日志</p>
</li>
<li><p>安全</p>
</li>
<li><p>请求超时</p>
</li>
<li><p>响应压缩</p>
</li>
<li><p>拦截器</p>
</li>
</ul>
<h3 id="使用请求上下文"><a href="#使用请求上下文" class="headerlink" title="使用请求上下文"></a>使用请求上下文</h3><h4 id="Request-Context"><a href="#Request-Context" class="headerlink" title="Request Context"></a>Request Context</h4><p>func(*Request) Context() context.Context</p>
<p>​        返回当前请求的上下文</p>
<p>func(*Request) WithContext(ctx context.Context) context.Context</p>
<p>​        基于 Context 进行 ”修改“，（实际上）创建一个新的 Context</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br><br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br>    Err() <span class="hljs-type">error</span><br><br>    Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这些方法都是用于读的，要更新的话得创建新的context</p>
<h4 id="Context-API-可以返回新-Context"><a href="#Context-API-可以返回新-Context" class="headerlink" title="Context API - 可以返回新 Context"></a>Context API - 可以返回新 Context</h4><p>WithCancel()，它有一个 CancelFunc</p>
<p>WithDeadline()，带有一个时间戳（time.Time）</p>
<p>WithTimeout()，带有一个具体的时间段（time.Duration)</p>
<p>WithValue()，在里面添加一些值</p>
<p>PS：new创建结构体返回的是一个对应类型的指针，而普通结构体的创建需要加&amp;才能是指针要不就是个普通的结构体无人指向它</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>TLS —— 传输层安全</p>
<h4 id="HTTP-Listener"><a href="#HTTP-Listener" class="headerlink" title="HTTP Listener"></a>HTTP Listener</h4><p>http.ListenAndServe 函数</p>
<p>http.ListenAndServeTLS 函数</p>
<p>用 https 会让http协议从1.1升级到2</p>
<p>他建立长连接，所以分成各种frame，可以数据类型来进行优化从而提高处理效率。</p>
<p>Server Push可以提前预加载好要加载的文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> pusher, ok := w.(http.Pusher); ok &#123;<br>    pusher.Push(<span class="hljs-string">&quot;/css/app.css&quot;</span>, &amp;http.PushOptions&#123;<br>    	  Header: http.Header&#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;text/css&quot;</span>&#125;&#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试model层</p>
<p>user<strong>_test</strong>.go</p>
<ul>
<li><p>测试代码所在文件的名称以 _test 结尾</p>
</li>
<li><p>对于生产编译，不会包含以 _test 结尾的文件</p>
</li>
<li><p>对于测试编译，会包含以 _test 结尾的文件</p>
</li>
</ul>
<p>func <strong>Test</strong>UpdatesModifiedTime( <strong>t *testing.T</strong> )</p>
<ul>
<li>测试函数名应以 Test 开头（需要导出）</li>
<li>函数名需要表达出被验证的特征</li>
<li>测试函数的参数类型是 *testing.T，它会提供测试相关的一些工具</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>Import _ “net/http/pprof”</p>
<ul>
<li>设置一些监听的 URL，它们会提供各类诊断信息</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/heap">http://localhost:8080/debug/pprof/heap</a> // 内存</p>
<ul>
<li>从应用获取内存dump：应用在使用哪些内存，他们会去哪</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/profile">http://localhost:8080/debug/pprof/profile</a> // CPU</p>
<ul>
<li>CPU的快照，可以看到谁在用 CPU</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/block">http://localhost:8080/debug/pprof/block</a> // goroutine</p>
<ul>
<li>看到阻塞的 goroutine</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/trace?second=5">http://localhost:8080/debug/pprof/trace?second=5</a> // trace</p>
<ul>
<li>监控这段时间内，什么在执行，什么在调用什么</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof">http://localhost:8080/debug/pprof</a> // 网址</p>
<h2 id="Day-1-HTTP基础"><a href="#Day-1-HTTP基础" class="headerlink" title="Day 1 HTTP基础"></a>Day 1 HTTP基础</h2><p>在实现<code>Engine</code>之前，我们调用 <em>http.HandleFunc</em> 实现了路由和Handler的映射，也就是只能针对具体的路由写处理逻辑。比如<code>/hello</code>。但是在实现<code>Engine</code>之后，我们拦截了所有的HTTP请求，拥有了统一的控制入口。在这里我们可以自由定义路由映射的规则，也可以统一添加一些处理逻辑，例如日志、异常处理等</p>
<p><code>gee.go</code>内容</p>
<ul>
<li>首先定义了类型<code>HandlerFunc</code>，这是提供给框架用户的，用来定义路由映射的处理方法。我们在<code>Engine</code>中，添加了一张路由映射表<code>router</code>，key 由请求方法和静态路由地址构成，例如<code>GET-/</code>、<code>GET-/hello</code>、<code>POST-/hello</code>，这样针对相同的路由，如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法。</li>
<li>当用户调用<code>(*Engine).GET()</code>方法时，会将路由和处理方法注册到映射表 <em>router</em>中，<code>(*Engine).Run()</code>方法，是 <em>ListenAndServe</em> 的包装。</li>
<li><code>Engine</code>实现的 <em>ServeHTTP</em> 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 <em>404 NOT FOUND</em> 。</li>
</ul>
<p>第二个参数类型是接口类型 <code>http.Handler</code>，<code>Handler</code> 的定义博文中已经贴了，是从 <code>http</code> 的源码中找到的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>    ServeHTTP(w ResponseWriter, r *Request)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(address <span class="hljs-type">string</span>, h Handler)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure>
<p>在 Go 语言中，实现了接口方法的 struct 都可以强制转换为接口类型。你可以这么写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">handler := (http.Handler)(engine) <span class="hljs-comment">// 手动转换为借口类型</span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:9999&quot;</span>, handler))<br></code></pre></td></tr></table></figure>
<p>然后，<code>ListenAndServe</code> 方法里面会去调用 <code>handler.ServeHTTP()</code> 方法，你感兴趣，可以在 http 的源码中找到调用的地方。但是这么写是多余的，传参时，会自动进行参数转换的。所以直接传入engine 即可。</p>
<p>在没有 engine 的情况下我们默认的是一个 DefaultServeMux 他负责识别所有的 handler，但他不能给 handler 分类，所以我们要引入 engine。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuqun0319/article/details/106136338">https://blog.csdn.net/liuqun0319/article/details/106136338</a> 详解 type func() 用法分析</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	one(<span class="hljs-number">2</span>, callback)<br>&#125;<br><br><span class="hljs-comment">//需要传递函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">callback</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;i am callBack&quot;</span>)<br>	fmt.Println(i)<br>&#125;<br><br><span class="hljs-comment">//main 中调用的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">one</span><span class="hljs-params">(i <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span>) &#123;<br>	two(i,fun(f))<br>&#125;<br><br><span class="hljs-comment">//one() 中调用的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">two</span><span class="hljs-params">(i <span class="hljs-type">int</span>, c Call)</span></span> &#123;<br>	c.call(i)<br>&#125;<br><br><span class="hljs-comment">//定义的type函数</span><br><span class="hljs-keyword">type</span> fun <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><br><span class="hljs-comment">//fun实现的Call接口的call()函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f fun)</span></span> call(i <span class="hljs-type">int</span>) &#123;<br>	f(i)<br>&#125;<br><br><span class="hljs-comment">//call接口</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">interface</span> &#123;<br>	call(<span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里解释清楚了上述的调用关系。首先 one() 参数中的函数调用 two() 参数中的接口，并且通过该接口为这个函数赋值，但最终真正运行的还是 one() 中的函数 callback，只不过 callback 代表着一个 fun 函数实现了一个接口，接口的功能是用来给 fun 函数赋值。如下转换</p>
<p><strong>流程图：</strong></p>
<pre><code class=" mermaid">graph LR;
		http请求 --&gt; engine;
		engine --&gt; GET请求;
		engine --&gt; POST请求;
</code></pre>
<p>其中 engine 是用来鉴别请求的（有两部分），它里面有一个路由map，用来存放我们设定好的路由。第二部分就是一个ServeHTTP方法（这个是在 GET 和 POST 方法中转换的，因为go中结构体放入函数中的参数接口可以自动转换为别的类型）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 所有的handler都要有SeverHTTP这样一个函数，还要有ResponseWriter, *Request这两个参数）</span><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>   ServeHTTP(ResponseWriter, *Request)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>engine 中的 ServeHTTP 目的是为了实现转换成 handler 的 engine 该有的接口。第一步通过 listenAndServer 将 engine 变成 handler 接口。因为变成了handler接口（如上），所以第二步 engine 也要实现 ServeHTTP 函数。第三步里面实现的内容就是 1.查找是否有对应的路由注册 2. 若查找到就直接为这个 handlerFunc 赋入参 3. 没找到就404</p>
<p>其中为什么可以直接写成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> handler, ok := e.Router[key]; ok &#123;<br>		handler(w, r) <span class="hljs-comment">// 调用存储在 map 中的函数，执行并赋值。</span><br></code></pre></td></tr></table></figure>
<p>handler 本身就是个 func 类型，所以这一步就是赋值并运行。</p>
<h2 id="Day-2-上下文"><a href="#Day-2-上下文" class="headerlink" title="Day 2 上下文"></a>Day 2 上下文</h2><p><strong>设计Context必要性</strong></p>
<ol>
<li>对Web服务来说，无非是根据请求<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写大量重复，繁杂的代码，而且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。</li>
</ol>
<p>用返回 JSON 数据作比较，感受下封装前后的差距。</p>
<p>封装前</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">obj = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;geektutu&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1234&quot;</span>,<br>&#125;<br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>w.WriteHeader(http.StatusOK)<br>encoder := json.NewEncoder(w)<br><span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>    http.Error(w, err.Error(), <span class="hljs-number">500</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>VS 封装后：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">c.JSON(http.StatusOK, gee.H&#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: c.PostForm(<span class="hljs-string">&quot;username&quot;</span>),<br>    <span class="hljs-string">&quot;password&quot;</span>: c.PostForm(<span class="hljs-string">&quot;password&quot;</span>),<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>流程图</p>
<pre><code class=" mermaid">graph LR;
		http请求 --&gt; engine;
		engine --&gt; router-get\post;
		router-get\post --&gt; PostForm;
		router-get\post --&gt; Query;
		router-get\post --&gt; Status;
		router-get\post --&gt; SetHeader;
		router-get\post --&gt; String;
		router-get\post --&gt; JSON;
		router-get\post --&gt; Data;
		router-get\post --&gt; HTML;
</code></pre>
<p>最重要的还是通过实现了 ServeHTTP 接口，接管了所有的 HTTP 请求。</p>
<p>后面集成了常用的方法，比如JSON，HTML等等，为的就是前文提到的，这样再处理JSON请求的时候不用重复的写一遍怎么将数据转成JSON，统一转换成JSON然后响应JSON请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// origin objects</span><br>	Writer http.ResponseWriter<br>	Req    *http.Request<br>	<span class="hljs-comment">// request info</span><br>	Path   <span class="hljs-type">string</span><br>	Method <span class="hljs-type">string</span><br>	<span class="hljs-comment">// response info</span><br>	StatusCode <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>本质上没有变就是在 w 和 r 的上面又封装了一层 context，这个 context 包含了一些属性比如请求中的路径和方法，响应的状态码。</p>
<p>把状态码的设置，响应头的内容的设置封装在 context 的方法中，Context 就像一次会话的百宝箱，可以找到任何东西。</p>
<ul>
<li>给<code>map[string]interface&#123;&#125;</code>起了一个别名<code>gee.H</code>，构建JSON数据时，显得更简洁。</li>
<li><code>Context</code>目前只包含了<code>http.ResponseWriter</code>和<code>*http.Request</code>，另外提供了对 Method 和 Path 这两个常用属性的直接访问。</li>
<li>提供了访问Query和PostForm参数的方法。</li>
<li>提供了快速构造String/Data/JSON/HTML响应的方法。</li>
</ul>
<p>二、区别：</p>
<p>1、json.NewDecoder是从一个<code>流</code>里面直接进行解码，代码精干；<br>2、json.Unmarshal是从已存在与内存中的json进行解码；<br>3、相对于解码，json.NewEncoder进行大JSON的编码比json.marshal性能高，因为内部使用pool。</p>
<p>三、场景应用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">encoder := json.NewEncoder(c.Writer)<br>	<span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>		http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>	&#125;<br></code></pre></td></tr></table></figure>
<p>1、json.NewDecoder用于http连接与socket连接的读取与写入，或者文件读取；<br>2、json.Unmarshal用于直接是byte的输入。</p>
<h2 id="Day-3-前缀树路由"><a href="#Day-3-前缀树路由" class="headerlink" title="Day 3 前缀树路由"></a>Day 3 前缀树路由</h2><p>所有的路由地址其实是虚拟的地址，就是map存储，相当于一个标识。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">parts := strings.Split(url, <span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这样之后 parts[0] = “”，是一个nil</p>
<p>我们对于路由的修改变成了，添加路由和查找路由，查找路由比较复杂一点，因为要考虑到通配符的问题。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h3><p>addRouter -&gt; getRouter -&gt; handle 在看一遍代码 走一遍流程就明了多了, 说白了就是 用前缀树结构存 前缀树结构取, 用GET /a/asd/c || GET a/s/c 匹配到路由(GET-/a/:param/c)对应的HandlerFunc 并把asd || s 存在context的Params里。</p>
<h3 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a><strong>BUG</strong></h3><p><strong>Q：</strong></p>
<p><strong>第一个 bug</strong></p>
<p>在 <code>trie.go</code> 里的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> insert(pattern <span class="hljs-type">string</span>, parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height &#123;<br>		n.pattern = pattern<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	part := parts[height]<br>	child := n.matchChild(part)<br>	<span class="hljs-keyword">if</span> child == <span class="hljs-literal">nil</span> &#123;<br>		child = &amp;node&#123;part: part, isWild: part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> || part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span>&#125;<br>		n.children = <span class="hljs-built_in">append</span>(n.children, child)<br>	&#125;<br>	child.insert(pattern, parts, height+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果第一次插入的<code>pattern</code>为<code>/:age</code>，<code>method</code> 为 <code>GET</code>，<code>handlefunc</code> 为 <code>handleAge()</code></p>
<p>那么会生成一个这样的 <code>node</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;:age&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br></code></pre></td></tr></table></figure>
<p>第二次插入的 <code>pattern</code> 为 <code>/18</code> ,<code>method</code> 与第一次相同，仍然为 <code>GET</code>，<code>handlefunc</code>为 <code>handle18()</code>，此时并不会修改之前的 <code>node</code>，而是修改了之前 <code>nodeAge</code> 的 <code>pattern</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;18&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br>handlers[<span class="hljs-string">&quot;GET-18&quot;</span>] =  handle18<br></code></pre></td></tr></table></figure>
<p>接下来看看<code>handle()</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;<br>	n, params := r.getRoute(c.Method, c.Path)<br>	<span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>		c.Params = params<br>		key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + n.pattern<br>		r.handlers[key](c)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		c.String(http.StatusNotFound, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当有一个 <code>/19</code> 的请求到来时，将会匹配到 <code>nodeAge</code>，但是由于 <code>nodeAge</code> 的 <code>pattern</code>变成了 <code>18</code>，因此将会被 <code>handle18()</code> 处理，这不太合适。</p>
<p><strong><code>GIN</code>的做法是将冲突的路由直接<code>panic</code>了。</strong></p>
<p><strong>第二个bug</strong></p>
<p><code>router</code>的 <code>handle</code> 方法貌似不是协程安全的</p>
<p>假设此时只有一个<code>/:age</code>的<code>router</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;:age&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br></code></pre></td></tr></table></figure>
<p>此时有两个请求地址分别为 <code>/18</code> 和 <code>/19</code>的请求到达。</p>
<p><code>handle()</code> 内的 <code>getRoute()</code> 函数得到的 <code>params</code> 分别为 <code>key:age value:18</code> 和 <code>key:age value:19</code>，它们会对<strong>同一个</strong> <code>context</code> 进行写入，因此不太安全。</p>
<p>在 <code>http</code> 包内的 <code>server.go</code> 文件中的 <code>Serve</code> 函数内，有这样一段注释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Serve accepts incoming connections on the Listener l, creating a</span><br><span class="hljs-comment">// new service goroutine for each. The service goroutines read requests and</span><br><span class="hljs-comment">// then call srv.Handler to reply to them.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// HTTP/2 support is only enabled if the Listener returns *tls.Conn</span><br><span class="hljs-comment">// connections and they were configured with &quot;h2&quot; in the TLS</span><br><span class="hljs-comment">// Config.NextProtos.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Serve always returns a non-nil error and closes l.</span><br><span class="hljs-comment">// After Shutdown or Close, the returned error is ErrServerClosed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure>
<p>可见，<code>http.ListenAndServe()</code> 是有可能开启多个协程的。</p>
<p><strong>A：</strong></p>
<p>第一个bug，存在覆盖的问题，gin 的做法才是对的，应该把问题暴露给用户。<br>第二个问题，http 请求是并发的，但每一个请求都会调用 <code>ServeHTTP</code> ，这个方法中，context 每次都创建新的，不会对同一个context进行写入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>	c := newContext(w, req)<br>	engine.router.handle(c)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键点：比较 parts 的长度有没有相匹配的深度就可以知道是否匹配上了，因为通配符也占位</p>
<h2 id="Day-4-分组控制"><a href="#Day-4-分组控制" class="headerlink" title="Day 4 分组控制"></a>Day 4 分组控制</h2><h3 id="分组的意义"><a href="#分组的意义" class="headerlink" title="分组的意义"></a>分组的意义</h3><p>分组控制(Group Control)是 Web 框架应提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如：</p>
<ul>
<li>以<code>/post</code>开头的路由匿名可访问。</li>
<li>以<code>/admin</code>开头的路由需要鉴权。</li>
<li>以<code>/api</code>开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</li>
</ul>
<p>ps：RESTful风格是 —— <strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</strong></p>
<p>parent 之前设计是用来拼接 prefix 的，每个 group 只记录自己的部分，最后通过 parent 层层回溯拼接。不过后来改用 <code>group.prefix + prefix</code> 的方式 group 初始化时已经拼接了完整的 prefix，所以不需要 <code>parent</code> 了，可以删除。</p>
<h2 id="Day-5-中间件"><a href="#Day-5-中间件" class="headerlink" title="Day 5 中间件"></a>Day 5 中间件</h2><p>Gee 的中间件的定义与路由映射的 Handler 一致，处理的输入是<code>Context</code>对象。插入点是框架接收到请求初始化<code>Context</code>对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对<code>Context</code>进行二次加工。c.Next()<code>表示等待执行其他的中间件或用户的</code>Handler</p>
<p>假设我们应用了中间件 A 和 B，和路由映射的 Handler。<code>c.handlers</code>是这样的[A, B, Handler]，<code>c.index</code>初始化为-1。调用<code>c.Next()</code>，接下来的流程是这样的：</p>
<ul>
<li>c.index++，c.index 变为 0</li>
<li>0 &lt; 3，调用 c.handlers[0]，即 A</li>
<li>执行 part1，调用 c.Next()</li>
<li>c.index++，c.index 变为 1</li>
<li>1 &lt; 3，调用 c.handlers[1]，即 B</li>
<li>执行 part3，调用 c.Next()</li>
<li>c.index++，c.index 变为 2</li>
<li>2 &lt; 3，调用 c.handlers[2]，即Handler</li>
<li>Handler 调用完毕，返回到 B 中的 part4，执行 part4</li>
<li>part4 执行完毕，返回到 A 中的 part2，执行 part2</li>
<li>part2 执行完毕，结束。</li>
</ul>
<p>一句话说清楚重点，最终的顺序是<code>part1 -&gt; part3 -&gt; Handler -&gt; part 4 -&gt; part2</code>。恰恰满足了我们对中间件的要求，接下来看调用部分的代码，就能全部串起来了。</p>
<p>目前的结构：</p>
<pre><code class=" mermaid">graph LR;
		http请求 --&gt; RouterGroup;
		RouterGroup --&gt; Engine;
		Engine --&gt; Context-get\post;
		Context-get\post --&gt; Next;
		Context-get\post --&gt; Param;
		Context-get\post --&gt; PostForm;
		Context-get\post --&gt; Query;
		Context-get\post --&gt; Status;
		Context-get\post --&gt; SetHeader;
		Context-get\post --&gt; String;
		Context-get\post --&gt; JSON;
		Context-get\post --&gt; Data;
		Context-get\post --&gt; HTML;
</code></pre>
<p>每一个use都会append一个中间件，并且存储在router group中，在实现serveHTTP的时候将这些中间件函数递给context</p>
<p>最后在next()中启动第一个handler</p>
<h2 id="Day-6-模版-Template"><a href="#Day-6-模版-Template" class="headerlink" title="Day 6 模版 Template"></a>Day 6 模版 Template</h2><p>那如果我么将所有的静态文件放在<code>/usr/web</code>目录下，那么<code>filepath</code>的值即是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。</p>
<p>找到文件后，如何返回这一步，<code>net/http</code>库已经实现了。因此，gee 框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给<code>http.FileServer</code>处理就好了</p>
<p>Golang 內建提供 <a target="_blank" rel="noopener" href="https://golang.org/pkg/net/http/#FileServer">http.FileServer</a> ，可以方便地透過 HTTP 存取檔案系統(file system)，例如以下程式碼執行之後，就可以透過瀏覽器打開網址 <code>http://localhost:8080</code> 瀏覽 <code>/usr/share/doc</code> 資料夾內的檔案。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, http.FileServer(http.Dir(<span class="hljs-string">&quot;/usr/share/doc&quot;</span>)))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以挂载一个文件路径通过ip来访问规定的地址。</p>
<p>如果是一个普通的结构体是需要加指针的</p>
<p>如果是一个map类型他自己就是个对象不用加指针</p>
<p>首先为 Engine 示例添加了 <code>*template.Template</code> 和 <code>template.FuncMap</code>对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。</p>
<p>另外，给用户分别提供了设置自定义渲染函数<code>funcMap</code>和加载模板的方法。</p>
<p>接下来，对原来的 <code>(*Context).HTML()</code>方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p>
<p>这一块设计比较简单，RouterGroup 只做路由的事情，Engine 做全局的事情。<code>LoadHTMLGlob</code> 设计成全局的了，你可以尝试下，实现 RouterGroup 级别的模板。</p>
<p><code>e.HtmlTemplates = template.Must(template.New(&quot;&quot;).Funcs(e.FuncMap).ParseGlob(pattern))</code></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/f-ck-need-u/p/10035768.html">https://www.cnblogs.com/f-ck-need-u/p/10035768.html</a></p>
<p><strong>使用template.New()函数可以创建一个空的、无解析数据的模板，同时还会创建一个common，也就是模板组</strong>。</p>
<p>也就是说，<strong>template.New()函数不仅创建了一个模板，还创建了一个空的common结构(模板组)。需要注意，新创建的common是空的，只有进行模板解析(Parse()，ParseFiles()等操作)之后，才会将模板添加到common的tmpl字段(map结构)中</strong>。</p>
<p>Parse()只能解析字符串，要解析文件中的内容，需要使用ParseFiles()或ParseGlob()。</p>
<p>template内置了一系列函数，但这些函数毕竟有限，可能无法满足特殊的需求。template允许我们定义自己的函数，添加到common中，然后就可以在待解析的内容中像使用内置函数一样使用自定义的函数。</p>
<p>自定义函数的优先级高于内置的函数优先级，即先检索自定义函数，再检索内置函数。也就是说，如果自定义函数的函数名和内置函数名相同，则内置函数将失效。</p>
<p>本文只对此稍作解释，本文的重点不是template的具体语法和用法。</p>
<p><strong>Golang Template</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lengyuezuixue/article/details/79367825?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;utm_relevant_index=1">https://blog.csdn.net/lengyuezuixue/article/details/79367825?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;utm_relevant_index=1</a></p>
<h2 id="Day-7-错误恢复"><a href="#Day-7-错误恢复" class="headerlink" title="Day 7 错误恢复"></a>Day 7 错误恢复</h2><p>Gee 的错误处理机制</p>
<p>对一个 Web 框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。</p>
<p>我们在第六天实现的框架并没有加入异常处理机制，如果代码中存在会触发 panic 的 BUG，很容易宕掉。</p>
<h1 id="分布式缓存-GeeCache"><a href="#分布式缓存-GeeCache" class="headerlink" title="分布式缓存 - GeeCache"></a>分布式缓存 - GeeCache</h1>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Backend-development/">Backend development</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/TCP-UDP/">TCP, UDP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/18/golang%E5%8E%9F%E7%90%86/">
                        <span class="hidden-mobile">golang原理</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> & <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
