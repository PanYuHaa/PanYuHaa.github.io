

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon1.png">
  <link rel="icon" href="/img/favicon1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Peter Pan">
  <meta name="keywords" content="">
  
    <meta name="description" content="Web框架 - Gee0.1 基本的net包建立tcp连接的步骤(server端)  设置tcp地址 设立监听对象 建立连接  1234567tcpAddr, _ :&#x3D; net.ResolveTCPAddr(&quot;tcp&quot;, &quot;:8888&quot;)listener, _ :&#x3D; net.ListenTCP(&quot;tcp&quot;, tcpAddr)conn, e">
<meta property="og:type" content="article">
<meta property="og:title" content="Gee系列实现">
<meta property="og:url" content="http://example.com/2022/06/29/Gee%E7%B3%BB%E5%88%97%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="PPStudy">
<meta property="og:description" content="Web框架 - Gee0.1 基本的net包建立tcp连接的步骤(server端)  设置tcp地址 设立监听对象 建立连接  1234567tcpAddr, _ :&#x3D; net.ResolveTCPAddr(&quot;tcp&quot;, &quot;:8888&quot;)listener, _ :&#x3D; net.ListenTCP(&quot;tcp&quot;, tcpAddr)conn, e">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-29T04:14:31.000Z">
<meta property="article:modified_time" content="2022-07-10T12:08:13.712Z">
<meta property="article:author" content="Peter Pan">
<meta property="article:tag" content="TCP, UDP">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>Gee系列实现 - PPStudy</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Gee系列实现">
              
                Gee系列实现
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-06-29 12:14" pubdate>
        June 29, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      14k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      115 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Gee系列实现</h1>
            
            <div class="markdown-body">
              <h1 id="Web框架-Gee"><a href="#Web框架-Gee" class="headerlink" title="Web框架 - Gee"></a>Web框架 - Gee</h1><h2 id="0-1-基本的net包"><a href="#0-1-基本的net包" class="headerlink" title="0.1 基本的net包"></a>0.1 基本的net包</h2><p>建立tcp连接的步骤(server端)</p>
<ol>
<li>设置tcp地址</li>
<li>设立监听对象</li>
<li>建立连接</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs go">tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>listener, _ := net.ListenTCP(<span class="hljs-string">&quot;tcp&quot;</span>, tcpAddr)<br>conn, err := listener.AcceptTCP()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-comment">// 创建好一个tcp的服务端</span><br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>优化，循环链接，要处理很多tcp请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>    listener, _ := net.ListenTCP(<span class="hljs-string">&quot;tcp&quot;</span>, tcpAddr)<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.AcceptTCP()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>          fmt.Println(err)<br>          <span class="hljs-keyword">return</span><br>          <span class="hljs-comment">// handle error</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> handleConnection(conn)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn *net.TCPConn)</span></span> &#123;<br>		<span class="hljs-keyword">for</span> &#123;<br>		buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>		n, err := conn.Read(buf)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>        <span class="hljs-keyword">break</span><br>		&#125;<br>		fmt.Println(conn.RemoteAddr().String() + <span class="hljs-type">string</span>(buf[<span class="hljs-number">0</span> : n])) <span class="hljs-comment">// 获取连接进来的地址 + 字符串</span><br>		str := <span class="hljs-string">&quot;received success! message: &quot;</span> + <span class="hljs-type">string</span>(buf[<span class="hljs-number">0</span> : n])<br>		conn.Write([]<span class="hljs-type">byte</span>(str))<br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>(dial端)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>    conn, _ := net.DialTCP(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-literal">nil</span>, tcpAddr)<br>    reader := bufio.NewReader(os.Stdin)<br>    <span class="hljs-keyword">for</span> &#123;<br>        bytes, _, _ := reader.ReadLine()<br>        conn.Write(bytes)<br>        rb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>        rn, _ := conn.Read(rb)<br>        fmt.Println(<span class="hljs-type">string</span>(rb[<span class="hljs-number">0</span> : rn])) <span class="hljs-comment">// string处理要不就是ASCII码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="0-2-Http包"><a href="#0-2-Http包" class="headerlink" title="0.2 Http包"></a>0.2 Http包</h2><p><strong>Get请求的实现</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;<br>		res.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;我收到了给你返回&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/test&quot;</span>, handler)<br>    server := http.Server&#123;<br>      Addr: <span class="hljs-string">&quot;:8080&quot;</span>,<br>      Handler: <span class="hljs-literal">nil</span>,<br>    &#125;<br>    server.ListenAndServe()<br>    <span class="hljs-comment">// http.ListenAndServe(&quot;:8080&quot;, nil)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>为什么不用判断req的方法就可以实现呢get呢？因为默认是get请求？</p>
<p>其中为什么前者response不是指针，而后者request是指针呢？因为request是外部传来的（这个有待以后check源码）</p>
<p><strong>server</strong> 服务，包含地址、端口、处理器等等</p>
<p><strong>conn</strong> 链接，用户请求来的</p>
<p><strong>response</strong> 返回信息</p>
<p><strong>request</strong> 用户的请求信息</p>
<p><strong>Handle</strong> 对于接收的信息进行处理并且返回的一个处理器</p>
<p>Step：</p>
<p>1、通过 Header() 来设置头map</p>
<p>2、通过 WriteHeader(code) 来设置状态码</p>
<p>3、通过 Write 写入这个io.writer 来控制返回值</p>
<p>4、通过 req.Body 以请求过来的body内容</p>
<p>5、剩下的就是组装，e.g. 一个内置的方法，把路径当静态显示</p>
<p>http.Handle(“/“, http.FileServer(http.dir(“/“)))</p>
<p>res是我们要返回的值，req是前端传给我们的值。</p>
<pre><code class=" mermaid">graph LR;
	http请求 --&gt; DefaultServeMux;
	DefaultServeMux --&gt; Handler1;
	DefaultServeMux --&gt; Handler2;
	DefaultServeMux --&gt; ......;
	DefaultServeMux --&gt; Handler3;
</code></pre>
<p>有自定义的handler的话就是这个样子。</p>
<pre><code class=" mermaid">graph LR;
	http请求 --&gt; myHandler;
</code></pre>
<p>Multiplexer（多路复用器）</p>
<p>他也是一个handler</p>
<p><strong>url通用格式</strong></p>
<p>Scheme : // [ userinfo@ ] host / path [ ?query ] [ #fragment ]</p>
<p>如果从浏览器发出的请求，那么你无法提取处 Fragment 字段的值（浏览器在发送请求时会把 fragment 部分去掉）</p>
<h3 id="FORM-表单"><a href="#FORM-表单" class="headerlink" title="FORM 表单"></a>FORM 表单</h3><h4 id="表单的-enctype-属性"><a href="#表单的-enctype-属性" class="headerlink" title="表单的 enctype 属性"></a>表单的 enctype 属性</h4><ul>
<li>如果 enctype 是 application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。例如：</li>
</ul>
<p>​            frist_name=peter&amp;last_name=pan</p>
<ul>
<li><p>如果 enctype 是 multipart/form-data，那么</p>
<p>​     每一个 name-value 对都会被转换为一个MIME消息部分</p>
<p>​     每一个部分都有自己的 Content Type 和 Content Dispostion</p>
</li>
</ul>
<p><strong>如何选择呢？</strong></p>
<p>简单文本：表单URL编码</p>
<p>大量数据，例如上传文件：multipart-MIME</p>
<p>​        甚至可以把二进制数据通过base64编码，来当作文本进行发送</p>
<h4 id="FORM-字段"><a href="#FORM-字段" class="headerlink" title="FORM 字段"></a>FORM 字段</h4><p>提取Request上的字段有三个，Form，PostForm，MultipartForm</p>
<p>通常做法调用 ParseForm 或 ParseMultipartForm 来解析 Request，然后相应的访问 Form、PostForm 或 MultipartForm 字段</p>
<h4 id="PostForm-字段"><a href="#PostForm-字段" class="headerlink" title="PostForm 字段"></a>PostForm 字段</h4><p>由于表单和 URL 里有同样的 Key，那么他们都会放在一个 slice 里面，（表单在前面，url的在后面）。如果只想要表单的 key - value 对，不要 URL 的，可以使用PostForm 字段</p>
<p>PostForm 和 Form 只支持 application/x-www-form-urlencoded</p>
<p>MultipartForm 字段支持 multipart key-value 对，返回类型是个 struct 不是 map。1⃣️ key—-string，value—-[]string 2⃣️ 空的（key—-string，value—-文件）所以这个是用来传输文件的</p>
<p>FormValue 方法会返回 Form 字段中指定 key 对应的第一个 value，无需调用ParseForm（无需解析）</p>
<p>PostFromValue 相同，但如果 enctype 设为 multipart/form-data</p>
<h4 id="FromFile方法"><a href="#FromFile方法" class="headerlink" title="FromFile方法"></a>FromFile方法</h4><p>上传文件还有一个简便方法：FormFile（例子）</p>
<p>​        无需调用 ParseMultipartForm 方法</p>
<p>​        返回指定 key 对应的第一个 value</p>
<p>​        同时返回 File 和FileHeader，以及错误信息</p>
<p>​        如果只上传一个文件，那么这种方式会快一些        </p>
<h3 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a>ResponseWriter</h3><p>从服务器向客户端返回响应需要使用 ResponseWriter</p>
<p>ResponseWriter 是一个接口，handler 用它来返回响应</p>
<p>真正支撑 ResponseWriter 的幕后 struct 是非导出的 http.response</p>
<p><strong>Q：为什么 Handler 的 ServeHTTP(w ResponseWriter, r *Request)，只有一个是指针类型？而 w 是按值传递的吗？</strong></p>
<p><strong>A：</strong>ResponseWriter是一个接口它代表了一个指针，w 和 r 都是按照引用传递的</p>
<h4 id="Header-方法"><a href="#Header-方法" class="headerlink" title="Header 方法"></a>Header 方法</h4><p>Header 方法返回 headers 的 map，可以进行修改</p>
<p>修改后的 headers 将会体现在返回给客户端的 HTTP 响应里</p>
<h4 id="Write-方法"><a href="#Write-方法" class="headerlink" title="Write 方法"></a>Write 方法</h4><p>写入body</p>
<h4 id="WriteHeader-方法"><a href="#WriteHeader-方法" class="headerlink" title="WriteHeader 方法"></a>WriteHeader 方法</h4><p>WriteHeader 方法接受一个整数类型（HTTP 状态码）作为参数，并把它作为 HTTP 响应的状态码返回</p>
<p>如果该方法没有显式调用，那么在第一次调用 Write 方法前，会隐式的调用 WriteHeader（http.StatusOK）</p>
<p>​        所以 WriteHeader 主要用来发送错误类的 HTTP 状态码</p>
<p>调用完 WriteHeader 方法之后，仍然可以写入到 ResponseWriter，但无法再修改 header 了</p>
<h4 id="内置的-Response"><a href="#内置的-Response" class="headerlink" title="内置的 Response"></a>内置的 Response</h4><p>NotFound 函数，404 + 额外的信息</p>
<p>ServeFile 函数，从文件系统提供文件，返回给请求者</p>
<p>ServeContent 函数，可以请求range内的内容</p>
<p>Redirect 函数，重定向</p>
<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><pre><code class=" mermaid">graph LR;
	模版 --&gt; 模版引擎;
	数据 --&gt; 模版引擎;
	模版引擎 --&gt; HTML
</code></pre>
<p>两种理想的模版引擎：1、无逻辑模版引擎 2、逻辑嵌入模版引擎</p>
<p>go使用的是text/template，HTML相关部分用的是html/template，是混合体</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="controller的角色"><a href="#controller的角色" class="headerlink" title="controller的角色"></a>controller的角色</h4><p>main()：设置类工作</p>
<p>controller：</p>
<p>​        静态资源</p>
<p>​        把不同的请求送到不同的controller进行处理</p>
<pre><code class=" mermaid">graph LR;
		前置controller --&gt; home_handler;
		前置controller --&gt; page1_handler;
		前置controller --&gt; page2_handler;
</code></pre>
<h4 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h4><p>静态路由：一个路径对应一个页面</p>
<p>/home</p>
<p>/about</p>
<p>带参数的路由：根据路由参数，创建出一族不同的页面</p>
<p>/companies/123</p>
<p>/companies/Microsoft</p>
<h4 id="第三方路由器"><a href="#第三方路由器" class="headerlink" title="第三方路由器"></a>第三方路由器</h4><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><p>Marshal和Unmarshal</p>
<p>Marshal（编码）：把 go struct 转化为 json 格式</p>
<p>​        MarshalIndent，（内容，换行，缩进）</p>
<p>Unmarshal（解码）：把 json 转化为 go struct</p>
<p><strong>针对 string 或 bytes：</strong></p>
<p>​        Marshal =&gt; String</p>
<p>​        Unmarshal &lt;= String</p>
<p><strong>针对stream：</strong></p>
<p>​        Encode =&gt; Stream，把数据写入到 io.Writer</p>
<p>​        Decode &lt;= Stream，从 io.Reader 读取数据</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>创建中间件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyMiddleware <span class="hljs-keyword">struct</span> &#123;<br>  	Next http.Handler<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyMiddleware)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>  	<span class="hljs-comment">// 在 next handler之前做一些事情</span><br>  	m.Next.ServeHTTP(w,r)<br>  	<span class="hljs-comment">// 在 next handler之后做一些事情（处理一些响应里面的内容）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="中间件的用途"><a href="#中间件的用途" class="headerlink" title="中间件的用途"></a>中间件的用途</h4><ul>
<li><p>Logging 日志</p>
</li>
<li><p>安全</p>
</li>
<li><p>请求超时</p>
</li>
<li><p>响应压缩</p>
</li>
<li><p>拦截器</p>
</li>
</ul>
<h3 id="使用请求上下文"><a href="#使用请求上下文" class="headerlink" title="使用请求上下文"></a>使用请求上下文</h3><h4 id="Request-Context"><a href="#Request-Context" class="headerlink" title="Request Context"></a>Request Context</h4><p>func(*Request) Context() context.Context</p>
<p>​        返回当前请求的上下文</p>
<p>func(*Request) WithContext(ctx context.Context) context.Context</p>
<p>​        基于 Context 进行 ”修改“，（实际上）创建一个新的 Context</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br><br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br>    Err() <span class="hljs-type">error</span><br><br>    Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这些方法都是用于读的，要更新的话得创建新的context</p>
<h4 id="Context-API-可以返回新-Context"><a href="#Context-API-可以返回新-Context" class="headerlink" title="Context API - 可以返回新 Context"></a>Context API - 可以返回新 Context</h4><p>WithCancel()，它有一个 CancelFunc</p>
<p>WithDeadline()，带有一个时间戳（time.Time）</p>
<p>WithTimeout()，带有一个具体的时间段（time.Duration)</p>
<p>WithValue()，在里面添加一些值</p>
<p>PS：new创建结构体返回的是一个对应类型的指针，而普通结构体的创建需要加&amp;才能是指针要不就是个普通的结构体无人指向它</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>TLS —— 传输层安全</p>
<h4 id="HTTP-Listener"><a href="#HTTP-Listener" class="headerlink" title="HTTP Listener"></a>HTTP Listener</h4><p>http.ListenAndServe 函数</p>
<p>http.ListenAndServeTLS 函数</p>
<p>用 https 会让http协议从1.1升级到2</p>
<p>他建立长连接，所以分成各种frame，可以数据类型来进行优化从而提高处理效率。</p>
<p>Server Push可以提前预加载好要加载的文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> pusher, ok := w.(http.Pusher); ok &#123;<br>    pusher.Push(<span class="hljs-string">&quot;/css/app.css&quot;</span>, &amp;http.PushOptions&#123;<br>    	  Header: http.Header&#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;text/css&quot;</span>&#125;&#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试model层</p>
<p>user<strong>_test</strong>.go</p>
<ul>
<li><p>测试代码所在文件的名称以 _test 结尾</p>
</li>
<li><p>对于生产编译，不会包含以 _test 结尾的文件</p>
</li>
<li><p>对于测试编译，会包含以 _test 结尾的文件</p>
</li>
</ul>
<p>func <strong>Test</strong>UpdatesModifiedTime( <strong>t *testing.T</strong> )</p>
<ul>
<li>测试函数名应以 Test 开头（需要导出）</li>
<li>函数名需要表达出被验证的特征</li>
<li>测试函数的参数类型是 *testing.T，它会提供测试相关的一些工具</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>Import _ “net/http/pprof”</p>
<ul>
<li>设置一些监听的 URL，它们会提供各类诊断信息</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/heap">http://localhost:8080/debug/pprof/heap</a> // 内存</p>
<ul>
<li>从应用获取内存dump：应用在使用哪些内存，他们会去哪</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/profile">http://localhost:8080/debug/pprof/profile</a> // CPU</p>
<ul>
<li>CPU的快照，可以看到谁在用 CPU</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/block">http://localhost:8080/debug/pprof/block</a> // goroutine</p>
<ul>
<li>看到阻塞的 goroutine</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/trace?second=5">http://localhost:8080/debug/pprof/trace?second=5</a> // trace</p>
<ul>
<li>监控这段时间内，什么在执行，什么在调用什么</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof">http://localhost:8080/debug/pprof</a> // 网址</p>
<h2 id="Day-1-HTTP基础"><a href="#Day-1-HTTP基础" class="headerlink" title="Day 1 HTTP基础"></a>Day 1 HTTP基础</h2><p>在实现<code>Engine</code>之前，我们调用 <em>http.HandleFunc</em> 实现了路由和Handler的映射，也就是只能针对具体的路由写处理逻辑。比如<code>/hello</code>。但是在实现<code>Engine</code>之后，我们拦截了所有的HTTP请求，拥有了统一的控制入口。在这里我们可以自由定义路由映射的规则，也可以统一添加一些处理逻辑，例如日志、异常处理等</p>
<p><code>gee.go</code>内容</p>
<ul>
<li>首先定义了类型<code>HandlerFunc</code>，这是提供给框架用户的，用来定义路由映射的处理方法。我们在<code>Engine</code>中，添加了一张路由映射表<code>router</code>，key 由请求方法和静态路由地址构成，例如<code>GET-/</code>、<code>GET-/hello</code>、<code>POST-/hello</code>，这样针对相同的路由，如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法。</li>
<li>当用户调用<code>(*Engine).GET()</code>方法时，会将路由和处理方法注册到映射表 <em>router</em>中，<code>(*Engine).Run()</code>方法，是 <em>ListenAndServe</em> 的包装。</li>
<li><code>Engine</code>实现的 <em>ServeHTTP</em> 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 <em>404 NOT FOUND</em> 。</li>
</ul>
<p>第二个参数类型是接口类型 <code>http.Handler</code>，<code>Handler</code> 的定义博文中已经贴了，是从 <code>http</code> 的源码中找到的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>    ServeHTTP(w ResponseWriter, r *Request)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(address <span class="hljs-type">string</span>, h Handler)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure>
<p>在 Go 语言中，实现了接口方法的 struct 都可以强制转换为接口类型。你可以这么写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">handler := (http.Handler)(engine) <span class="hljs-comment">// 手动转换为借口类型</span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:9999&quot;</span>, handler))<br></code></pre></td></tr></table></figure>
<p>然后，<code>ListenAndServe</code> 方法里面会去调用 <code>handler.ServeHTTP()</code> 方法，你感兴趣，可以在 http 的源码中找到调用的地方。但是这么写是多余的，传参时，会自动进行参数转换的。所以直接传入engine 即可。</p>
<p>在没有 engine 的情况下我们默认的是一个 DefaultServeMux 他负责识别所有的 handler，但他不能给 handler 分类，所以我们要引入 engine。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuqun0319/article/details/106136338">https://blog.csdn.net/liuqun0319/article/details/106136338</a> 详解 type func() 用法分析</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	one(<span class="hljs-number">2</span>, callback)<br>&#125;<br><br><span class="hljs-comment">//需要传递函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">callback</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;i am callBack&quot;</span>)<br>	fmt.Println(i)<br>&#125;<br><br><span class="hljs-comment">//main 中调用的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">one</span><span class="hljs-params">(i <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span>) &#123;<br>	two(i,fun(f))<br>&#125;<br><br><span class="hljs-comment">//one() 中调用的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">two</span><span class="hljs-params">(i <span class="hljs-type">int</span>, c Call)</span></span> &#123;<br>	c.call(i)<br>&#125;<br><br><span class="hljs-comment">//定义的type函数</span><br><span class="hljs-keyword">type</span> fun <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><br><span class="hljs-comment">//fun实现的Call接口的call()函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f fun)</span></span> call(i <span class="hljs-type">int</span>) &#123;<br>	f(i)<br>&#125;<br><br><span class="hljs-comment">//call接口</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">interface</span> &#123;<br>	call(<span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里解释清楚了上述的调用关系。首先 one() 参数中的函数调用 two() 参数中的接口，并且通过该接口为这个函数赋值，但最终真正运行的还是 one() 中的函数 callback，只不过 callback 代表着一个 fun 函数实现了一个接口，接口的功能是用来给 fun 函数赋值。如下转换</p>
<p><strong>流程图：</strong></p>
<pre><code class=" mermaid">graph LR;
		http请求 --&gt; engine;
		engine --&gt; GET请求;
		engine --&gt; POST请求;
</code></pre>
<p>其中 engine 是用来鉴别请求的（有两部分），它里面有一个路由map，用来存放我们设定好的路由。第二部分就是一个ServeHTTP方法（这个是在 GET 和 POST 方法中转换的，因为go中结构体放入函数中的参数接口可以自动转换为别的类型）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 所有的handler都要有SeverHTTP这样一个函数，还要有ResponseWriter, *Request这两个参数）</span><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>   ServeHTTP(ResponseWriter, *Request)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>engine 中的 ServeHTTP 目的是为了实现转换成 handler 的 engine 该有的接口。第一步通过 listenAndServer 将 engine 变成 handler 接口。因为变成了handler接口（如上），所以第二步 engine 也要实现 ServeHTTP 函数。第三步里面实现的内容就是 1.查找是否有对应的路由注册 2. 若查找到就直接为这个 handlerFunc 赋入参 3. 没找到就404</p>
<p>其中为什么可以直接写成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> handler, ok := e.Router[key]; ok &#123;<br>		handler(w, r) <span class="hljs-comment">// 调用存储在 map 中的函数，执行并赋值。</span><br></code></pre></td></tr></table></figure>
<p>handler 本身就是个 func 类型，所以这一步就是赋值并运行。</p>
<h2 id="Day-2-上下文"><a href="#Day-2-上下文" class="headerlink" title="Day 2 上下文"></a>Day 2 上下文</h2><p><strong>设计Context必要性</strong></p>
<ol>
<li>对Web服务来说，无非是根据请求<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写大量重复，繁杂的代码，而且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。</li>
</ol>
<p>用返回 JSON 数据作比较，感受下封装前后的差距。</p>
<p>封装前</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">obj = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;geektutu&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1234&quot;</span>,<br>&#125;<br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>w.WriteHeader(http.StatusOK)<br>encoder := json.NewEncoder(w)<br><span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>    http.Error(w, err.Error(), <span class="hljs-number">500</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>VS 封装后：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">c.JSON(http.StatusOK, gee.H&#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: c.PostForm(<span class="hljs-string">&quot;username&quot;</span>),<br>    <span class="hljs-string">&quot;password&quot;</span>: c.PostForm(<span class="hljs-string">&quot;password&quot;</span>),<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>流程图</p>
<pre><code class=" mermaid">graph LR;
		http请求 --&gt; engine;
		engine --&gt; router-get\post;
		router-get\post --&gt; PostForm;
		router-get\post --&gt; Query;
		router-get\post --&gt; Status;
		router-get\post --&gt; SetHeader;
		router-get\post --&gt; String;
		router-get\post --&gt; JSON;
		router-get\post --&gt; Data;
		router-get\post --&gt; HTML;
</code></pre>
<p>最重要的还是通过实现了 ServeHTTP 接口，接管了所有的 HTTP 请求。</p>
<p>后面集成了常用的方法，比如JSON，HTML等等，为的就是前文提到的，这样再处理JSON请求的时候不用重复的写一遍怎么将数据转成JSON，统一转换成JSON然后响应JSON请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// origin objects</span><br>	Writer http.ResponseWriter<br>	Req    *http.Request<br>	<span class="hljs-comment">// request info</span><br>	Path   <span class="hljs-type">string</span><br>	Method <span class="hljs-type">string</span><br>	<span class="hljs-comment">// response info</span><br>	StatusCode <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>本质上没有变就是在 w 和 r 的上面又封装了一层 context，这个 context 包含了一些属性比如请求中的路径和方法，响应的状态码。</p>
<p>把状态码的设置，响应头的内容的设置封装在 context 的方法中，Context 就像一次会话的百宝箱，可以找到任何东西。</p>
<ul>
<li>给<code>map[string]interface&#123;&#125;</code>起了一个别名<code>gee.H</code>，构建JSON数据时，显得更简洁。</li>
<li><code>Context</code>目前只包含了<code>http.ResponseWriter</code>和<code>*http.Request</code>，另外提供了对 Method 和 Path 这两个常用属性的直接访问。</li>
<li>提供了访问Query和PostForm参数的方法。</li>
<li>提供了快速构造String/Data/JSON/HTML响应的方法。</li>
</ul>
<p>二、区别：</p>
<p>1、json.NewDecoder是从一个<code>流</code>里面直接进行解码，代码精干；<br>2、json.Unmarshal是从已存在与内存中的json进行解码；<br>3、相对于解码，json.NewEncoder进行大JSON的编码比json.marshal性能高，因为内部使用pool。</p>
<p>三、场景应用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">encoder := json.NewEncoder(c.Writer)<br>	<span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>		http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>	&#125;<br></code></pre></td></tr></table></figure>
<p>1、json.NewDecoder用于http连接与socket连接的读取与写入，或者文件读取；<br>2、json.Unmarshal用于直接是byte的输入。</p>
<h2 id="Day-3-前缀树路由"><a href="#Day-3-前缀树路由" class="headerlink" title="Day 3 前缀树路由"></a>Day 3 前缀树路由</h2><p>所有的路由地址其实是虚拟的地址，就是map存储，相当于一个标识。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">parts := strings.Split(url, <span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这样之后 parts[0] = “”，是一个nil</p>
<p>我们对于路由的修改变成了，添加路由和查找路由，查找路由比较复杂一点，因为要考虑到通配符的问题。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h3><p>addRouter -&gt; getRouter -&gt; handle 在看一遍代码 走一遍流程就明了多了, 说白了就是 用前缀树结构存 前缀树结构取, 用GET /a/asd/c || GET a/s/c 匹配到路由(GET-/a/:param/c)对应的HandlerFunc 并把asd || s 存在context的Params里。</p>
<h3 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a><strong>BUG</strong></h3><p><strong>Q：</strong></p>
<p><strong>第一个 bug</strong></p>
<p>在 <code>trie.go</code> 里的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> insert(pattern <span class="hljs-type">string</span>, parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height &#123;<br>		n.pattern = pattern<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	part := parts[height]<br>	child := n.matchChild(part)<br>	<span class="hljs-keyword">if</span> child == <span class="hljs-literal">nil</span> &#123;<br>		child = &amp;node&#123;part: part, isWild: part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> || part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span>&#125;<br>		n.children = <span class="hljs-built_in">append</span>(n.children, child)<br>	&#125;<br>	child.insert(pattern, parts, height+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果第一次插入的<code>pattern</code>为<code>/:age</code>，<code>method</code> 为 <code>GET</code>，<code>handlefunc</code> 为 <code>handleAge()</code></p>
<p>那么会生成一个这样的 <code>node</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;:age&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br></code></pre></td></tr></table></figure>
<p>第二次插入的 <code>pattern</code> 为 <code>/18</code> ,<code>method</code> 与第一次相同，仍然为 <code>GET</code>，<code>handlefunc</code>为 <code>handle18()</code>，此时并不会修改之前的 <code>node</code>，而是修改了之前 <code>nodeAge</code> 的 <code>pattern</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;18&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br>handlers[<span class="hljs-string">&quot;GET-18&quot;</span>] =  handle18<br></code></pre></td></tr></table></figure>
<p>接下来看看<code>handle()</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;<br>	n, params := r.getRoute(c.Method, c.Path)<br>	<span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>		c.Params = params<br>		key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + n.pattern<br>		r.handlers[key](c)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		c.String(http.StatusNotFound, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当有一个 <code>/19</code> 的请求到来时，将会匹配到 <code>nodeAge</code>，但是由于 <code>nodeAge</code> 的 <code>pattern</code>变成了 <code>18</code>，因此将会被 <code>handle18()</code> 处理，这不太合适。</p>
<p><strong><code>GIN</code>的做法是将冲突的路由直接<code>panic</code>了。</strong></p>
<p><strong>第二个bug</strong></p>
<p><code>router</code>的 <code>handle</code> 方法貌似不是协程安全的</p>
<p>假设此时只有一个<code>/:age</code>的<code>router</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;:age&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br></code></pre></td></tr></table></figure>
<p>此时有两个请求地址分别为 <code>/18</code> 和 <code>/19</code>的请求到达。</p>
<p><code>handle()</code> 内的 <code>getRoute()</code> 函数得到的 <code>params</code> 分别为 <code>key:age value:18</code> 和 <code>key:age value:19</code>，它们会对<strong>同一个</strong> <code>context</code> 进行写入，因此不太安全。</p>
<p>在 <code>http</code> 包内的 <code>server.go</code> 文件中的 <code>Serve</code> 函数内，有这样一段注释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Serve accepts incoming connections on the Listener l, creating a</span><br><span class="hljs-comment">// new service goroutine for each. The service goroutines read requests and</span><br><span class="hljs-comment">// then call srv.Handler to reply to them.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// HTTP/2 support is only enabled if the Listener returns *tls.Conn</span><br><span class="hljs-comment">// connections and they were configured with &quot;h2&quot; in the TLS</span><br><span class="hljs-comment">// Config.NextProtos.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Serve always returns a non-nil error and closes l.</span><br><span class="hljs-comment">// After Shutdown or Close, the returned error is ErrServerClosed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure>
<p>可见，<code>http.ListenAndServe()</code> 是有可能开启多个协程的。</p>
<p><strong>A：</strong></p>
<p>第一个bug，存在覆盖的问题，gin 的做法才是对的，应该把问题暴露给用户。<br>第二个问题，http 请求是并发的，但每一个请求都会调用 <code>ServeHTTP</code> ，这个方法中，context 每次都创建新的，不会对同一个context进行写入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>	c := newContext(w, req)<br>	engine.router.handle(c)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键点：比较 parts 的长度有没有相匹配的深度就可以知道是否匹配上了，因为通配符也占位</p>
<h2 id="Day-4-分组控制"><a href="#Day-4-分组控制" class="headerlink" title="Day 4 分组控制"></a>Day 4 分组控制</h2><h3 id="分组的意义"><a href="#分组的意义" class="headerlink" title="分组的意义"></a>分组的意义</h3><p>分组控制(Group Control)是 Web 框架应提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如：</p>
<ul>
<li>以<code>/post</code>开头的路由匿名可访问。</li>
<li>以<code>/admin</code>开头的路由需要鉴权。</li>
<li>以<code>/api</code>开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</li>
</ul>
<p>ps：RESTful风格是 —— <strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</strong></p>
<p>parent 之前设计是用来拼接 prefix 的，每个 group 只记录自己的部分，最后通过 parent 层层回溯拼接。不过后来改用 <code>group.prefix + prefix</code> 的方式 group 初始化时已经拼接了完整的 prefix，所以不需要 <code>parent</code> 了，可以删除。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Backend-development/">Backend development</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/TCP-UDP/">TCP, UDP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/18/golang%E5%8E%9F%E7%90%86/">
                        <span class="hidden-mobile">golang原理</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> & <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
