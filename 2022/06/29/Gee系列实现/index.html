

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon1.png">
  <link rel="icon" href="/img/favicon1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Peter Pan">
  <meta name="keywords" content="">
  
    <meta name="description" content="Web框架 - Gee0.1 基本的net包建立tcp连接的步骤(server端)  设置tcp地址 设立监听对象 建立连接  1234567tcpAddr, _ :&#x3D; net.ResolveTCPAddr(&quot;tcp&quot;, &quot;:8888&quot;)listener, _ :&#x3D; net.ListenTCP(&quot;tcp&quot;, tcpAddr)conn, e">
<meta property="og:type" content="article">
<meta property="og:title" content="Gee系列实现">
<meta property="og:url" content="http://example.com/2022/06/29/Gee%E7%B3%BB%E5%88%97%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="PPStudy">
<meta property="og:description" content="Web框架 - Gee0.1 基本的net包建立tcp连接的步骤(server端)  设置tcp地址 设立监听对象 建立连接  1234567tcpAddr, _ :&#x3D; net.ResolveTCPAddr(&quot;tcp&quot;, &quot;:8888&quot;)listener, _ :&#x3D; net.ListenTCP(&quot;tcp&quot;, tcpAddr)conn, e">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://geektutu.com/post/geecache-day1/lru.jpg">
<meta property="og:image" content="https://geektutu.com/post/geecache-day4/hash_select.jpg">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000040178986">
<meta property="article:published_time" content="2022-06-29T04:14:31.000Z">
<meta property="article:modified_time" content="2022-08-06T09:24:52.032Z">
<meta property="article:author" content="Peter Pan">
<meta property="article:tag" content="TCP, UDP">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://geektutu.com/post/geecache-day1/lru.jpg">
  
  
  <title>Gee系列实现 - PPStudy</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Gee系列实现">
              
                Gee系列实现
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-06-29 12:14" pubdate>
        June 29, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      28k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      237 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Gee系列实现</h1>
            
            <div class="markdown-body">
              <h1 id="Web框架-Gee"><a href="#Web框架-Gee" class="headerlink" title="Web框架 - Gee"></a>Web框架 - Gee</h1><h2 id="0-1-基本的net包"><a href="#0-1-基本的net包" class="headerlink" title="0.1 基本的net包"></a>0.1 基本的net包</h2><p>建立tcp连接的步骤(server端)</p>
<ol>
<li>设置tcp地址</li>
<li>设立监听对象</li>
<li>建立连接</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs go">tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>listener, _ := net.ListenTCP(<span class="hljs-string">&quot;tcp&quot;</span>, tcpAddr)<br>conn, err := listener.AcceptTCP()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-comment">// 创建好一个tcp的服务端</span><br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>优化，循环链接，要处理很多tcp请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>    listener, _ := net.ListenTCP(<span class="hljs-string">&quot;tcp&quot;</span>, tcpAddr)<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.AcceptTCP()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>          fmt.Println(err)<br>          <span class="hljs-keyword">return</span><br>          <span class="hljs-comment">// handle error</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> handleConnection(conn)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn *net.TCPConn)</span></span> &#123;<br>		<span class="hljs-keyword">for</span> &#123;<br>		buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>		n, err := conn.Read(buf)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>        <span class="hljs-keyword">break</span><br>		&#125;<br>		fmt.Println(conn.RemoteAddr().String() + <span class="hljs-type">string</span>(buf[<span class="hljs-number">0</span> : n])) <span class="hljs-comment">// 获取连接进来的地址 + 字符串</span><br>		str := <span class="hljs-string">&quot;received success! message: &quot;</span> + <span class="hljs-type">string</span>(buf[<span class="hljs-number">0</span> : n])<br>		conn.Write([]<span class="hljs-type">byte</span>(str))<br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>(dial端)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>    conn, _ := net.DialTCP(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-literal">nil</span>, tcpAddr)<br>    reader := bufio.NewReader(os.Stdin)<br>    <span class="hljs-keyword">for</span> &#123;<br>        bytes, _, _ := reader.ReadLine()<br>        conn.Write(bytes)<br>        rb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>        rn, _ := conn.Read(rb)<br>        fmt.Println(<span class="hljs-type">string</span>(rb[<span class="hljs-number">0</span> : rn])) <span class="hljs-comment">// string处理要不就是ASCII码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="0-2-Http包"><a href="#0-2-Http包" class="headerlink" title="0.2 Http包"></a>0.2 Http包</h2><p><strong>Get请求的实现</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;<br>		res.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;我收到了给你返回&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/test&quot;</span>, handler)<br>    server := http.Server&#123;<br>      Addr: <span class="hljs-string">&quot;:8080&quot;</span>,<br>      Handler: <span class="hljs-literal">nil</span>,<br>    &#125;<br>    server.ListenAndServe()<br>    <span class="hljs-comment">// http.ListenAndServe(&quot;:8080&quot;, nil)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>为什么不用判断req的方法就可以实现呢get呢？因为默认是get请求？</p>
<p>其中为什么前者response不是指针，而后者request是指针呢？因为request是外部传来的（这个有待以后check源码）</p>
<p><strong>server</strong> 服务，包含地址、端口、处理器等等</p>
<p><strong>conn</strong> 链接，用户请求来的</p>
<p><strong>response</strong> 返回信息</p>
<p><strong>request</strong> 用户的请求信息</p>
<p><strong>Handle</strong> 对于接收的信息进行处理并且返回的一个处理器</p>
<p>Step：</p>
<p>1、通过 Header() 来设置头map</p>
<p>2、通过 WriteHeader(code) 来设置状态码</p>
<p>3、通过 Write 写入这个io.writer 来控制返回值</p>
<p>4、通过 req.Body 以请求过来的body内容</p>
<p>5、剩下的就是组装，e.g. 一个内置的方法，把路径当静态显示</p>
<p>http.Handle(“/“, http.FileServer(http.dir(“/“)))</p>
<p>res是我们要返回的值，req是前端传给我们的值。</p>
<pre><code class=" mermaid">graph LR;
	http请求 --&gt; DefaultServeMux;
	DefaultServeMux --&gt; Handler1;
	DefaultServeMux --&gt; Handler2;
	DefaultServeMux --&gt; ......;
	DefaultServeMux --&gt; Handler3;
</code></pre>
<p>有自定义的handler的话就是这个样子。</p>
<pre><code class=" mermaid">graph LR;
	http请求 --&gt; myHandler;
</code></pre>
<p>Multiplexer（多路复用器）</p>
<p>他也是一个handler</p>
<p><strong>url通用格式</strong></p>
<p>Scheme : // [ userinfo@ ] host / path [ ?query ] [ #fragment ]</p>
<p>如果从浏览器发出的请求，那么你无法提取处 Fragment 字段的值（浏览器在发送请求时会把 fragment 部分去掉）</p>
<h3 id="FORM-表单"><a href="#FORM-表单" class="headerlink" title="FORM 表单"></a>FORM 表单</h3><h4 id="表单的-enctype-属性"><a href="#表单的-enctype-属性" class="headerlink" title="表单的 enctype 属性"></a>表单的 enctype 属性</h4><ul>
<li>如果 enctype 是 application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。例如：</li>
</ul>
<p>​            frist_name=peter&amp;last_name=pan</p>
<ul>
<li><p>如果 enctype 是 multipart/form-data，那么</p>
<p>​     每一个 name-value 对都会被转换为一个MIME消息部分</p>
<p>​     每一个部分都有自己的 Content Type 和 Content Dispostion</p>
</li>
</ul>
<p><strong>如何选择呢？</strong></p>
<p>简单文本：表单URL编码</p>
<p>大量数据，例如上传文件：multipart-MIME</p>
<p>​        甚至可以把二进制数据通过base64编码，来当作文本进行发送</p>
<h4 id="FORM-字段"><a href="#FORM-字段" class="headerlink" title="FORM 字段"></a>FORM 字段</h4><p>提取Request上的字段有三个，Form，PostForm，MultipartForm</p>
<p>通常做法调用 ParseForm 或 ParseMultipartForm 来解析 Request，然后相应的访问 Form、PostForm 或 MultipartForm 字段</p>
<h4 id="PostForm-字段"><a href="#PostForm-字段" class="headerlink" title="PostForm 字段"></a>PostForm 字段</h4><p>由于表单和 URL 里有同样的 Key，那么他们都会放在一个 slice 里面，（表单在前面，url的在后面）。如果只想要表单的 key - value 对，不要 URL 的，可以使用PostForm 字段</p>
<p>PostForm 和 Form 只支持 application/x-www-form-urlencoded</p>
<p>MultipartForm 字段支持 multipart key-value 对，返回类型是个 struct 不是 map。1⃣️ key—-string，value—-[]string 2⃣️ 空的（key—-string，value—-文件）所以这个是用来传输文件的</p>
<p>FormValue 方法会返回 Form 字段中指定 key 对应的第一个 value，无需调用ParseForm（无需解析）</p>
<p>PostFromValue 相同，但如果 enctype 设为 multipart/form-data</p>
<h4 id="FromFile方法"><a href="#FromFile方法" class="headerlink" title="FromFile方法"></a>FromFile方法</h4><p>上传文件还有一个简便方法：FormFile（例子）</p>
<p>​        无需调用 ParseMultipartForm 方法</p>
<p>​        返回指定 key 对应的第一个 value</p>
<p>​        同时返回 File 和FileHeader，以及错误信息</p>
<p>​        如果只上传一个文件，那么这种方式会快一些        </p>
<h3 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a>ResponseWriter</h3><p>从服务器向客户端返回响应需要使用 ResponseWriter</p>
<p>ResponseWriter 是一个接口，handler 用它来返回响应</p>
<p>真正支撑 ResponseWriter 的幕后 struct 是非导出的 http.response</p>
<p><strong>Q：为什么 Handler 的 ServeHTTP(w ResponseWriter, r *Request)，只有一个是指针类型？而 w 是按值传递的吗？</strong></p>
<p><strong>A：</strong>ResponseWriter是一个接口它代表了一个指针，w 和 r 都是按照引用传递的</p>
<h4 id="Header-方法"><a href="#Header-方法" class="headerlink" title="Header 方法"></a>Header 方法</h4><p>Header 方法返回 headers 的 map，可以进行修改</p>
<p>修改后的 headers 将会体现在返回给客户端的 HTTP 响应里</p>
<h4 id="Write-方法"><a href="#Write-方法" class="headerlink" title="Write 方法"></a>Write 方法</h4><p>写入body</p>
<h4 id="WriteHeader-方法"><a href="#WriteHeader-方法" class="headerlink" title="WriteHeader 方法"></a>WriteHeader 方法</h4><p>WriteHeader 方法接受一个整数类型（HTTP 状态码）作为参数，并把它作为 HTTP 响应的状态码返回</p>
<p>如果该方法没有显式调用，那么在第一次调用 Write 方法前，会隐式的调用 WriteHeader（http.StatusOK）</p>
<p>​        所以 WriteHeader 主要用来发送错误类的 HTTP 状态码</p>
<p>调用完 WriteHeader 方法之后，仍然可以写入到 ResponseWriter，但无法再修改 header 了</p>
<h4 id="内置的-Response"><a href="#内置的-Response" class="headerlink" title="内置的 Response"></a>内置的 Response</h4><p>NotFound 函数，404 + 额外的信息</p>
<p>ServeFile 函数，从文件系统提供文件，返回给请求者</p>
<p>ServeContent 函数，可以请求range内的内容</p>
<p>Redirect 函数，重定向</p>
<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><pre><code class=" mermaid">graph LR;
	模版 --&gt; 模版引擎;
	数据 --&gt; 模版引擎;
	模版引擎 --&gt; HTML
</code></pre>
<p>两种理想的模版引擎：1、无逻辑模版引擎 2、逻辑嵌入模版引擎</p>
<p>go使用的是text/template，HTML相关部分用的是html/template，是混合体</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="controller的角色"><a href="#controller的角色" class="headerlink" title="controller的角色"></a>controller的角色</h4><p>main()：设置类工作</p>
<p>controller：</p>
<p>​        静态资源</p>
<p>​        把不同的请求送到不同的controller进行处理</p>
<pre><code class=" mermaid">graph LR;
		前置controller --&gt; home_handler;
		前置controller --&gt; page1_handler;
		前置controller --&gt; page2_handler;
</code></pre>
<h4 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h4><p>静态路由：一个路径对应一个页面</p>
<p>/home</p>
<p>/about</p>
<p>带参数的路由：根据路由参数，创建出一族不同的页面</p>
<p>/companies/123</p>
<p>/companies/Microsoft</p>
<h4 id="第三方路由器"><a href="#第三方路由器" class="headerlink" title="第三方路由器"></a>第三方路由器</h4><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><p>Marshal和Unmarshal</p>
<p>Marshal（编码）：把 go struct 转化为 json 格式</p>
<p>​        MarshalIndent，（内容，换行，缩进）</p>
<p>Unmarshal（解码）：把 json 转化为 go struct</p>
<p><strong>针对 string 或 bytes：</strong></p>
<p>​        Marshal =&gt; String</p>
<p>​        Unmarshal &lt;= String</p>
<p><strong>针对stream：</strong></p>
<p>​        Encode =&gt; Stream，把数据写入到 io.Writer</p>
<p>​        Decode &lt;= Stream，从 io.Reader 读取数据</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>创建中间件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyMiddleware <span class="hljs-keyword">struct</span> &#123;<br>  	Next http.Handler<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyMiddleware)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>  	<span class="hljs-comment">// 在 next handler之前做一些事情</span><br>  	m.Next.ServeHTTP(w,r)<br>  	<span class="hljs-comment">// 在 next handler之后做一些事情（处理一些响应里面的内容）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="中间件的用途"><a href="#中间件的用途" class="headerlink" title="中间件的用途"></a>中间件的用途</h4><ul>
<li><p>Logging 日志</p>
</li>
<li><p>安全</p>
</li>
<li><p>请求超时</p>
</li>
<li><p>响应压缩</p>
</li>
<li><p>拦截器</p>
</li>
</ul>
<h3 id="使用请求上下文"><a href="#使用请求上下文" class="headerlink" title="使用请求上下文"></a>使用请求上下文</h3><h4 id="Request-Context"><a href="#Request-Context" class="headerlink" title="Request Context"></a>Request Context</h4><p>func(*Request) Context() context.Context</p>
<p>​        返回当前请求的上下文</p>
<p>func(*Request) WithContext(ctx context.Context) context.Context</p>
<p>​        基于 Context 进行 ”修改“，（实际上）创建一个新的 Context</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br><br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br>    Err() <span class="hljs-type">error</span><br><br>    Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这些方法都是用于读的，要更新的话得创建新的context</p>
<h4 id="Context-API-可以返回新-Context"><a href="#Context-API-可以返回新-Context" class="headerlink" title="Context API - 可以返回新 Context"></a>Context API - 可以返回新 Context</h4><p>WithCancel()，它有一个 CancelFunc</p>
<p>WithDeadline()，带有一个时间戳（time.Time）</p>
<p>WithTimeout()，带有一个具体的时间段（time.Duration)</p>
<p>WithValue()，在里面添加一些值</p>
<p>PS：new创建结构体返回的是一个对应类型的指针，而普通结构体的创建需要加&amp;才能是指针要不就是个普通的结构体无人指向它</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>TLS —— 传输层安全</p>
<h4 id="HTTP-Listener"><a href="#HTTP-Listener" class="headerlink" title="HTTP Listener"></a>HTTP Listener</h4><p>http.ListenAndServe 函数</p>
<p>http.ListenAndServeTLS 函数</p>
<p>用 https 会让http协议从1.1升级到2</p>
<p>他建立长连接，所以分成各种frame，可以数据类型来进行优化从而提高处理效率。</p>
<p>Server Push可以提前预加载好要加载的文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> pusher, ok := w.(http.Pusher); ok &#123;<br>    pusher.Push(<span class="hljs-string">&quot;/css/app.css&quot;</span>, &amp;http.PushOptions&#123;<br>    	  Header: http.Header&#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;text/css&quot;</span>&#125;&#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试model层</p>
<p>user<strong>_test</strong>.go</p>
<ul>
<li><p>测试代码所在文件的名称以 _test 结尾</p>
</li>
<li><p>对于生产编译，不会包含以 _test 结尾的文件</p>
</li>
<li><p>对于测试编译，会包含以 _test 结尾的文件</p>
</li>
</ul>
<p>func <strong>Test</strong>UpdatesModifiedTime( <strong>t *testing.T</strong> )</p>
<ul>
<li>测试函数名应以 Test 开头（需要导出）</li>
<li>函数名需要表达出被验证的特征</li>
<li>测试函数的参数类型是 *testing.T，它会提供测试相关的一些工具</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>Import _ “net/http/pprof”</p>
<ul>
<li>设置一些监听的 URL，它们会提供各类诊断信息</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/heap">http://localhost:8080/debug/pprof/heap</a> // 内存</p>
<ul>
<li>从应用获取内存dump：应用在使用哪些内存，他们会去哪</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/profile">http://localhost:8080/debug/pprof/profile</a> // CPU</p>
<ul>
<li>CPU的快照，可以看到谁在用 CPU</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/block">http://localhost:8080/debug/pprof/block</a> // goroutine</p>
<ul>
<li>看到阻塞的 goroutine</li>
</ul>
<p>go tool pprof <a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof/trace?second=5">http://localhost:8080/debug/pprof/trace?second=5</a> // trace</p>
<ul>
<li>监控这段时间内，什么在执行，什么在调用什么</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/debug/pprof">http://localhost:8080/debug/pprof</a> // 网址</p>
<h2 id="Day-1-HTTP基础"><a href="#Day-1-HTTP基础" class="headerlink" title="Day 1 HTTP基础"></a>Day 1 HTTP基础</h2><p>在实现<code>Engine</code>之前，我们调用 <em>http.HandleFunc</em> 实现了路由和Handler的映射，也就是只能针对具体的路由写处理逻辑。比如<code>/hello</code>。但是在实现<code>Engine</code>之后，我们拦截了所有的HTTP请求，拥有了统一的控制入口。在这里我们可以自由定义路由映射的规则，也可以统一添加一些处理逻辑，例如日志、异常处理等</p>
<p><code>gee.go</code>内容</p>
<ul>
<li>首先定义了类型<code>HandlerFunc</code>，这是提供给框架用户的，用来定义路由映射的处理方法。我们在<code>Engine</code>中，添加了一张路由映射表<code>router</code>，key 由请求方法和静态路由地址构成，例如<code>GET-/</code>、<code>GET-/hello</code>、<code>POST-/hello</code>，这样针对相同的路由，如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法。</li>
<li>当用户调用<code>(*Engine).GET()</code>方法时，会将路由和处理方法注册到映射表 <em>router</em>中，<code>(*Engine).Run()</code>方法，是 <em>ListenAndServe</em> 的包装。</li>
<li><code>Engine</code>实现的 <em>ServeHTTP</em> 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 <em>404 NOT FOUND</em> 。</li>
</ul>
<p>第二个参数类型是接口类型 <code>http.Handler</code>，<code>Handler</code> 的定义博文中已经贴了，是从 <code>http</code> 的源码中找到的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>    ServeHTTP(w ResponseWriter, r *Request)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(address <span class="hljs-type">string</span>, h Handler)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure>
<p>在 Go 语言中，实现了接口方法的 struct 都可以强制转换为接口类型。你可以这么写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">handler := (http.Handler)(engine) <span class="hljs-comment">// 手动转换为借口类型</span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:9999&quot;</span>, handler))<br></code></pre></td></tr></table></figure>
<p>然后，<code>ListenAndServe</code> 方法里面会去调用 <code>handler.ServeHTTP()</code> 方法，你感兴趣，可以在 http 的源码中找到调用的地方。但是这么写是多余的，传参时，会自动进行参数转换的。所以直接传入engine 即可。</p>
<p>在没有 engine 的情况下我们默认的是一个 DefaultServeMux 他负责识别所有的 handler，但他不能给 handler 分类，所以我们要引入 engine。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuqun0319/article/details/106136338">https://blog.csdn.net/liuqun0319/article/details/106136338</a> 详解 type func() 用法分析</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	one(<span class="hljs-number">2</span>, callback)<br>&#125;<br><br><span class="hljs-comment">//需要传递函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">callback</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;i am callBack&quot;</span>)<br>	fmt.Println(i)<br>&#125;<br><br><span class="hljs-comment">//main 中调用的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">one</span><span class="hljs-params">(i <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span>) &#123;<br>	two(i,fun(f))<br>&#125;<br><br><span class="hljs-comment">//one() 中调用的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">two</span><span class="hljs-params">(i <span class="hljs-type">int</span>, c Call)</span></span> &#123;<br>	c.call(i)<br>&#125;<br><br><span class="hljs-comment">//定义的type函数</span><br><span class="hljs-keyword">type</span> fun <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><br><span class="hljs-comment">//fun实现的Call接口的call()函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f fun)</span></span> call(i <span class="hljs-type">int</span>) &#123;<br>	f(i)<br>&#125;<br><br><span class="hljs-comment">//call接口</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">interface</span> &#123;<br>	call(<span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里解释清楚了上述的调用关系。首先 one() 参数中的函数调用 two() 参数中的接口，并且通过该接口为这个函数赋值，但最终真正运行的还是 one() 中的函数 callback，只不过 callback 代表着一个 fun 函数实现了一个接口，接口的功能是用来给 fun 函数赋值。如下转换</p>
<p><strong>流程图：</strong></p>
<pre><code class=" mermaid">graph LR;
		http请求 --&gt; engine;
		engine --&gt; GET请求;
		engine --&gt; POST请求;
</code></pre>
<p>其中 engine 是用来鉴别请求的（有两部分），它里面有一个路由map，用来存放我们设定好的路由。第二部分就是一个ServeHTTP方法（这个是在 GET 和 POST 方法中转换的，因为go中结构体放入函数中的参数接口可以自动转换为别的类型）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 所有的handler都要有SeverHTTP这样一个函数，还要有ResponseWriter, *Request这两个参数）</span><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>   ServeHTTP(ResponseWriter, *Request)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>engine 中的 ServeHTTP 目的是为了实现转换成 handler 的 engine 该有的接口。第一步通过 listenAndServer 将 engine 变成 handler 接口。因为变成了handler接口（如上），所以第二步 engine 也要实现 ServeHTTP 函数。第三步里面实现的内容就是 1.查找是否有对应的路由注册 2. 若查找到就直接为这个 handlerFunc 赋入参 3. 没找到就404</p>
<p>其中为什么可以直接写成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> handler, ok := e.Router[key]; ok &#123;<br>		handler(w, r) <span class="hljs-comment">// 调用存储在 map 中的函数，执行并赋值。</span><br></code></pre></td></tr></table></figure>
<p>handler 本身就是个 func 类型，所以这一步就是赋值并运行。</p>
<h2 id="Day-2-上下文"><a href="#Day-2-上下文" class="headerlink" title="Day 2 上下文"></a>Day 2 上下文</h2><p><strong>设计Context必要性</strong></p>
<ol>
<li>对Web服务来说，无非是根据请求<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写大量重复，繁杂的代码，而且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。</li>
</ol>
<p>用返回 JSON 数据作比较，感受下封装前后的差距。</p>
<p>封装前</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">obj = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;geektutu&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1234&quot;</span>,<br>&#125;<br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>w.WriteHeader(http.StatusOK)<br>encoder := json.NewEncoder(w)<br><span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>    http.Error(w, err.Error(), <span class="hljs-number">500</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>VS 封装后：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">c.JSON(http.StatusOK, gee.H&#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: c.PostForm(<span class="hljs-string">&quot;username&quot;</span>),<br>    <span class="hljs-string">&quot;password&quot;</span>: c.PostForm(<span class="hljs-string">&quot;password&quot;</span>),<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>流程图</p>
<pre><code class=" mermaid">graph LR;
		http请求 --&gt; engine;
		engine --&gt; router-get\post;
		router-get\post --&gt; PostForm;
		router-get\post --&gt; Query;
		router-get\post --&gt; Status;
		router-get\post --&gt; SetHeader;
		router-get\post --&gt; String;
		router-get\post --&gt; JSON;
		router-get\post --&gt; Data;
		router-get\post --&gt; HTML;
</code></pre>
<p>最重要的还是通过实现了 ServeHTTP 接口，接管了所有的 HTTP 请求。</p>
<p>后面集成了常用的方法，比如JSON，HTML等等，为的就是前文提到的，这样再处理JSON请求的时候不用重复的写一遍怎么将数据转成JSON，统一转换成JSON然后响应JSON请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// origin objects</span><br>	Writer http.ResponseWriter<br>	Req    *http.Request<br>	<span class="hljs-comment">// request info</span><br>	Path   <span class="hljs-type">string</span><br>	Method <span class="hljs-type">string</span><br>	<span class="hljs-comment">// response info</span><br>	StatusCode <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>本质上没有变就是在 w 和 r 的上面又封装了一层 context，这个 context 包含了一些属性比如请求中的路径和方法，响应的状态码。</p>
<p>把状态码的设置，响应头的内容的设置封装在 context 的方法中，Context 就像一次会话的百宝箱，可以找到任何东西。</p>
<ul>
<li>给<code>map[string]interface&#123;&#125;</code>起了一个别名<code>gee.H</code>，构建JSON数据时，显得更简洁。</li>
<li><code>Context</code>目前只包含了<code>http.ResponseWriter</code>和<code>*http.Request</code>，另外提供了对 Method 和 Path 这两个常用属性的直接访问。</li>
<li>提供了访问Query和PostForm参数的方法。</li>
<li>提供了快速构造String/Data/JSON/HTML响应的方法。</li>
</ul>
<p>二、区别：</p>
<p>1、json.NewDecoder是从一个<code>流</code>里面直接进行解码，代码精干；<br>2、json.Unmarshal是从已存在与内存中的json进行解码；<br>3、相对于解码，json.NewEncoder进行大JSON的编码比json.marshal性能高，因为内部使用pool。</p>
<p>三、场景应用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">encoder := json.NewEncoder(c.Writer)<br>	<span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>		http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>	&#125;<br></code></pre></td></tr></table></figure>
<p>1、json.NewDecoder用于http连接与socket连接的读取与写入，或者文件读取；<br>2、json.Unmarshal用于直接是byte的输入。</p>
<h2 id="Day-3-前缀树路由"><a href="#Day-3-前缀树路由" class="headerlink" title="Day 3 前缀树路由"></a>Day 3 前缀树路由</h2><p>所有的路由地址其实是虚拟的地址，就是map存储，相当于一个标识。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">parts := strings.Split(url, <span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这样之后 parts[0] = “”，是一个nil</p>
<p>我们对于路由的修改变成了，添加路由和查找路由，查找路由比较复杂一点，因为要考虑到通配符的问题。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h3><p>addRouter -&gt; getRouter -&gt; handle 在看一遍代码 走一遍流程就明了多了, 说白了就是 用前缀树结构存 前缀树结构取, 用GET /a/asd/c || GET a/s/c 匹配到路由(GET-/a/:param/c)对应的HandlerFunc 并把asd || s 存在context的Params里。</p>
<h3 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a><strong>BUG</strong></h3><p><strong>Q：</strong></p>
<p><strong>第一个 bug</strong></p>
<p>在 <code>trie.go</code> 里的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> insert(pattern <span class="hljs-type">string</span>, parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height &#123;<br>		n.pattern = pattern<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	part := parts[height]<br>	child := n.matchChild(part)<br>	<span class="hljs-keyword">if</span> child == <span class="hljs-literal">nil</span> &#123;<br>		child = &amp;node&#123;part: part, isWild: part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> || part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span>&#125;<br>		n.children = <span class="hljs-built_in">append</span>(n.children, child)<br>	&#125;<br>	child.insert(pattern, parts, height+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果第一次插入的<code>pattern</code>为<code>/:age</code>，<code>method</code> 为 <code>GET</code>，<code>handlefunc</code> 为 <code>handleAge()</code></p>
<p>那么会生成一个这样的 <code>node</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;:age&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br></code></pre></td></tr></table></figure>
<p>第二次插入的 <code>pattern</code> 为 <code>/18</code> ,<code>method</code> 与第一次相同，仍然为 <code>GET</code>，<code>handlefunc</code>为 <code>handle18()</code>，此时并不会修改之前的 <code>node</code>，而是修改了之前 <code>nodeAge</code> 的 <code>pattern</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;18&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br>handlers[<span class="hljs-string">&quot;GET-18&quot;</span>] =  handle18<br></code></pre></td></tr></table></figure>
<p>接下来看看<code>handle()</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;<br>	n, params := r.getRoute(c.Method, c.Path)<br>	<span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>		c.Params = params<br>		key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + n.pattern<br>		r.handlers[key](c)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		c.String(http.StatusNotFound, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当有一个 <code>/19</code> 的请求到来时，将会匹配到 <code>nodeAge</code>，但是由于 <code>nodeAge</code> 的 <code>pattern</code>变成了 <code>18</code>，因此将会被 <code>handle18()</code> 处理，这不太合适。</p>
<p><strong><code>GIN</code>的做法是将冲突的路由直接<code>panic</code>了。</strong></p>
<p><strong>第二个bug</strong></p>
<p><code>router</code>的 <code>handle</code> 方法貌似不是协程安全的</p>
<p>假设此时只有一个<code>/:age</code>的<code>router</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;:age&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br></code></pre></td></tr></table></figure>
<p>此时有两个请求地址分别为 <code>/18</code> 和 <code>/19</code>的请求到达。</p>
<p><code>handle()</code> 内的 <code>getRoute()</code> 函数得到的 <code>params</code> 分别为 <code>key:age value:18</code> 和 <code>key:age value:19</code>，它们会对<strong>同一个</strong> <code>context</code> 进行写入，因此不太安全。</p>
<p>在 <code>http</code> 包内的 <code>server.go</code> 文件中的 <code>Serve</code> 函数内，有这样一段注释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Serve accepts incoming connections on the Listener l, creating a</span><br><span class="hljs-comment">// new service goroutine for each. The service goroutines read requests and</span><br><span class="hljs-comment">// then call srv.Handler to reply to them.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// HTTP/2 support is only enabled if the Listener returns *tls.Conn</span><br><span class="hljs-comment">// connections and they were configured with &quot;h2&quot; in the TLS</span><br><span class="hljs-comment">// Config.NextProtos.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Serve always returns a non-nil error and closes l.</span><br><span class="hljs-comment">// After Shutdown or Close, the returned error is ErrServerClosed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure>
<p>可见，<code>http.ListenAndServe()</code> 是有可能开启多个协程的。</p>
<p><strong>A：</strong></p>
<p>第一个bug，存在覆盖的问题，gin 的做法才是对的，应该把问题暴露给用户。<br>第二个问题，http 请求是并发的，但每一个请求都会调用 <code>ServeHTTP</code> ，这个方法中，context 每次都创建新的，不会对同一个context进行写入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>	c := newContext(w, req)<br>	engine.router.handle(c)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键点：比较 parts 的长度有没有相匹配的深度就可以知道是否匹配上了，因为通配符也占位</p>
<h2 id="Day-4-分组控制"><a href="#Day-4-分组控制" class="headerlink" title="Day 4 分组控制"></a>Day 4 分组控制</h2><h3 id="分组的意义"><a href="#分组的意义" class="headerlink" title="分组的意义"></a>分组的意义</h3><p>分组控制(Group Control)是 Web 框架应提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如：</p>
<ul>
<li>以<code>/post</code>开头的路由匿名可访问。</li>
<li>以<code>/admin</code>开头的路由需要鉴权。</li>
<li>以<code>/api</code>开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</li>
</ul>
<p>ps：RESTful风格是 —— <strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</strong></p>
<p>parent 之前设计是用来拼接 prefix 的，每个 group 只记录自己的部分，最后通过 parent 层层回溯拼接。不过后来改用 <code>group.prefix + prefix</code> 的方式 group 初始化时已经拼接了完整的 prefix，所以不需要 <code>parent</code> 了，可以删除。</p>
<h2 id="Day-5-中间件"><a href="#Day-5-中间件" class="headerlink" title="Day 5 中间件"></a>Day 5 中间件</h2><p>Gee 的中间件的定义与路由映射的 Handler 一致，处理的输入是<code>Context</code>对象。插入点是框架接收到请求初始化<code>Context</code>对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对<code>Context</code>进行二次加工。c.Next()<code>表示等待执行其他的中间件或用户的</code>Handler</p>
<p>假设我们应用了中间件 A 和 B，和路由映射的 Handler。<code>c.handlers</code>是这样的[A, B, Handler]，<code>c.index</code>初始化为-1。调用<code>c.Next()</code>，接下来的流程是这样的：</p>
<ul>
<li>c.index++，c.index 变为 0</li>
<li>0 &lt; 3，调用 c.handlers[0]，即 A</li>
<li>执行 part1，调用 c.Next()</li>
<li>c.index++，c.index 变为 1</li>
<li>1 &lt; 3，调用 c.handlers[1]，即 B</li>
<li>执行 part3，调用 c.Next()</li>
<li>c.index++，c.index 变为 2</li>
<li>2 &lt; 3，调用 c.handlers[2]，即Handler</li>
<li>Handler 调用完毕，返回到 B 中的 part4，执行 part4</li>
<li>part4 执行完毕，返回到 A 中的 part2，执行 part2</li>
<li>part2 执行完毕，结束。</li>
</ul>
<p>一句话说清楚重点，最终的顺序是<code>part1 -&gt; part3 -&gt; Handler -&gt; part 4 -&gt; part2</code>。恰恰满足了我们对中间件的要求，接下来看调用部分的代码，就能全部串起来了。</p>
<p>目前的结构：</p>
<pre><code class=" mermaid">graph LR;
		http请求 --&gt; RouterGroup;
		RouterGroup --&gt; Engine;
		Engine --&gt; Context-get\post;
		Context-get\post --&gt; Next;
		Context-get\post --&gt; Param;
		Context-get\post --&gt; PostForm;
		Context-get\post --&gt; Query;
		Context-get\post --&gt; Status;
		Context-get\post --&gt; SetHeader;
		Context-get\post --&gt; String;
		Context-get\post --&gt; JSON;
		Context-get\post --&gt; Data;
		Context-get\post --&gt; HTML;
</code></pre>
<p>每一个use都会append一个中间件，并且存储在router group中，在实现serveHTTP的时候将这些中间件函数递给context</p>
<p>最后在next()中启动第一个handler</p>
<h2 id="Day-6-模版-Template"><a href="#Day-6-模版-Template" class="headerlink" title="Day 6 模版 Template"></a>Day 6 模版 Template</h2><p>那如果我么将所有的静态文件放在<code>/usr/web</code>目录下，那么<code>filepath</code>的值即是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。</p>
<p>找到文件后，如何返回这一步，<code>net/http</code>库已经实现了。因此，gee 框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给<code>http.FileServer</code>处理就好了</p>
<p>Golang 內建提供 <a target="_blank" rel="noopener" href="https://golang.org/pkg/net/http/#FileServer">http.FileServer</a> ，可以方便地透過 HTTP 存取檔案系統(file system)，例如以下程式碼執行之後，就可以透過瀏覽器打開網址 <code>http://localhost:8080</code> 瀏覽 <code>/usr/share/doc</code> 資料夾內的檔案。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, http.FileServer(http.Dir(<span class="hljs-string">&quot;/usr/share/doc&quot;</span>)))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以挂载一个文件路径通过ip来访问规定的地址。</p>
<p>如果是一个普通的结构体是需要加指针的</p>
<p>如果是一个map类型他自己就是个对象不用加指针</p>
<p>首先为 Engine 示例添加了 <code>*template.Template</code> 和 <code>template.FuncMap</code>对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。</p>
<p>另外，给用户分别提供了设置自定义渲染函数<code>funcMap</code>和加载模板的方法。</p>
<p>接下来，对原来的 <code>(*Context).HTML()</code>方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p>
<p>这一块设计比较简单，RouterGroup 只做路由的事情，Engine 做全局的事情。<code>LoadHTMLGlob</code> 设计成全局的了，你可以尝试下，实现 RouterGroup 级别的模板。</p>
<p><code>e.HtmlTemplates = template.Must(template.New(&quot;&quot;).Funcs(e.FuncMap).ParseGlob(pattern))</code></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/f-ck-need-u/p/10035768.html">https://www.cnblogs.com/f-ck-need-u/p/10035768.html</a></p>
<p><strong>使用template.New()函数可以创建一个空的、无解析数据的模板，同时还会创建一个common，也就是模板组</strong>。</p>
<p>也就是说，<strong>template.New()函数不仅创建了一个模板，还创建了一个空的common结构(模板组)。需要注意，新创建的common是空的，只有进行模板解析(Parse()，ParseFiles()等操作)之后，才会将模板添加到common的tmpl字段(map结构)中</strong>。</p>
<p>Parse()只能解析字符串，要解析文件中的内容，需要使用ParseFiles()或ParseGlob()。</p>
<p>template内置了一系列函数，但这些函数毕竟有限，可能无法满足特殊的需求。template允许我们定义自己的函数，添加到common中，然后就可以在待解析的内容中像使用内置函数一样使用自定义的函数。</p>
<p>自定义函数的优先级高于内置的函数优先级，即先检索自定义函数，再检索内置函数。也就是说，如果自定义函数的函数名和内置函数名相同，则内置函数将失效。</p>
<p>本文只对此稍作解释，本文的重点不是template的具体语法和用法。</p>
<p><strong>Golang Template</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lengyuezuixue/article/details/79367825?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;utm_relevant_index=1">https://blog.csdn.net/lengyuezuixue/article/details/79367825?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;utm_relevant_index=1</a></p>
<h2 id="Day-7-错误恢复"><a href="#Day-7-错误恢复" class="headerlink" title="Day 7 错误恢复"></a>Day 7 错误恢复</h2><p>Gee 的错误处理机制</p>
<p>对一个 Web 框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。</p>
<p>我们在第六天实现的框架并没有加入异常处理机制，如果代码中存在会触发 panic 的 BUG，很容易宕掉。</p>
<h1 id="分布式缓存-GeeCache"><a href="#分布式缓存-GeeCache" class="headerlink" title="分布式缓存 - GeeCache"></a>分布式缓存 - GeeCache</h1><h2 id="Day-1-LRU缓存机制"><a href="#Day-1-LRU缓存机制" class="headerlink" title="Day 1 LRU缓存机制"></a>Day 1 LRU缓存机制</h2><h3 id="1-核心数据结构"><a href="#1-核心数据结构" class="headerlink" title="1. 核心数据结构"></a>1. 核心数据结构</h3><p><img src="https://geektutu.com/post/geecache-day1/lru.jpg" srcset="/img/loading.gif" lazyload alt="implement lru algorithm with golang"></p>
<p>这张图很好地表示了 LRU 算法最核心的 2 个数据结构</p>
<ul>
<li>绿色的是字典(map)，存储键和值的映射关系。这样根据某个键(key)查找对应的值(value)的复杂是<code>O(1)</code>，在字典中插入一条记录的复杂度也是<code>O(1)</code>。</li>
<li>红色的是双向链表(double linked list)实现的队列。将所有的值放到双向链表中，这样，当访问到某个值时，将其移动到队尾的复杂度是<code>O(1)</code>，在队尾新增一条记录以及删除一条记录的复杂度均为<code>O(1)</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Cache is a LRU cache. It is not safe for concurrent access.</span><br><span class="hljs-keyword">type</span> Cache <span class="hljs-keyword">struct</span> &#123;<br>	maxBytes <span class="hljs-type">int64</span><br>	nbytes   <span class="hljs-type">int64</span><br>	ll       *list.List<br>	cache    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element<br>	<span class="hljs-comment">// optional and executed when an entry is purged.</span><br>	OnEvicted <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>, value Value)</span></span> <span class="hljs-comment">// 驱逐</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在这里我们直接使用 Go 语言标准库实现的双向链表<code>list.List</code>。</li>
<li>字典的定义是 <code>map[string]*list.Element</code>，键是字符串，值是双向链表中对应节点的指针。</li>
<li><code>maxBytes</code> 是允许使用的最大内存，<code>nbytes</code> 是当前已使用的内存，<code>OnEvicted</code> 是某条记录被移除时的回调函数，可以为 nil。</li>
<li>键值对 <code>entry</code> 是双向链表节点的数据类型，在链表中仍保存每个值对应的 key 的好处在于，淘汰队首节点时，需要用 key 从字典中删除对应的映射。</li>
<li>为了通用性，我们允许值是实现了 <code>Value</code> 接口的任意类型，该接口只包含了一个方法 <code>Len() int</code>，用于返回值所占用的内存大小。</li>
</ul>
<h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h3><p>查找主要有 2 个步骤，第一步是从字典中找到对应的双向链表的节点，第二步，将该节点移动到队尾。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get look ups a key&#x27;s value</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Get(key <span class="hljs-type">string</span>) (value Value, ok <span class="hljs-type">bool</span>) &#123;<br>	<span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;<br>		c.ll.MoveToFront(ele)<br>		kv := ele.Value.(*entry)<br>		<span class="hljs-keyword">return</span> kv.value, <span class="hljs-literal">true</span><br>	&#125;<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>如果键对应的链表节点存在，则将对应节点移动到队尾，并返回查找到的值。</li>
<li><code>c.ll.MoveToFront(ele)</code>，即将链表中的节点 <code>ele</code> 移动到队尾（双向链表作为队列，队首队尾是相对的，在这里约定 front 为队尾）</li>
</ul>
<p>其中<code>kv := ele.Value.(*entry)</code></p>
<p>一个简单的断言表达式：</p>
<p>var s = x.(T)</p>
<p>如果 x 不是 nil，且 x 可以转换成 T 类型，就会断言成功，返回 T 类型的变量 s。如果 T 不是接口类型，则要求 x 的类型就是 T（或者包含x），如果 T 是一个接口，要求 x 实现了 T 接口。</p>
<p>如果断言类型成立，则表达式返回值就是 T 类型的 x，如果断言失败就会触发 panic。</p>
<p>上述表所示再断言失败就会 panic，go 提供了另外一种带返回是否成立的断言语法：</p>
<p>s, ok := x.(T)</p>
<p>该方法和第一种差不多一样，但是 ok 会返回是否断言成功不会出现 panic，ok 就表示是否是成功了。</p>
<h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3. 删除"></a>3. 删除</h3><p>这里的删除，实际上是缓存淘汰。即移除最近最少访问的节点（队首）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RemoveOldest removes the oldest item</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> RemoveOldest() &#123;<br>	ele := c.ll.Back()<br>	<span class="hljs-keyword">if</span> ele != <span class="hljs-literal">nil</span> &#123;<br>		c.ll.Remove(ele)<br>		kv := ele.Value.(*entry)<br>		<span class="hljs-built_in">delete</span>(c.cache, kv.key)<br>		c.nbytes -= <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(kv.key)) + <span class="hljs-type">int64</span>(kv.value.Len())<br>		<span class="hljs-keyword">if</span> c.OnEvicted != <span class="hljs-literal">nil</span> &#123;<br>			c.OnEvicted(kv.key, kv.value)<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>c.ll.Back()</code> 取到队首节点，从链表中删除。</li>
<li><code>delete(c.cache, kv.key)</code>，从字典中 <code>c.cache</code> 删除该节点的映射关系。</li>
<li>更新当前所用的内存 <code>c.nbytes</code>。</li>
<li>如果回调函数 <code>OnEvicted</code> 不为 nil，则调用回调函数。</li>
</ul>
<h3 id="4-新增-修改"><a href="#4-新增-修改" class="headerlink" title="4. 新增/修改"></a>4. 新增/修改</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Add adds a value to the cache.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Add(key <span class="hljs-type">string</span>, value Value) &#123;<br>	<span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;<br>		c.ll.MoveToFront(ele)<br>		kv := ele.Value.(*entry)<br>		c.nbytes += <span class="hljs-type">int64</span>(value.Len()) - <span class="hljs-type">int64</span>(kv.value.Len())<br>		kv.value = value<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)<br>		c.cache[key] = ele<br>		c.nbytes += <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(key)) + <span class="hljs-type">int64</span>(value.Len())<br>	&#125;<br>	<span class="hljs-keyword">for</span> c.maxBytes != <span class="hljs-number">0</span> &amp;&amp; c.maxBytes &lt; c.nbytes &#123;<br>		c.RemoveOldest()<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>如果键存在，则更新对应节点的值，并将该节点移到队尾。</li>
<li>不存在则是新增场景，首先队尾添加新节点 <code>&amp;entry&#123;key, value&#125;</code>, 并字典中添加 key 和节点的映射关系。</li>
<li>更新 <code>c.nbytes</code>，如果超过了设定的最大值 <code>c.maxBytes</code>，则移除最少访问的节点。</li>
</ul>
<p>最后，为了方便测试，我们实现 <code>Len()</code> 用来获取添加了多少条数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Len the number of cache entries</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">return</span> c.ll.Len()<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Day-2-单机并发缓存"><a href="#Day-2-单机并发缓存" class="headerlink" title="Day 2 单机并发缓存"></a>Day 2 单机并发缓存</h2><h3 id="1-支持并发读写"><a href="#1-支持并发读写" class="headerlink" title="1. 支持并发读写"></a>1. 支持并发读写</h3><p>接下来我们使用 <code>sync.Mutex</code> 封装 LRU 的几个方法，使之支持并发的读写。在这之前，我们抽象了一个只读数据结构 <code>ByteView</code> 用来表示缓存值，是 GeeCache 主要的数据结构之一。</p>
<ul>
<li>ByteView 只有一个数据成员，<code>b []byte</code>，b 将会存储真实的缓存值。选择 byte 类型是为了能够支持任意的数据类型的存储，例如字符串、图片等。</li>
<li>实现 <code>Len() int</code> 方法，我们在 lru.Cache 的实现中，要求被缓存对象必须实现 Value 接口，即 <code>Len() int</code> 方法，返回其所占的内存大小。</li>
<li><code>b</code> 是只读的，使用 <code>ByteSlice()</code> 方法返回一个拷贝，防止缓存值被外部程序修改。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cache <span class="hljs-keyword">struct</span> &#123;<br>	mu         sync.Mutex<br>	lru        *lru.Cache<br>	cacheBytes <span class="hljs-type">int64</span> <span class="hljs-comment">// cache的内容长度</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>主体结构Group</strong></p>
<p>Group 是 GeeCache 最核心的数据结构，负责与用户的交互，并且控制缓存值存储和获取的流程。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">                            <span class="hljs-comment">是</span><br><span class="hljs-comment">接收 key</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-comment">检查是否被缓存</span> <span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">返回缓存值 ⑴</span><br>                <span class="hljs-comment">|  否                         是</span><br>                <span class="hljs-comment">|</span><span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">是否应当从远程节点获取</span> <span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">与远程节点交互</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-comment">返回缓存值 ⑵</span><br>                            <span class="hljs-comment">|  否</span><br>                            <span class="hljs-comment">|</span><span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">调用`回调函数`，获取值并添加到缓存</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-comment">返回缓存值 ⑶</span><br></code></pre></td></tr></table></figure>
<p>我们将在 <code>geecache.go</code> 中实现主体结构 Group，那么 GeeCache 的代码结构的雏形已经形成了。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">geecache/<br>    |<span class="hljs-params">--lru/</span><br>        |<span class="hljs-params">--lru</span>.go  <span class="hljs-string">//</span> lru 缓存淘汰策略<br>    |<span class="hljs-params">--byteview</span>.go <span class="hljs-string">//</span> 缓存值的抽象与封装<br>    |<span class="hljs-params">--cache</span>.go    <span class="hljs-string">//</span> 并发控制<br>    |<span class="hljs-params">--geecache</span>.go <span class="hljs-string">//</span> 负责与外部交互，控制缓存存储和获取的主流程<br></code></pre></td></tr></table></figure>
<p>接下来我们将实现流程 ⑴ 和 ⑶，远程交互的部分后续再实现。</p>
<p>我们思考一下，如果缓存不存在，应从数据源（文件，数据库等）获取数据并添加到缓存中。GeeCache 是否应该支持多种数据源的配置呢？不应该，一是数据源的种类太多，没办法一一实现；二是扩展性不好。如何从源头获取数据，应该是用户决定的事情，我们就把这件事交给用户好了。因此，我们设计了一个回调函数(callback)，在缓存不存在时，调用这个函数，得到源数据。</p>
<p>GetGroup()</p>
<ul>
<li>一个 Group 可以认为是一个缓存的命名空间，每个 Group 拥有一个唯一的名称 <code>name</code>。比如可以创建三个 Group，缓存学生的成绩命名为 scores，缓存学生信息的命名为 info，缓存学生课程的命名为 courses。</li>
<li>第二个属性是 <code>getter Getter</code>，即缓存未命中时获取源数据的回调(callback)。</li>
<li>第三个属性是 <code>mainCache cache</code>，即一开始实现的并发缓存。</li>
<li>构建函数 <code>NewGroup</code> 用来实例化 Group，并且将 group 存储在全局变量 <code>groups</code> 中。</li>
<li><code>GetGroup</code> 用来特定名称的 Group，这里使用了只读锁 <code>RLock()</code>，因为不涉及任何冲突变量的写操作。</li>
</ul>
<h2 id="Day-3-HTTP-服务端"><a href="#Day-3-HTTP-服务端" class="headerlink" title="Day 3 HTTP 服务端"></a>Day 3 HTTP 服务端</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">url := <span class="hljs-string">&quot;/_geecache/scores/Tom&quot;</span><br>basePath := <span class="hljs-string">&quot;/_geecache/&quot;</span><br>fmt.Println(url[<span class="hljs-built_in">len</span>(basePath):])<br>parts := strings.SplitN(url[<span class="hljs-built_in">len</span>(basePath):],<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">2</span>)<br>fmt.Println(strings.SplitN(url[<span class="hljs-built_in">len</span>(basePath):],<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">2</span>))<br>fmt.Printf(<span class="hljs-string">&quot;parts[0]: %s\n&quot;</span>, parts[<span class="hljs-number">0</span>])<br>fmt.Printf(<span class="hljs-string">&quot;parts[1]: %s\n&quot;</span>, parts[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>
<p>注意这里的切片basePath是有两个/，所以后面不用+1</p>
<h2 id="Day-4-一致性Hash"><a href="#Day-4-一致性Hash" class="headerlink" title="Day 4 一致性Hash"></a>Day 4 一致性Hash</h2><h3 id="1-为什么使用一致性Hash"><a href="#1-为什么使用一致性Hash" class="headerlink" title="1.为什么使用一致性Hash"></a>1.为什么使用一致性Hash</h3><h4 id="1-1-我该访问谁？"><a href="#1-1-我该访问谁？" class="headerlink" title="1.1 我该访问谁？"></a>1.1 我该访问谁？</h4><p>对于分布式缓存来说，当一个节点接收到请求，如果该节点并没有存储缓存值，那么它面临的难题是，从谁那获取数据？自己，还是节点1, 2, 3, 4… 。假设包括自己在内一共有 10 个节点，当一个节点接收到请求时，随机选择一个节点，由该节点从数据源获取数据。</p>
<p>假设第一次随机选取了节点 1 ，节点 1 从数据源获取到数据的同时缓存该数据；那第二次，只有 1/10 的可能性再次选择节点 1, 有 9/10 的概率选择了其他节点，如果选择了其他节点，就意味着需要再一次从数据源获取数据，一般来说，这个操作是很耗时的。这样做，一是缓存效率低，二是各个节点上存储着相同的数据，浪费了大量的存储空间。</p>
<p>那有什么办法，对于给定的 key，每一次都选择同一个节点呢？使用 hash 算法也能够做到这一点。那把 key 的每一个字符的 ASCII 码加起来，再除以 10 取余数可以吗？当然可以，这可以认为是自定义的 hash 算法。</p>
<p><img src="https://geektutu.com/post/geecache-day4/hash_select.jpg" srcset="/img/loading.gif" lazyload alt="hash select peer"></p>
<p>从上面的图可以看到，任意一个节点任意时刻请求查找键 <code>Tom</code> 对应的值，都会分配给节点 2，有效地解决了上述的问题。</p>
<h5 id="1-2-节点数量变化了怎么办？"><a href="#1-2-节点数量变化了怎么办？" class="headerlink" title="1.2 节点数量变化了怎么办？"></a>1.2 节点数量变化了怎么办？</h5><p>简单求取 Hash 值解决了缓存性能的问题，但是没有考虑节点数量变化的场景。假设，移除了其中一台节点，只剩下 9 个，那么之前 <code>hash(key) % 10</code> 变成了 <code>hash(key) % 9</code>，也就意味着几乎缓存值对应的节点都发生了改变。即几乎所有的缓存值都失效了。节点在接收到对应的请求时，均需要重新去数据源获取数据，容易引起 <code>缓存雪崩</code>。</p>
<blockquote>
<p>缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。常因为缓存服务器宕机，或缓存设置了相同的过期时间引起。</p>
</blockquote>
<p>那如何解决这个问题呢？一致性哈希算法可以。</p>
<p>一致性哈希算法将 key 映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ChecksumIEEE</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">uint32</span><br></code></pre></td></tr></table></figure>
<p> ChecksumIEEE 使用 IEEE 多项式返回数据的 CRC-32 校验和。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">uint32</span> <span class="hljs-type">uint32</span><br></code></pre></td></tr></table></figure>
<p>uint32 is the set of all unsigned 32-bit integers. Range: 0 through 4294967295</p>
<h3 id="Go标准库是如何实现二分查找的？"><a href="#Go标准库是如何实现二分查找的？" class="headerlink" title="Go标准库是如何实现二分查找的？"></a>Go标准库是如何实现二分查找的？</h3><p>我们先看一下标准库中的代码实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span><span class="hljs-params">(n <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// Define f(-1) == false and f(n) == true.</span><br>    <span class="hljs-comment">// Invariant: f(i-1) == false, f(j) == true.</span><br>    i, j := <span class="hljs-number">0</span>, n<br>    <span class="hljs-keyword">for</span> i &lt; j &#123;<br>        h := <span class="hljs-type">int</span>(<span class="hljs-type">uint</span>(i+j) &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// avoid overflow when computing h</span><br>        <span class="hljs-comment">// i ≤ h &lt; j</span><br>        <span class="hljs-keyword">if</span> !f(h) &#123;<br>            i = h + <span class="hljs-number">1</span> <span class="hljs-comment">// preserves f(i-1) == false</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = h <span class="hljs-comment">// preserves f(j) == true 因为是开区间所以，j = h</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.</span><br>    <span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure>
<p>🌟这个函数返回的是我们要找的index距离他最小的坐标（0开始）</p>
<p>初一看，与我们上面的实现一点也不同呢，我们来分析一下。</p>
<p>入参<code>n</code>就是代表要查找序列的长度，入参<code>f</code>就是我们自定义的条件。这段代码很短，大概思路就是：</p>
<ul>
<li>定义好这段序列的开始、结尾的位置</li>
<li>使用位移操作获取中位数，这样能更好的避免溢出</li>
<li>然后根据我们传入的条件判断是否符合条件，逐渐缩小范围</li>
</ul>
<p>这段代码与我实现的不同在于，它并不是在用户传入的比较函数<code>f</code>返回<code>true</code>就结束查找，而是继续在当前<code>[i, j)</code>区间的前半段查找，并且，当<code>f</code>为<code>false</code>时，也不比较当前元素与要查找的元素的大小关系，而是直接在后半段查找。所以<code>for</code>循环退出的唯一条件就是<code>i&gt;=j</code>，如果我们这样使用，就会出现问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nums := []<span class="hljs-type">int64</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br>    fmt.Println(sort.Search(<span class="hljs-built_in">len</span>(nums), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> nums[i] == <span class="hljs-number">1</span><br>    &#125;))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果竟然是<code>7</code>，而不是<code>1</code>，如果我们把条件改成<code>return nums[i] &gt;=1</code>，运行结果就对了。这是因为我们传入的条件并不是让用户确认目标条件，这里的思想是让我们逐步缩小范围，通过这个条件，我们每次都可以缩小范围，说的有点饶，就上面的代码举个例子。现在是一个升序数组，我们要找的数值是<code>1</code>，我们传入的条件是<code>return nums[i]&gt;=1</code>，第一进入函数<code>Search</code>，我们获取中的中位数<code>h</code>是<code>3</code>，当前元素是大于目标数值的，所以我们只能在前半段查找，就是这样不断缩小范围，找到我们最终的那个数值，如果当前序列中没有我们要找的目标数值，那么就会返回我们可以插入的位置，也就是最后一位元素的坐标+1的位置。</p>
<p>这个逻辑说实话，我也是第一次接触，仔细思考了一下，这种实现还是有一些优点的：</p>
<ul>
<li>使用<strong>移位操作</strong>，避免因为<code>i+j</code>太大而造成的溢出</li>
<li>如果我们查找序列中有多个元素相等时，且我们要找的元素就是这个时，我们总会找到下标最小的那个元素</li>
<li>如果我们没找到要找的目标元素时，返回的下标是我们可插入的位置，我们在进行数据插入时，依然可以保证数据的有序</li>
</ul>
<p>🌟<strong>注意：使用<code>sort.Search</code>时，入参条件是根据要查找的序列是升序序列还是降序序列来决定的，如果是升序序列，则传入的条件应该是<code>&gt;=目标元素值</code>，如果是降序序列，则传入的条件应该是<code>&lt;=目标元素值</code></strong></p>
<p>解析<code>int(uint(i+j) &gt;&gt; 1)</code>这段代码</p>
<p>这里我想单独解析一下这段代码，因为很少见，所以可以当作一个知识点记一下。这里使用到的是移位操作，通过向右移动一位，正好可以得到<code>/2</code>的结果。具体什么原因呢，我画了一个图，手工画的，看完你就懂了：</p>
<p><img src="https://segmentfault.com/img/remote/1460000040178986" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>懂了吧，兄弟们！移位实现要比乘除发的效率高很多，我们在平常开发中可以使用这种方式来提升效率。</p>
<p>这里还有一个点就是使用<code>uint</code>数据类型，因为<code>uint</code>的数据范围是<code>2^32</code>即<code>0</code>到<code>4294967295</code>。使用<code>uint</code>可以避免因为<code>i+j</code>太大而造成的溢出。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>范例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>A &amp; B</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>按位或</td>
<td>A \</td>
<td>B</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>A ^ B</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移运算符</td>
<td>A &lt;&lt; 2</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移运算符</td>
<td>A &gt;&gt; 2</td>
</tr>
</tbody>
</table>
</div>
<p><strong>说明</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>功能</th>
<th>运算规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>按位与</td>
<td>双目运算符</td>
<td>参与运算的两数各对应的二进制位相与</td>
<td>如果两数对应的二进制位都为 1，那么结果为 1， 否则结果为 0。</td>
</tr>
<tr>
<td>按位或</td>
<td>双目运算符</td>
<td>参与运算的两数各对应的二进制位相或</td>
<td>如果两数对应的二进制位有一个为 1，那么结果为 1， 否则结果为 0。</td>
</tr>
<tr>
<td>按位异或</td>
<td>双目运算符</td>
<td>参与运算的两数各对应的二进制位相异或</td>
<td>如果两数对应的二进制位不同，那么结果为 1， 否则结果为 0。</td>
</tr>
<tr>
<td>左移</td>
<td>双目运算符</td>
<td>把运算符 <code>&lt;&lt;</code> 左边的运算数的各二进制位全部左移若干位，高位丢弃，低位补 0。</td>
<td>左移 N 位，就是乘以 2 的 N 次方。</td>
</tr>
<tr>
<td>右移</td>
<td>双目运算符</td>
<td>把运算符 <code>&lt;&lt;</code> 左边的运算数的各二进制位全部右移若干位。</td>
<td>右移 N 位，就是除以 2 的 N 次方。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get gets the closest item in the hash to the provided key.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Get(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(m.keys) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>	&#125;<br><br>	hash := <span class="hljs-type">int</span>(m.hash([]<span class="hljs-type">byte</span>(key)))<br>	<span class="hljs-comment">// Binary search for appropriate replica.</span><br>	idx := sort.Search(<span class="hljs-built_in">len</span>(m.keys), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>		<span class="hljs-keyword">return</span> m.keys[i] &gt;= hash<br>	&#125;)<br><br>	<span class="hljs-keyword">return</span> m.hashMap[m.keys[idx%<span class="hljs-built_in">len</span>(m.keys)]]<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>选择节点就非常简单了，第一步，计算 key 的哈希值。</li>
<li>第二步，顺时针找到第一个匹配的虚拟节点的下标 <code>idx</code>，从 m.keys 中获取到对应的哈希值。如果 <code>idx == len(m.keys)</code>，说明应选择 <code>m.keys[0]</code>，因为 <code>m.keys</code> 是一个环状结构，所以用取余数的方式来处理这种情况。</li>
<li>第三步，通过 <code>hashMap</code> 映射得到真实的节点。</li>
</ul>
<p>至此，整个一致性哈希算法就实现完成了。</p>
<p>🌟流程是先有hash的key，通过key我们再进行查找对应的节点的hash，通过hash作为hashMap的key找到hashMap里面的存值（真实节点）这就是<code>return m.hashMap[m.keys[idx%len(m.keys)]]</code>的意义。</p>
<p>idx%len(m.keys)是成环形的关键，保证如果超过目前设立的所有节点（虚 + 实）就默认找一圈找到下标0的位置。</p>
<p>keys数组存的是下标连续的hash值，所以必定通过go的二分查找能找到一个已存在的节点，如果比已存在的A节点小的话就插在A的位置（下标相同）</p>
<h2 id="Day-5-分布式节点"><a href="#Day-5-分布式节点" class="headerlink" title="Day 5 分布式节点"></a>Day 5 分布式节点</h2><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">使用一致性哈希选择节点        是                                    是</span><br>    <span class="hljs-comment">|</span><span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">是否是远程节点</span> <span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">HTTP 客户端访问远程节点</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-comment">成功？</span><span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">服务端返回返回值</span><br>                    <span class="hljs-comment">|  否                                    ↓  否</span><br>                    <span class="hljs-comment">|</span><span class="hljs-literal">----------------------------</span>&gt; <span class="hljs-comment">回退到本地节点处理。</span><br></code></pre></td></tr></table></figure>
<p>默认格式<code>%v</code>下，对于不同的数据类型，底层会去调用默认的格式化方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">bool</span>:                    %t <br><span class="hljs-type">int</span>, <span class="hljs-type">int8</span> etc.:          %d <br><span class="hljs-type">uint</span>, <span class="hljs-type">uint8</span> etc.:        %d, %x <span class="hljs-keyword">if</span> printed with %#v<br><span class="hljs-type">float32</span>, <span class="hljs-type">complex64</span>, etc: %g<br><span class="hljs-type">string</span>:                  %s<br><span class="hljs-keyword">chan</span>:                    %p <br>pointer:                 %p<br></code></pre></td></tr></table></figure>
<h3 id="func-QueryEscape"><a href="#func-QueryEscape" class="headerlink" title="func QueryEscape"></a>func QueryEscape</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QueryEscape</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure>
<p>QueryEscape函数对s进行转码使之可以安全的用在URL查询里。</p>
<h3 id="func-QueryUnescape"><a href="#func-QueryUnescape" class="headerlink" title="func QueryUnescape"></a>func QueryUnescape</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QueryUnescape</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure>
<p>QueryUnescape函数用于将QueryEscape转码的字符串还原。它会把%AB改为字节0xAB，将’+’改为’ ‘。如果有某个%后面未跟两个十六进制数字，本函数会返回错误。</p>
<p>http.Get()就是发送一个get请求</p>
<p>当Point.Distance被第一个包装方法调用时，它的接收器值是p.Point，而不是p，当然了，在Point类的方法里，你是访问不到ColoredPoint的任何字段的。</p>
<p>在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中(译注：访问需要通过该指针指向的对象去取)。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。下面这个ColoredPoint的声明内嵌了一个*Point的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> car <span class="hljs-keyword">struct</span> &#123;<br>	e     engine<br>	price <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> engine <span class="hljs-keyword">struct</span> &#123;<br>	name <span class="hljs-type">string</span><br>	size <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e engine)</span></span> start() &#123;<br>	fmt.Println(<span class="hljs-string">&quot;engine start...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ChangeName</span><span class="hljs-params">(e engine, newName <span class="hljs-type">string</span>)</span></span> &#123;<br>	e.name = newName<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	car := &amp;car&#123;<br>		e: engine&#123;<br>			name: <span class="hljs-string">&quot;HONDA&quot;</span>,<br>			size: <span class="hljs-number">200</span>,<br>		&#125;,<br>		price: <span class="hljs-number">9999</span>,<br>	&#125;<br>	car.e.start()<br>	ChangeName(car.e, <span class="hljs-string">&quot;KTM&quot;</span>)<br>	fmt.Println(car.e.name)<br>&#125;<br><br>engine start...<br>HONDA<br></code></pre></td></tr></table></figure>
<p>这时如果结构体作为形参传入函数中，当时不是按照地址传递而是值传递是无法修改的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> car <span class="hljs-keyword">struct</span> &#123;<br>	e     *engine<br>	price <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> engine <span class="hljs-keyword">struct</span> &#123;<br>	name <span class="hljs-type">string</span><br>	size <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e engine)</span></span> start() &#123;<br>	fmt.Println(<span class="hljs-string">&quot;engine start...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ChangeName</span><span class="hljs-params">(e *engine, newName <span class="hljs-type">string</span>)</span></span> &#123;<br>	e.name = newName<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	car := &amp;car&#123;<br>		e: &amp;engine&#123;<br>			name: <span class="hljs-string">&quot;HONDA&quot;</span>,<br>			size: <span class="hljs-number">200</span>,<br>		&#125;,<br>		price: <span class="hljs-number">9999</span>,<br>	&#125;<br>	car.e.start()<br>	ChangeName(car.e, <span class="hljs-string">&quot;KTM&quot;</span>)<br>	fmt.Println(car.e.name)<br>&#125;<br><br>engine start...<br>KTM<br></code></pre></td></tr></table></figure>
<p>这时是地址传递才能改变内部的值</p>
<ul>
<li><code>Set()</code> 方法实例化了一致性哈希算法，并且添加了传入的节点。</li>
<li>并为每一个节点创建了一个 HTTP 客户端 <code>httpGetter</code>。</li>
<li><code>PickerPeer()</code> 包装了一致性哈希算法的 <code>Get()</code> 方法，根据具体的 key，选择节点，返回节点对应的 HTTP 客户端。</li>
</ul>
<p>至此，HTTPPool 既具备了提供 HTTP 服务的能力，也具备了根据具体的 key，创建 HTTP 客户端从远程节点获取缓存值的能力。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>    <span class="hljs-comment">// 第一个参数是命令行key，第二个参数是默认是，第三个参数是 .exe -h 提示 </span><br>    <span class="hljs-keyword">var</span> user = flag.String(<span class="hljs-string">&quot;user&quot;</span>， <span class="hljs-string">&quot;root&quot;</span>， <span class="hljs-string">&quot;用户名&quot;</span>) <br>    <span class="hljs-keyword">var</span> port = flag.Int(<span class="hljs-string">&quot;port&quot;</span>， <span class="hljs-number">3306</span>， <span class="hljs-string">&quot;端口&quot;</span>) <br>    <span class="hljs-keyword">var</span> ip = flag.String(<span class="hljs-string">&quot;ip&quot;</span>， <span class="hljs-string">&quot;localhost&quot;</span>， <span class="hljs-string">&quot;mysql ip&quot;</span>) <br> <br>    <span class="hljs-comment">//必须使用flag.Parse()解析一下命令行参数 </span><br>    flag.Parse() <br>    <span class="hljs-comment">//flag.Type返回的是一个指针，必须通过 *变量取值 </span><br>    fmt.Println(*user，*port，*ip) <br>&#125; <br></code></pre></td></tr></table></figure>
<p><strong>使用情境</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">trap</span> <span class="hljs-string">&#x27;rm -f &quot;/var/tmp/CJK.text&quot;&#x27;</span> EXIT<br><span class="hljs-comment">#當腳本遇上 EXIT 就會執行 rm -f &quot;/var/tmp/CJK.txt&quot;。</span><br></code></pre></td></tr></table></figure>
<p>常用於退出腳本時清理檔案，或是執行錯誤時退出腳本。</p>
<p>如果當退出要執行多行指令可以使用呼叫函式的方式，使用舉例如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">Exit_safely</span></span> ()&#123;<br>  command1<br>  command2<br>  command3<br>&#125;<br><span class="hljs-built_in">trap</span> Exit_safely EXIT<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;rm server;kill 0&quot;</span> EXIT<br><br>go build -o server<br>./server -port=8001 &amp;<br>./server -port=8002 &amp;<br>./server -port=8003 -api=1 &amp;<br><br><span class="hljs-built_in">sleep</span> 2<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt; start test&quot;</span><br>curl <span class="hljs-string">&quot;http://localhost:9999/api?key=Tom&quot;</span><br>curl <span class="hljs-string">&quot;http://localhost:9999/api?key=Tom&quot;</span><br>curl <span class="hljs-string">&quot;http://localhost:9999/api?key=Tom&quot;</span><br><br><span class="hljs-built_in">wait</span><br></code></pre></td></tr></table></figure>
<p>wait(参数)  使用 wait 是在等待上一批或上一个脚本执行完（即上一个的进程终止），再执行wait之后的命令。</p>
<h2 id="Day-6-防止缓存击穿"><a href="#Day-6-防止缓存击穿" class="headerlink" title="Day 6 防止缓存击穿"></a>Day 6 防止缓存击穿</h2><blockquote>
<p><strong>缓存雪崩</strong>：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。</p>
<p><strong>缓存击穿</strong>：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。</p>
<p><strong>缓存穿透</strong>：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。</p>
</blockquote>
<h2 id="Day-7-使用-Protobuf-通信"><a href="#Day-7-使用-Protobuf-通信" class="headerlink" title="Day 7 使用 Protobuf 通信"></a>Day 7 使用 Protobuf 通信</h2><p>protobuf 广泛地应用于远程过程调用(RPC) 的二进制传输，使用 protobuf 的目的非常简单，为了获得更高的性能。传输前使用 protobuf 编码，接收方再进行解码，可以显著地降低二进制传输的大小。另外一方面，protobuf 可非常适合传输结构化数据，便于通信字段的扩展。</p>
<p>使用 protobuf 一般分为以下 2 步：</p>
<ul>
<li>按照 protobuf 的语法，在 <code>.proto</code> 文件中定义数据结构，并使用 <code>protoc</code> 生成 Go 代码（<code>.proto</code>文件是跨平台的，还可以生成 C、Java 等其他源码文件）。</li>
<li>在项目代码中引用生成的 Go 代码。</li>
</ul>
<p><code>option go_package = &quot;./&quot;; // 指定生成的go文件所在path</code></p>
<h1 id="ORM框架-GeeORM"><a href="#ORM框架-GeeORM" class="headerlink" title="ORM框架 - GeeORM"></a>ORM框架 - GeeORM</h1><h2 id="Day-0-序言"><a href="#Day-0-序言" class="headerlink" title="Day 0 序言"></a>Day 0 序言</h2><p>go的反射</p>
<ul>
<li><code>reflect.ValueOf()</code> 获取指针对应的反射值。</li>
<li><code>reflect.Indirect()</code> 获取指针指向的对象的反射值。</li>
<li><code>(reflect.Type).Name()</code> 返回类名(字符串)。</li>
<li><code>(reflect.Type).Field(i)</code> 获取第 i 个成员变量。</li>
</ul>
<p>并发协程之间不需要消息传递，非常适合 <code>sync.WaitGroup</code>。</p>
<ul>
<li>wg.Add(1) 锁加1。</li>
<li>wg.Wait() 阻塞，直到锁被释放。</li>
<li>wg.Done() 锁减1。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Backend-development/">Backend development</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/TCP-UDP/">TCP, UDP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/23/simple-distributed/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">simple distributed</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/18/golang%E5%8E%9F%E7%90%86/">
                        <span class="hidden-mobile">golang原理</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> & <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
