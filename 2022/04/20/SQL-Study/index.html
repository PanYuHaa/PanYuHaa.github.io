

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon1.png">
  <link rel="icon" href="/img/favicon1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Peter Pan">
  <meta name="keywords" content="">
  
    <meta name="description" content="基本书写规范对于 SQL 初学者，在写 SQL 语句时，只要遵守下面几个书写规则，就可以避免很多错误。这些规则都非常简单，下面我们来逐一介绍。 SQL 语句要以分号;结尾 在 RDBMS （关系型数据库）当中，SQL 语句是逐条执行的，一条 SQL 语句代表着数据库的一个操作。 我们通常在句子的句尾加注标点表示这句话结束，中文句子以句号。结尾，英文以点号.结尾，而 SQL 语句则使用英文分号;结尾">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL Study">
<meta property="og:url" content="http://example.com/2022/04/20/SQL-Study/index.html">
<meta property="og:site_name" content="PPStudy">
<meta property="og:description" content="基本书写规范对于 SQL 初学者，在写 SQL 语句时，只要遵守下面几个书写规则，就可以避免很多错误。这些规则都非常简单，下面我们来逐一介绍。 SQL 语句要以分号;结尾 在 RDBMS （关系型数据库）当中，SQL 语句是逐条执行的，一条 SQL 语句代表着数据库的一个操作。 我们通常在句子的句尾加注标点表示这句话结束，中文句子以句号。结尾，英文以点号.结尾，而 SQL 语句则使用英文分号;结尾">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/dbStudy.png">
<meta property="article:published_time" content="2022-04-20T11:43:33.000Z">
<meta property="article:modified_time" content="2022-06-27T01:29:51.147Z">
<meta property="article:author" content="Peter Pan">
<meta property="article:tag" content="data base">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/dbStudy.png">
  
  
  <title>SQL Study - PPStudy</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="SQL Study">
              
                SQL Study
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-20 19:43" pubdate>
        April 20, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      112 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">SQL Study</h1>
            
            <div class="markdown-body">
              <h1 id="基本书写规范"><a href="#基本书写规范" class="headerlink" title="基本书写规范"></a>基本书写规范</h1><p>对于 SQL 初学者，在写 SQL 语句时，只要遵守下面几个书写规则，就可以避免很多错误。这些规则都非常简单，下面我们来逐一介绍。</p>
<p><strong>SQL 语句要以分号<code>;</code>结尾</strong></p>
<p>在 RDBMS （关系型数据库）当中，SQL 语句是逐条执行的，一条 SQL 语句代表着数据库的一个操作。</p>
<p>我们通常在句子的句尾加注标点表示这句话结束，中文句子以句号<code>。</code>结尾，英文以点号<code>.</code>结尾，而 SQL 语句则使用英文分号<code>;</code>结尾。</p>
<p><strong>SQL 语句不区分大小写</strong></p>
<p>SQL 不区分关键字的大小写。例如，不管写成 SELECT 还是 select，解释都是一样的。表名和列名也是如此。（但是注意字符串是要分大小写的）</p>
<p>提示：关键字是数据库事先定义的，有特别意义的单词。</p>
<p>虽然可以根据个人喜好选择大写还是小写（或大小写混杂），但为了理解起来更加容易，本教程使用以下规则来书写 SQL 语句。</p>
<ul>
<li>关键字大写</li>
<li>数据库名、表名和列名等小写</li>
</ul>
<p>需要注意的是，插入到表中的数据是区分大小写的。例如，向数据库中插入单词 Computer、COMPUTER 或 computer，这三个是不一样的数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/dbStudy.png" srcset="/img/loading.gif" lazyload alt="dbStudy"></p>
<p>自学网网址：<a target="_blank" rel="noopener" href="http://www.xuesql.cn/">http://www.xuesql.cn/</a></p>
<h1 id="一-SQL的SELECT使用"><a href="#一-SQL的SELECT使用" class="headerlink" title="一. SQL的SELECT使用"></a>一. SQL的SELECT使用</h1><h2 id="1-1-条件查询语法"><a href="#1-1-条件查询语法" class="headerlink" title="1.1 条件查询语法"></a>1.1 条件查询语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql"># 条件查询语法<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition<br>    AND/OR another_condition<br>    AND/OR …;<br></code></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>Operator（操作符）</th>
<th>Condition（解释）</th>
<th>Example（例子）</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>Case sensitive exact string comparison (<em>notice the single equals</em>)完全等于</td>
<td>col_name = “abc”</td>
</tr>
<tr>
<td>!= or &lt;&gt;</td>
<td>Case sensitive exact string inequality comparison 不等于</td>
<td>col_name != “abcd”</td>
</tr>
<tr>
<td>LIKE</td>
<td>Case insensitive exact string comparison 没有用通配符等价于 =</td>
<td>col_name LIKE “ABC”</td>
</tr>
<tr>
<td>NOT LIKE</td>
<td>Case insensitive exact string inequality comparison 没有用通配符等价于 !=</td>
<td>col_name NOT LIKE”ABCD”</td>
</tr>
<tr>
<td>%</td>
<td>Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) 通配符，代表匹配0个以上的字符</td>
<td>col_name LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”) “%AT%” 代表AT 前后可以有任意字符</td>
</tr>
<tr>
<td>_</td>
<td>Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) 和% 相似，代表1个字符</td>
<td>col_name LIKE “AN_” (matches “AND”, but not “AN”)</td>
</tr>
<tr>
<td>IN (…)</td>
<td>String exists in a list 在列表</td>
<td>col_name IN (“A”, “B”, “C”)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-2-DISTINCT语法"><a href="#1-2-DISTINCT语法" class="headerlink" title="1.2 DISTINCT语法"></a>1.2 DISTINCT语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 选取出唯一的结果的语法<br>SELECT DISTINCT column, another_column, …<br>FROM mytable<br>WHERE condition(s);<br></code></pre></td></tr></table></figure>
<p>因为 <code>DISTINCT</code> 语法会直接删除重复的行，我们还会学习 <code>GROUP BY</code> 语句， <code>GROUP BY</code> 也会返回唯一的行，不过可以对具有相同的 属性值的行做一些统计计算，比如：求和。</p>
<h2 id="1-3-结果排序-Ordering-results"><a href="#1-3-结果排序-Ordering-results" class="headerlink" title="1.3 结果排序(Ordering results)"></a>1.3 结果排序(Ordering results)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 结果排序（ordered results）<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition(s)<br>ORDER BY column ASC/DESC;<br></code></pre></td></tr></table></figure>
<p><code>ORDER BY col_name</code> 这句话的意思就是让结果按照 col_name 列的具体值做 ASC升序 或 DESC 降序，对数字来说就是升序 1，2，3，… 或降序 … 3,2,1。对于文本列，升序和降序指的是按文本的字母序。</p>
<h2 id="1-4-通过Limit选取部分结果"><a href="#1-4-通过Limit选取部分结果" class="headerlink" title="1.4 通过Limit选取部分结果"></a>1.4 通过Limit选取部分结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># limited查询<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition(s)<br>ORDER BY column ASC/DESC<br>LIMIT num_limit OFFSET num_offset;<br></code></pre></td></tr></table></figure>
<p><code>LIMIT</code> 和 <code>OFFSET</code> 子句通常和<code>ORDER BY</code> 语句一起使用，当我们对整个结果集排序之后，我们可以 <code>LIMIT</code>来指定只返回多少行结果 ,用 <code>OFFSET</code>来指定从哪一行开始返回。你可以想象一下从一条长绳子剪下一小段的过程，我们通过 <code>OFFSET</code> 指定从哪里开始剪，用 <code>LIMIT</code> 指定剪下多少长度。</p>
<p>PS：num_offset 是从0开始的</p>
<h2 id="1-5-数据库范式"><a href="#1-5-数据库范式" class="headerlink" title="1.5 数据库范式"></a>1.5 数据库范式</h2><p>数据库范式是数据表设计的规范，在范式规范下，数据库里每个表存储的<strong>重复数据降到最少（这有助于数据的一致性维护）</strong>，同时在数据库范式下，表和表之间不再有很强的数据耦合，可以独立的增长 (ie. 比如汽车引擎的增长和汽车的增长是完全独立的). 范式带来了很多好处，但随着数据表的分离，意味着我们要查询多个数据属性时，需要更复杂的SQL语句，也就是本节开始介绍的多表连接技术。这样SQL的性能也会面临更多的挑战，特别是当大数据量的表很多的情况下。</p>
<p>如果一个实体（比如Dog）的属性数据被分散到多个数据表中，我们就需要学习如何通过 <code>JOIN</code>连表技术来整合这些数据并找到我们想要查询的数据项。</p>
<h2 id="1-6-用JOINs进行多表联合查询"><a href="#1-6-用JOINs进行多表联合查询" class="headerlink" title="1.6 用JOINs进行多表联合查询"></a>1.6 用JOINs进行多表联合查询</h2><p><code>主键(primary key)</code>, 一般关系数据表中，都会有一个属性列设置为 <code>主键(primary key)</code>。主键是唯一标识一条数据的，不会重复复（想象你的身份证号码)。一个最常见的主键就是auto-incrementing integer(自增ID，每写入一行数据ID+1, 当然字符串，hash值等只要是每条数据是唯一的也可以设为主键.</p>
<p>借助<code>主键(primary key)</code>（当然其他唯一性的属性也可以），我们可以把两个表中具有相同 主键ID的数据连接起来（因为一个ID可以简要的识别一条数据，所以连接之后还是表达的同一条数据）（你可以想象一个左右连线游戏）。具体我们用到 <code>JOIN</code> 关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">用LEFT/RIGHT/FULL JOINs 做多表查询<br>SELECT column, another_column, …<br>FROM mytable<br>INNER/LEFT/RIGHT/FULL JOIN another_table<br>    ON mytable.id = another_table.matching_id<br>WHERE condition(s)<br>ORDER BY column, … ASC/DESC<br>LIMIT num_limit OFFSET num_offset;<br></code></pre></td></tr></table></figure>
<p>PS：<code>INNER JOIN</code> 可以简写做 <code>JOIN</code>. 两者是相同的意思，但我们还是会继续写作 <code>INNER JOIN</code> 以便和后面的 <code>LEFT JOIN</code>， <code>RIGHT JOIN</code>等相比较。(内连接，左连接，右连接)</p>
<p>LEFT JOIN：左边的全部存在，右边的有缺失就NULL</p>
<p>RIGHT JOIN：右边的全部存在，左边的有缺失就NULL</p>
<h2 id="1-7-查询条件中处理NULL"><a href="#1-7-查询条件中处理NULL" class="headerlink" title="1.7 查询条件中处理NULL"></a>1.7 查询条件中处理NULL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 在查询条件中处理 NULL<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE column IS/IS NOT NULL<br>AND/OR another_condition<br>AND/OR …;<br></code></pre></td></tr></table></figure>
<p>判断是否为NULL</p>
<h2 id="1-8-查询中使用表达式"><a href="#1-8-查询中使用表达式" class="headerlink" title="1.8 查询中使用表达式"></a>1.8 查询中使用表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 包含表达式的例子<br>SELECT  particle_speed / 2.0 AS half_particle_speed (对结果做了一个除2）<br>FROM physics_data<br>WHERE ABS(particle_position) * 10.0 &gt;500<br>            （条件要求这个属性绝对值乘以10大于500）;<br>         <br># AS使用别名<br>SELECT col_expression AS expr_description, …<br>FROM mytable;<br><br># 属性列和表取别名的例子<br>SELECT column AS better_column_name, …<br>FROM a_long_widgets_table_name AS mywidgets<br>INNER JOIN widget_sales<br>  ON mywidgets.id = widget_sales.widget_id;<br></code></pre></td></tr></table></figure>
<p><strong>e.g【难题】John Lasseter导演的每部电影每分钟值多少钱,告诉我最高的3个电影名和价值就可以</strong> </p>
<p>Table: Movies(Read - Only)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Id</th>
<th>Title</th>
<th>Director</th>
<th>Year</th>
<th>Length_minutes</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Toy Story</td>
<td>John Lasseter</td>
<td>1995</td>
<td>81</td>
</tr>
<tr>
<td>2</td>
<td>A Bug’s Life</td>
<td>John Lasseter</td>
<td>1998</td>
<td>95</td>
</tr>
<tr>
<td>3</td>
<td>Toy Story 2</td>
<td>John Lasseter</td>
<td>1999</td>
<td>93</td>
</tr>
<tr>
<td>4</td>
<td>Monsters, Inc.</td>
<td>Pete Docter</td>
<td>2001</td>
<td>92</td>
</tr>
<tr>
<td>5</td>
<td>Finding Nemo</td>
<td>Finding Nemo</td>
<td>2003</td>
<td>107</td>
</tr>
<tr>
<td>6</td>
<td>The Incredibles</td>
<td>Brad Bird</td>
<td>2004</td>
<td>116</td>
</tr>
<tr>
<td>7</td>
<td>Cars</td>
<td>John Lasseter</td>
<td>2006</td>
<td>117</td>
</tr>
<tr>
<td>8</td>
<td>Ratatouille</td>
<td>Brad Bird</td>
<td>2007</td>
<td>115</td>
</tr>
<tr>
<td>9</td>
<td>WALL-E</td>
<td>Andrew Stanton</td>
<td>2008</td>
<td>104</td>
</tr>
<tr>
<td>10</td>
<td>Up</td>
<td>Pete Docter</td>
<td>2009</td>
<td>101</td>
</tr>
<tr>
<td>11</td>
<td>Toy Story 3</td>
<td>Lee Unkrich</td>
<td>2010</td>
<td>103</td>
</tr>
<tr>
<td>12</td>
<td>Cars 2</td>
<td>John Lasseter</td>
<td>2011</td>
<td>120</td>
</tr>
<tr>
<td>13</td>
<td>Brave</td>
<td>Brenda Chapman</td>
<td>2012</td>
<td>102</td>
</tr>
<tr>
<td>14</td>
<td>Monsters University</td>
<td>Dan Scanlon</td>
<td>2013</td>
<td>110</td>
</tr>
</tbody>
</table>
</div>
<p>Table: Boxoffice(Read - Only)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Movie_id</th>
<th>Rating</th>
<th>Domestic_sales</th>
<th>International_sales</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>8.2</td>
<td>380843261</td>
<td>555900000</td>
</tr>
<tr>
<td>14</td>
<td>7.4</td>
<td>268492764</td>
<td>475066843</td>
</tr>
<tr>
<td>8</td>
<td>8</td>
<td>206445654</td>
<td>417277164</td>
</tr>
<tr>
<td>12</td>
<td>6.4</td>
<td>191452396</td>
<td>368400000</td>
</tr>
<tr>
<td>3</td>
<td>7.9</td>
<td>245852179</td>
<td>239163000</td>
</tr>
<tr>
<td>6</td>
<td>8</td>
<td>261441092</td>
<td>370001000</td>
</tr>
<tr>
<td>9</td>
<td>8.5</td>
<td>223808164</td>
<td>297503696</td>
</tr>
<tr>
<td>11</td>
<td>8.4</td>
<td>415004880</td>
<td>648167031</td>
</tr>
<tr>
<td>1</td>
<td>8.3</td>
<td>191796233</td>
<td>170162503</td>
</tr>
<tr>
<td>7</td>
<td>7.2</td>
<td>244082982</td>
<td>217900167</td>
</tr>
<tr>
<td>10</td>
<td>8.3</td>
<td>293004164</td>
<td>438338580</td>
</tr>
<tr>
<td>4</td>
<td>8.1</td>
<td>289916256</td>
<td>272900000</td>
</tr>
<tr>
<td>2</td>
<td>7.2</td>
<td>162798565</td>
<td>200600000</td>
</tr>
<tr>
<td>13</td>
<td>7.2</td>
<td>237283207</td>
<td>301700000</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 输出变量，AS用来起别名<br>SELECT title, ((domestic_sales + international_sales) / length_minutes) AS sale_value FROM movies AS m<br><br># 内连接两个表，ON通过什么属性<br>INNER JOIN boxoffice AS b<br>ON m.id = b.movie_id<br><br># WHERE逻辑控制判断<br>WHERE director = &quot;John Lasseter&quot;<br><br># ORDER BY排序<br>ORDER BY sale_value DESC<br><br># LIMIT限制，OFFSET表示起始位置<br>LIMIT 3 <br></code></pre></td></tr></table></figure>
<h2 id="1-9-常见的统计函数"><a href="#1-9-常见的统计函数" class="headerlink" title="1.9 常见的统计函数"></a>1.9 常见的统计函数</h2><p>下面介绍几个常用统计函数:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>COUNT(<em>*</em></strong>)<strong>, </strong>COUNT(<strong><em>column</em></strong>)**</td>
<td style="text-align:left">计数！COUNT(*) 统计数据行数，COUNT(column) 统计column非NULL的行数。</td>
</tr>
<tr>
<td><strong>MIN(*</strong>column<strong>*)</strong></td>
<td style="text-align:left">找column最小的一行。</td>
</tr>
<tr>
<td><strong>MAX(*</strong>column<strong>*)</strong></td>
<td style="text-align:left">找column最大的一行。</td>
</tr>
<tr>
<td><strong>AVG(*</strong>column*)</td>
<td style="text-align:left">对column所有行取平均值。</td>
</tr>
<tr>
<td><strong>SUM(*</strong>column<strong>*)</strong></td>
<td style="text-align:left">对column所有行求和。</td>
</tr>
</tbody>
</table>
</div>
<p>分组统计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 用分组的方式统计，通过分组的方式对局部特征进行处理<br>SELECT AGG_FUNC(column_or_expression) AS aggregate_description, …<br>FROM mytable<br>WHERE constraint_expression<br>GROUP BY column;<br></code></pre></td></tr></table></figure>
<p>到目前为止，我们的Query查询已经有点复杂了，不过还好我们已经基本把查询语法介绍完了。在 <code>GROUP BY</code> 分组语法中，我们知道数据库是先对数据做<code>WHERE</code>，然后对结果做分组，如果我们要对分组完的数据再筛选出几条如何办？ （想一下按年份统计电影票房，要筛选出&gt;100万的年份？） </p>
<p>一个不常用的语法 <code>HAVING</code> 语法将用来解决这个问题，他可以对分组之后的数据再做SELECT筛选.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 用HAVING进行筛选，进行GROUP BY之后的二级分类<br>SELECT group_by_column, AGG_FUNC(column_expression) AS aggregate_result_alias, …<br>FROM mytable<br>WHERE condition<br>GROUP BY column<br>HAVING group_condition;<br></code></pre></td></tr></table></figure>
<p><strong>e.g【难题】按角色分组算出每个角色按有办公室和没办公室的统计人数(列出角色，数量，有无办公室,注意一个角色如果部分有办公室，部分没有需分开统计）</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Role</th>
<th>Name</th>
<th>Building</th>
<th>Years_employed</th>
</tr>
</thead>
<tbody>
<tr>
<td>Engineer</td>
<td>Becky A.</td>
<td>1e</td>
<td>4</td>
</tr>
<tr>
<td>Engineer</td>
<td>Dan B.</td>
<td>1e</td>
<td>2</td>
</tr>
<tr>
<td>Engineer</td>
<td>Sharon F.</td>
<td>1e</td>
<td>6</td>
</tr>
<tr>
<td>Engineer</td>
<td>Dan M.</td>
<td>1e</td>
<td>4</td>
</tr>
<tr>
<td>Engineer</td>
<td>Malcom S.</td>
<td>1e</td>
<td>1</td>
</tr>
<tr>
<td>Artist</td>
<td>Tylar S.</td>
<td>2w</td>
<td>2</td>
</tr>
<tr>
<td>Artist</td>
<td>Sherman D.</td>
<td>2w</td>
<td>8</td>
</tr>
<tr>
<td>Artist</td>
<td>Jakob J.</td>
<td>2w</td>
<td>6</td>
</tr>
<tr>
<td>Artist</td>
<td>Lillia A.</td>
<td>2w</td>
<td>7</td>
</tr>
<tr>
<td>Artist</td>
<td>Brandon J.</td>
<td>2w</td>
<td>7</td>
</tr>
<tr>
<td>Manager</td>
<td>Scott K.</td>
<td>1e</td>
<td>9</td>
</tr>
<tr>
<td>Manager</td>
<td>Shirlee M.</td>
<td>1e</td>
<td>3</td>
</tr>
<tr>
<td>Manager</td>
<td>Daria O.</td>
<td>2w</td>
<td>6</td>
</tr>
<tr>
<td>Engineer</td>
<td>Yancy I.</td>
<td>null</td>
<td>0</td>
</tr>
<tr>
<td>Artist</td>
<td>Oliver P.</td>
<td>null</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT count(*) as count,Role,building is not null as have_building<br>FROM employees <br>group by Role,building is not null	<br></code></pre></td></tr></table></figure>
<p>这里学到了GROUP BY可以进行二级分类。</p>
<h2 id="1-10-总结"><a href="#1-10-总结" class="headerlink" title="1.10 总结"></a>1.10 总结</h2><p>集合所有的查询相关的语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 这才是完整的SELECT查询<br>SELECT DISTINCT column, AGG_FUNC(column_or_expression), …<br>FROM mytable<br>    JOIN another_table<br>      ON mytable.column = another_table.column<br>    WHERE constraint_expression<br>    GROUP BY column<br>    HAVING constraint_expression<br>    ORDER BY column ASC/DESC<br>    LIMIT count OFFSET COUNT;<br></code></pre></td></tr></table></figure>
<p>一个查询SQL的执行总是先从数据里按条件选出数据，然后对这些数据再次做一些整理处理，按要求返回成结果，让结果尽可能是简单直接的。因为一个查询SQL由很多部分组成，所以搞清楚这些部分的执行顺序还挺重要的，这有助于我们更深刻的理解SQL执行过程。</p>
<p><strong>‼️查询执行顺序</strong></p>
<h3 id="1-FROM-和-JOINs"><a href="#1-FROM-和-JOINs" class="headerlink" title="1. FROM 和 JOINs"></a>1. <code>FROM</code> 和 <code>JOIN</code>s</h3><p><code>FROM</code> 或 <code>JOIN</code>会第一个执行，确定一个整体的数据范围. 如果要JOIN不同表，可能会生成一个临时Table来用于 下面的过程。总之第一步可以简单理解为确定一个数据源表（含临时表)</p>
<h3 id="2-WHERE"><a href="#2-WHERE" class="headerlink" title="2. WHERE"></a>2. <code>WHERE</code></h3><p>我们确定了数据来源 <code>WHERE</code> 语句就将在这个数据源中按要求进行数据筛选，并丢弃不符合要求的数据行，所有的筛选col属性 只能来自<code>FROM</code>圈定的表. AS别名还不能在这个阶段使用，因为可能别名是一个还没执行的表达式</p>
<h3 id="3-GROUP-BY"><a href="#3-GROUP-BY" class="headerlink" title="3. GROUP BY"></a>3. <code>GROUP BY</code></h3><p>如果你用了 <code>GROUP BY</code> 分组，那<code>GROUP BY</code> 将对之前的数据进行分组，统计等，并将是结果集缩小为分组数.这意味着 其他的数据在分组后丢弃.</p>
<h3 id="4-HAVING"><a href="#4-HAVING" class="headerlink" title="4. HAVING"></a>4. <code>HAVING</code></h3><p>如果你用了 <code>GROUP BY</code> 分组, <code>HAVING</code> 会在分组完成后对结果集再次筛选。AS别名也不能在这个阶段使用.</p>
<h3 id="5-SELECT"><a href="#5-SELECT" class="headerlink" title="5. SELECT"></a>5. <code>SELECT</code></h3><p>确定结果之后，<code>SELECT</code>用来对结果col简单筛选或计算，决定输出什么数据.</p>
<h3 id="6-DISTINCT"><a href="#6-DISTINCT" class="headerlink" title="6. DISTINCT"></a>6. <code>DISTINCT</code></h3><p>如果数据行有重复<code>DISTINCT</code> 将负责排重.</p>
<h3 id="7-ORDER-BY"><a href="#7-ORDER-BY" class="headerlink" title="7. ORDER BY"></a>7. <code>ORDER BY</code></h3><p>在结果集确定的情况下，<code>ORDER BY</code> 对结果做排序。因为<code>SELECT</code>中的表达式已经执行完了。此时可以用AS别名.</p>
<h3 id="8-LIMIT-OFFSET"><a href="#8-LIMIT-OFFSET" class="headerlink" title="8. LIMIT / OFFSET"></a>8. <code>LIMIT</code> / <code>OFFSET</code></h3><p>最后 <code>LIMIT</code> 和 <code>OFFSET</code> 从排序的结果中截取部分数据.</p>
<p><strong>结论</strong></p>
<p>不是每一个SQL语句都要用到所有的句法，但灵活运用以上的句法组合和深刻理解SQL执行原理将能在SQL层面更好的解决数据问题，而不用把问题 都抛给程序逻辑.</p>
<p>Table：Movies(Read - Only)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Id</th>
<th>Title</th>
<th>Director</th>
<th>Year</th>
<th>Length_minutes</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Toy Story</td>
<td>John Lasseter</td>
<td>1995</td>
<td>81</td>
</tr>
<tr>
<td>2</td>
<td>A Bug’s Life</td>
<td>John Lasseter</td>
<td>1998</td>
<td>95</td>
</tr>
<tr>
<td>3</td>
<td>Toy Story 2</td>
<td>John Lasseter</td>
<td>1999</td>
<td>93</td>
</tr>
<tr>
<td>4</td>
<td>Monsters, Inc.</td>
<td>Pete Docter</td>
<td>2001</td>
<td>92</td>
</tr>
<tr>
<td>5</td>
<td>Finding Nemo</td>
<td>Finding Nemo</td>
<td>2003</td>
<td>107</td>
</tr>
<tr>
<td>6</td>
<td>The Incredibles</td>
<td>Brad Bird</td>
<td>2004</td>
<td>116</td>
</tr>
<tr>
<td>7</td>
<td>Cars</td>
<td>John Lasseter</td>
<td>2006</td>
<td>117</td>
</tr>
<tr>
<td>8</td>
<td>Ratatouille</td>
<td>Brad Bird</td>
<td>2007</td>
<td>115</td>
</tr>
<tr>
<td>9</td>
<td>WALL-E</td>
<td>Andrew Stanton</td>
<td>2008</td>
<td>104</td>
</tr>
<tr>
<td>10</td>
<td>Up</td>
<td>Pete Docter</td>
<td>2009</td>
<td>101</td>
</tr>
<tr>
<td>11</td>
<td>Toy Story 3</td>
<td>Lee Unkrich</td>
<td>2010</td>
<td>103</td>
</tr>
<tr>
<td>12</td>
<td>Cars 2</td>
<td>John Lasseter</td>
<td>2011</td>
<td>120</td>
</tr>
<tr>
<td>13</td>
<td>Brave</td>
<td>Brenda Chapman</td>
<td>2012</td>
<td>102</td>
</tr>
<tr>
<td>14</td>
<td>Monsters University</td>
<td>Dan Scanlon</td>
<td>2013</td>
<td>110</td>
</tr>
</tbody>
</table>
</div>
<p>Table：Boxoffice(Read - Only)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Movie_id</th>
<th>Rating</th>
<th>Domestic_sales</th>
<th>International_sales</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>8.2</td>
<td>380843261</td>
<td>555900000</td>
</tr>
<tr>
<td>14</td>
<td>7.4</td>
<td>268492764</td>
<td>475066843</td>
</tr>
<tr>
<td>8</td>
<td>8</td>
<td>206445654</td>
<td>417277164</td>
</tr>
<tr>
<td>12</td>
<td>6.4</td>
<td>191452396</td>
<td>368400000</td>
</tr>
<tr>
<td>3</td>
<td>7.9</td>
<td>245852179</td>
<td>239163000</td>
</tr>
<tr>
<td>6</td>
<td>8</td>
<td>261441092</td>
<td>370001000</td>
</tr>
<tr>
<td>9</td>
<td>8.5</td>
<td>223808164</td>
<td>297503696</td>
</tr>
<tr>
<td>11</td>
<td>8.4</td>
<td>415004880</td>
<td>648167031</td>
</tr>
<tr>
<td>1</td>
<td>8.3</td>
<td>191796233</td>
<td>170162503</td>
</tr>
<tr>
<td>7</td>
<td>7.2</td>
<td>244082982</td>
<td>217900167</td>
</tr>
<tr>
<td>10</td>
<td>8.3</td>
<td>293004164</td>
<td>438338580</td>
</tr>
<tr>
<td>4</td>
<td>8.1</td>
<td>289916256</td>
<td>272900000</td>
</tr>
<tr>
<td>2</td>
<td>7.2</td>
<td>162798565</td>
<td>200600000</td>
</tr>
<tr>
<td>13</td>
<td>7.2</td>
<td>237283207</td>
<td>301700000</td>
</tr>
</tbody>
</table>
</div>
<p><strong>e.g【难题】按导演分组计算销售总额,求出平均销售额冠军（统计结果过滤掉只有单部电影的导演，列出导演名，总销量，电影数量，平均销量) </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(domestic_sales + international_sales) sum_sale, director,COUNT(*) count, AVG(domestic_sales + international_sales) ave_sale FROM movies m<br>INNER JOIN boxoffice b<br>ON m.id = b.movie_id<br>GROUP BY director<br>HAVING count != 1<br>ORDER BY ave_sale DESC<br>LIMIT 1<br></code></pre></td></tr></table></figure>
<p><strong>Q：</strong>为什么where里面不能count()而having里面可以</p>
<p><strong>A：</strong>因为聚合函数是做统计用的，所有的聚合方式使用都是，函数名(字段) 对这一个字段进行聚合。但在mysql内部运行机制中，where后面还没有结果，只有select后面才有结果集。所以聚合函数是不能放在where后面,却可以放在select后面。</p>
<p><strong>e.g【变态难】找出每部电影和单部电影销售冠军之间的销售差，列出电影名，销售额差额</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT title,<br>(SELECT (Domestic_sales + International_sales) FROM movies m<br>JOIN boxoffice b<br>ON m.id = b.movie_id <br>ORDER BY(Domestic_sales+<br>International_sales) DESC <br>LIMIT 1)<br>  - (Domestic_sales+International_sales) as sale_diff<br>FROM movies m<br>LEFT JOIN boxoffice b<br>ON m.id = b.movie_id <br>ORDER BY sale_diff DESC<br></code></pre></td></tr></table></figure>
<p>SELECT是可以嵌套的，SELECT是输出的表达式。</p>
<h1 id="二-SQL的DQL、DDL、DML、DCL使用"><a href="#二-SQL的DQL、DDL、DML、DCL使用" class="headerlink" title="二. SQL的DQL、DDL、DML、DCL使用"></a>二. SQL的DQL、DDL、DML、DCL使用</h1><h2 id="1-数据查询语言DQL"><a href="#1-数据查询语言DQL" class="headerlink" title="1. 数据查询语言DQL"></a><strong>1.</strong> 数据查询语言DQL</h2><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：<br>SELECT &lt;字段名表&gt;<br>FROM &lt;表或视图名&gt;<br>WHERE &lt;查询条件&gt;</p>
<h2 id="2-数据操纵语言DML"><a href="#2-数据操纵语言DML" class="headerlink" title="2. 数据操纵语言DML"></a>2. 数据操纵语言DML</h2><p><strong>数据库意义： </strong>数据存储，数据管理</p>
<p>DML：数据操作语言</p>
<p>添加( INSERT )</p>
<p>修改( UPDATE )</p>
<p>删除( DELETE )</p>
<h2 id="3-数据定义语言DDL"><a href="#3-数据定义语言DDL" class="headerlink" title="3. 数据定义语言DDL"></a>3. 数据定义语言DDL</h2><p>数据定义语言DDL用来创建数据库中的各种对象——-表、视图、<br>索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER<br>          |      |      |      |      |<br>         表   视图  索引  同义词  簇</p>
<p>DDL操作是隐性提交的！不能rollback </p>
<h2 id="4-数据控制语言DCL"><a href="#4-数据控制语言DCL" class="headerlink" title="4. 数据控制语言DCL"></a>4. 数据控制语言DCL</h2><p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制<br>数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p>
<p>1) GRANT：授权。</p>
<p>2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。<br>   回滚—-ROLLBACK<br>   回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>   SQL&gt;ROLLBACK;</p>
<p>3) COMMIT [WORK]：提交。</p>
<p>  在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。</p>
<h1 id="三-其他数据库对象"><a href="#三-其他数据库对象" class="headerlink" title="三. 其他数据库对象"></a>三. 其他数据库对象</h1><h1 id="四-数据库基本性质"><a href="#四-数据库基本性质" class="headerlink" title="四. 数据库基本性质"></a>四. 数据库基本性质</h1><h2 id="1-事务（Transaction）"><a href="#1-事务（Transaction）" class="headerlink" title="1. 事务（Transaction）"></a>1. 事务（Transaction）</h2><p>概念：是由一组SQL语句组成的一个程序执行单元（Unit），它需要满足ACID特性。<br><strong>ACID：</strong><br>原子性（Atomicity）：事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。\<br>一致性（Consistency）：数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。\<br>隔离性（Isolation）：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其他事务运行结果。\<br>持久性（Durability）：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
<h2 id="2-并发一致性问题"><a href="#2-并发一致性问题" class="headerlink" title="2. 并发一致性问题"></a>2. 并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h3 id="2-1-丢失修改"><a href="#2-1-丢失修改" class="headerlink" title="2.1 丢失修改"></a>2.1 丢失修改</h3><p>T1事务和T2事务同时进行更新操作同一个数据，T1在前，T2在后，T2的修改覆盖了T1的修改。</p>
<h3 id="2-2-读脏数据"><a href="#2-2-读脏数据" class="headerlink" title="2.2 读脏数据"></a>2.2 读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<h3 id="2-3-不可重复读"><a href="#2-3-不可重复读" class="headerlink" title="2.3 不可重复读"></a>2.3 不可重复读</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<h3 id="2-4-幻读"><a href="#2-4-幻读" class="headerlink" title="2.4 幻读"></a>2.4 幻读</h3><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。与不可重复读不同的是，前者是读了更新的数据内容，后者是读了更新的数据项</p>
<h2 id="3-封锁"><a href="#3-封锁" class="headerlink" title="3. 封锁"></a>3. 封锁</h2><h3 id="3-1-封锁类型"><a href="#3-1-封锁类型" class="headerlink" title="3.1 封锁类型"></a>3.1 封锁类型</h3><h4 id="3-1-1-读写锁"><a href="#3-1-1-读写锁" class="headerlink" title="3.1.1 读写锁"></a>3.1.1 读写锁</h4><ul>
<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。<br>有两个规定：<br>1）T 拿到 X 锁的时候，其他的读写数据的请求都要隔离。<br>2）T 拿到 S 锁的时候，其他的更新数据的请求都要隔离。</li>
</ul>
<p>XS锁兼容关系<br>|      | X    | S    |<br>| —— | —— | —— |<br>| X    | ❌    | ❌    |<br>| S    | ❌    | ✅    |</p>
<h4 id="3-1-2-意向锁"><a href="#3-1-2-意向锁" class="headerlink" title="3.1.2 意向锁"></a>3.1.2 意向锁</h4><p>在T对数据加入X锁或者S锁之前要拿到意向锁，确认没有别的事务对数据表和某行数据进行操作意向。</p>
<h2 id="4-隔离级别"><a href="#4-隔离级别" class="headerlink" title="4. 隔离级别"></a>4. 隔离级别</h2><h3 id="4-1-未提交读（READ-UNCOMMITTED）"><a href="#4-1-未提交读（READ-UNCOMMITTED）" class="headerlink" title="4.1 未提交读（READ UNCOMMITTED）"></a>4.1 未提交读（READ UNCOMMITTED）</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h3 id="4-2-提交读（READ-COMMITTED）"><a href="#4-2-提交读（READ-COMMITTED）" class="headerlink" title="4.2 提交读（READ COMMITTED）"></a>4.2 提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。解决脏读。</p>
<h3 id="4-3-可重复读（REPEATABLE-READ）"><a href="#4-3-可重复读（REPEATABLE-READ）" class="headerlink" title="4.3 可重复读（REPEATABLE READ）"></a>4.3 可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。解决不可重复读，脏读。</p>
<h3 id="4-4-可序列化（SERIALIZABLE）"><a href="#4-4-可序列化（SERIALIZABLE）" class="headerlink" title="4.4 可序列化（SERIALIZABLE）"></a>4.4 可序列化（SERIALIZABLE）</h3><p>强制事务串行的执行，并且通过锁来规定同一时间执行的事务只有一个，规定好了执行的秩序。解决脏读、不可重复读、幻读。</p>
<p>隔离级别能解决的并发一致性问题</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>提交读</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>可重复读</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>可序列化</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-多版本并发控制MVCC"><a href="#5-多版本并发控制MVCC" class="headerlink" title="5. 多版本并发控制MVCC"></a>5. 多版本并发控制MVCC</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<p><strong>MVCC</strong>(Multi Version Concurrency Control的简称)，代表<strong>多版本并发控制</strong>。</p>
<p>MVCC最大的优势：<strong>读不加锁，读写不冲突</strong>。读写不冲突是非常重要的，极大的增加了系统的并发性能。<strong>MVCC机制也是乐观锁的一种体现。</strong></p>
<p><strong>基本思想</strong></p>
<p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p>
<p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p>
<p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p>
<h1 id="五-数据库的原理"><a href="#五-数据库的原理" class="headerlink" title="五. 数据库的原理"></a>五. 数据库的原理</h1><h2 id="一、索引优化"><a href="#一、索引优化" class="headerlink" title="一、索引优化"></a>一、索引优化</h2><h3 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;<br></code></pre></td></tr></table></figure>
<h3 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT film_id, actor_ id FROM sakila.film_actor<br>WHERE actor_id = 1 AND film_id = 1;<br></code></pre></td></tr></table></figure>
<h3 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,<br>COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,<br>COUNT(*)<br>FROM payment;<br>   staff_id_selectivity: 0.0001<br>customer_id_selectivity: 0.0373<br>               COUNT(*): 16049<br></code></pre></td></tr></table></figure>
<h3 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引</li>
</ul>
<h2 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h2><h3 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><h4 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h4><ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<p><strong>准确自己查询的内容！</strong></p>
<h4 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h4><p>最有效的方式是使用索引来覆盖查询。</p>
<h2 id="三、重构查询方式"><a href="#三、重构查询方式" class="headerlink" title="三、重构查询方式"></a>三、重构查询方式</h2><h3 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> messages <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">create</span> &lt; DATE_SUB(NOW(), INTERVAL <span class="hljs-number">3</span> MONTH);<br>rows_affected = 0<br>do &#123;<br>    rows_affected = do_query(<br>    &quot;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> messages <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">create</span>  &lt; DATE_SUB(NOW(), INTERVAL <span class="hljs-number">3</span> MONTH) <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10000</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">&#125; while rows_affected &gt; 0</span><br></code></pre></td></tr></table></figure>
<h3 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM tag<br>JOIN tag_post ON tag_post.tag_id=tag.id<br>JOIN post ON tag_post.post_id=post.id<br>WHERE tag.tag=&#x27;mysql&#x27;;<br>SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;<br>SELECT * FROM tag_post WHERE tag_id=1234;<br>SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);<br></code></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>0、如果语句是<code>select * from T where ID=500</code>，即<strong>主键查询</strong>方式，则只需要搜索ID这棵B+树；</p>
<p>如果语句是<code>select * from T where k=5</code>，即<strong>普通索引</strong>查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</p>
<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>
<p>1、能多列索引就多列索引</p>
<p>2、把选择性高的放前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>3、索引使用条件：</p>
<ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引就非常有效；</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/SQL/">SQL</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/data-base/">data base</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">代码随想录</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/15/Computer-Systems-A-Programmer-s-Perspective/">
                        <span class="hidden-mobile">Computer Systems: A Programmer‘s Perspective</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> & <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
