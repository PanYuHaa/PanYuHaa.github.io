

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon1.png">
  <link rel="icon" href="/img/favicon1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Peter Pan">
  <meta name="keywords" content="">
  
    <meta name="description" content="第3章 数组3.2 二分查找704. Binary Search Q: Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return">
<meta property="og:type" content="article">
<meta property="og:title" content="代码随想录">
<meta property="og:url" content="http://example.com/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/index.html">
<meta property="og:site_name" content="PPStudy">
<meta property="og:description" content="第3章 数组3.2 二分查找704. Binary Search Q: Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/spiraln.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/removelinked-list.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/rev1ex1.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/circularlinkedlist.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/java-hashset-hierarchy.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201123195242899.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201123200304469.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201123202736384.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201123203735933.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202011232041348.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201124200229824.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201124201331223.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210130182532303.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020111720451790.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020112917480858.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201124154758229.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201201232445286.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201213162821958.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210107093253987.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210110103003361.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021011010304192.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210110103109140.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021011010314055.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202101101032124.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210110103244701.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210118163425129.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210117171307407.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210120111201512.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210120181331461.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210224225642465.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201228181724295.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021011215282060.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210210150215918.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210303173115966.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210714101750205.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210114162113131.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/608996/201408/141025088894028.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210121171032473.jpg">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20220714101414.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20220714102201.png">
<meta property="article:published_time" content="2022-04-21T01:38:37.000Z">
<meta property="article:modified_time" content="2022-10-07T01:06:38.659Z">
<meta property="article:author" content="Peter Pan">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/spiraln.jpg">
  
  
  <title>代码随想录 - PPStudy</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="代码随想录">
              
                代码随想录
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-21 09:38" pubdate>
        April 21, 2022 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      133k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      1108 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">代码随想录</h1>
            
            <div class="markdown-body">
              <h1 id="第3章-数组"><a href="#第3章-数组" class="headerlink" title="第3章 数组"></a>第3章 数组</h1><h2 id="3-2-二分查找"><a href="#3-2-二分查找" class="headerlink" title="3.2 二分查找"></a>3.2 二分查找</h2><p><strong>704. Binary Search</strong></p>
<p><strong>Q:</strong> Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> pivot, left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>      pivot = left + (right - left) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[pivot] == target) <span class="hljs-keyword">return</span> pivot;<br>      <span class="hljs-keyword">if</span> (target &lt; nums[pivot]) right = pivot - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> left = pivot + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中 (left + right) / 2 = left + (right / 2) - (left / 2) = left + (right - left) / 2</p>
<p>我采用的是 [left, right] 闭区间，所以判断条件是 &lt;= ，left和right相等的时候有意义。</p>
<h2 id="3-3-移除元素"><a href="#3-3-移除元素" class="headerlink" title="3.3 移除元素"></a><strong>3.3 移除元素</strong></h2><p><strong>27. Remove Element</strong></p>
<p><strong>Q: </strong>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <strong>in-place</strong>. The relative order of the elements may be changed.</p>
<p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p>
<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] != val) &#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>1⃣️ 由于有空间复杂度的限制，所以不能建立另外一个数组来进行赋值，暗示我们用双指针法，双指针法是常用的降低时间复杂度的方法。</p>
<p>2⃣️ nums = [0, 1 ,4 ,0 ,3 , _ , _] 因为数组中的元素在内存地址上是连续的，不能单独删除数组中的某个元素，只能覆盖。</p>
<h2 id="3-4-长度最小的子数组"><a href="#3-4-长度最小的子数组" class="headerlink" title="3.4 长度最小的子数组"></a>3.4 长度最小的子数组</h2><p><strong>209. Minimum Size Subarray Sum</strong></p>
<p><strong>Q: </strong>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>
<p><strong>A1:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span> MAX;<br>        <span class="hljs-type">int</span> subSum;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历数组中的每一个作为开头</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            subSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-comment">// 求子数组的和</span><br>                subSum += nums[j];<br>                <span class="hljs-keyword">if</span> (subSum &gt;= target) &#123;<br>                    subLength = j - i + <span class="hljs-number">1</span>;<br>                    resultLength = resultLength &gt; subLength ? subLength : resultLength;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span>= MAX ? <span class="hljs-number">0</span> : resultLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>暴力解法，不过也有巧妙思路，通过MAX这个变量增加了判断是否返回0的方法，是flag的另一种用法。</p>
<p><strong>A2:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span> MAX;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 标记左边的起始位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 用j标记的是窗口右边指针的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            subSum += nums[j];<br>            <span class="hljs-comment">// 保证窗口内的sum值永远是大于等于target的</span><br>            <span class="hljs-keyword">while</span> (subSum &gt;= target) &#123;<br>                <span class="hljs-comment">// 获取子数组的长度并判断是否是最小的，+1是因为数组是从0开始的</span><br>                subLength = j - i + <span class="hljs-number">1</span>;<br>                resultLength = resultLength &gt; subLength ? subLength : resultLength;<br>                <span class="hljs-comment">// 收缩左边的指针的位置</span><br>                subSum -= nums[i++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span>= MAX ? <span class="hljs-number">0</span> : resultLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要考虑三个问题：</p>
<p>1⃣️ 窗口内的元素是什么？</p>
<p>2⃣️ 窗口的起始位置？</p>
<p>3⃣️ 窗口的结束位置？</p>
<p>滑动窗口的精妙之处在于根据当前子数组和的大小，不断调节子数组的起始位置，从而将时间复杂度从O(n^2)变成O(n)。</p>
<p>subLength和resultLength必须在满足subSum &gt;= target的时候才有意义，所以放在内部。</p>
<h2 id="3-5-螺旋矩阵"><a href="#3-5-螺旋矩阵" class="headerlink" title="3.5 螺旋矩阵"></a>3.5 螺旋矩阵</h2><p><strong>59. Spiral Matrix II</strong></p>
<p><strong>Q: </strong>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n2</code> in spiral order.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/spiraln.jpg" srcset="/img/loading.gif" lazyload alt="spiraln"></p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] Matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义列边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义行边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 填充值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> row;<br>        <span class="hljs-type">int</span> col;<br><br>        <span class="hljs-keyword">while</span> (value != (n * n) + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 从左向右走</span><br>            <span class="hljs-keyword">for</span> (col = left; col &lt;= right; col++) &#123;<br>                Matrix[up][col] = value;<br>                value++;<br>            &#125;<br>            up++;<br>            <span class="hljs-comment">// 从上向下走</span><br>            <span class="hljs-keyword">for</span> (row = up; row &lt;= down; row++) &#123;<br>                Matrix[row][right] = value;<br>                value++;<br>            &#125;<br>            right--;<br>            <span class="hljs-comment">// 从右向左走</span><br>            <span class="hljs-keyword">for</span> (col = right; col &gt;= left; col--) &#123;<br>                Matrix[down][col] = value;<br>                value++;<br>            &#125;<br>            down--;<br>            <span class="hljs-comment">// 从下向上走</span><br>            <span class="hljs-keyword">for</span> (row = down; row &gt;= up; row--) &#123;<br>                Matrix[row][left] = value;<br>                value++;<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>规定出四个边界，每个方向遍历一次以后通过 ++ 操作来使此行或者此列不再遍历。循环终止的方法有两种，其一是方阵的情况下进行特殊判断，其二是不规则矩阵的情况下进行每个方向上的判断。</p>
<h1 id="第4章-链表"><a href="#第4章-链表" class="headerlink" title="第4章 链表"></a>第4章 链表</h1><h2 id="4-2-虚拟头节点链表删除"><a href="#4-2-虚拟头节点链表删除" class="headerlink" title="4.2 虚拟头节点链表删除"></a>4.2 虚拟头节点链表删除</h2><p><strong>203. Remove Linked List Elements</strong></p>
<p><strong>Q: </strong>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/removelinked-list.jpg" srcset="/img/loading.gif" lazyload alt="removelinked-list"></p>
<p><strong>A1: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>		<span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 虚拟头结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fakeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        fakeHead.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> fakeHead, cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>                pre.next = cur.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = pre.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过加入虚拟头节点来解决如果是第一位就要删除的pre和cur不好指向的问题</p>
<p><strong>A2:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        head.next = removeElements(head.next, val);<br>        <span class="hljs-keyword">return</span> head.val == val ? head.next : head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>递归的方法实现，先递归到最底层，然后往回一点点走，每次都判断，如果有要删除的值就返回前一个，没有要删除的就返回当前的结点，直到回到最初的位置。</p>
<h2 id="4-3-链表常见的六个操作"><a href="#4-3-链表常见的六个操作" class="headerlink" title="4.3 链表常见的六个操作"></a>4.3 链表常见的六个操作</h2><p><strong>707. Design Linked List</strong></p>
<p><strong>Q: </strong>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.<br>A node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code>is the value of the current node, and <code>next</code> is a pointer/reference to the next node.<br>If you want to use the doubly linked list, you will need one more attribute <code>prev</code>to indicate the previous node in the linked list. Assume all nodes in the linked list are <strong>0-indexed</strong>.</p>
<p>Implement the <code>MyLinkedList</code> class:</p>
<ul>
<li><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</li>
<li><code>int get(int index)</code> Get the value of the <code>indexth</code> node in the linked list. If the index is invalid, return <code>-1</code>.</li>
<li><code>void addAtHead(int val)</code> Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>
<li><code>void addAtTail(int val)</code> Append a node of value <code>val</code> as the last element of the linked list.</li>
<li><code>void addAtIndex(int index, int val)</code> Add a node of value <code>val</code>before the <code>indexth</code> node in the linked list. If <code>index</code> equals the length of the linked list, the node will be appended to the end of the linked list. If <code>index</code> is greater than the length, the node <strong>will not be inserted</strong>.</li>
<li><code>void deleteAtIndex(int index)</code> Delete the <code>indexth</code> node in the linked list, if the index is valid.</li>
</ul>
<p><strong>A:</strong> </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyLinkedList <span class="hljs-keyword">struct</span> &#123;<br>	head *Node<br>&#125;<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>	Val  <span class="hljs-type">int</span><br>	Next *Node<br>	Prev *Node<br>&#125;<br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyLinkedList &#123;<br>	<span class="hljs-keyword">return</span> MyLinkedList&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> Get(index <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>	curr := this.head<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>		curr = curr.Next<br>	&#125;<br>	<span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> curr.Val<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="hljs-type">int</span>) &#123;<br>	node := &amp;Node&#123;Val: val&#125;<br>	node.Next = this.head<br>	<span class="hljs-keyword">if</span> this.head != <span class="hljs-literal">nil</span> &#123;<br>		this.head.Prev = node<br>	&#125;<br>	this.head = node<br>&#125;<br><br><span class="hljs-comment">/** Append a node of value val to the last element of the linked list. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="hljs-type">int</span>) &#123;<br>	<span class="hljs-keyword">if</span> this.head == <span class="hljs-literal">nil</span> &#123;<br>		this.AddAtHead(val)<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	node := &amp;Node&#123;Val: val&#125;<br>	curr := this.head<br>	<span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &amp;&amp; curr.Next != <span class="hljs-literal">nil</span> &#123;<br>		curr = curr.Next<br>	&#125;<br>	node.Prev = curr<br>	curr.Next = node<br>&#125;<br><br><span class="hljs-comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="hljs-type">int</span>, val <span class="hljs-type">int</span>) &#123;<br>	<span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>		this.AddAtHead(val)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		node := &amp;Node&#123;Val: val&#125;<br>		curr := this.head<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index<span class="hljs-number">-1</span> &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>			curr = curr.Next<br>		&#125;<br>		<span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &#123;<br>			node.Next = curr.Next<br>			node.Prev = curr<br>			<span class="hljs-keyword">if</span> node.Next != <span class="hljs-literal">nil</span> &#123;<br>				node.Next.Prev = node<br>			&#125;<br>			curr.Next = node<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/** Delete the index-th node in the linked list, if the index is valid. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="hljs-type">int</span>) &#123;<br>	<span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>		this.head = this.head.Next<br>		<span class="hljs-keyword">if</span> this.head != <span class="hljs-literal">nil</span> &#123;<br>			this.head.Prev = <span class="hljs-literal">nil</span><br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		curr := this.head<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index<span class="hljs-number">-1</span> &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>			curr = curr.Next<br>		&#125;<br>		<span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &amp;&amp; curr.Next != <span class="hljs-literal">nil</span> &#123;<br>			curr.Next = curr.Next.Next<br>			<span class="hljs-keyword">if</span> curr.Next != <span class="hljs-literal">nil</span> &#123;<br>				curr.Next.Prev = curr<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * param_1 := obj.Get(index);</span><br><span class="hljs-comment"> * obj.AddAtHead(val);</span><br><span class="hljs-comment"> * obj.AddAtTail(val);</span><br><span class="hljs-comment"> * obj.AddAtIndex(index,val);</span><br><span class="hljs-comment"> * obj.DeleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h2 id="4-4-反转链表"><a href="#4-4-反转链表" class="headerlink" title="4.4 反转链表"></a>4.4 反转链表</h2><p><strong>206. Reverse Linked List</strong></p>
<p><strong>Q:</strong> Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/rev1ex1.jpg" srcset="/img/loading.gif" lazyload alt="rev1ex1"></p>
<p><strong>A:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//双指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> pre *ListNode<br>    cur := head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next := cur.Next<br>        cur.Next = pre<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br><br><span class="hljs-comment">//递归</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> help(<span class="hljs-literal">nil</span>, head)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">help</span><span class="hljs-params">(pre, head *ListNode)</span></span>*ListNode&#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> pre<br>    &#125;<br>    next := head.Next<br>    head.Next = pre<br>    <span class="hljs-keyword">return</span> help(head, next)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-5-删除倒数第n个字节"><a href="#4-5-删除倒数第n个字节" class="headerlink" title="4.5 删除倒数第n个字节"></a>4.5 删除倒数第n个字节</h2><p><strong>19. Remove Nth Node From End of List</strong></p>
<p><strong>Q: </strong>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head. </p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// fakeHead</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fakeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        fakeHead.next = head;<br>        <span class="hljs-comment">// fast &amp; slow, fast pointer faster than slow pointer n steps.</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> fakeHead;<br>        <span class="hljs-comment">// set the position of the fast pointer.</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// n represent the times of loop, if &#x27;i&#x27; start from 0.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> fakeHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过双指针的间距来找到倒数第n个的位置，我让fast提前等于head再往后走，是为了在找到最后的null的时候，slow正好是要删除的结点的前一个。</p>
<h2 id="4-6-环形链表"><a href="#4-6-环形链表" class="headerlink" title="4.6 环形链表"></a>4.6 环形链表</h2><p><strong>142. Linked List Cycle II</strong></p>
<p><strong>Q: </strong>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return</em> <code>null</code>.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>
<p><strong>Do not modify</strong> the linked list.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/circularlinkedlist.png" srcset="/img/loading.gif" lazyload alt="circularlinkedlist"></p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<span class="hljs-comment">// 有环</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> fast;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span><br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1.next;<br>                    index2 = index2.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>双指针的思想，具体推导过程见书P66。</p>
<p>1⃣️判断是否有环？</p>
<p>2⃣️判断环的入口在哪里？</p>
<p>x为起始位置到循环入口的距离，y为循环入口到fast和slow的相遇位置，z为相遇位置到循环入口处的距离。</p>
<p><strong>x = (n - 1)(y + z) + z</strong>，当n = 1时x = z。代表着走了一圈就相遇了。若n &gt; 1的话，道理一样，总之是index2会比index1少转一圈并且相遇。</p>
<p>z是fast相遇的位置开始走，最起码要走一圈，多的就是在入口点前相遇的时候，转了几圈y + z代表的是走一圈要的距离。</p>
<p>ps: n一定大于等于1，因为index1必须最起码走一圈才能够和index2相遇。</p>
<h1 id="第5章-哈希表"><a href="#第5章-哈希表" class="headerlink" title="第5章 哈希表"></a>第5章 哈希表</h1><h2 id="5-2-有效的字母异位词"><a href="#5-2-有效的字母异位词" class="headerlink" title="5.2 有效的字母异位词"></a>5.2 有效的字母异位词</h2><p><strong>242. Valid Anagram</strong></p>
<p><strong>Q: </strong>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code><em>otherwise</em>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            record[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            record[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里用到了一个常用的处理字符出现次数的方法。字符 - ‘a’也算是一种哈希函数，它可以把字符串通过ASCII转换，用26位的数组存储他们出现的次数。</p>
<h2 id="5-3-两个数组的交集"><a href="#5-3-两个数组的交集" class="headerlink" title="5.3 两个数组的交集"></a>5.3 两个数组的交集</h2><p><strong>349. Intersection of Two Arrays</strong></p>
<p><strong>Q: </strong>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; intersect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;<br>            set.add(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(nums2[i])) &#123;<br>                intersect.add(nums2[i]);<br>            &#125;<br>        &#125;<br>  			<span class="hljs-comment">// set turn to the int[]</span><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[intersect.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer num : intersect) &#123;<br>            result[i++] = num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/java-hashset-hierarchy.png" srcset="/img/loading.gif" lazyload alt="java-hashset-hierarchy"></p>
<ul>
<li><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p>
</li>
<li><p>HashSet 允许有 null 值。</p>
</li>
<li><p>HashSet 是无序的，即不会记录插入的顺序。</p>
</li>
<li><p>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。</p>
</li>
<li><p>HashSet 实现了 Set 接口。</p>
</li>
</ul>
<p>进行了两步，第一步初筛有哪些value，第二步确定相交的value又有哪些。</p>
<h2 id="5-4-两数之和"><a href="#5-4-两数之和" class="headerlink" title="5.4 两数之和"></a>5.4 两数之和</h2><p><strong>1. Two Sum</strong></p>
<p><strong>Q: </strong>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>
<p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the <em>same</em> element twice.</p>
<p>You can return the answer in any order.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(target - nums[i]), i&#125;;<br>            &#125;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;No two sum solution&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>思路</p>
<p>标签：哈希映射</p>
<ul>
<li>这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n^2)</li>
<li>由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度</li>
<li>遍历数组 nums, i为当前下标，每个值都判断map中是否存在 target - nums[i] 的 key 值</li>
<li>如果存在则找到了两个值，如果不存在则将当前的 (nums[i], i) 存入 map 中，继续遍历直到找到为止</li>
</ul>
<p>每次都是先判断已有的map里面是否有答案，若没有答案就放进map里，这样只要找到答案立马可以得到结果（通过 target - nums[i] 和此时的 i 得到对应的下标）并且有最优的空间复杂度。之所以用map也是因为我们需要的答案是下标，map可以存储每个数组的下标，而单一的数组是做不到的。</p>
<h2 id="5-5-四数相加"><a href="#5-5-四数相加" class="headerlink" title="5.5 四数相加"></a>5.5 四数相加</h2><p><strong>454. 4Sum II</strong></p>
<p><strong>Q:</strong> Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span>[] B, <span class="hljs-type">int</span>[] C, <span class="hljs-type">int</span>[] D)</span> &#123;<br>        Map&lt;Integer,Integer&gt; sums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : B) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a + b;<br>                <span class="hljs-keyword">if</span>(sums.containsKey(sum)) &#123;<br>                    sums.put(sum, sums.get(sum)+<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    sums.put(sum, <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : C) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : D)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> -(c + d);<br>                <span class="hljs-keyword">if</span> (sums.containsKey(sum)) &#123;<br>                    count+=sums.get(sum);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>利用两数之和的思想，先把四个数组融合成两个，把前两个数组可以组成的所有都放在一个map里面，利用双层遍历把后续的两个数组都进行做差查找。</p>
<h2 id="5-6-三数之和"><a href="#5-6-三数之和" class="headerlink" title="5.6 三数之和"></a>5.6 三数之和</h2><p><strong>15. 3Sum</strong></p>
<p><strong>Q: </strong>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + <span class="hljs-number">2</span> &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;              <span class="hljs-comment">// skip same result</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, k = nums.length - <span class="hljs-number">1</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> -nums[i];<br>        <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] + nums[k] == target) &#123;<br>                res.add(Arrays.asList(nums[i], nums[j], nums[k]));<br>                j++;<br>                k--;<br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) j++;  <span class="hljs-comment">// skip same result</span><br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]) k--;  <span class="hljs-comment">// skip same result</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j] + nums[k] &gt; target) &#123;<br>                k--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Array.sort(int[] arr)用来sort数组默认是从小到大。</p>
<p>res.add(Arrays.asList(nums[i], nums[j], nums[k]));这是List加入一系列数的方法。</p>
<p>把三个动点变成一个定点，两个动点。定点作为循环条件，在循环的基础上进行判断，一个左指针和一个右指针来判断在定点基础上，有没有组合使结果成立。这个的优点是判断了一个重复的情况直接跳过，因为题目说了不能有重复的三元组。</p>
<h2 id="5-7-四数之和"><a href="#5-7-四数之和" class="headerlink" title="5.7 四数之和"></a>5.7 四数之和</h2><p><strong>18. 4Sum</strong></p>
<p><strong>Q: </strong>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong>quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>You may return the answer in <strong>any order</strong>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> targetDiff;<br>        <span class="hljs-type">int</span> left, right;<br>        <span class="hljs-comment">// sort input</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-comment">// skip the same result, if the cur value is same as the former value, the skip the cur value.</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 在 nums[i] 基础上，从 i + 1 处开始遍历，继续三数之和的思想</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-comment">// skip the same result</span><br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                left = j + <span class="hljs-number">2</span>;<br>                right = nums.length - <span class="hljs-number">1</span>;<br>                targetDiff = target - nums[i] - nums[j];<br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-comment">// 若包含的元素能够做差满足问题</span><br>                    <span class="hljs-keyword">if</span> (targetDiff - nums[left] - nums[right] == <span class="hljs-number">0</span>) &#123;<br>                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));<br>                        left++;<br>                        right--;<br>                        <span class="hljs-comment">// skip the same result</span><br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="hljs-number">1</span>]) &#123; left++; &#125;<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="hljs-number">1</span>]) &#123; right--; &#125;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetDiff - nums[left] - nums[right] &gt; <span class="hljs-number">0</span>) &#123;<br>                        left++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在三数之和的基础上，增加了一个维度，他的时间复杂度的增加完全是因为固定的前两位，若是五数之和时间复杂度再*n。</p>
<h1 id="第6章-字符串"><a href="#第6章-字符串" class="headerlink" title="第6章 字符串"></a>第6章 字符串</h1><h2 id="6-2-反转字符串"><a href="#6-2-反转字符串" class="headerlink" title="6.2 反转字符串"></a>6.2 反转字符串</h2><p><strong>344. Reverse String</strong></p>
<p><strong>Q: </strong>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>
<p>You must do this by modifying the input array <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> with <code>O(1)</code> extra memory.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">char</span> temp;<br>      <br>        <span class="hljs-keyword">while</span>(i &lt;= j)&#123;<br>            temp = s[i];<br>            s[i] = s[j];<br>            s[j] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>基本的swap思想，关注点在于 i &lt;= j 和 i &lt; j 都是成立的，但是后者可以少判断一个i = j，可以节省判断的一点点时间。</p>
<h2 id="6-3-反转字符串-II"><a href="#6-3-反转字符串-II" class="headerlink" title="6.3 反转字符串 II"></a>6.3 反转字符串 II</h2><p><strong>541. Reverse String II</strong></p>
<p><strong>Q: </strong>Given a string <code>s</code> and an integer <code>k</code>, reverse the first <code>k</code> characters for every <code>2k</code> characters counting from the start of the string.</p>
<p>If there are fewer than <code>k</code> characters left, reverse all of them. If there are less than <code>2k</code> but greater than or equal to <code>k</code> characters, then reverse the first <code>k</code>characters and leave the other as original.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] charArr = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i += (<span class="hljs-number">2</span> * k)) &#123;<br>            <span class="hljs-comment">// the rest is less than the k, reverse all the rest</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> s.length() - i;<br>            <span class="hljs-keyword">if</span> (rest &lt; k) &#123;<br>                reverseChar(charArr, i, s.length() - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArr);<br>            &#125; <br><br>            <span class="hljs-comment">// 交换的位置是左边i，右边i + (k - 1)</span><br>            reverseChar(charArr, i, (i + k) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArr);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseChar</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">char</span> temp;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            temp = arr[left];<br>            arr[left] = arr[right];<br>            arr[right] = temp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>思路：先分析出交换的方法总共就有两种，交换前k个和交换所有，交换剩余所有是特殊的，所以我们把它放在前面当作特殊条件，只要出现了直接得到结果不用进行多余的判断。</p>
<h2 id="6-4-反转字符串里的单词"><a href="#6-4-反转字符串里的单词" class="headerlink" title="6.4 反转字符串里的单词"></a>6.4 反转字符串里的单词</h2><p><strong>151. Reverse Words in a String</strong></p>
<p><strong>Q: </strong>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>
<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>
<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>
<p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>      <span class="hljs-type">char</span>[] a = s.toCharArray();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length;<br><br>      <span class="hljs-comment">// step 1. reverse the whole string</span><br>      reverse(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// step 2. reverse each word</span><br>      reverseWords(a, n);<br>      <span class="hljs-comment">// step 3. clean up spaces</span><br>      <span class="hljs-keyword">return</span> cleanSpaces(a, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j || i &lt; n &amp;&amp; a[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++; <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; i || j &lt; n &amp;&amp; a[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++; <span class="hljs-comment">// skip non spaces</span><br>        reverse(a, i, j - <span class="hljs-number">1</span>);                      <span class="hljs-comment">// reverse the word</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// trim leading, trailing and multiple spaces</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">cleanSpaces</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="hljs-string">&#x27; &#x27;</span>) j++;             <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] != <span class="hljs-string">&#x27; &#x27;</span>) a[i++] = a[j++]; <span class="hljs-comment">// keep non spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="hljs-string">&#x27; &#x27;</span>) j++;             <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">if</span> (j &lt; n) a[i++] = <span class="hljs-string">&#x27; &#x27;</span>;                      <span class="hljs-comment">// keep only one space</span><br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(a).substring(<span class="hljs-number">0</span>, i);<br>    &#125;<br><br>    <span class="hljs-comment">// reverse a[] from a[i] to a[j]</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>      <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[i];<br>        a[i++] = a[j];<br>        a[j--] = t;<br>      &#125;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>三大关键部分：字符串反转，单词反转，去除空格。</p>
<p>reverseWords部分，i代表的是字符串的起点，j代表的是字符串的终点，i先跳过空格，j再跳过所有字符。</p>
<p>CleanSpace部分，把循环里面的步骤分为：1⃣️ 跳过空格，直到找到非空停止。2⃣️ 把非空的值填入到数组的头部，一直重复，直到找到下一个空格。(j &lt; n) 就是用来防止如果后面不再出现空格了，如何退出循环。<3⃣️ 找到下次非空的话，代表有下一个需要进行处理的字母，就将之前填充好的字母的下一位填充一个空格，结束本次循环> </p>
<h2 id="6-6-使用KMP匹配字符串"><a href="#6-6-使用KMP匹配字符串" class="headerlink" title="6.6 使用KMP匹配字符串"></a>6.6 使用KMP匹配字符串</h2><p><strong>28. Implement strStr()</strong></p>
<p><strong>Q: </strong>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>
<p><strong>Clarification:</strong></p>
<p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/cstring/strstr/">strstr()</a> and Java’s <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String">indexOf()</a>).</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span>(haystack == <span class="hljs-literal">null</span> || needle == <span class="hljs-literal">null</span> || needle.length() &gt; haystack.length()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-type">int</span>[] next = kmpPreprocess(needle);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; haystack.length() &amp;&amp; j &lt; needle.length()) &#123;<br>          	<span class="hljs-comment">// 找到了就继续往后找</span><br>            <span class="hljs-keyword">if</span>(haystack.charAt(i) == needle.charAt(j)) &#123;<br>                i++; j++;<br>            <span class="hljs-comment">// 如果匹配串中此位置不相等，匹配串就回退next数组的j - 1位置的值</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 如果字符串没有找到匹配串中的值，并且匹配串还未成功匹配</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span>= needle.length() ? i - j : -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] kmpPreprocess(String s) &#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-comment">// 直接用前缀表作next数组</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>          	<span class="hljs-comment">// 向前回退，在j = 0或者s[i] == s[j]时退出</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 找到相同的前后缀</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-comment">// 将j(前缀的长度)赋给next[i]</span><br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>KMP思想，利用next数组作为匹配的方法。两种构造next数组方法的区别就在于匹配的地方，如果由前缀表统一减一来构造next数组，那么遇到不匹配的地方直接回归对应下标的next数组的数值就行了；不减一的方法，遇到不匹配的地方就查找前一位下标的next数组对应的数值进行回退。</p>
<p>之所以为什么是next[j - 1]是因为，由于当前j位置是不匹配的但j - 1的位置之前的都是匹配的，所以我们要回到尽可能远离起始的位置（根据相同前后缀），也就是next[j - 1]存储的位置信息。</p>
<h2 id="6-7-找到重复的子字符串"><a href="#6-7-找到重复的子字符串" class="headerlink" title="6.7 找到重复的子字符串"></a>6.7 找到重复的子字符串</h2><p><strong>459. Repeated Substring Pattern</strong></p>
<p><strong>Q: </strong>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] next = kmpPreprocess(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % (len - (next[len - <span class="hljs-number">1</span>])) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] kmpPreprocess(String s) &#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-comment">// 直接用前缀表作next数组</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>          	<span class="hljs-comment">// 向前回退，在j = 0或者s[i] == s[j]时退出</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 找到相同的前后缀</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-comment">// 将j(前缀的长度)赋给next[i]</span><br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果len % (len - (next[len - 1])) == 0，则说明(数组长度 - 最长相等前后缀的长度)正好可以被数组的长度整除，该字符串中有重复的数组。</p>
<p>len - 1代表的是最后一位next数组。用前缀表不用-1，因为前缀表本身就+1了。</p>
<p>Cral哥写的这种比较好理解，我一直让j充当相同的j前缀的长度，如果往后遍历的i一直是后缀的起始位置。不用考虑i和j之间的元素，只需要看i和j的位置。基本步调是(和初始是一样的)i在前面，j在后面，如果相同了j++跟上，i继续走一个，如果出现了不一样的，则一直往前回退到有相同的(也可能一直回退到开头)，然后继续按之前的步调走，直到后缀遍历完成。</p>
<p>PS：其中对于前缀表减1的那种方法和这种方法主要的区别是前缀表那种，预处理方便，前缀表减少1那种，遍历的时候方便。方便指好思考。</p>
<h1 id="第7章-栈与队列"><a href="#第7章-栈与队列" class="headerlink" title="第7章 栈与队列"></a>第7章 栈与队列</h1><h2 id="7-2-用栈组成队列"><a href="#7-2-用栈组成队列" class="headerlink" title="7.2 用栈组成队列"></a>7.2 用栈组成队列</h2><p><strong>232. Implement Queue using Stacks</strong></p>
<p><strong>Q: </strong>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyQueue</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>
<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>
<li><code>int peek()</code> Returns the element at the front of the queue.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code>otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</li>
</ul>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <br>    <span class="hljs-comment">// 待处理part</span><br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">stkIn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <span class="hljs-comment">// 预备输出part</span><br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">stkOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stkIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 只有当stkOut为空的时候才导入stkIn的peek</span><br>        <span class="hljs-keyword">if</span> (stkOut.empty()) &#123;<br>            <span class="hljs-comment">// 导入全部的stkIn</span><br>            <span class="hljs-keyword">while</span> (!stkIn.empty()) &#123;<br>                stkOut.push(stkIn.peek());<br>                stkIn.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出栈不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) stkOut.peek();<br>        stkOut.pop();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 只有当stkOut为空的时候才导入stkIn的peek</span><br>        <span class="hljs-keyword">if</span> (stkOut.empty()) &#123;<br>            <span class="hljs-comment">// 导入全部的stkIn</span><br>            <span class="hljs-keyword">while</span> (!stkIn.empty()) &#123;<br>                stkOut.push(stkIn.peek());<br>                stkIn.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出栈不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) stkOut.peek();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (stkIn.empty() &amp;&amp; stkOut.empty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>要使用两个队列，一个用来输入一个用来输出。特别要注意的是关注输出栈是不是空的，如果非空要优先处理输出栈的（pop和peek方法）</p>
<h2 id="7-3-用队列组成栈"><a href="#7-3-用队列组成栈" class="headerlink" title="7.3 用队列组成栈"></a>7.3 用队列组成栈</h2><p><strong>225. Implement Stack using Queues</strong></p>
<p><strong>Q: </strong></p>
<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyStack</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>
<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>
<li><code>int top()</code> Returns the element on the top of the stack.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code>otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code>operations are valid.</li>
<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</li>
</ul>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// Push element x onto stack.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue.add(x);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)<br>            queue.add(queue.poll());<br>            n--;<br>    &#125;<br><br>    <span class="hljs-comment">// Removes the element on top of the stack.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        queue.poll();<br>    &#125;<br><br>    <span class="hljs-comment">// Get the top element.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br><br>    <span class="hljs-comment">// Return whether the stack is empty.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里和之前的用栈组成队列不太一样，可以只使用一个，总体来讲是个缓存的思想，将队头的元素重新放回到队尾(双队列也如此)。</p>
<h2 id="7-4-匹配括号"><a href="#7-4-匹配括号" class="headerlink" title="7.4 匹配括号"></a>7.4 匹配括号</h2><p><strong>20. Valid Parentheses</strong></p>
<p><strong>Q: </strong>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code>and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Character&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>      <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() != c)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先学会一点，匹配对的问题可以用栈来解决(先出现的左符号要最后匹配右符号，这样正好符合栈的特点)。对于这道题我们反过来想，当匹配到左符号，就将对应的右符号压入栈，然后往后匹配看看后面有没有对应的右符号。</p>
<h2 id="7-5-逆波兰表达式"><a href="#7-5-逆波兰表达式" class="headerlink" title="7.5 逆波兰表达式"></a>7.5 逆波兰表达式</h2><p><strong>150. Evaluate Reverse Polish Notation</strong></p>
<p><strong>Q: </strong>Evaluate the value of an arithmetic expression in <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</p>
<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer or another expression.</p>
<p><strong>Note</strong> that division between two integers should truncate toward zero.</p>
<p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        <span class="hljs-type">int</span> a,b;<br>		Stack&lt;Integer&gt; S = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>		<span class="hljs-keyword">for</span> (String s : tokens) &#123;<br>			<span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;+&quot;</span>)) &#123;<br>				S.add(S.pop()+S.pop());<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>				b = S.pop();<br>				a = S.pop();<br>				S.add(a / b);<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;*&quot;</span>)) &#123;<br>				S.add(S.pop() * S.pop());<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>				b = S.pop();<br>				a = S.pop();<br>				S.add(a - b);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				S.add(Integer.parseInt(s));<br>			&#125;<br>		&#125;	<br>		<span class="hljs-keyword">return</span> S.pop();<br>	  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用栈来存之前的路径，如果是数字就入栈，如果是符号就出栈前两位数字进行计算，将结果再入栈。</p>
<h2 id="7-6-滑动窗口最大值"><a href="#7-6-滑动窗口最大值" class="headerlink" title="7.6 滑动窗口最大值"></a>7.6 滑动窗口最大值</h2><p><strong>239. Sliding Window Maximum</strong></p>
<p><strong>Q: </strong>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code>which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return <em>the max sliding window</em>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义数组</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-comment">//弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出</span><br>    <span class="hljs-comment">//同时判断队列当前是否为空</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; val == deque.peek()) &#123;<br>            deque.poll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出</span><br>    <span class="hljs-comment">//保证队列元素单调递减</span><br>    <span class="hljs-comment">//比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.add(val);<br>    &#125;<br>    <span class="hljs-comment">//队列队顶元素始终为最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> deque.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//存放结果元素的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//自定义队列</span><br>        <span class="hljs-type">MyQueue</span> <span class="hljs-variable">myQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br>        <span class="hljs-comment">//先将前k的元素放入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            myQueue.add(nums[i]);<br>        &#125;<br>        res[num++] = myQueue.peek();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//滑动窗口移除最前面的元素，移除是判断该元素是否放入队列</span><br>            myQueue.poll(nums[i - k]);<br>            <span class="hljs-comment">//滑动窗口加入最后面的元素</span><br>            myQueue.add(nums[i]);<br>            <span class="hljs-comment">//记录对应的最大值</span><br>            res[num++] = myQueue.peek();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//解法二</span><br><span class="hljs-comment">//利用双端队列手动实现单调队列</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可</span><br><span class="hljs-comment"> * 单调队列类似 （tail --&gt;） 3 --&gt; 2 --&gt; 1 --&gt; 0 (--&gt; head) (右边为头结点，元素存的是下标)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        ArrayDeque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span><br>            <span class="hljs-comment">// 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="hljs-number">1</span>)&#123;<br>                deque.poll();<br>            &#125;<br>            <span class="hljs-comment">// 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br><br>            deque.offer(i);<br><br>            <span class="hljs-comment">// 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span><br>            <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>)&#123;<br>                res[idx++] = nums[deque.peek()];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>deque 双端队列：如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名 <strong>Deque</strong> 。 <strong>Java</strong>集合提供了接口 <strong>Deque</strong> 来实现一个双端队列，它的功能是： 既可以添加到队尾，也可以添加到队首； 既可以从队首获取，又可以从队尾获取。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Queue</th>
<th style="text-align:left">Deque</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">添加元素到队尾</td>
<td style="text-align:left">add(E e) / offer(E e)</td>
<td style="text-align:left">addLast(E e) / offerLast(E e)</td>
</tr>
<tr>
<td style="text-align:left">取队首元素并删除</td>
<td style="text-align:left">E remove() / E poll()</td>
<td style="text-align:left">E removeFirst() / E pollFirst()</td>
</tr>
<tr>
<td style="text-align:left">取队首元素但不删除</td>
<td style="text-align:left">E element() / E peek()</td>
<td style="text-align:left">E getFirst() / E peekFirst()</td>
</tr>
<tr>
<td style="text-align:left">添加元素到队首</td>
<td style="text-align:left">无</td>
<td style="text-align:left">addFirst(E e) / offerFirst(E e)</td>
</tr>
<tr>
<td style="text-align:left">取队尾元素并删除</td>
<td style="text-align:left">无</td>
<td style="text-align:left">E removeLast() / E pollLast()</td>
</tr>
<tr>
<td style="text-align:left">取队尾元素但不删除</td>
<td style="text-align:left">无</td>
<td style="text-align:left">E getLast() / E peekLast()</td>
</tr>
</tbody>
</table>
</div>
<h2 id="7-7-前k个高频元素"><a href="#7-7-前k个高频元素" class="headerlink" title="7.7 前k个高频元素"></a>7.7 前k个高频元素</h2><p><strong>347. Top K Frequent Elements</strong></p>
<p><strong>Q: </strong>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-comment">// 记录频率</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();<br>        <span class="hljs-comment">// 根据map的value值正序排，相当于一个小顶堆</span><br>        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;<br>            queue.offer(entry);<br>            <span class="hljs-keyword">if</span> (queue.size() &gt; k) &#123;<br>                queue.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = queue.poll().getKey();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这道题目主要涉及到如下三块内容：</p>
<ol>
<li>要统计元素出现频率</li>
<li>对频率排序</li>
<li>找出前K个高频元素</li>
</ol>
<h2 id="7-8-接雨水"><a href="#7-8-接雨水" class="headerlink" title="7.8 接雨水"></a>7.8 接雨水</h2><p><strong>42. Trapping Rain Water</strong></p>
<p><strong>Q: </strong>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftMax[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> rightMax[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        rightMax[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; n;i++) &#123;<br>            leftMax[i] = Math.max(leftMax[i - <span class="hljs-number">1</span>], height[i]);<br>            rightMax[n - i - <span class="hljs-number">1</span>] = Math.max(rightMax[n - i], height[n - i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">trappedWater</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            trappedWater += Math.min(leftMax[i], rightMax[i]) - height[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> trappedWater;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>每一列雨水的高度主要取决于左侧最高的柱子和右侧的最高的柱子之间的最矮的柱子的高度</p>
<p>由于决定当前坐标的位置盛水的高度只取决于其左右两边的围栏的最小值（木桶效应），所以我们需要建立两个数组用来存储当前位置的其左右两边的水桶的高度最大值。</p>
<p>Step1: 我们先将同一个坐标位置下的左右两边最大的高度存储下来</p>
<p>Step2: 我们求解水量 Math.min(leftMax[i], rightMax[i]) - height[i]</p>
<h1 id="第8章-二叉树"><a href="#第8章-二叉树" class="headerlink" title="第8章 二叉树"></a>第8章 二叉树</h1><h2 id="8-1-二叉树前中后序遍历"><a href="#8-1-二叉树前中后序遍历" class="headerlink" title="8.1 二叉树前中后序遍历"></a>8.1 二叉树前中后序遍历</h2><h3 id="8-1-1-前序遍历"><a href="#8-1-1-前序遍历" class="headerlink" title="8.1.1 前序遍历"></a>8.1.1 前序遍历</h3><p><strong>144. Binary Tree Preorder Traversal</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>		<span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        preorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        result.add(root.val);   <span class="hljs-comment">// get value of root</span><br>        preorder(root.left, result); <span class="hljs-comment">// left</span><br>        preorder(root.right, result); <span class="hljs-comment">// right</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>根左右顺序递归进去，遍历树和图还是比较好想的，因为可以正向思维往深了走。</p>
<h3 id="8-1-2-中序遍历"><a href="#8-1-2-中序遍历" class="headerlink" title="8.1.2 中序遍历"></a><strong>8.1.2 中序遍历</strong></h3><p><strong>94. Binary Tree Inorder Traversal</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        inorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorder(root.left, result);    <span class="hljs-comment">// left</span><br>        result.add(root.val); <span class="hljs-comment">// get value of root</span><br>        inorder(root.right, result); <span class="hljs-comment">// right</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>左根右顺序递归进去</p>
<h3 id="8-1-3-后序遍历"><a href="#8-1-3-后序遍历" class="headerlink" title="8.1.3 后序遍历"></a><strong>8.1.3 后序遍历</strong></h3><p><strong>145. Binary Tree Postorder Traversal</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the postorder traversal of its nodes’ values</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        postorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorder(root.left, result); <span class="hljs-comment">// left</span><br>        postorder(root.right, result); <span class="hljs-comment">// right</span><br>        result.add(root.val); <span class="hljs-comment">// get value of root</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-2-二叉树层序遍历"><a href="#8-2-二叉树层序遍历" class="headerlink" title="8.2 二叉树层序遍历"></a>8.2 二叉树层序遍历</h2><p><strong>102. Binary Tree Level Order Traversal</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p>
<p><strong>A：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;  <br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();  <br>        queue.add(root);  <br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;  <br>          List&lt;Integer&gt; itemList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>          <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();  <br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;  <br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();  <br>            itemList.add(node.val);  <br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;  <br>              queue.offer(node.left);  <br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;  <br>              queue.offer(node.right);  <br>            &#125;  <br>          &#125;  <br>          res.add(itemList);   <br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>层序遍历的关键在于队列的使用。我们先将根放入队列中，然后终止判定为队列为空，那么如何保证他不会空呢？由于每次出栈一个元素后就把他的左右子树放进队列（如果有的话），这样可以保证队列不会空而退出循环，并且是按照左右子树的顺序也保证了后面的层序遍历仍然是从左往右。</p>
<p>跟行有关的二叉树可以优先选择层序遍历。</p>
<p><strong>EXTEND QUESTIONS:</strong></p>
<p>107、199、637、429、515、116、104</p>
<h2 id="8-11-二叉树的所有路径"><a href="#8-11-二叉树的所有路径" class="headerlink" title="8.11 二叉树的所有路径"></a>8.11 二叉树的所有路径</h2><p><strong>257. Binary Tree Paths</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>A:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>      	<span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>    &#125;<br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>      	<span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;strconv.Itoa(root.Val)&#125;<br>    &#125;<br>    tmpLeft := binaryTreePaths(root.Left)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmpLeft); i++ &#123;<br>      	res = <span class="hljs-built_in">append</span>(res, strconv.Itoa(root.Val)+<span class="hljs-string">&quot;-&gt;&quot;</span>+tmpLeft[i])<br>    &#125;<br>    tmpRight := binaryTreePaths(root.Right)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmpRight); i++ &#123;<br>      	res = <span class="hljs-built_in">append</span>(res, strconv.Itoa(root.Val)+<span class="hljs-string">&quot;-&gt;&quot;</span>+tmpRight[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也是递归的思想，从根向子节点遍历的话用前序遍历（根左右）。tmpLeft代表的是左边收集到的路径，同理tmpRight就是右边收集到的路径。</p>
<h2 id="8-12-路径总和"><a href="#8-12-路径总和" class="headerlink" title="8.12 路径总和"></a>8.12 路径总和</h2><p><strong>112. Path Sum</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> pathSum(root, targetSum - root.Val)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, count <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &amp;&amp; count == <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 遇到叶子结点，并且计数为0</span><br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 遇到叶子节点,Count不为0，直接返回</span><br>    <br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        count -= root.Left.Val  <span class="hljs-comment">// 递归，处理节点</span><br>        <span class="hljs-keyword">if</span> pathSum(root.Left, count) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        count += root.Left.Val  <span class="hljs-comment">// 回溯，撤销处理结果</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        count -= root.Right.Val  <span class="hljs-comment">// 递归，处理节点</span><br>        <span class="hljs-keyword">if</span> pathSum(root.Right, count) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        count += root.Right.Val  <span class="hljs-comment">// 回溯，撤销处理结果</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>递归和回溯是要在一起的，每一次递归都要有对应的回溯，这里用到的是根左右的形式。递归的话不要仔细去想具体的每一步是怎么样的，而是要关注三部曲，1⃣️入口的样子，2⃣️终止条件，3⃣️中间的处理逻辑。本篇通过leetcode上 <strong>112. 路径总和</strong> 和 <strong>113. 路径总和ii</strong> 详细的讲解了递归函数什么时候需要返回值，什么不需要返回值。</p>
<p><strong>113. Path Sum II</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals</em> <code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p>
<p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, sum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">var</span> slice [][]<span class="hljs-type">int</span><br>	slice = findPath(root, sum, slice, []<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>))<br>    fmt.Println(slice)<br>	<span class="hljs-keyword">return</span> slice<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPath</span><span class="hljs-params">(root *TreeNode, sum <span class="hljs-type">int</span>, slice [][]<span class="hljs-type">int</span>, path []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;    <br>      	<span class="hljs-keyword">return</span> slice<br>    &#125;<br>    sum -= root.Val  <span class="hljs-comment">// 进入一个节点就用当前val减少sum的值</span><br>    path = <span class="hljs-built_in">append</span>(path, root.Val)  <span class="hljs-comment">// 将当前val这个结果加入（一个切片）</span><br>    <span class="hljs-keyword">if</span> sum == <span class="hljs-number">0</span> &amp;&amp; root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// 如果摸到了最末端一个节点并且sum已经被减光</span><br>      	slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, path...))  <span class="hljs-comment">// 把之前栈的结果全部导入到slice里面</span><br>        <span class="hljs-keyword">return</span> slice<br>    &#125;<br>    slice = findPath(root.Left, sum, slice, path)<br>    slice = findPath(root.Right, sum, slice, path)<br>    <span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure>
<p>学习的别人的思路，整体采用的是根左右也就是从上向下遍历的过程。slice是要输出的结果，path用来存储之前走过的路径。只有当sum == 0完全符合条件的时候才将之前存的所有路径都放入切片。</p>
<p>PS: slice的切片是左闭右开的，所以<code>len(stack) - 1</code>相当于退出去了一位数。</p>
<h2 id="8-13-构造一颗二叉树"><a href="#8-13-构造一颗二叉树" class="headerlink" title="8.13 构造一颗二叉树"></a>8.13 构造一颗二叉树</h2><p><strong>106. Construct Binary Tree from Inorder and Postorder Traversal</strong></p>
<p><strong>Q：</strong>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(inorder []<span class="hljs-type">int</span>, postorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>   	postorderLen := <span class="hljs-built_in">len</span>(postorder)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>		root := &amp;TreeNode&#123;Val: postorder[postorderLen<span class="hljs-number">-1</span>]&#125;<br>    postorder = postorder[:postorderLen<span class="hljs-number">-1</span>]<br>    <br>    <span class="hljs-keyword">for</span> pos, node := <span class="hljs-keyword">range</span> inorder &#123;<br>        <span class="hljs-keyword">if</span> node == root.Val &#123;<br>            root.Left = buildTree(inorder[:pos], postorder[:<span class="hljs-built_in">len</span>(inorder[:pos])])<br>            root.Right = buildTree(inorder[pos+<span class="hljs-number">1</span>:], postorder[<span class="hljs-built_in">len</span>(inorder[:pos]):])<br>        &#125;<br>		&#125;<br>	  <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>来看一下一共分几步：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到当前节点在中序的位置，此处节点看为根</li>
<li>第四步：<code>root.Left = buildTree(inorder[:pos], postorder[:len(inorder[:pos])])</code>区间是左闭右开，所以我们进行切片，取中序中此点的左侧，和后序中的左边。</li>
<li>第五步：<code>root.Right = buildTree(inorder[pos+1:], postorder[len(inorder[:pos]):])</code>区间是左闭右开，进行切片，取中序中此点的右侧，和后序列中的右边（因为已经抛开了根节点，所以右侧的所有都是右子树的所有内容。</li>
</ul>
<p>全程都是抠出来后序遍历中的数值制作节点，root.Left = [ return root ] 同理right也是这样，我们每一层叠戴的都是下一层的某一个根节点</p>
<p><strong>105. Construct Binary Tree from Preorder and Inorder Traversal</strong></p>
<p><strong>Q：</strong>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    root := &amp;TreeNode&#123; Val: preorder[<span class="hljs-number">0</span>] &#125;    <br>    preorder = preorder[<span class="hljs-number">1</span>:]  <span class="hljs-comment">// poll the first preorder value</span><br>    <br>    <span class="hljs-keyword">for</span> pos, node := <span class="hljs-keyword">range</span> inorder &#123; <span class="hljs-comment">// preorder:(before) N L R (now) L R</span><br>        <span class="hljs-keyword">if</span> node == root.Val &#123;<br>            root.Left = buildTree(preorder[:pos], inorder[:pos])<br>            root.Right = buildTree(preorder[pos:], inorder[pos+<span class="hljs-number">1</span>:])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同理上面的不同的是，pos这里是inorder中L的长度。</p>
<h2 id="8-14-合并两个二叉树"><a href="#8-14-合并两个二叉树" class="headerlink" title="8.14 合并两个二叉树"></a>8.14 合并两个二叉树</h2><p><strong>617. Merge Two Binary Trees</strong></p>
<p><strong>Q：</strong>You are given two binary trees <code>root1</code> and <code>root2</code>.</p>
<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>
<p>Return <em>the merged tree</em>.</p>
<p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTrees</span><span class="hljs-params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root2 &#125;<br>    <span class="hljs-keyword">if</span> root2 == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root1 &#125;<br>    <br>    root1.Val += root2.Val<br>    root1.Left = mergeTrees(root1.Left, root2.Left)<br>    root1.Right = mergeTrees(root1.Right, root2.Right)<br>    <span class="hljs-keyword">return</span> root1<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以其中一个为根，以其中一个为参照物进行合并。</p>
<ul>
<li>简单题。采用深搜的思路，分别从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。两个二叉树的对应节点可能存在以下三种情况：<ul>
<li>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</li>
<li>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</li>
<li>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</li>
</ul>
</li>
<li>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。用递归实现即可</li>
</ul>
<h2 id="8-15-二叉搜索树中的搜索"><a href="#8-15-二叉搜索树中的搜索" class="headerlink" title="8.15 二叉搜索树中的搜索"></a>8.15 二叉搜索树中的搜索</h2><p><strong>700. Search in a Binary Search Tree</strong></p>
<p><strong>Q：</strong>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p>
<p>Find the node in the BST that the node’s value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || root.Val == val &#123; <span class="hljs-keyword">return</span> root &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Val &gt; val &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.Left, val)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt; val &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.Right, val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<p><strong>因为搜索到目标节点了，就要立即return了，这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。</strong></p>
<p>（如果你没有写return那么就算找到了我们也没有回去的路了，相当于是停在了找到的点那里）</p>
<h2 id="8-16-验证二叉搜索树"><a href="#8-16-验证二叉搜索树" class="headerlink" title="8.16 验证二叉搜索树"></a>8.16 验证二叉搜索树</h2><p><strong>98. Validate Binary Search Tree</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>
<p>A <strong>valid BST</strong> is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong>the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;&#125;<br>    inOrder(root, &amp;arr)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>        <span class="hljs-keyword">if</span> arr[i - <span class="hljs-number">1</span>] &gt;= arr[i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, arr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, arr)<br>    *arr = <span class="hljs-built_in">append</span>(*arr, root.Val)<br>    inOrder(root.Right, arr)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。</strong></p>
<p>中序遍历，验证遍历的元素是不是从小到大。我们先存储左根右的数组序列，然后check他的顺序是否是对的。</p>
<p><code>*arr = append(*arr, root.Val)</code>这里如果不加*的话，代表arr就是个指向isValidBST的arr的一个指针，加了星号才能提取到他指向的内容，并且操作他指向的内容！</p>
<h2 id="8-17-二叉搜索树的最小绝对值差"><a href="#8-17-二叉搜索树的最小绝对值差" class="headerlink" title="8.17 二叉搜索树的最小绝对值差"></a>8.17 二叉搜索树的最小绝对值差</h2><p><strong>530. Minimum Absolute Difference in BST</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum absolute difference between the values of any two different nodes in the tree</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;&#125;<br>    inOrder(root, &amp;arr)<br>    diff := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>        diff = <span class="hljs-built_in">append</span>(diff, abs(arr[i - <span class="hljs-number">1</span>] - arr[i]))<br>    &#125;<br>    fmt.Print(<span class="hljs-string">&quot;diff: &quot;</span>)<br>    fmt.Println(diff)<br>    min := diff[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(diff); j++ &#123;<br>        <span class="hljs-keyword">if</span> diff[j] &lt; min &#123;<br>            min = diff[j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> min<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -a<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, arr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, arr)<br>    *arr = <span class="hljs-built_in">append</span>(*arr, root.Val)<br>    inOrder(root.Right, arr)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>由于是 BST 树，利用它有序的性质，中根遍历的结果是有序的。中根遍历过程中动态维护前后两个节点的差值，即可找到最小差值。</li>
<li>此题与第 783 题完全相同。</li>
</ul>
<h2 id="8-18-二叉搜索树中的众数"><a href="#8-18-二叉搜索树中的众数" class="headerlink" title="8.18 二叉搜索树中的众数"></a>8.18 二叉搜索树中的众数</h2><p><strong>501. Find Mode in Binary Search Tree</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary search tree (BST) with duplicates, return <em>all the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mode_(statistics">mode(s)</a>) (i.e., the most frequently occurred element) in it</em>.</p>
<p>If the tree has more than one mode, return them in <strong>any order</strong>.</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMode</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    inOrder(root, m)<br>    max := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">if</span> val &gt;= max &#123;<br>            max = val<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">if</span> val == max &#123;<br>            res = <span class="hljs-built_in">append</span>(res, key)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, m)<br>    <span class="hljs-keyword">if</span> _, exist := m[root.Val]; !exist &#123;<br>        m[root.Val] = <span class="hljs-number">1</span><br>    &#125;<br>    m[root.Val] += <span class="hljs-number">1</span><br>    inOrder(root.Right, m)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-19-二叉树的最近公共祖先"><a href="#8-19-二叉树的最近公共祖先" class="headerlink" title="8.19 二叉树的最近公共祖先"></a>8.19 二叉树的最近公共祖先</h2><p><strong>236. Lowest Common Ancestor of a Binary Tree</strong></p>
<p><strong>Q：</strong>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// stop</span><br>    <span class="hljs-keyword">if</span> root == p || root == q || root == <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-comment">// left</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br>    <span class="hljs-comment">// right</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br>    <span class="hljs-comment">// root</span><br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &amp;&amp; left != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 搜索一条边的写法：</span><br><span class="hljs-keyword">if</span> (递归函数(root.left)) <span class="hljs-keyword">return</span> <br><br><span class="hljs-keyword">if</span> (递归函数(root.right)) <span class="hljs-keyword">return</span> <br><br><span class="hljs-comment">// 搜索整个树写法：</span><br>left = 递归函数(root.left)<br>right = 递归函数(root.right)<br>left与right的逻辑处理<br></code></pre></td></tr></table></figure>
<p>注意：</p>
<p>1、p和q如果写了肯定是在这个BST里面的，所以必然不会有nil的结果。</p>
<p>2、我们为什么要回溯某一个right或者left？如果是最简单的情况，我们找的p和q在同一个子树上面，那么返回的就是他们的祖先，如果不在同一个子树上面，返回的就是他们的根节点。知道了这个规则以后，就很好理解了为什么要返回right或者left了，并且为什么是从下往上找而不是从上往下找。逻辑就是，我从下往上左右去找是否有满足的p和q如果都满足了那么此时的root就是p和q的祖父，如果没有满足就是nil，继续往上找。</p>
<h2 id="8-20-在二叉搜索树中插入一个节点"><a href="#8-20-在二叉搜索树中插入一个节点" class="headerlink" title="8.20 在二叉搜索树中插入一个节点"></a>8.20 在二叉搜索树中插入一个节点</h2><p><strong>701. Insert into a Binary Search Tree</strong></p>
<p><strong>Q：</strong>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p>
<p><strong>Notice</strong> that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: val&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &lt; root.Val &#123;<br>        root.Left = insertIntoBST(root.Left, val)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.Right = insertIntoBST(root.Right, val)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实这道题目其实是一道简单题目，<strong>但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人</strong>，瞬间感觉题目复杂了很多。</p>
<p>其实<strong>可以不考虑题目中提示所说的改变树的结构的插入方式。</strong></p>
<p><strong>有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作</strong>。</p>
<p>思路：我们找的是一条边，如果是空的节点的话就是找到了该插入的位置，插入即可，剩下的返回的都是现存的节点值。</p>
<h2 id="8-21-在二叉搜索树中删除一个节点"><a href="#8-21-在二叉搜索树中删除一个节点" class="headerlink" title="8.21 在二叉搜索树中删除一个节点"></a>8.21 在二叉搜索树中删除一个节点</h2><p><strong>450. Delete Node in a BST</strong></p>
<p><strong>Q：</strong>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.</li>
</ol>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(root *TreeNode, key <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val == key &#123;<br>        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Right<br>        &#125;<br>        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Left<br>        &#125;<br>        tmp := root.Right<br>        <span class="hljs-keyword">for</span> tmp.Left != <span class="hljs-literal">nil</span> &#123;<br>            tmp = tmp.Left<br>        &#125;<br>        tmp.Left = root.Left<br>        <span class="hljs-keyword">return</span> root.Right<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> key &lt; root.Val &#123;<br>        root.Left = deleteNode(root.Left, key)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.Right = deleteNode(root.Right, key)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要的点在于考虑删除节点的位置，有以下五种情况：</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<h2 id="8-22-修剪二叉搜索树"><a href="#8-22-修剪二叉搜索树" class="headerlink" title="8.22 修剪二叉搜索树"></a>8.22 修剪二叉搜索树</h2><p><strong>669. Trim a Binary Search Tree</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p>
<p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trimBST</span><span class="hljs-params">(root *TreeNode, low <span class="hljs-type">int</span>, high <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Val &lt; low &#123;<br>        right := trimBST(root.Right, low, high)<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &gt; high &#123;<br>        left := trimBST(root.Left, low, high)<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <br>    root.Right = trimBST(root.Right, low, high)<br>    root.Left = trimBST(root.Left, low, high)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>确定终止条件</li>
</ul>
<p>修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。</p>
<p>思路：</p>
<p>1、如果此时的节点值小于了最小边界（因为是闭区间），那这个节点就废掉，我们找比他大的（他的右子树中是否有符合的节点）</p>
<p>2、如果此时的节点值大于了最大边界（因为是闭区间），那这个节点就废掉，我们找比他小的（他的左子树中是否有符合的节点）</p>
<p>3、拼接分支，类似于之前的用法，如果没有裁剪就返回的是root（当前的节点）如果有裁剪，返回的就是获取的left或者right</p>
<h2 id="8-23-构建一棵平衡二叉树"><a href="#8-23-构建一棵平衡二叉树" class="headerlink" title="8.23 构建一棵平衡二叉树"></a>8.23 构建一棵平衡二叉树</h2><p><strong>108. Convert Sorted Array to Binary Search Tree</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a <strong>height-balanced</strong> binary search tree</em>.</p>
<p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> &amp;TreeNode&#123;<br>        Val: nums[<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>], <br>        Left: sortedArrayToBST(nums[:<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>]), <br>        Right: sortedArrayToBST(nums[<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>:])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>删除二叉树节点，增加二叉树节点，都是用递归函数的返回值来完成，这样是比较方便的。</p>
<ul>
<li>确定递归终止条件</li>
</ul>
<p>如果nums的长度为0，则说明没有数需要放入了，利用了go的切片，注意切片是左闭右开</p>
<p>Step：</p>
<p>1、将此时的节点值写成nums的中心</p>
<p>2、左支是此点的左边所有数组</p>
<p>3、右支是此点右边的所有数组</p>
<p>4、迭代，终止条件如上</p>
<h1 id="第9章-回溯算法"><a href="#第9章-回溯算法" class="headerlink" title="第9章 回溯算法"></a>第9章 回溯算法</h1><p>回溯问题的模板</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">backtracking(参数) &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="9-1-组合问题"><a href="#9-1-组合问题" class="headerlink" title="9.1 组合问题"></a>9.1 组合问题</h2><p><strong>77. Combinations</strong></p>
<p><strong>Q：</strong>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers out of the range</em> <code>[1, n]</code>.</p>
<p>You may return the answer in <strong>any order</strong>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span> || k &gt; n &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;  <span class="hljs-comment">// c is combine</span><br>    generateCombinations(n, k, <span class="hljs-number">1</span>, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateCombinations</span><span class="hljs-params">(n, k, start <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == k &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// for i := start; i &lt;= n; i++ 不剪枝头的写法</span><br>    <span class="hljs-keyword">for</span> i := start; i &lt;= n - (k - <span class="hljs-built_in">len</span>(c)) + <span class="hljs-number">1</span>; i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, i)<br>        generateCombinations(n, k, i + <span class="hljs-number">1</span>, c, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195242899.png" srcset="/img/loading.gif" lazyload alt="77. Combinations"></p>
<p><code>i &lt;= n - (k - len(c)) + 1</code>这个条件很关键他可以帮助我们减少分支，去除那些本身为空的答案。n 本身是我们可选项的上限，我们只靠start来控制不重复。</p>
<ol>
<li>已经选择的元素个数：len(c)</li>
<li>还需要的元素个数为: k - len(c)          （从后往前数，最开始一层就是k，所以倒数后k个数是最远的起始位置）</li>
<li><p>在集合n中至多要从该起始位置 : n - (k - len(c)) + 1(start)，开始遍历  </p>
<p>(翻译过来就是如果总共的n个数减去我们还需要的元素后剩余的最大个数，作为我们起始位置的最远端)</p>
</li>
</ol>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
<h2 id="9-2-组合总和-III"><a href="#9-2-组合总和-III" class="headerlink" title="9.2 组合总和 III"></a>9.2 组合总和 III</h2><p><strong>216. Combination Sum III</strong></p>
<p><strong>Q：</strong>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>
<ul>
<li>Only numbers <code>1</code> through <code>9</code> are used.</li>
<li>Each number is used <strong>at most once</strong>.</li>
</ul>
<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum3</span><span class="hljs-params">(k <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span> || k &gt; n &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    generateCombinations(k, n, <span class="hljs-number">1</span>, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateCombinations</span><span class="hljs-params">(k, target, start <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == k &amp;&amp; target == <span class="hljs-number">0</span>&#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>  <br>  	<span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> &#125;<br><br>    <span class="hljs-keyword">for</span> i := start; i &lt;= <span class="hljs-number">9</span>; i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, i)<br>        generateCombinations(k, target - i, i + <span class="hljs-number">1</span>, c, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>雷同77题，不过遇到一个问题就是当对i进行剪枝的时候，他会爆栈。</p>
<h2 id="9-3-电话号码的字母组合"><a href="#9-3-电话号码的字母组合" class="headerlink" title="9.3 电话号码的字母组合"></a>9.3 电话号码的字母组合</h2><p><strong>17. Letter Combinations of a Phone Number</strong></p>
<p><strong>Q：</strong>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>
<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> result []<span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;2&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;3&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;4&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;5&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;j&quot;</span>, <span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;6&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;7&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;8&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;v&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;9&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(digits <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    result = []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> digits == <span class="hljs-string">&quot;&quot;</span> &#123;<br>     	 <span class="hljs-keyword">return</span> result<br>    &#125;<br>    letterFunc(<span class="hljs-string">&quot;&quot;</span>, digits)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterFunc</span><span class="hljs-params">(res <span class="hljs-type">string</span>, digits <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> digits == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        result = <span class="hljs-built_in">append</span>(result, res)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    k := digits[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]	<span class="hljs-comment">// 选取第一个字母</span><br>    digits = digits[<span class="hljs-number">1</span>:]	 <span class="hljs-comment">// 剔除第一个字母</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dict[k]); i++ &#123;<br>        res += dict[k][i]<br>        letterFunc(res, digits)<br>        res = res[:<span class="hljs-built_in">len</span>(res) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于go中string的理解不够深。string的处理使用切片的，并且切片以后才能slice才是可以用append的。</p>
<p><img src="https://img-blog.csdnimg.cn/20201123200304469.png" srcset="/img/loading.gif" lazyload alt="17. 电话号码的字母组合"></p>
<p>剩下的就是按照回溯的公式去套题。for里面装的是每层要处理的子集。</p>
<h2 id="9-4-组合总和（二）"><a href="#9-4-组合总和（二）" class="headerlink" title="9.4 组合总和（二）"></a>9.4 组合总和（二）</h2><p><strong>39. Combination Sum</strong></p>
<p><strong>Q：</strong>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>
<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>
<p>It is <strong>guaranteed</strong> that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    findCombination(candidates, c, target, <span class="hljs-number">0</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCombination</span><span class="hljs-params">(cand, c []<span class="hljs-type">int</span>, target, index <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(cand); i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, cand[i])<br>        findCombination(cand, c, target - cand[i], i, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为元素可以重复，所以index和i组合保证他不往回头（向前）找元素就可以了。</p>
<p>✨<strong>其中为什么一定要有c附魔给b呢？</strong>这里是深复制和浅复制的问题。如果不 copy 一份，直接把 c 加入到 res 结果数组中，下一轮递归过程中，c 会变，这个变化也会影响到 res 里面的值。如果还不明白的话，你可以把 copy c 的那 2 行代码注释掉，直接把 c append 到 res 中，你再看输出结果就能看到原因了。</p>
<p><strong>浅拷贝</strong>: 对于仅仅是复制了引用（地址），换句话说，复制了之后，原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响，为<strong>浅拷贝</strong>。 <strong>深拷贝</strong>：而如果是在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响，为<strong>深拷贝</strong></p>
<p>（简而言之：浅拷贝拷贝的是值，他和原本的指针指的是同一个地方，类似引用，当指针所指内容变了这个拷贝值也变；而深拷贝拷贝的是另一个对象，一个一模一样的对象但是占用的另一个空间，这样就算前者再变也不会影响新拷贝出来的对象）</p>
<h2 id="9-5-组合总和（三）"><a href="#9-5-组合总和（三）" class="headerlink" title="9.5 组合总和（三）"></a>9.5 组合总和（三）</h2><p><strong>40. Combination Sum II</strong></p>
<p><strong>Q：</strong>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate combinations.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum2</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(candidates) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>	&#125;<br>	c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>	sort.Ints(candidates) <span class="hljs-comment">// 这里是去重的关键逻辑</span><br>    findCombination(candidates, c, target, <span class="hljs-number">0</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCombination</span><span class="hljs-params">(cand, c []<span class="hljs-type">int</span>, target, index <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(cand); i++ &#123;<br>        <span class="hljs-comment">// 这里是去重的关键逻辑,本次不取重复数字，下次循环可能会取重复数字</span><br>        <span class="hljs-keyword">if</span> i &gt; index &amp;&amp; cand[i] == cand[i<span class="hljs-number">-1</span>] &#123; <br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>        c = <span class="hljs-built_in">append</span>(c, cand[i])<br>        findCombination(cand, c, target - cand[i], i + <span class="hljs-number">1</span>, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>题目要求出总和为 sum 的所有组合，组合需要去重。这一题是第 39 题的加强版，第 39 题中元素可以重复利用(重复元素可无限次使用)，这一题中元素只能有限次数的利用，因为存在重复元素，并且每个元素只能用一次(重复元素只能使用有限次)</li>
<li>这一题和第 47 题类似，只不过元素可以反复使用。</li>
<li>总体来说需要注意的两个重复位置，第一个是通过取得重复的根，从而得到两个同样的结果，第二个就是出现前后颠倒但集合相同的问题。</li>
</ul>
<p>所以先排好序（保证了结果肯定是递增的顺序，不会出现 [1, 7] 和 [7, 1] 这种组合，再判断。i &gt; index 表示除了本层的第一个选取的数以外的数，并且这个数和前一个数相同的话跳过。本质上这个判断是去除同一层重复获取的数字是forbidden的。</p>
<p>选择过程树形结构如图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20201123202736384.png" srcset="/img/loading.gif" lazyload alt="40.组合总和II"></p>
<h2 id="9-6-分割回文串"><a href="#9-6-分割回文串" class="headerlink" title="9.6 分割回文串"></a>9.6 分割回文串</h2><p><strong>131. Palindrome Partitioning</strong></p>
<p><strong>Q：</strong>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a <strong>palindrome</strong>. Return all possible palindrome partitioning of <code>s</code>.</p>
<p>A <strong>palindrome</strong> string is a string that reads the same backward as forward.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    c, res := []<span class="hljs-type">string</span>&#123;&#125;, [][]<span class="hljs-type">string</span>&#123;&#125;<br>    findPartition(<span class="hljs-number">0</span>, s, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPartition</span><span class="hljs-params">(start <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, c []<span class="hljs-type">string</span>, res *[][]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(s) &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        sub := s[start : i + <span class="hljs-number">1</span>]  <span class="hljs-comment">// partition</span><br>        <span class="hljs-keyword">if</span> IsPalindrome(sub) &#123; <span class="hljs-comment">// combine</span><br>            c = <span class="hljs-built_in">append</span>(c, sub)<br>            findPartition(i + <span class="hljs-number">1</span>, s, c, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    length := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= length/<span class="hljs-number">2</span>; i++ &#123;<br>      	<span class="hljs-keyword">if</span> s[i] != s[length - <span class="hljs-number">1</span> - i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      	&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>其树形结构为下图</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" srcset="/img/loading.gif" lazyload alt="131.分割回文串"></p>
<p>这一题的关键在于分割和组合的思想。要先切割，判断是否符合回文串？符合的话才继续进行组合递归下一层。</p>
<h2 id="9-7-复原IP地址"><a href="#9-7-复原IP地址" class="headerlink" title="9.7 复原IP地址"></a>9.7 复原IP地址</h2><p><strong>93. Restore IP Addresses</strong></p>
<p><strong>Q：</strong>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p>
<ul>
<li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li>
</ul>
<p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into</em> <code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br>		<span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>	&#125;<br>	res, ip := []<span class="hljs-type">string</span>&#123;&#125;, []<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ip, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s <span class="hljs-type">string</span>, start, cut <span class="hljs-type">int</span>, ip []<span class="hljs-type">int</span>, res *[]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> cut == <span class="hljs-number">4</span> &amp;&amp; start == <span class="hljs-built_in">len</span>(s) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ip))<br>        <span class="hljs-built_in">copy</span>(tmp, ip)<br>        resIp := getIp(tmp)<br>        *res = <span class="hljs-built_in">append</span>(*res, resIp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> cut &gt; <span class="hljs-number">4</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        sub := s[start : i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> isValid(sub) &#123;<br>            tmp, _ := strconv.Atoi(sub)<br>            ip = <span class="hljs-built_in">append</span>(ip, tmp)<br>            cut++<br>            dfs(s, i + <span class="hljs-number">1</span>, cut, ip, res)<br>            ip = ip[:<span class="hljs-built_in">len</span>(ip) - <span class="hljs-number">1</span>]<br>            cut--<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; <span class="hljs-built_in">len</span>(s) != <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 0开头的不可以</span><br>    tmp, _ := strconv.Atoi(s)<br>    <span class="hljs-keyword">if</span> (tmp &gt; <span class="hljs-number">255</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIp</span><span class="hljs-params">(ip []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    resIp := strconv.Itoa(ip[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(ip); i++ &#123;<br>      	resIp += <span class="hljs-string">&quot;.&quot;</span> + strconv.Itoa(ip[i])<br>    &#125;<br>		<span class="hljs-keyword">return</span> resIp<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要考虑到如下三点：</p>
<ul>
<li>段位以0为开头的数字不合法</li>
<li>段位里有非正整数字符不合法</li>
<li>段位如果大于255了不合法</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201123203735933.png" srcset="/img/loading.gif" lazyload alt="93.复原IP地址"></p>
<p>对于语法的一些注意点，首先int转string（strconv.Itoa）是返回一个值的；string转int（strconv.Atoi）是返回两个值的。</p>
<p>一些注意点，这道题和分割回文串是很类似的，思想是一样的。首先我们要分割，接着我们要判断分割的sub是否符合条件，如果符合才继续深入到下一层，如果不符合就不继续。</p>
<h2 id="9-8-子集问题（一）"><a href="#9-8-子集问题（一）" class="headerlink" title="9.8 子集问题（一）"></a>9.8 子集问题（一）</h2><p><strong>78. Subsets</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p>
<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    cur, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(<span class="hljs-number">0</span>, nums, cur, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, nums, cur []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>  	<span class="hljs-comment">// 和之前最不一样的地方就是这里，不限制到叶子结点才加入res</span><br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cur))<br>    <span class="hljs-built_in">copy</span>(tmp, cur)<br>    *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>    <br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(nums) &#123; <span class="hljs-keyword">return</span> &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        cur = <span class="hljs-built_in">append</span>(cur, nums[i]) <span class="hljs-comment">// 原来是切掉一部分，现在是找某一个值</span><br>        dfs(i + <span class="hljs-number">1</span>, nums, cur, res)<br>        cur = cur[:<span class="hljs-built_in">len</span>(cur) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p>
<p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p>
<p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong></p>
<p><img src="https://img-blog.csdnimg.cn/202011232041348.png" srcset="/img/loading.gif" lazyload alt="78.子集"></p>
<p>从图中红线部分，可以看出<strong>遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合</strong>。</p>
<h2 id="9-9-子集问题（二）"><a href="#9-9-子集问题（二）" class="headerlink" title="9.9 子集问题（二）"></a><strong>9.9 子集问题（二）</strong></h2><p><strong>90. Subsets II</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible subsets (the power set)</em>.</p>
<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsetsWithDup</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    cur, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    sort.Ints(nums)<br>    dfs(<span class="hljs-number">0</span>, nums, cur, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, nums, cur []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cur))<br>    <span class="hljs-built_in">copy</span>(tmp, cur)<br>    *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>    <br>    <span class="hljs-comment">// if start == len(nums) &#123; return &#125;</span><br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> i &gt; start &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        cur = <span class="hljs-built_in">append</span>(cur, nums[i]) <br>        dfs(i + <span class="hljs-number">1</span>, nums, cur, res)<br>        cur = cur[:<span class="hljs-built_in">len</span>(cur) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于 []int, []float, []string 这种元素类型是基础类型的切片使用 sort 包提供的下面几个函数进行排序。</p>
<p>sort.Ints<br>sort.Floats<br>sort.Strings</p>
<p>用到了之前剪枝的方法，先排序，这样保证如果重复的元素都是挨着的</p>
<h2 id="9-10-递增子序列"><a href="#9-10-递增子序列" class="headerlink" title="9.10 递增子序列"></a>9.10 递增子序列</h2><p><strong>491. Increasing Subsequences</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code>, return all the different possible increasing subsequences of the given array with <strong>at least two elements</strong>. You may return the answer in <strong>any order</strong>.</p>
<p>The given array may contain duplicates, and two equal integers should also be considered a special case of increasing sequence.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findSubsequences</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    c, visited, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> _, ok := visited[nums[i]]; ok &#123;<br>          	<span class="hljs-keyword">continue</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            visited[nums[i]] = <span class="hljs-literal">true</span><br>            generateIncSubsets(nums, i, c, &amp;res)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateIncSubsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, current <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    c = <span class="hljs-built_in">append</span>(c, nums[current])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) &gt;= <span class="hljs-number">2</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>    &#125;<br>    visited := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := current + <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>      	<span class="hljs-comment">// 如果当前数值大于前一个数值，并且没有用过，进入DFS下一层</span><br>        <span class="hljs-keyword">if</span> nums[current] &lt;= nums[i] &#123;<br>            <span class="hljs-keyword">if</span> _, ok := visited[nums[i]]; ok &#123;<br>              	<span class="hljs-keyword">continue</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                visited[nums[i]] = <span class="hljs-literal">true</span><br>                generateIncSubsets(nums, i, c, res)<br>            &#125;<br>        &#125;<br>    &#125;<br>    c = c[:<span class="hljs-built_in">len</span>(c)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>给出一个数组，要求找出这个数组中所有长度大于 2 的非递减子序列。子序列顺序和原数组元素下标必须是顺序的，不能是逆序的。</li>
<li>这一题和第 78 题和第 90 题是类似的题目。第 78 题和第 90 题是求所有子序列，这一题在这两题的基础上增加了非递减和长度大于 2 的条件。需要注意的两点是，原数组中元素可能会重复，最终结果输出的时候需要去重。最终结果输出的去重用 map 处理，数组中重复元素用 DFS 遍历搜索。在每次 DFS 中，用 map 记录遍历过的元素，保证本轮 DFS 中不出现重复的元素，递归到下一层还可以选择值相同，但是下标不同的另外一个元素。外层循环也要加一个 map，这个 map 是过滤每组解因为重复元素导致的重复解，经过过滤以后，起点不同了，最终的解也会不同。</li>
<li>重点在于对于同一层不能够重复</li>
</ul>
<p>树结构</p>
<p><img src="https://img-blog.csdnimg.cn/20201124200229824.png" srcset="/img/loading.gif" lazyload alt="491. 递增子序列1"></p>
<h2 id="9-11-排列问题（一）"><a href="#9-11-排列问题（一）" class="headerlink" title="9.11 排列问题（一）"></a>9.11 排列问题（一）</h2><p><strong>46. Permutations</strong></p>
<p><strong>Q：</strong>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>    	  <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>		&#125;<br>    c, used, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(nums, c, used, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, used <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(tmp, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> !used[nums[i]] &#123;<br>          	used[nums[i]] = <span class="hljs-literal">true</span><br>            c = <span class="hljs-built_in">append</span>(c, nums[i])<br>            dfs(nums, c, used, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>            used[nums[i]] = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>树状图</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" srcset="/img/loading.gif" lazyload alt="46.全排列"></p>
<p>大家此时可以感受出排列问题的不同：</p>
<ul>
<li>每层都是从0开始搜索而不是startIndex</li>
<li>需要used数组记录path里都放了哪些元素了</li>
</ul>
<p>排列问题是回溯算法解决的经典题目。</p>
<p>注意map[key]的返回值（value，isExist）</p>
<h2 id="9-12-排列问题（二）"><a href="#9-12-排列问题（二）" class="headerlink" title="9.12 排列问题（二）"></a>9.12 排列问题（二）</h2><p><strong>47. Permutations II</strong></p>
<p><strong>Q：</strong>Given a collection of numbers, <code>nums</code>, that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permuteUnique</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>    	  <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>		&#125;<br>    c, used, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    sort.Ints(nums)<br>    dfs(nums, c, used, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, used <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(tmp, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> !used[i] &#123;<br>          	<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>] &#123; <span class="hljs-comment">// 关键去重语句</span><br>              	<span class="hljs-comment">// 当前数值的数在前面已经出现过，并且他的前一个数没有被用过才跳过</span><br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            used[i] = <span class="hljs-literal">true</span><br>            c = <span class="hljs-built_in">append</span>(c, nums[i])<br>            dfs(nums, c, used, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>            used[i] = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>树状图</p>
<p><img src="https://img-blog.csdnimg.cn/20201124201331223.png" srcset="/img/loading.gif" lazyload alt="47.全排列II1"></p>
<p>和 9.11 不同的是我们不但要消除纵向的重复，也要消除横向的重复。纵向的重复就不能单单只是消除。</p>
<p><code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]</code>为什么要加 !used[i - 1] 呢？因为每一层都要遍历所有的数，如果只是单单的nums[i] == nums[i-1] 就跳过的话，那么所有的层都会跳过，加入 !used[i - 1] 后代表着，在同一层的情况下（因为同一层如果相同的话只能选择其中一个数字，所以相同的数字只能有一位是 true 其他都是 false）如果当前数字和前一个相同的时候跳过。</p>
<h2 id="9-13-N-皇后问题"><a href="#9-13-N-皇后问题" class="headerlink" title="9.13 N 皇后问题"></a>9.13 N 皇后问题</h2><p><strong>51. N-Queens</strong></p>
<p><strong>Q：</strong>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code>chessboard such that no two queens attack each other.</p>
<p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space, respectively.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    idx, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">string</span>&#123;&#125;<br>    dfs(n, <span class="hljs-number">0</span>, idx, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(n, row <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> row == n &#123;<br>        *res = <span class="hljs-built_in">append</span>(*res, generateBoard(n, idx))<br>        fmt.Println()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>        <span class="hljs-keyword">if</span> isValid(row, col, n, idx) &#123;<br>            idx = <span class="hljs-built_in">append</span>(idx, col)<br>            dfs(n, row + <span class="hljs-number">1</span>, idx, res)<br>            idx = idx[:<span class="hljs-built_in">len</span>(idx) - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(row, col, n <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    col45 := col<br>    col135 := col<br>    <span class="hljs-comment">// 检查列</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(idx); i++ &#123;<br>        <span class="hljs-keyword">if</span> col == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查45˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col45++<br>        <span class="hljs-keyword">if</span> col45 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查135˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col135--<br>        <span class="hljs-keyword">if</span> col135 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateBoard</span><span class="hljs-params">(n <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    board := []<span class="hljs-type">string</span>&#123;&#125;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>      	res += <span class="hljs-string">&quot;.&quot;</span><br>    &#125;<br>    <span class="hljs-comment">// 生成棋盘让所有的内容都是...</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; n; row++ &#123;<br>     	 	board = <span class="hljs-built_in">append</span>(board, res)<br>    &#125;<br>    <span class="hljs-comment">// 按照收集到的位置，进行改写有皇后的位置</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; n; row++ &#123;<br>        tmp := []<span class="hljs-type">byte</span>(board[row]) <span class="hljs-comment">// byte才能够修改string的某一位</span><br>        tmp[idx[row]] = <span class="hljs-string">&#x27;Q&#x27;</span><br>        board[row] = <span class="hljs-type">string</span>(tmp)<br>    &#125;<br>    <span class="hljs-keyword">return</span> board<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先来看一下皇后们的约束条件：</p>
<ol>
<li>不能同行</li>
<li>不能同列</li>
<li>不能同斜线</li>
</ol>
<p>树结构</p>
<p><img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" srcset="/img/loading.gif" lazyload alt="51.N皇后"></p>
<p>这种题的大概dfs流程是这样的，首先确定终止条件，然后是难点在于要判断是否要进入下一层这个判断条件是一个难点，第二个难点就是生成棋盘的时间，我是先记录要放棋子的位置再放在最后来生成，也可以从始至终就生成一点点填充。总体来说这两种方法不同的点在于判断的过程不同。</p>
<h2 id="9-14-解数独"><a href="#9-14-解数独" class="headerlink" title="9.14 解数独"></a>9.14 解数独</h2><p><strong>37. Sudoku Solver</strong></p>
<p><strong>Q：</strong>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p>
<ol>
<li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li>
<li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li>
<li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code>sub-boxes of the grid.</li>
</ol>
<p>The <code>&#39;.&#39;</code> character indicates empty cells.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>)</span></span>  &#123;<br>    dfs(&amp;board)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(board *[][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// scan</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">9</span>; row++ &#123;<br>        <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; <span class="hljs-number">9</span>; col++ &#123;<br>            <span class="hljs-keyword">if</span> (*board)[row][col] != <span class="hljs-string">&#x27;.&#x27;</span> &#123; <span class="hljs-keyword">continue</span> &#125;<br>            <span class="hljs-comment">// fill</span><br>            <span class="hljs-keyword">var</span> num <span class="hljs-type">byte</span><br>            <span class="hljs-keyword">for</span> num = <span class="hljs-string">&#x27;1&#x27;</span>; num &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; num++ &#123;<br>                <span class="hljs-keyword">if</span> isValid(row, col, num, board) &#123;<br>                  (*board)[row][col] = num   <span class="hljs-comment">// 填充</span><br>                  <span class="hljs-keyword">if</span> dfs(board) == <span class="hljs-literal">true</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                  (*board)[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>   <span class="hljs-comment">// 回溯</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 遍历完了都没有false，返回true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(row, col <span class="hljs-type">int</span>, num <span class="hljs-type">byte</span>, board *[][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>		<span class="hljs-comment">// check row</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> num == (*board)[i][col] &#123;<br>          	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// check col</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++ &#123;<br>        <span class="hljs-keyword">if</span> num == (*board)[row][j] &#123;<br>          	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// check inner-9</span><br>    startRow := (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span><br>    startCol := (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">for</span> i := startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> num == (*board)[i][j] &#123;<br>              	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>树状图：</p>
<p><img src="https://img-blog.csdnimg.cn/2020111720451790.png" srcset="/img/loading.gif" lazyload alt="37.解数独"></p>
<p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p>
<p>判断棋盘是否合法有如下三个维度：</p>
<ul>
<li>同行是否重复</li>
<li>同列是否重复</li>
<li>9宫格里是否重复</li>
</ul>
<p>注意如果要提取二维数组的地址的元素的话要写 (*a)[ ] [ ] 这样。</p>
<p>在 check inner-9 的时候遇到检查那9块的问题。首先他们的起始点有 (0, 0) (3, 3) (6, 6)…..通过除 3 以后发现在第一块，但具体的坐标要乘 3 因为毕竟除法过（0，1，2来进行乘法）</p>
<p>答案有可能不唯一，真正退出的位置是在<code>if dfs(board) == true &#123; return true &#125; // 如果找到合适一组立刻返回</code>这一行。</p>
<h1 id="第10章-贪心算法"><a href="#第10章-贪心算法" class="headerlink" title="第10章 贪心算法"></a>第10章 贪心算法</h1><ul>
<li>将问题分解为若子问题。</li>
<li>找出适合的贪心策略。</li>
<li>求解每一个子问题的最优解。</li>
<li>将局部最优堆叠成全局最优</li>
</ul>
<h2 id="10-1-分发饼干"><a href="#10-1-分发饼干" class="headerlink" title="10.1 分发饼干"></a>10.1 分发饼干</h2><p><strong>455. Assign Cookie</strong></p>
<p><strong>Q：</strong>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p>
<p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code>will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(g []<span class="hljs-type">int</span>, s []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	sort.Ints(g)<br>	sort.Ints(s)<br>	gi, si, res := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> gi &lt; <span class="hljs-built_in">len</span>(g) &amp;&amp; si &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>		<span class="hljs-keyword">if</span> s[si] &gt;= g[gi] &#123;<br>			res++<br>			si++<br>			gi++<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			si++<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。</p>
<p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p>
<p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>
<p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p>
<p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p>
<ul>
<li>假设你想给小朋友们饼干，每个小朋友最多能够给一块饼干。每个小朋友都有一个“贪心指数”，称为 <code>g[i]</code>，<code>g[i]</code> 表示的是这名小朋友需要的饼干大小的最小值。同时，每个饼干都有一个大小值 <code>s[i]</code>，如果 <code>s[j] ≥ g[i]</code>，我们将饼干 <code>j</code> 分给小朋友 <code>i</code> 后，小朋友会很开心。给定数组 <code>g[]</code> 和 <code>s[]</code>，问如何分配饼干，能让更多的小朋友开心。</li>
<li>这是一道典型的简单贪心题。贪心题一般都伴随着排序。将 <code>g[]</code> 和 <code>s[]</code> 分别排序。按照最难满足的小朋友开始给饼干，依次往下满足，最终能满足的小朋友数就是最终解。</li>
</ul>
<p>注意一个饼干最多给一个孩子。</p>
<h2 id="10-2-摆动排序"><a href="#10-2-摆动排序" class="headerlink" title="10.2 摆动排序"></a>10.2 摆动排序</h2><p><strong>376. Wiggle Subsequence</strong></p>
<p><strong>Q：</strong>A <strong>wiggle sequence</strong> is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.</p>
<ul>
<li>For example, <code>[1, 7, 4, 9, 2, 5]</code> is a <strong>wiggle sequence</strong> because the differences <code>(6, -3, 5, -7, 3)</code> alternate between positive and negative.</li>
<li>In contrast, <code>[1, 4, 7, 2, 5]</code> and <code>[1, 7, 4, 5, 5]</code> are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.</li>
</ul>
<p>A <strong>subsequence</strong> is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.</p>
<p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>wiggle subsequence</strong> of</em> <code>nums</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br>	&#125;<br>	res := <span class="hljs-number">1</span><br>	prevDiff := nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>]<br>	<span class="hljs-keyword">if</span> prevDiff != <span class="hljs-number">0</span> &#123;<br>		res = <span class="hljs-number">2</span><br>	&#125;<br>    <span class="hljs-comment">// 从第三个数开始，i下标的位置是 前中后 的后</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        diff := nums[i] - nums[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-comment">// 如果是波峰或者波谷的话</span><br>        <span class="hljs-keyword">if</span> diff &gt; <span class="hljs-number">0</span> &amp;&amp; prevDiff &lt;= <span class="hljs-number">0</span> || diff &lt; <span class="hljs-number">0</span> &amp;&amp; prevDiff &gt;= <span class="hljs-number">0</span> &#123;<br>            res++<br>            prevDiff = diff<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>题目要求找到摆动序列最长的子序列。本题可以用贪心的思路，记录当前序列的上升和下降的趋势。扫描数组过程中，每扫描一个元素都判断是“峰”还是“谷”，根据前一个是“峰”还是“谷”做出对应的决定。利用贪心的思想找到最长的摆动子序列。</li>
</ul>
<p><code>diff &gt; 0 &amp;&amp; prevDiff &lt;= 0 || diff &lt; 0 &amp;&amp; prevDiff &gt;= 0</code>这句的判断里面为什么要有等号呢？因为其实你只要保证在 i - 1 位置之前的都是平的，或者与其后面的单调趋势是相反的，就可以保证单调性的不同（平 to 增减，增 to 减，减 to 增）</p>
<h2 id="10-3-最大子序和"><a href="#10-3-最大子序和" class="headerlink" title="10.3 最大子序和"></a>10.3 最大子序和</h2><p><strong>53. Maximum Subarray</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p>
<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSum := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>      	<span class="hljs-comment">// 就加正数</span><br>        <span class="hljs-keyword">if</span> nums[i] + nums[i<span class="hljs-number">-1</span>] &gt; nums[i] &#123;<br>            nums[i] += nums[i<span class="hljs-number">-1</span>]<br>        &#125;<br>      	<span class="hljs-comment">// 如果当前子序列大于了之前存的总和就存下</span><br>        <span class="hljs-keyword">if</span> nums[i] &gt; maxSum &#123;<br>            maxSum = nums[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>局部最优：</strong>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p>
<p>全局最优：选取最大“连续和”</p>
<p>这个思想主要是不利用额外的存储空间。举例，[-2,1,-3,4,-1,2,1,-5,4] 我们贪心的点在于必须要子序列要是在增加的才加上。尽管倒数第二个 -5 + 6 = 1 是比自身大的但是没有大过 maxSum，也无所谓。所以总结一下就是，我们要加入当前数的前一个数，如果是上升的值就保存，并且如果当前 sum 后整体大于了统计的 max，就更新 max 要不就继续遍历。就像我们的人生一样，我们就记录我们能前进的值，忘掉那些退步的地方，并且记录下我们max的里程碑。</p>
<p>golang的最大值和最小值的定义 <a target="_blank" rel="noopener" href="https://blog.csdn.net/lishanleilixin/article/details/103269904">https://blog.csdn.net/lishanleilixin/article/details/103269904</a></p>
<h2 id="10-4-买卖股票的最佳时机-II"><a href="#10-4-买卖股票的最佳时机-II" class="headerlink" title="10.4 买卖股票的最佳时机 II"></a>10.4 买卖股票的最佳时机 II</h2><p><strong>122. Best Time to Buy and Sell Stock II</strong></p>
<p><strong>Q：</strong>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p>
<p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    profit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        <span class="hljs-keyword">if</span> prices[i] - prices[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &#123;<br>            profit += prices[i] - prices[i - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020112917480858.png" srcset="/img/loading.gif" lazyload alt="122.买卖股票的最佳时机II"></p>
<p>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p>
<p>那么只收集正利润就是贪心所贪的地方！</p>
<p><strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</p>
<h2 id="10-5-跳跃游戏"><a href="#10-5-跳跃游戏" class="headerlink" title="10.5 跳跃游戏"></a>10.5 跳跃游戏</h2><p><strong>55. Jump Game</strong></p>
<p><strong>Q：</strong>You are given an integer array <code>nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p>
<p>Return <code>true</code> <em>if you can reach the last index, or</em> <code>false</code> <em>otherwise</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    cover := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果是跳跃数组的长度为1</span><br>    <span class="hljs-comment">// 每次在当前范围里面找每个数</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= cover; i++ &#123;<br>        cover = max(i + nums[i], cover) <span class="hljs-comment">// 覆盖面的选择，从当前cover范围和当前位置代表的未来cover范围二选一</span><br>        <span class="hljs-keyword">if</span> cover &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果能包含到最后一个位置就代表能跳到</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 没找到就false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> a &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>图片势力</p>
<p><img src="https://img-blog.csdnimg.cn/20201124154758229.png" srcset="/img/loading.gif" lazyload alt="55.跳跃游戏"></p>
<h2 id="10-6-跳跃游戏-II"><a href="#10-6-跳跃游戏-II" class="headerlink" title="10.6 跳跃游戏 II"></a>10.6 跳跃游戏 II</h2><p><strong>45. Jump Game II</strong></p>
<p><strong>Q：</strong>Given an array of non-negative integers <code>nums</code>, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>You can assume that you can always reach the last index.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    curDistance := <span class="hljs-number">0</span> <span class="hljs-comment">// 当前覆盖的最远距离下标</span><br>    step := <span class="hljs-number">0</span> <span class="hljs-comment">// 记录走的最大步数</span><br>    nextDistance := <span class="hljs-number">0</span> <span class="hljs-comment">// 下一步覆盖的最远距离下标</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123; <span class="hljs-comment">// 注意这里是小于等于nums.size() - 2，这是关键所在</span><br>        nextDistance = max(i + nums[i], nextDistance) <span class="hljs-comment">// 更新下一步覆盖的最远距离下标</span><br>        <span class="hljs-keyword">if</span> i == curDistance &#123; <span class="hljs-comment">// 遇到当前覆盖的最远距离下标</span><br>            curDistance = nextDistance <span class="hljs-comment">// 更新当前覆盖的最远距离下标</span><br>            step++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> step<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> a &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>理解本题的关键在于：<strong>以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点</strong>，这个范围内最小步数一定可以跳到，不用管具体是怎么跳的，不纠结于一步究竟跳一个单位还是两个单位。</p>
<p><img src="https://img-blog.csdnimg.cn/20201201232445286.png" srcset="/img/loading.gif" lazyload alt="45.跳跃游戏II2"></p>
<p>一个个找，找每个范围内的最远距离。cur 记录的是当前可以跳的最远距离，所以一旦 i = cur 的时候说明要走下一跳了</p>
<p>（只有 i 到达了上一次记录的最远距离的时候，才更新 cur = next 的最远距离）</p>
<h2 id="10-7-加油站"><a href="#10-7-加油站" class="headerlink" title="10.7 加油站"></a>10.7 加油站</h2><p><strong>134. Gas Station</strong></p>
<p><strong>Q：</strong>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>ith</code> station is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>ith</code> station to its next <code>(i + 1)th</code> station. You begin the journey with an empty tank at one of the gas stations.</p>
<p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong></p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(gas []<span class="hljs-type">int</span>, cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	curSum := <span class="hljs-number">0</span><br>	totalSum := <span class="hljs-number">0</span><br>	start := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(gas); i++ &#123;<br>		curSum += gas[i] - cost[i]<br>		totalSum += gas[i] - cost[i]<br>		<span class="hljs-keyword">if</span> curSum &lt; <span class="hljs-number">0</span> &#123;<br>			start = i+<span class="hljs-number">1</span><br>			curSum = <span class="hljs-number">0</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> totalSum &lt; <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> start<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201213162821958.png" srcset="/img/loading.gif" lazyload alt="134.加油站"></p>
<p>我把所有的差值加一遍只要是能总和大于0肯定能跑完，然后找第一个可以 gas - cost &gt; 0 的位置作为起点</p>
<h2 id="10-8-分发糖果"><a href="#10-8-分发糖果" class="headerlink" title="10.8 分发糖果"></a>10.8 分发糖果</h2><p><strong>135. Candy</strong></p>
<p><strong>Q：</strong>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">candy</span><span class="hljs-params">(ratings []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// initialization</span><br>    candy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ratings))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(ratings); i++ &#123;<br>        candy[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// front to back</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(ratings); i++ &#123;<br>        <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>] &#123;<br>            candy[i] = candy[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    fmt.Println(candy)<br>    <span class="hljs-comment">// back to front</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(ratings) - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] &#123;<br>            candy[i] = max(candy[i], candy[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">// 因为是更新数值，所以用max，并不是单纯的覆盖</span><br>        &#125;<br>    &#125;<br>    fmt.Println(candy)<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> candy &#123;<br>        res += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这在leetcode上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p>
<p>那么本题我采用了两次贪心的策略：</p>
<ul>
<li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li>
<li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li>
</ul>
<p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p>
<h2 id="10-9-柠檬水找零"><a href="#10-9-柠檬水找零" class="headerlink" title="10.9 柠檬水找零"></a>10.9 柠檬水找零</h2><p><strong>860. Lemonade Change</strong></p>
<p><strong>Q：</strong>At a lemonade stand, each lemonade costs <code>$5</code>. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a <code>$5</code>, <code>$10</code>, or <code>$20</code> bill. You must provide the correct change to each customer so that the net transaction is that the customer pays <code>$5</code>.</p>
<p>Note that you do not have any change in hand at first.</p>
<p>Given an integer array <code>bills</code> where <code>bills[i]</code> is the bill the <code>ith</code> customer pays, return <code>true</code> <em>if you can provide every customer with the correct change, or</em> <code>false</code> <em>otherwise</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(bills []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    count5 := <span class="hljs-number">0</span><br>    count10 := <span class="hljs-number">0</span><br>    count20 := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(bills); i++ &#123;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">5</span> &#123;<br>            count5++<br>        &#125;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">if</span> count5 &lt;= <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>            count5--<br>            count10++<br>        &#125;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">20</span> &#123;<br>          	<span class="hljs-comment">// 优先处理10块的，再处理5块的</span><br>            <span class="hljs-keyword">if</span> count5 &gt; <span class="hljs-number">0</span> &amp;&amp; count10 &gt; <span class="hljs-number">0</span> &#123;<br>                count5--<br>                count10--<br>                count20++<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> count10 == <span class="hljs-number">0</span> &amp;&amp; count5 &gt;= <span class="hljs-number">3</span> &#123;<br>                count5 -= <span class="hljs-number">3</span><br>                count20++<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>有如下三种情况：</p>
<ul>
<li>情况一：账单是5，直接收下。</li>
<li>情况二：账单是10，消耗一个5，增加一个10</li>
<li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li>
</ul>
<p>局部最优推算出全局最优</p>
<h2 id="10-10-用最少数量的箭射爆气球"><a href="#10-10-用最少数量的箭射爆气球" class="headerlink" title="10.10 用最少数量的箭射爆气球"></a>10.10 用最少数量的箭射爆气球</h2><p><strong>452. Minimum Number of Arrows to Burst Balloons</strong></p>
<p><strong>Q：</strong>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array <code>points</code> where <code>points[i] = [xstart, xend]</code> denotes a balloon whose <strong>horizontal diameter</strong>stretches between <code>xstart</code> and <code>xend</code>. You do not know the exact y-coordinates of the balloons.</p>
<p>Arrows can be shot up <strong>directly vertically</strong> (in the positive y-direction) from different points along the x-axis. A balloon with <code>xstart</code> and <code>xend</code> is <strong>burst</strong> by an arrow shot at <code>x</code> if <code>xstart &lt;= x &lt;= xend</code>. There is <strong>no limit</strong> to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</p>
<p>Given the array <code>points</code>, return <em>the <strong>minimum</strong> number of arrows that must be shot to burst all balloons</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(points [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// 弓箭数</span><br>    <span class="hljs-comment">// 先按照第一位排序</span><br>    sort.Slice(points, <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> points[i][<span class="hljs-number">0</span>] &lt; points[j][<span class="hljs-number">0</span>]<br>    &#125;)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(points); i++&#123;<br>        <span class="hljs-keyword">if</span> points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; points[i][<span class="hljs-number">0</span>] &#123; <span class="hljs-comment">// 如果前一位的右边界小于后一位的左边界，则一定不重合</span><br>            res++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            points[i][<span class="hljs-number">1</span>] = min(points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], points[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界,覆盖该位置的值，留到下一步使用</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p>贪心，先确定一个思路，再看这个思路是否有bug，没有bug就可以使用贪心</p>
<p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？</p>
<p>尝试一下举反例，发现没有这种情况。</p>
<p>sort.Slice使用指南<a target="_blank" rel="noopener" href="http://books.studygolang.com/Mastering_Go_ZH_CN/eBook/chapter3/03.3.7.html">http://books.studygolang.com/Mastering_Go_ZH_CN/eBook/chapter3/03.3.7.html</a></p>
<h2 id="10-11-合并区间"><a href="#10-11-合并区间" class="headerlink" title="10.11 合并区间"></a>10.11 合并区间</h2><p><strong>56. Merge Intervals</strong></p>
<p><strong>Q：</strong>Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//先从小到大排序</span><br>    sort.Slice(intervals,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>]&lt;intervals[j][<span class="hljs-number">0</span>]<br>    &#125;)<br>    <span class="hljs-comment">//再弄重复的</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(intervals)<span class="hljs-number">-1</span>;i++&#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">1</span>] &gt;= intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&#123;<br>            intervals[i][<span class="hljs-number">1</span>] = max(intervals[i][<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<span class="hljs-comment">//赋值最大值</span><br>            intervals = <span class="hljs-built_in">append</span>(intervals[:i+<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">2</span>:]...)<br>            i--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> intervals<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a &gt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么我按照左边界排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。</p>
<p><code>intervals = append(intervals[:i+1],intervals[i+2:]...)</code>将第一位提取出来，后面跳过下一位把后面的接过来，相当于剔除了第二位。</p>
<h2 id="10-12-单调递增的数字"><a href="#10-12-单调递增的数字" class="headerlink" title="10.12 单调递增的数字"></a>10.12 单调递增的数字</h2><p><strong>738. Monotone Increasing Digits</strong></p>
<p><strong>Q：</strong>An integer has <strong>monotone increasing digits</strong> if and only if each pair of adjacent digits <code>x</code> and <code>y</code> satisfy <code>x &lt;= y</code>.</p>
<p>Given an integer <code>n</code>, return <em>the largest number that is less than or equal to</em> <code>n</code><em>with <strong>monotone increasing digits</strong></em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(N <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    s := strconv.Itoa(N) <span class="hljs-comment">// 将数字转为字符串，方便使用下标</span><br>    ss := []<span class="hljs-type">byte</span>(s) <span class="hljs-comment">// 将字符串转为byte数组，方便更改。</span><br>    n := <span class="hljs-built_in">len</span>(ss)<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> N<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span> ; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> ss[i - <span class="hljs-number">1</span>] &gt; ss[i] &#123; <span class="hljs-comment">// 前一个大于后一位,前一位减1，后面的全部置为9</span><br>            ss[i - <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j := i ; j &lt; n; j++ &#123; <span class="hljs-comment">// 后面的全部置为9</span><br>                ss[j] = <span class="hljs-string">&#x27;9&#x27;</span><br>            &#125;<br>        &#125; <br>    &#125;<br>    res, _ := strconv.Atoi(<span class="hljs-type">string</span>(ss))<br>    <span class="hljs-keyword">return</span> res <br>&#125;<br></code></pre></td></tr></table></figure>
<p>从前往后遍历不行，因为会修改原本的值，但是从后往前不会。</p>
<p>对于go语言如果要修改string的内容最好先转化成byte数组。</p>
<p>前一个大于后一位,前一位减1，后面的全部置为9（因为要求最大）！</p>
<h1 id="第11章-动态规划"><a href="#第11章-动态规划" class="headerlink" title="第11章 动态规划"></a>第11章 动态规划</h1><p>动规五部曲：</p>
<p>这里我们要用一个一维dp数组来保存递归的结果</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>为什么这是一道非常简单的入门题目呢？</p>
<p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></table></figure>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p>
<p>0 1 1 2 3 5 8 13 21 34 55</p>
<p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p>
<h2 id="11-1-斐波那契数列"><a href="#11-1-斐波那契数列" class="headerlink" title="11.1 斐波那契数列"></a>11.1 斐波那契数列</h2><p><strong>509. Fibonacci Number</strong></p>
<p><strong>Q：</strong>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(n)</span></span> = <span class="hljs-built_in">F</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(n - <span class="hljs-number">2</span>), <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure>
<p>Given <code>n</code>, calculate <code>F(n)</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> n&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>      	dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="11-2-爬楼梯"><a href="#11-2-爬楼梯" class="headerlink" title="11.2 爬楼梯"></a>11.2 爬楼梯</h2><p><strong>70. Climbing Stairs</strong></p>
<p><strong>Q：</strong>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>
<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> n&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">// 第一层的方法数量</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span> <span class="hljs-comment">// 第二层的方法数量</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>初始化第一步和第二步，然后递归后面的步子，关键在于递推公式的生成</p>
<p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p>
<p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p>
<p>走一步和走两步的方法总和</p>
<h2 id="11-3-使用最小花费爬楼梯"><a href="#11-3-使用最小花费爬楼梯" class="headerlink" title="11.3 使用最小花费爬楼梯"></a>11.3 使用最小花费爬楼梯</h2><p><strong>746. Min Cost Climbing Stairs</strong></p>
<p><strong>Q：</strong>You are given an integer array <code>cost</code> where <code>cost[i]</code> is the cost of <code>ith</code> step on a staircase. Once you pay the cost, you can either climb one or two steps.</p>
<p>You can either start from the step with index <code>0</code>, or the step with index <code>1</code>.</p>
<p>Return <em>the minimum cost to reach the top of the floor</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cost))<br>    dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>]<br>    dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(cost); i++ &#123;<br>        dp[i] = min(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> min(dp[<span class="hljs-built_in">len</span>(dp) - <span class="hljs-number">1</span>], dp[<span class="hljs-built_in">len</span>(dp) - <span class="hljs-number">2</span>]) <span class="hljs-comment">// 返回的是踏上楼顶的前一步或者前两步</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]</strong>。</p>
<p><strong>可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]</strong>。</p>
<p>那么究竟是选dp[i-1]还是dp[i-2]呢？</p>
<p>一定是选最小的，所以dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];</p>
<p><strong>注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的</strong>，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值</p>
<h2 id="11-4-不同路径-I"><a href="#11-4-不同路径-I" class="headerlink" title="11.4 不同路径 I"></a>11.4 不同路径 I</h2><p><strong>62. Unique Paths</strong></p>
<p><strong>Q：</strong>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>
<p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>
<p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>		dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>		dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>	&#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> dp[<span class="hljs-number">0</span>] &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>] <span class="hljs-comment">// 从左边来的和右边来的数量的总和</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>按照动规五部曲来分析：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i] [j] ：表示从（0 ，0）出发，到(i, j) 有dp[i] [j]条不同的路径。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>想要求dp[i] [j]，只能有两个方向来推导出来，即dp[i - 1] [j] 和 dp[i] [j - 1]。</p>
<p>此时在回顾一下 dp[i - 1] [j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。</p>
<p>那么很自然，dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，因为dp[i] [j]只有这两个方向过来。</p>
<ol>
<li>dp数组的初始化</li>
</ol>
<p>如何初始化呢，首先dp[i] [0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0] [j]也同理。</p>
<p>所以初始化代码为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>这里要看一下递归公式dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，dp[i] [j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p>
<p>这样就可以保证推导dp[i] [j]的时候，dp[i - 1] [j] 和 dp[i] [j - 1]一定是有数值的。</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<h2 id="11-5-不同路径-II"><a href="#11-5-不同路径-II" class="headerlink" title="11.5 不同路径 II"></a>11.5 不同路径 II</h2><p><strong>63. Unique Paths II</strong></p>
<p><strong>Q：</strong>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m-1][n-1]</code>). The robot can only move either down or right at any point in time.</p>
<p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p>
<p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>
<p>The testcases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(obstacleGrid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(obstacleGrid)<br>    n := <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">if</span> obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">for</span> k := i; k &lt; m; k++ &#123;<br>                dp[k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果发现了这一行有一个石头，那么这一行从石头开始后面的全部到达不了</span><br>            &#125;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">for</span> k := j; k &lt; n; k++ &#123;<br>                dp[<span class="hljs-number">0</span>][k] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果发现了这一列有一个石头，那么这一列从石头开始后面的全部到达不了</span><br>            &#125;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span> &#123;   <br>                dp[i][j] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果此点有障碍物，那么这点就不是通路就为0</span><br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有两个关键点，第一个是初始化的时候要注意，如果出现了障碍物，那么剩下的一行或者一列将都是0；第二个是当进行的时候如果当前点是障碍点了，那么就把它置0，因为对于下一个点来说，他并不能帮助下一点到达自己的目的地。</p>
<h2 id="11-6-整数拆分"><a href="#11-6-整数拆分" class="headerlink" title="11.6 整数拆分"></a>11.6 整数拆分</h2><p><strong>343. Integer Break</strong></p>
<p><strong>Q：</strong>Given an integer <code>n</code>, break it into the sum of <code>k</code> <strong>positive integers</strong>, where <code>k &gt;= 2</code>, and maximize the product of those integers.</p>
<p>Return <em>the maximum product you can get</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123; <span class="hljs-comment">// 真正dp序列的循环，把n这个数拆出来一个然后分析看看这么拆是不是最小的乘积</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i - <span class="hljs-number">1</span>; j++ &#123; <span class="hljs-comment">// 正整数所以j从1开始，为什么不能到达i-1，比如n是10，那么我能拆开的两个数就是9和1</span><br>            dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)) <span class="hljs-comment">// j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n] <span class="hljs-comment">// 由于前面在比较的同时需要给dp[n]赋值，必须保证当到达dp[n]的时候，其数值是最大的，所以在递推公式中有dp[n]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>动规五部曲，分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p>
<p>dp[i]的定义讲贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！</p>
<ol>
<li>确定递推公式🌟</li>
</ol>
<p>可以想 dp[i]最大乘积是怎么得到的呢？</p>
<p>其实可以从1遍历j，然后有两种渠道得到dp[i].</p>
<p>一个是j * (i - j) 直接相乘。</p>
<p>一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。</p>
<p><strong>也可以这么理解，j <em> (i - j) 是单纯的把整数拆分为两个数相乘，而j </em> dp[i - j]是拆分成两个以及两个以上的个数相乘。</strong></p>
<p>如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了</p>
<ol>
<li>dp的初始化</li>
</ol>
<p>不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？</p>
<p>有的题解里会给出dp[0] = 1，dp[1] = 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。</p>
<p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。</p>
<p>拆分0和拆分1的最大乘积是多少？</p>
<p>这是无解的。</p>
<p>这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) <em> j, dp[i - j] </em> j));</p>
<p>dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。</p>
<p>枚举j的时候，是从1开始的。i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<h2 id="11-7-不同的二叉树搜索树"><a href="#11-7-不同的二叉树搜索树" class="headerlink" title="11.7 不同的二叉树搜索树"></a>11.7 不同的二叉树搜索树</h2><p><strong>96. Unique Binary Search Trees</strong></p>
<p><strong>Q：</strong>Given an integer <code>n</code>, return <em>the number of structurally unique <strong>BST’</strong>s (binary search trees) which has exactly</em> <code>n</code> <em>nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  	dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>) <span class="hljs-comment">// 包含 0 + (1 to n)</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i; j++ &#123; <span class="hljs-comment">// 假如只有左子树或者右子树的时候就会 j = i</span><br>            dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><strong>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]</strong>。</p>
<p>也可以理解是i个的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p>
<p>以下分析如果想不清楚，就来回想一下dp[i]的定义</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p>
<p>j相当于是头结点的元素，从1遍历到i为止。</p>
<p>所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p>
<p>其中第二个循环for j的那个就是为了找寻不同的数量的左子树。之所以右子树的数量为 i - j 是因为左子树加上右子树的总和为 i - 1</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。</p>
<p>那么dp[0]应该是多少呢？</p>
<p>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。</p>
<p>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。</p>
<p>所以初始化dp[0] = 1</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p>
<p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>        dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>n为5时候的dp数组状态如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210107093253987.png" srcset="/img/loading.gif" lazyload alt="96.不同的二叉搜索树3"></p>
<h2 id="11-8-0-1背包理论基础"><a href="#11-8-0-1背包理论基础" class="headerlink" title="11.8 0 - 1背包理论基础"></a>11.8 0 - 1背包理论基础</h2><p>依然动规五部曲分析一波。</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<p>只看这个二维数组的定义，大家一定会有点懵，看下面这个图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103003361.png" srcset="/img/loading.gif" lazyload alt="动态规划-背包问题1"></p>
<p><strong>要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的</strong>，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>再回顾一下dp[i] [j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
<p>那么可以有两个方向推出来dp[i] [j]，</p>
<ul>
<li><strong>不放物品i</strong>：由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i] [j]就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li>
<li><strong>放物品i</strong>：由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1] [j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li>
</ul>
<p>所以递归公式： dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：</p>
<p><img src="https://img-blog.csdnimg.cn/2021011010304192.png" srcset="/img/loading.gif" lazyload alt="动态规划-背包问题2"></p>
<p>在看其他情况。</p>
<p>状态转移方程 dp[i][j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p>
<p>dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>
<p>那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。</p>
<p>当j &gt;= weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p>
<p>代码初始化如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; weight[<span class="hljs-number">0</span>]; j++) &#123;  <span class="hljs-comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br>    dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时dp数组初始化情况如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103109140.png" srcset="/img/loading.gif" lazyload alt="动态规划-背包问题7"></p>
<p>dp[0] [j] 和 dp[i] [0] 都已经初始化了，那么其他下标应该初始化多少呢？</p>
<p>其实从递归公式： dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p>
<p><strong>初始-1，初始-2，初始100，都可以！</strong></p>
<p>但只不过一开始就统一把dp数组统一初始为0，更方便一些。</p>
<p>如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg" srcset="/img/loading.gif" lazyload alt="动态规划-背包问题10"></p>
<p>最后初始化代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">// 初始化 dp<br>vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0));<br>for (int j = weight[0]; j &lt;= bagweight; j++) &#123;<br>    dp[0][j] = value[0];<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的</strong>。</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量</p>
<p><img src="https://img-blog.csdnimg.cn/2021011010314055.png" srcset="/img/loading.gif" lazyload alt="动态规划-背包问题3"></p>
<p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？</strong></p>
<p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p>
<p>那么我先给出先遍历物品，然后遍历背包重量的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）</strong></p>
<p>例如这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为什么也是可以的呢？</p>
<p><strong>要理解递归的本质和递推的方向</strong>。</p>
<p>dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 递归公式中可以看出dp[i] [j]是靠dp[i-1] [j]和dp[i - 1] [j - weight[i]]推导出来的。</p>
<p>dp[i-1] [j]和dp[i - 1] [j - weight[i]] 都在dp[i] [j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/202101101032124.png" srcset="/img/loading.gif" lazyload alt="动态规划-背包问题5"></p>
<p>再来看看先遍历背包，再遍历物品呢，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103244701.png" srcset="/img/loading.gif" lazyload alt="动态规划-背包问题6"></p>
<p><strong>大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！</strong></p>
<p>但先遍历物品再遍历背包这个顺序更好理解。</p>
<p><strong>其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了</strong>。</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>来看一下对应的dp数组的数值，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210118163425129.jpg" srcset="/img/loading.gif" lazyload alt="动态规划-背包问题4"></p>
<p>最终结果就是dp[2] [4]。</p>
<p>建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。</p>
<p><strong>做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！</strong></p>
<p>二维变成一维后的主要变化在遍历顺序上。</p>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15</p>
<p>如果正序遍历</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 30</p>
<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>
<p>倒序就是先算dp[2]</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>正序就是迭代的过程，不会考虑上层有什么会随机添加，他会添加同样的东西；而倒序是递归，他会根据当前状态去往下找状态，他需要底层的内容支持，是有规则规定的。</p>
<p>二维数组数据是隔离的，而一维的都在同一行，所以不能够正序遍历。</p>
<h2 id="11-9-分割等和子集"><a href="#11-9-分割等和子集" class="headerlink" title="11.9 分割等和子集"></a>11.9 分割等和子集</h2><p><strong>416. Partition Equal Subset Sum</strong></p>
<p><strong>Q：</strong>Given a <strong>non-empty</strong> array <code>nums</code> containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 分割等和子集 动态规划</span><br><span class="hljs-comment">// 时间复杂度O(n^2) 空间复杂度O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += num<br>    &#125;<br>    <span class="hljs-comment">// 如果 nums 的总和为奇数则不可能平分成两个子集</span><br>    <span class="hljs-keyword">if</span> sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <br>    target := sum / <span class="hljs-number">2</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, target + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">for</span> j := target; j &gt;= num; j-- &#123;<br>            <span class="hljs-keyword">if</span> dp[j] &lt; dp[j - num] + num &#123; <span class="hljs-comment">// 如果能能放下num（重量j - num）并且价值增加为num后大于当前的价值，那么就更新</span><br>                dp[j] = dp[j - num] + num<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target] == target<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    动态五部曲：</span><br><span class="hljs-comment">        1.确定dp数组和下标含义</span><br><span class="hljs-comment">        2.确定递推公式</span><br><span class="hljs-comment">        3.dp数组初始化</span><br><span class="hljs-comment">        4.dp遍历顺序</span><br><span class="hljs-comment">        5.打印</span><br><span class="hljs-comment">    **/</span><br>    <span class="hljs-comment">//确定和</span><br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> nums&#123;<br>        sum+=v<br>    &#125;<br>    <span class="hljs-keyword">if</span> sum%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>&#123;   <span class="hljs-comment">//如果和为奇数，则不可能分成两个相等的数组</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    sum/=<span class="hljs-number">2</span><br>    <span class="hljs-comment">//确定dp数组和下标含义</span><br>    <span class="hljs-keyword">var</span> dp [][]<span class="hljs-type">bool</span> <span class="hljs-comment">//dp[i][j] 表示： 前i个石头是否总和不大于j</span><br>    <span class="hljs-comment">//初始化数组</span><br>    dp=<span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>,<span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i,_:=<span class="hljs-keyword">range</span> dp&#123;<br>        dp[i]=<span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>,sum+<span class="hljs-number">1</span>)<br>        dp[i][<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(nums);i++&#123;<br>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=sum;j++&#123;<span class="hljs-comment">//j是固定总量</span><br>            <span class="hljs-keyword">if</span> j&gt;=nums[i<span class="hljs-number">-1</span>]&#123;<span class="hljs-comment">//如果容量够用则可放入背包</span><br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]||dp[i<span class="hljs-number">-1</span>][j-nums[i<span class="hljs-number">-1</span>]]<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果容量不够用则不拿，维持前一个状态</span><br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)][sum]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。</p>
<p>关键点判断能不能重复放入（我们需要不可重复放入）</p>
<p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p>
<ul>
<li>背包的体积为sum / 2</li>
<li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li>
<li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li>
<li>背包中每一个元素是不可重复放入。</li>
</ul>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>​       <strong>dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]</strong>。但是dp[j]是肯定小于等于sum/2的。j代表能存放的所有可能性</p>
<ol>
<li><p>确定递推公式</p>
<p>dp[j] = max(dp[j], dp[j - 1] + nums[i])</p>
</li>
<li><p>dp数组如何初始化</p>
<p>dp[0] = 0</p>
<p>dp[1] = nums[0]</p>
</li>
<li><p>确定遍历顺序</p>
<p>选数字是从前往后，选数值是从后往前</p>
</li>
<li><p>举例推导dp数组</p>
</li>
</ol>
<p>01背包相对于本题，主要要理解，题目中物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2。</p>
<h2 id="11-10-目标和"><a href="#11-10-目标和" class="headerlink" title="11.10 目标和"></a>11.10 目标和</h2><p><strong>494. Target Sum</strong></p>
<p><strong>Q：</strong>You are given an integer array <code>nums</code> and an integer <code>target</code>.</p>
<p>You want to build an <strong>expression</strong> out of nums by adding one of the symbols <code>&#39;+&#39;</code> and <code>&#39;-&#39;</code> before each integer in nums and then concatenate all the integers.</p>
<ul>
<li>For example, if <code>nums = [2, 1]</code>, you can add a <code>&#39;+&#39;</code> before <code>2</code> and a <code>&#39;-&#39;</code> before <code>1</code> and concatenate them to build the expression <code>&quot;+2-1&quot;</code>.</li>
</ul>
<p>Return the number of different <strong>expressions</strong> that you can build, which evaluates to <code>target</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	sum := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>		sum += v<br>	&#125;<br>	<span class="hljs-keyword">if</span> abs(target) &gt; sum &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> (sum+target)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br>	<span class="hljs-comment">// 计算背包大小</span><br>	bag := (sum + target) / <span class="hljs-number">2</span><br>	<span class="hljs-comment">// 定义dp数组</span><br>	dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, bag+<span class="hljs-number">1</span>)<br>	<span class="hljs-comment">// 初始化</span><br>	dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>	<span class="hljs-comment">// 遍历顺序</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>		<span class="hljs-keyword">for</span> j := bag; j &gt;= nums[i]; j-- &#123;<br>			<span class="hljs-comment">//推导公式</span><br>			dp[j] += dp[j-nums[i]]<br>			<span class="hljs-comment">//fmt.Println(dp)</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[bag]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(math.Abs(<span class="hljs-type">float64</span>(x)))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这是一个组合的问题</p>
<p>题目要求在数组元素前加上 + 或者 - 号，其实相当于把数组分成了 2 组，一组全部都加 + 号，一组都加 - 号。记 + 号的一组 P ，记 - 号的一组 N，那么可以推出以下的关系。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">sum(P) - sum(N) = target<br>sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)<br>                       <span class="hljs-number">2</span> * sum(P) = target + sum(nums)<br></code></pre></td></tr></table></figure>
<p>等号两边都加上 <code>sum(N) + sum(P)</code>，于是可以得到结果 <code>2 * sum(P) = target + sum(nums)</code>，那么这道题就转换成了，能否在数组中找到这样一个集合，和等于 <code>(target + sum(nums)) / 2</code>。那么这题就转化为了第 416 题了。<code>dp[i]</code> 中存储的是能使和为 <code>i</code>的方法个数。</p>
<h2 id="11-11-一和零"><a href="#11-11-一和零" class="headerlink" title="11.11 一和零"></a>11.11 一和零</h2><p><strong>474. Ones and Zeroes</strong></p>
<p><strong>Q：</strong>You are given an array of binary strings <code>strs</code> and two integers <code>m</code> and <code>n</code>.</p>
<p>Return <em>the size of the largest subset of <code>strs</code> such that there are <strong>at most</strong></em> <code>m``0</code><em>‘s and</em> <code>n</code> <code>1</code><em>‘s in the subset</em>.</p>
<p>A set <code>x</code> is a <strong>subset</strong> of a set <code>y</code> if all elements of <code>x</code> are also elements of <code>y</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>, m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-comment">// 定义数组</span><br>	dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>	<span class="hljs-keyword">for</span> i,_ := <span class="hljs-keyword">range</span> dp &#123;<br>		dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span> )<br>	&#125;<br>	<span class="hljs-comment">// 遍历</span><br>	<span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(strs);i++ &#123;<br>		zeroNum,oneNum := <span class="hljs-number">0</span> , <span class="hljs-number">0</span><br>		<span class="hljs-comment">//计算0,1 个数</span><br>		<span class="hljs-comment">//或者直接strings.Count(strs[i],&quot;0&quot;)</span><br>		<span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> strs[i] &#123;<br>			<span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>				zeroNum++<br>			&#125;<br>		&#125;<br>		oneNum = <span class="hljs-built_in">len</span>(strs[i])-zeroNum<br>		<span class="hljs-comment">// 从后往前 遍历背包容量</span><br>		<span class="hljs-keyword">for</span> j:= m ; j &gt;= zeroNum;j-- &#123;<br>			<span class="hljs-keyword">for</span> k:=n ; k &gt;= oneNum;k-- &#123;<br>				<span class="hljs-comment">// 推导公式</span><br>				dp[j][k] = max(dp[j][k],dp[j-zeroNum][k-oneNum]+<span class="hljs-number">1</span>)<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//fmt.Println(dp)</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> a &gt; b &#123;<br>		<span class="hljs-keyword">return</span> a<br>	&#125;<br>	<span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" srcset="/img/loading.gif" lazyload alt="416.分割等和子集1"></p>
<p>0 1背包的问题，大体感觉就是我本身没有东西，我一点点放东西所以初始值可以为0，迭代公式就是xxx + 1</p>
<p>状态图</p>
<p><img src="https://img-blog.csdnimg.cn/20210120111201512.jpg" srcset="/img/loading.gif" lazyload alt="474.一和零"></p>
<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值。压缩以后行没有了，所以只剩下dp[j]。</p>
<h2 id="11-12-零钱兑换-II"><a href="#11-12-零钱兑换-II" class="headerlink" title="11.12 零钱兑换 II"></a>11.12 零钱兑换 II</h2><p><strong>518. Coin Change 2</strong></p>
<p><strong>Q：</strong>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>
<p>Return <em>the number of combinations that make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.</p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<p>The answer is <strong>guaranteed</strong> to fit into a signed <strong>32-bit</strong> integer.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(amount <span class="hljs-type">int</span>, coins []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-comment">// 定义dp数组</span><br>	dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>	<span class="hljs-comment">// 初始化,0大小的背包, 当然是不装任何东西了, 就是1种方法</span><br>	dp[<span class="hljs-number">0</span>]  = <span class="hljs-number">1</span><br>	<span class="hljs-comment">// 遍历顺序</span><br>	<span class="hljs-comment">// 遍历物品</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span> ;i &lt; <span class="hljs-built_in">len</span>(coins);i++ &#123;<br>		<span class="hljs-comment">// 遍历背包</span><br>		<span class="hljs-keyword">for</span> j:= coins[i] ; j &lt;= amount ;j++ &#123;<br>			<span class="hljs-comment">// 推导公式</span><br>			dp[j] += dp[j-coins[i]]<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>遍历顺序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>假设：coins[0] = 1，coins[1] = 5。</p>
<p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p>
<p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p>
<p>如果把两个for交换顺序，代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">for (int j = 0; j &lt;= amount; j++) &#123; // 遍历背包容量<br>    for (int i = 0; i &lt; coins.size(); i++) &#123; // 遍历物品<br>        if (j - coins[i] &gt;= 0) dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p>
<p><strong>此时dp[j]里算出来的就是排列数！</strong></p>
<p>dp推导</p>
<p><img src="https://img-blog.csdnimg.cn/20210120181331461.jpg" srcset="/img/loading.gif" lazyload alt="518.零钱兑换II"></p>
<p>在求装满背包有几种方案的时候，认清遍历顺序是非常关键的。</p>
<p><strong>如果求【组合数】就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求【排列数】就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>组合内容不能重复，排列内容可以重复。</p>
<h2 id="11-13-拼凑一个正整数"><a href="#11-13-拼凑一个正整数" class="headerlink" title="11.13 拼凑一个正整数"></a>11.13 拼凑一个正整数</h2><p><strong>377. Combination Sum IV</strong></p>
<p><strong>Q：</strong>Given an array of <strong>distinct</strong> integers <code>nums</code> and a target integer <code>target</code>, return <em>the number of possible combinations that add up to</em> <code>target</code>.</p>
<p>The test cases are generated so that the answer can fit in a <strong>32-bit</strong> integer.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-comment">//定义dp数组</span><br>	dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, target+<span class="hljs-number">1</span>)<br>	<span class="hljs-comment">// 初始化</span><br>	dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>	<span class="hljs-comment">// 遍历顺序, 先遍历背包,再循环遍历物品</span><br>	<span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;=target;j++ &#123;<br>		<span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i &lt; <span class="hljs-built_in">len</span>(nums);i++ &#123;<br>			<span class="hljs-keyword">if</span> j &gt;= nums[i] &#123;<br>				dp[j] += dp[j-nums[i]] <span class="hljs-comment">// j容量下，我放入不同的nums[i]的量，如果可以放进去看看，当前j容量下可以放几种</span><br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[target]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>弄清什么是组合，什么是排列很重要。</p>
<p>组合不强调顺序，(1,5)和(5,1)是同一个组合。</p>
<p>排列强调顺序，(1,5)和(5,1)是两个不同的排列。</p>
<p>个数可以不限使用，说明这是一个完全背包。</p>
<p>得到的集合是排列，说明需要考虑元素之间的顺序。</p>
<p>本题要求的是排列，那么这个for循环嵌套的顺序可以有说法了。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>这道题背包容量可以是从1开始的因为0容量的时候是没有意义的，肯定到达不了target。</p>
<h2 id="11-14-零钱兑换"><a href="#11-14-零钱兑换" class="headerlink" title="11.14 零钱兑换"></a>11.14 零钱兑换</h2><p><strong>322. Coin Change</strong></p>
<p><strong>Q：</strong>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>
<p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>	<span class="hljs-comment">// 初始化dp[0]</span><br>	dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>	<span class="hljs-comment">// 遍历背包,从1开始</span><br>	<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= amount; j++ &#123;<br>		<span class="hljs-comment">// 初始化为math.MaxInt32</span><br>		dp[j] = math.MaxInt32<br>		<span class="hljs-comment">// 遍历物品</span><br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(coins); i++ &#123;<br>			<span class="hljs-keyword">if</span> j &gt;= coins[i] &#123;<br>				<span class="hljs-comment">// 推导公式</span><br>				dp[j] = min(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>)<br>				<span class="hljs-comment">//fmt.Println(dp)</span><br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 没找到能装满背包的, 就返回-1</span><br>	<span class="hljs-keyword">if</span> dp[amount] == math.MaxInt32 &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>math.MaxInt32，最大可以是64</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p>
<ol>
<li>确定递推公式</li>
</ol>
<p>得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。</p>
<p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p>
<p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p>
<p>递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</p>
<p><code>dp[j] = min(dp[j], dp[j-coins[i]]+1)</code> 在当前容量j下，投放硬币所有可能性coins[i]（如果你选择一个很大的，他就会往前跳很多去找，这样跳的步长大，走的次数就少），将与dp[j]（如果没有更新过为Max）更小的数量为dp[j]的数量</p>
<h2 id="11-15-完全平方数"><a href="#11-15-完全平方数" class="headerlink" title="11.15 完全平方数"></a>11.15 完全平方数</h2><p><strong>279. Perfect Squares</strong></p>
<p><strong>Q：</strong>Given an integer <code>n</code>, return <em>the least number of perfect square numbers that sum to</em> <code>n</code>.</p>
<p>A <strong>perfect square</strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code>are perfect squares while <code>3</code> and <code>11</code> are not.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        dp[i] = math.MaxInt32<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j * j &lt;= i; j++ &#123;<br>            dp[i] = min(dp[i], dp[i - (j * j)] + <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></p>
<ol>
<li>确定递推公式</li>
</ol>
<p>dp[j] = min(dp[j], dp[j - (i * i)] + 1)，是不放还是放当前的数看看组合出来的数量哪个小，选哪个作为当前的数量。</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>dp[0] = 0 因为平方数是从1开始的</p>
<h2 id="11-16-单词拆分"><a href="#11-16-单词拆分" class="headerlink" title="11.16 单词拆分"></a>11.16 单词拆分</h2><p><strong>139. Word Break</strong></p>
<p><strong>Q：</strong>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(s <span class="hljs-type">string</span>, wordDict []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    wordDictSet := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br>    <span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> wordDict&#123;<br>        wordDictSet[w] = <span class="hljs-literal">true</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[j] &amp;&amp; wordDictSet[s[j:i]] &#123; <span class="hljs-comment">// dp[j]用来确保之前的都是已经匹配到的，i是下次匹配的起点</span><br>                dp[i] = <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p>
<p>所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</p>
<p>那么dp[0]有没有意义呢？</p>
<p>dp[0]表示如果字符串为空的话，说明出现在字典里。</p>
<p>但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</p>
<p>下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</p>
<p>还要讨论两层for循环的前后循序。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<h2 id="11-17-买卖股票的最佳时机"><a href="#11-17-买卖股票的最佳时机" class="headerlink" title="11.17 买卖股票的最佳时机"></a>11.17 买卖股票的最佳时机</h2><p><strong>121. Best Time to Buy and Sell Stock</strong></p>
<p><strong>Q：</strong>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>
<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 贪心</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    low := math.MaxInt32<br>    rlt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> prices&#123;<br>        low = min(low, prices[i])<br>        rlt = max(rlt, prices[i]-low)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> rlt<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	length:=<span class="hljs-built_in">len</span>(prices)<br>	<span class="hljs-keyword">if</span> length==<span class="hljs-number">0</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>	dp:=<span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,length)<br>	<span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;length;i++&#123;<br>		dp[i]=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">2</span>)<br>	&#125;<br>	<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=-prices[<span class="hljs-number">0</span>]<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;length;i++&#123;<br>		dp[i][<span class="hljs-number">0</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],-prices[i])<br>		dp[i][<span class="hljs-number">1</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+prices[i])<br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[length<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a&gt;b&#123;<br>        <span class="hljs-keyword">return</span> a <br>    &#125;<br>    <span class="hljs-keyword">return</span> b <br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i] [0] 表示第i天持有股票所得最多现金 ，<strong>这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</strong></p>
<p>其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。</p>
<p>dp[i] [1] 表示第i天不持有股票所得最多现金</p>
<p><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></p>
<p>很多同学把“持有”和“买入”没分区分清楚。</p>
<p>在下面递推公式分析中，我会进一步讲解。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</li>
<li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</li>
</ul>
<p>那么dp[i] [0]应该选所得现金最大的，所以dp[i] [0] = max(dp[i - 1] [0], -prices[i]);</p>
<p>如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</li>
<li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1] [0]</li>
</ul>
<p>同样dp[i] [1]取最大的，dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</p>
<p>这样递归公式我们就分析完了</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>由递推公式 dp[i] [0] = max(dp[i - 1] [0], -prices[i]); 和 dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);可以看出</p>
<p>其基础都是要从dp[0] [0]和dp[0] [1]推导出来。</p>
<p>那么dp[0] [0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -= prices[0];</p>
<p>dp[0] [1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] = 0;</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210224225642465.png" srcset="/img/loading.gif" lazyload alt="121.买卖股票的最佳时机"></p>
<p>dp[5] [1]就是最终结果。</p>
<p>为什么不是dp[5] [0]呢？</p>
<p><strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p>
<p>此题只买卖股票一次！相当于用同一个时间拆分成两部分，持有股票给不持有股票服务，如何服务呢？就是在不持有股票的情况下肯定是比持有的多，那么我们就根据不持有股票的的值进行售卖看看现在的差价是，直接摆烂的多还是卖出以后多，最后推移到最后得到结果。</p>
<h2 id="11-18-买卖股票的最佳时机-II"><a href="#11-18-买卖股票的最佳时机-II" class="headerlink" title="11.18 买卖股票的最佳时机 II"></a>11.18 买卖股票的最佳时机 II</h2><p><strong>122. Best Time to Buy and Sell Stock II</strong></p>
<p><strong>Q：</strong>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p>
<p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 买卖股票的最佳时机Ⅱ 动态规划</span><br><span class="hljs-comment">// 时间复杂度：O(n) 空间复杂度：O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(prices))<br>    status := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(prices) * <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = status[:<span class="hljs-number">2</span>]<br>        status = status[<span class="hljs-number">2</span>:]<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i])<br>        dp[i][<span class="hljs-number">1</span>] = max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i])<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(prices) - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>和上一题不同的是可以多次买卖股票以谋求最大利润</p>
<p>唯一的区别<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);</code></p>
<p>就是当你买入的时候一定是前一个状态售出后才能够买入。</p>
<h2 id="11-19-买卖股票的最佳时机-III"><a href="#11-19-买卖股票的最佳时机-III" class="headerlink" title="11.19 买卖股票的最佳时机 III"></a>11.19 买卖股票的最佳时机 III</h2><p><strong>123. Best Time to Buy and Sell Stock III</strong></p>
<p><strong>Q：</strong>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>Find the maximum profit you can achieve. You may complete <strong>at most two transactions</strong>.</p>
<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp:=<span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(prices))<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(prices);i++&#123;<br>        dp[i]=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=-prices[<span class="hljs-number">0</span>]<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]=-prices[<span class="hljs-number">0</span>]<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(prices);i++&#123;<br>        dp[i][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]	<span class="hljs-comment">// 没有操作</span><br>        dp[i][<span class="hljs-number">1</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]-prices[i]) <span class="hljs-comment">// 第一次买入</span><br>        dp[i][<span class="hljs-number">2</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+prices[i]) <span class="hljs-comment">// 第一次卖出</span><br>        dp[i][<span class="hljs-number">3</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]-prices[i]) <span class="hljs-comment">// 第二次买入</span><br>        dp[i][<span class="hljs-number">4</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">4</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>]+prices[i]) <span class="hljs-comment">// 第二次卖出</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>][<span class="hljs-number">4</span>]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a&gt;b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>举例推导dp数组</strong></p>
<p>以输入[1,2,3,4,5]为例</p>
<p><img src="https://img-blog.csdnimg.cn/20201228181724295.png" srcset="/img/loading.gif" lazyload alt="123.买卖股票的最佳时机III"></p>
<p>大家可以看到红色框为最后两次卖出的状态。</p>
<p>现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。</p>
<p>所以最终最大利润是dp[4] [4]</p>
<h2 id="11-20-买卖股票的最佳时机-IV"><a href="#11-20-买卖股票的最佳时机-IV" class="headerlink" title="11.20 买卖股票的最佳时机 IV"></a>11.20 买卖股票的最佳时机 IV</h2><p><strong>188. Best Time to Buy and Sell Stock IV</strong></p>
<p><strong>Q：</strong>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day, and an integer <code>k</code>.</p>
<p>Find the maximum profit you can achieve. You may complete at most <code>k</code>transactions.</p>
<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">## 11.21 买卖股票的最佳时机含冷冻期</span><br><span class="hljs-string"></span><br><span class="hljs-string">**309. Best Time to Buy and Sell Stock with Cooldown**</span><br><span class="hljs-string"></span><br><span class="hljs-string">**Q：**You are given an array `</span>prices<span class="hljs-string">` where `</span>prices[i]<span class="hljs-string">` is the price of a given stock on the `</span>ith<span class="hljs-string">` day.</span><br><span class="hljs-string"></span><br><span class="hljs-string">Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:</span><br><span class="hljs-string"></span><br><span class="hljs-string">- After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</span><br><span class="hljs-string"></span><br><span class="hljs-string">**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</span><br><span class="hljs-string"></span><br><span class="hljs-string">**A：**</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><span class="hljs-keyword">go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">4</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]) - prices[i])<br>        dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>])<br>        dp[i][<span class="hljs-number">2</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + prices[i]<br>        dp[i][<span class="hljs-number">3</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], max(dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>], dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>]))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>确定dp数组以及下标的含义</p>
<p>dp[i] [j]，第i天状态为j，所剩的最多现金为dp[i] [j]。</p>
<p><strong>其实本题很多同学搞的比较懵，是因为出现冷冻期之后，状态其实是比较复杂度</strong>，例如今天买入股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。 具体可以区分出如下四个状态：</p>
<ul>
<li>状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</li>
<li>卖出股票状态，这里就有两种卖出股票状态<ul>
<li>状态二：两天前就卖出了股票，度过了冷冻期；一直没操作，今天保持卖出股票状态</li>
<li>状态三：今天卖出了股票</li>
</ul>
</li>
<li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！(冷冻期也属于卖出股票的一种)</li>
</ul>
<p>转移方程：</p>
<p>达到买入股票状态（状态一）即：dp[i] [0]，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是持有股票状态（状态一），dp[i] [0] = dp[i - 1] [0]</li>
<li>操作二：今天买入了，有两种情况<ul>
<li>前一天是冷冻期（状态四），dp[i - 1] [3] - prices[i]</li>
<li>前一天是保持卖出股票状态（状态二），dp[i - 1] [1] - prices[i]</li>
</ul>
</li>
</ul>
<p>所以操作二取最大值，即：max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]</p>
<p>那么dp[i] [0] = max(dp[i - 1] [0], max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]);</p>
<p>达到保持卖出股票状态（状态二）即：dp[i] [1]，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是状态二</li>
<li>操作二：前一天是冷冻期（状态四）</li>
</ul>
<p>dp[i][1] = max(dp[i - 1] [1], dp[i - 1] [3]);</p>
<p>达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：</p>
<ul>
<li>操作一：昨天一定是买入股票状态（状态一），今天卖出</li>
</ul>
<p>即：dp[i] [2] = dp[i - 1] [0] + prices[i];</p>
<p>达到冷冻期状态（状态四），即：dp[i] [3]，只有一个操作：</p>
<ul>
<li>操作一：昨天卖出了股票（状态三）</li>
</ul>
<p>dp[i] [3] = dp[i - 1] [2];</p>
<h2 id="11-22-买卖股票的最佳时机含手续费"><a href="#11-22-买卖股票的最佳时机含手续费" class="headerlink" title="11.22 买卖股票的最佳时机含手续费"></a>11.22 买卖股票的最佳时机含手续费</h2><p><strong>714. Best Time to Buy and Sell Stock with Transaction Fee</strong></p>
<p><strong>Q：</strong>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day, and an integer <code>fee</code> representing a transaction fee.</p>
<p>Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.</p>
<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>, fee <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>    dp := <span class="hljs-built_in">make</span>([][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>, n) <span class="hljs-comment">// 两种初始化的方法</span><br><span class="hljs-comment">//    for i := 0; i &lt; n; i++ &#123;</span><br><span class="hljs-comment">//        dp[i] = make([]int, 2)</span><br><span class="hljs-comment">//    &#125;</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] - prices[i]) <span class="hljs-comment">// 持有股票</span><br>        dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + prices[i] - fee) <span class="hljs-comment">// 未持有股票</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>本题只需要在计算卖出操作的时候减去手续费就可以了</p>
<p>状态1 买入，持有股票（昨天已经买入了；昨天没有买入，今天买入）</p>
<p>状态2 卖出，未持有股票（昨天卖出了；今天卖出）</p>
<h2 id="11-23-最长递增子序列"><a href="#11-23-最长递增子序列" class="headerlink" title="11.23 最长递增子序列"></a>11.23 最长递增子序列</h2><p><strong>300. Longest Increasing Subsequence</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code>, return the length of the longest strictly increasing subsequence.</p>
<p>A <strong>subsequence</strong> is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, <code>[3,6,2,7]</code> is a subsequence of the array <code>[0,3,1,6,2,2,7]</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划求解</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// dp数组的定义 dp[i]表示取第i个元素的时候，表示子序列的长度，其中包括 nums[i] 这个元素</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br><br>    <span class="hljs-comment">// 初始化，所有的元素都应该初始化为1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-number">1</span><br>    &#125;<br><br>    ans := dp[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[j] &#123;<br>                dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> dp[i] &gt; ans &#123;<br>            ans = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>dp[i]的定义</li>
</ol>
<p><strong>dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度</strong></p>
<ol>
<li>状态转移方程</li>
</ol>
<p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p>
<p>所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p>
<p><strong>注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值</strong>。</p>
<ol>
<li>dp[i]的初始化</li>
</ol>
<p>每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是1.</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>dp[i] 是有0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。</p>
<p>最长自增子序列的定义，只要有比他小的就算上。</p>
<h2 id="11-24-最长连续递增序列"><a href="#11-24-最长连续递增序列" class="headerlink" title="11.24 最长连续递增序列"></a>11.24 最长连续递增序列</h2><p><strong>674. Longest Continuous Increasing Subsequence</strong></p>
<p><strong>Q：</strong>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest <strong>continuous increasing subsequence</strong> (i.e. subarray)</em>. The subsequence must be <strong>strictly</strong> increasing.</p>
<p>A <strong>continuous increasing subsequence</strong> is defined by two indices <code>l</code> and <code>r</code>(<code>l &lt; r</code>) such that it is <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> and for each <code>l &lt;= i &lt; r</code>, <code>nums[i] &lt; nums[i + 1]</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        dp[i] = <span class="hljs-number">1</span><br>    &#125;<br>    res := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &gt; nums[i<span class="hljs-number">-1</span>] &#123;<br>            dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> dp[i] &gt; res &#123;<br>            res = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于要求连续所以我们用一层循环就可以了。</p>
<h2 id="11-25-最长重复子数组"><a href="#11-25-最长重复子数组" class="headerlink" title="11.25 最长重复子数组"></a>11.25 最长重复子数组</h2><p><strong>718. Maximum Length of Repeated Subarray</strong></p>
<p><strong>Q：</strong>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>the maximum length of a subarray that appears in <strong>both</strong> arrays</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLength</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(nums1)<br>    n := <span class="hljs-built_in">len</span>(nums2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> dp[i][j] &gt; res &#123;<br>                res = dp[i][j]<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//fmt.Println(dp[i][1:])</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这道题状态图比较重要</p>
<p>dp[i] [j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i] [j]。 （<strong>特别注意</strong>： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）</p>
<p>之所以为了增加一位是因为这样的话他的棋盘格就很清晰。</p>
<p><code>nums1[i-1] == nums2[j-1]</code>之所以这里比较的是i-1和j-1是因为，我们多加了一位所以从下图就可以看到他是偏移了一位，想要获得对应的值需要让序列号-1</p>
<p><img src="https://img-blog.csdnimg.cn/2021011215282060.jpg" srcset="/img/loading.gif" lazyload alt="718.最长重复子数组"></p>
<p>我们可以看到通过一个巧妙的相同的数字为标准，如果连续的子列的话他会是成斜线的。</p>
<h2 id="11-26-最长公共子序列"><a href="#11-26-最长公共子序列" class="headerlink" title="11.26 最长公共子序列"></a>11.26 最长公共子序列</h2><p><strong>1143. Longest Common Subsequence</strong></p>
<p><strong>Q：</strong>Given two strings <code>text1</code> and <code>text2</code>, return <em>the length of their longest <strong>common subsequence</strong>.</em> If there is no <strong>common subsequence</strong>, return <code>0</code>.</p>
<p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p>
<ul>
<li>For example, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code>.</li>
</ul>
<p>A <strong>common subsequence</strong> of two strings is a subsequence that is common to both strings.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(text1)<br>    n := <span class="hljs-built_in">len</span>(text2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p>
<p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i] [j] = dp[i - 1] [j - 1] + 1;</p>
<p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p>
<p>即：dp[i] [j] = max(dp[i - 1] [j], dp[i] [j - 1]);</p>
<p>与11.24不同的是他不需要考虑连续，只要相同就可以了。由于是存在即可计算的情况，所以说我们可以单纯的记录当前最大的重复量。但11.24不可以，他要求是连续的，所以只要有不同的了就清零（在代码中就是不赋值）</p>
<p><img src="https://img-blog.csdnimg.cn/20210210150215918.jpg" srcset="/img/loading.gif" lazyload alt="1143.最长公共子序列1"></p>
<h2 id="11-27-不相交的线"><a href="#11-27-不相交的线" class="headerlink" title="11.27 不相交的线"></a>11.27 不相交的线</h2><p><strong>1035. Uncrossed Lines</strong></p>
<p><strong>Q：</strong>You are given two integer arrays <code>nums1</code> and <code>nums2</code>. We write the integers of <code>nums1</code> and <code>nums2</code> (in the order they are given) on two separate horizontal lines.</p>
<p>We may draw connecting lines: a straight line connecting two numbers <code>nums1[i]</code> and <code>nums2[j]</code> such that:</p>
<ul>
<li><code>nums1[i] == nums2[j]</code>, and</li>
<li>the line we draw does not intersect any other connecting (non-horizontal) line.</li>
</ul>
<p>Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).</p>
<p>Return <em>the maximum number of connecting lines we can draw in this way</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxUncrossedLines</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(nums1)<br>    n := <span class="hljs-built_in">len</span>(nums2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>      	<span class="hljs-comment">//fmt.Println(dp[i][1:])</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！</strong></p>
<p>我们可以这样理解，我们按照列扫描，行代表我们侦查其中一个字符串的内容长度。重点在于我们如何控制数据不往回看（通过从前往后遍历）</p>
<h2 id="11-28-最大子序和"><a href="#11-28-最大子序和" class="headerlink" title="11.28 最大子序和"></a>11.28 最大子序和</h2><p><strong>53. Maximum Subarray</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p>
<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    res := dp[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        dp[i] = max(dp[i<span class="hljs-number">-1</span>] + nums[i], nums[i]) <span class="hljs-comment">// 选 or 不继续累加清零</span><br>        <span class="hljs-keyword">if</span> dp[i] &gt; res &#123;<br>            res = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="11-29-判断子序和"><a href="#11-29-判断子序和" class="headerlink" title="11.29 判断子序和"></a>11.29 判断子序和</h2><p><strong>392. Is Subsequence</strong></p>
<p><strong>Q：</strong>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is a <strong>subsequence</strong> of</em> <code>t</code><em>, or</em> <code>false</code> <em>otherwise</em>.</p>
<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(s)<br>    n := <span class="hljs-built_in">len</span>(t)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i<span class="hljs-number">-1</span>] == t[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> dp[m][n] == m &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>dp[i] [j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i] [j]</strong>。</p>
<p>注意这里是判断s是否为t的子序列。即t的长度是大于等于s的。</p>
<p>有同学问了，为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？</p>
<p>用i来表示也可以！</p>
<p>但我统一以下标i-1为结尾的字符串来计算，这样在下面的递归公式中会容易理解一些，如果还有疑惑，可以继续往下看。</p>
<p>这道题和最长公共子序列很像不过是加了一个判断而已。注意由于没有要求连续，所以要赋值所有需要不相等的位置。</p>
<p><img src="https://img-blog.csdnimg.cn/20210303173115966.png" srcset="/img/loading.gif" lazyload alt="392.判断子序列"></p>
<h2 id="11-30-不同的子序列"><a href="#11-30-不同的子序列" class="headerlink" title="11.30 不同的子序列"></a>11.30 不同的子序列</h2><p><strong>115. Distinct Subsequences</strong></p>
<p><strong>Q：</strong>Given two strings <code>s</code> and <code>t</code>, return <em>the number of distinct subsequences of <code>s</code>which equals <code>t</code></em>.</p>
<p>A string’s <strong>subsequence</strong> is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters’ relative positions. (i.e., <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p>
<p>The test cases are generated so that the answer fits on a 32-bit signed integer.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp:= <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(dp);i++&#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(t)+<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(dp);i++&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// dp[0][j] 为 0，默认值，因此不需要初始化</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(dp);i++&#123;<br>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;<span class="hljs-built_in">len</span>(dp[i]);j++&#123;<br>            <span class="hljs-keyword">if</span> s[i<span class="hljs-number">-1</span>] == t[j<span class="hljs-number">-1</span>]&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-1</span>][j]<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(dp)<span class="hljs-number">-1</span>][<span class="hljs-built_in">len</span>(dp[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>dp[i] [j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i] [j]。</p>
<p>这一类问题，基本是要分析两种情况</p>
<ul>
<li>s[i - 1] 与 t[j - 1]相等</li>
<li>s[i - 1] 与 t[j - 1] 不相等</li>
</ul>
<p>当s[i - 1] 与 t[j - 1]相等时，dp[i] [j]可以有两部分组成。</p>
<p>一部分是用s[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]。</p>
<p>一部分是不用s[i - 1]来匹配，个数为dp[i - 1] [j]。</p>
<p>这里可能有同学不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。</p>
<p>例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。</p>
<p>当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p>
<p>所以当s[i - 1] 与 t[j - 1]相等时，dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j];</p>
<p>当s[i - 1] 与 t[j - 1]不相等时，dp[i] [j]只有一部分组成，不用s[i - 1]来匹配，即：dp[i - 1] [j]</p>
<p>所以递推公式为：dp[i] [j] = dp[i - 1] [j];</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg" srcset="/img/loading.gif" lazyload alt="115.不同的子序列"></p>
<p>此题关键在于用不用当前扫描的这一位来匹配。不用的话直接j-1变成j跳过当前位直接扫描下一个有没有。</p>
<h2 id="11-31-两个字符串的删除操作"><a href="#11-31-两个字符串的删除操作" class="headerlink" title="11.31 两个字符串的删除操作"></a>11.31 两个字符串的删除操作</h2><p><strong>583. Delete Operation for Two Strings</strong></p>
<p><strong>Q：</strong>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of <strong>steps</strong>required to make</em> <code>word1</code> <em>and</em> <code>word2</code> <em>the same</em>.</p>
<p>In one <strong>step</strong>, you can delete exactly one character in either string.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(word1)<br>    n := <span class="hljs-built_in">len</span>(word2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] != word2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = min(dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, min(dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p>
<ul>
<li>当word1[i - 1] 与 word2[j - 1]相同的时候</li>
<li>当word1[i - 1] 与 word2[j - 1]不相同的时候</li>
</ul>
<p>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i] [j] = dp[i - 1] [j - 1];</p>
<p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p>
<p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1] [j] + 1</p>
<p>情况二：删word2[j - 1]，最少操作次数为dp[i] [j - 1] + 1</p>
<p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1] [j - 1] + 2</p>
<p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i] [j] = min({dp[i - 1] [j - 1] + 2, dp[i - 1] [j] + 1, dp[i] [j - 1] + 1});</p>
<p>小难点，删除word1[i-1]为什么是dp[i - 1] [j] + 1，因为这道题和不同的子序列不同，他是删除思维是反着的，所以删除一个元素就是直接由跳过j方向，让i-1加1。这里的加就是删除一个元素</p>
<p><img src="https://img-blog.csdnimg.cn/20210714101750205.png" srcset="/img/loading.gif" lazyload alt="583.两个字符串的删除操作1"></p>
<h2 id="11-32-编辑距离"><a href="#11-32-编辑距离" class="headerlink" title="11.32 编辑距离"></a>11.32 编辑距离</h2><p><strong>72. Edit Distance</strong></p>
<p><strong>Q：</strong>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.</p>
<p>You have the following three operations permitted on a word:</p>
<ul>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ul>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(word1)<br>    n := <span class="hljs-built_in">len</span>(word2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>) <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], min(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span> <span class="hljs-comment">// 替换，删除i-1方向，删除j方向</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-comment">// min的不同写法，语法糖写法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	m, n := <span class="hljs-built_in">len</span>(word1), <span class="hljs-built_in">len</span>(word2)<br>	dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>		dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m+<span class="hljs-number">1</span>; i++ &#123;<br>		dp[i][<span class="hljs-number">0</span>] = i <span class="hljs-comment">// word1[i] 变成 word2[0], 删掉 word1[i], 需要 i 部操作</span><br>	&#125;<br>	<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n+<span class="hljs-number">1</span>; j++ &#123;<br>		dp[<span class="hljs-number">0</span>][j] = j <span class="hljs-comment">// word1[0] 变成 word2[j], 插入 word1[j]，需要 j 部操作</span><br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m+<span class="hljs-number">1</span>; i++ &#123;<br>		<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; j++ &#123;<br>			<span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>] &#123;<br>				dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>			&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Min(插入，删除，替换)</span><br>				dp[i][j] = Min(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span><br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span><span class="hljs-params">(args ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	min := args[<span class="hljs-number">0</span>]<br>	<span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> args &#123;<br>		<span class="hljs-keyword">if</span> item &lt; min &#123;<br>			min = item<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> min<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">if (word1[i - 1] == word2[j - 1])<br>    不操作<br>if (word1[i - 1] != word2[j - 1])<br>    增<br>    删<br>    换<br></code></pre></td></tr></table></figure>
<p>也就是如上4种情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>])<span class="hljs-string">` 那么说明不用任何编辑，`</span>dp[i][j]<span class="hljs-string">` 就应该是 `</span>dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<span class="hljs-string">`，即`</span>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure>
<p>此时可能有同学有点不明白，为啥要即<code>dp[i][j] = dp[i - 1][j - 1]</code>呢？</p>
<p>那么就在回顾上面讲过的<code>dp[i][j]</code>的定义，<code>word1[i - 1]</code> 与 <code>word2[j - 1]</code>相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串<code>word2</code>的最近编辑距离<code>dp[i - 1][j - 1]</code>就是 <code>dp[i][j]</code>了。</p>
<p>在下面的讲解中，如果哪里看不懂，就回想一下<code>dp[i][j]</code>的定义，就明白了。</p>
<p><strong>在整个动规的过程中，最为关键就是正确理解<code>dp[i][j]</code>的定义！</strong></p>
<p><code>if (word1[i - 1] != word2[j - 1])</code>，此时就需要编辑了，如何编辑呢？</p>
<ul>
<li>操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。</li>
</ul>
<p>即 <code>dp[i][j] = dp[i - 1][j] + 1;</code></p>
<ul>
<li>操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。</li>
</ul>
<p>即 <code>dp[i][j] = dp[i][j - 1] + 1;</code></p>
<p>这里有同学发现了，怎么都是删除元素，添加元素去哪了。</p>
<p><strong>word2添加一个元素，相当于word1删除一个元素</strong>，例如 <code>word1 = &quot;ad&quot; ，word2 = &quot;a&quot;</code>，<code>word1</code>删除元素<code>&#39;d&#39;</code> 和 <code>word2</code>添加一个元素<code>&#39;d&#39;</code>，变成<code>word1=&quot;a&quot;, word2=&quot;ad&quot;</code>， 最终的操作数是一样！ dp数组如下图所示意的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">           a                         a     d<br>  +-----+-----+             +-----+-----+-----+<br>  |  0  |  1  |             |  0  |  1  |  2  |<br>  +-----+-----+   ===&gt;      +-----+-----+-----+<br>a |  1  |  0  |           a |  1  |  0  |  1  |<br>  +-----+-----+             +-----+-----+-----+<br>d |  2  |  1  |<br>  +-----+-----+<br></code></pre></td></tr></table></figure>
<p>操作三：替换元素，<code>word1</code>替换<code>word1[i - 1]</code>，使其与<code>word2[j - 1]</code>相同，此时不用增加元素，那么以下标<code>i-2</code>为结尾的<code>word1</code> 与 <code>j-2</code>为结尾的<code>word2</code>的最近编辑距离 加上一个替换元素的操作。</p>
<p>即 <code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p>
<p>综上，当 <code>if (word1[i - 1] != word2[j - 1])</code> 时取最小的，即：<code>dp[i][j] = min(&#123;dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]&#125;) + 1;</code></p>
<p>递归公式代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]&#125;) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210114162113131.jpg" srcset="/img/loading.gif" lazyload alt="72.编辑距离"></p>
<h2 id="11-33-回文子串"><a href="#11-33-回文子串" class="headerlink" title="11.33 回文子串"></a>11.33 回文子串</h2><p><strong>647. Palindromic Substrings</strong></p>
<p><strong>Q：</strong>Given a string <code>s</code>, return <em>the number of <strong>palindromic substrings</strong> in it</em>.</p>
<p>A string is a <strong>palindrome</strong> when it reads the same backward as forward.</p>
<p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res:=<span class="hljs-number">0</span><br>    dp:=<span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>,<span class="hljs-built_in">len</span>(s))<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;<br>        dp[i]=<span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>,<span class="hljs-built_in">len</span>(s))<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;<br>        <span class="hljs-keyword">for</span> j:=i;j&lt;<span class="hljs-built_in">len</span>(s);j++&#123;<br>            <span class="hljs-keyword">if</span> s[i]==s[j]&#123;<br>                <span class="hljs-keyword">if</span> j-i&lt;=<span class="hljs-number">1</span>&#123;<br>                    res++<br>                    dp[i][j]=<span class="hljs-literal">true</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]&#123;<br>                    res++<br>                    dp[i][j]=<span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在确定递推公式时，就要分析如下几种情况。</p>
<p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p>
<p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p>
<p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<ul>
<li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li>
<li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li>
<li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true。</li>
</ul>
<h2 id="11-34-最长回文子序列"><a href="#11-34-最长回文子序列" class="headerlink" title="11.34 最长回文子序列"></a>11.34 最长回文子序列</h2><p><strong>516. Longest Palindromic Subsequence</strong></p>
<p><strong>Q：</strong>Given a string <code>s</code>, find <em>the longest palindromic <strong>subsequence</strong>‘s length in</em> <code>s</code>.</p>
<p>A <strong>subsequence</strong> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	size := <span class="hljs-built_in">len</span>(s)<br>	max := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>		<span class="hljs-keyword">if</span> a &gt; b &#123;<br>			<span class="hljs-keyword">return</span> a<br>		&#125;<br>		<span class="hljs-keyword">return</span> b<br>	&#125;<br>	dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, size)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>		dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, size)<br>		dp[i][i] = <span class="hljs-number">1</span><br>	&#125;<br>	<span class="hljs-keyword">for</span> i := size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>		<span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; size; j++ &#123;<br>			<span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>				dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span><br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				dp[i][j] = max(dp[i][j<span class="hljs-number">-1</span>], dp[i+<span class="hljs-number">1</span>][j])<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][size<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h1><p>算法时间复杂度</p>
<p><img src="https://images0.cnblogs.com/i/608996/201408/141025088894028.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-旋转数组"><a href="#1-旋转数组" class="headerlink" title="1. 旋转数组"></a>1. 旋转数组</h3><p><strong>189. Rotate Array</strong></p>
<p><strong>Q：Given an array, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</strong></p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span>  &#123;<br>    k = k % <span class="hljs-built_in">len</span>(nums)<br>    reverse(nums)<br>    reverse(nums[:k])<br>    reverse(nums[k:])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>&#123;<br>    l:=<span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;l/<span class="hljs-number">2</span>;i++&#123;<br>        nums[i], nums[l<span class="hljs-number">-1</span>-i] = nums[l<span class="hljs-number">-1</span>-i], nums[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如下步骤就可以<strong>左旋转</strong>字符串：</p>
<ol>
<li>反转区间为前n的子串</li>
<li>反转区间为n到末尾的子串</li>
<li>反转整个字符串</li>
</ol>
<p>本题是<strong>右旋转</strong>，其实就是反转的顺序改动一下，优先反转整个字符串，步骤如下：</p>
<ol>
<li>反转整个字符串</li>
<li>反转区间为前k的子串</li>
<li>反转区间为k到末尾的子串</li>
</ol>
<p>右旋转为了将右边的元素放到左边需要先镜像一下所有的元素，然后我反转需要移动的前k个元素，剩下的元素由于被镜像了我仍然需要反转。</p>
<p>左旋转就是先反转要移动的左边位数，再反转右边的，最后反转全部，和上述不同的在于他们反转过后要去的地方不一样，左旋转的最左边位置，反转过后不在最右边，而是在中间的右边。</p>
<h3 id="2-在排序数组中查找元素的第一个和最后一个位置（不太会，要再看）"><a href="#2-在排序数组中查找元素的第一个和最后一个位置（不太会，要再看）" class="headerlink" title="2. 在排序数组中查找元素的第一个和最后一个位置（不太会，要再看）"></a>2. 在排序数组中查找元素的第一个和最后一个位置（不太会，要再看）</h3><p><strong>34. Find First and Last Position of Element in Sorted Array</strong></p>
<p><strong>Q：</strong>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p>
<p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    leftBorder := getLeft(nums, target)<br>    rightBorder := getRight(nums, target)<br>    <span class="hljs-comment">// 情况一</span><br>    <span class="hljs-keyword">if</span> leftBorder == <span class="hljs-number">-2</span> || rightBorder == <span class="hljs-number">-2</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>    &#125;<br>    <span class="hljs-comment">// 情况三</span><br>    <span class="hljs-keyword">if</span> rightBorder - leftBorder &gt; <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;leftBorder + <span class="hljs-number">1</span>, rightBorder - <span class="hljs-number">1</span>&#125;<br>    &#125;<br>    <span class="hljs-comment">// 情况二</span><br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLeft</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    border := <span class="hljs-number">-2</span> <span class="hljs-comment">// 记录border没有被赋值的情况；这里不能赋值-1，target = num[0]时，会无法区分情况一和情况二</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123; <span class="hljs-comment">// []闭区间</span><br>        mid := left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123; <span class="hljs-comment">// 找到第一个等于target的位置</span><br>            right = mid - <span class="hljs-number">1</span><br>            border = right<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left =  mid + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> border<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRight</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    border := <span class="hljs-number">-2</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        mid := left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123; <br>            right = mid - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 找到第一个大于target的位置</span><br>            left = mid + <span class="hljs-number">1</span><br>            border = left<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> border<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>寻找target在数组里的左右边界，有如下三种情况：</p>
<ul>
<li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li>
<li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li>
<li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li>
</ul>
<p>这三种情况都考虑到，说明就想的很清楚了。</p>
<p>接下来，在去寻找左边界，和右边界了。</p>
<h3 id="3-两两交换链表中的节点"><a href="#3-两两交换链表中的节点" class="headerlink" title="3. 两两交换链表中的节点"></a>3. 两两交换链表中的节点</h3><p><strong>24. Swap Nodes in Pairs</strong></p>
<p><strong>Q：</strong>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>	fakeHead := &amp;ListNode&#123;Val: <span class="hljs-number">0</span>, Next: head&#125;<br>	curr := fakeHead<br><br>	<span class="hljs-keyword">for</span> curr.Next != <span class="hljs-literal">nil</span> &amp;&amp; curr.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        <br>		next1 := curr.Next<br>		next2 := curr.Next.Next<br>        next3 := curr.Next.Next.Next<br>        next1.Next = next3 <br>        <br>		<span class="hljs-comment">// curr.Next = next2 </span><br>		<span class="hljs-comment">// curr.Next.Next = next1 </span><br>		<span class="hljs-comment">// curr = curr.Next.Next </span><br>        next2.Next = next1<br>        curr.Next = next2 <span class="hljs-comment">// 第一次连接fakeHead用的</span><br>        curr = next1 <span class="hljs-comment">// 更新为下一组的前一个节点，相当于fakeHead</span><br>	&#125;<br><br>	<span class="hljs-keyword">return</span> fakeHead.Next<br>&#125;<br><br><span class="hljs-comment">// 递归版本</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    next := head.Next<br>    head.Next = swapPairs(next.Next) <span class="hljs-comment">// 连接以2号位为头节点的交换处</span><br>    next.Next = head<br>    <span class="hljs-keyword">return</span> next<br>&#125;<br></code></pre></td></tr></table></figure>
<p>新思路，我们将不用pre和cur的方式，我们可以将我们要处理的所有节点用next1、next2…进行编号，然后再进行处理，个人感觉思路会更加清晰一些。</p>
<h3 id="4-重排链表"><a href="#4-重排链表" class="headerlink" title="4. 重排链表"></a>4. 重排链表</h3><p><strong>143. Reorder List</strong></p>
<p><strong>Q：</strong>You are given the head of a singly linked-list. The list can be represented as:</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-symbol">L1</span> → … → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-built_in">Ln</span><br></code></pre></td></tr></table></figure>
<p><em>Reorder the list to be on the following form:</em></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-built_in">Ln</span> → <span class="hljs-symbol">L1</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-symbol">L2</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">2</span> → …<br></code></pre></td></tr></table></figure>
<p>You may not modify the values in the list’s nodes. Only nodes themselves may be changed.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(head *ListNode)</span></span>  &#123;<br>    <span class="hljs-keyword">var</span> slow=head<br>    <span class="hljs-keyword">var</span> fast=head<br>    <span class="hljs-keyword">for</span> fast!=<span class="hljs-literal">nil</span>&amp;&amp;fast.Next!=<span class="hljs-literal">nil</span>&#123;<br>        slow=slow.Next<br>        fast=fast.Next.Next<br>    &#125;  <span class="hljs-comment">//双指针将链表分为左右两部分</span><br>    <span class="hljs-keyword">var</span> right =<span class="hljs-built_in">new</span>(ListNode)<br>    <span class="hljs-keyword">for</span> slow!=<span class="hljs-literal">nil</span>&#123;<br>        temp:=slow.Next<br>        slow.Next=right.Next <span class="hljs-comment">// 指向之前保存的前一个头</span><br>        right.Next=slow<br>        slow=temp<br>    &#125;  <span class="hljs-comment">//翻转链表右半部分</span><br>    right=right.Next  <span class="hljs-comment">//right为反转后得右半部分</span><br>    h:=head<br>    <span class="hljs-keyword">for</span> right.Next!=<span class="hljs-literal">nil</span>&#123;<br>        temp:=right.Next<br>        right.Next=h.Next<br>        h.Next=right<br>        h=h.Next.Next<br>        right=temp<br>    &#125; <span class="hljs-comment">//将左右两部分重新组合</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用快慢指针来找到一半的起点位置。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这里的反转就是反转链表那个流程，right就是我们之前总用的pre</p>
<p><code>right.Next!=nil</code>才有继续下去的意义</p>
<p>所有while循环的地方就是让我们思考什么情况下是有意义的</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1-求根到叶子节点数字之和"><a href="#1-求根到叶子节点数字之和" class="headerlink" title="1. 求根到叶子节点数字之和"></a>1. 求根到叶子节点数字之和</h3><p><strong>129. Sum Root to Leaf Numbers</strong></p>
<p><strong>Q：</strong>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p>
<p>Each root-to-leaf path in the tree represents a number.</p>
<ul>
<li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li>
</ul>
<p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>
<p>A <strong>leaf</strong> node is a node with no children.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    dfs(root, root.Val, &amp;sum)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, tmpSum <span class="hljs-type">int</span>, sum *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        *sum += tmpSum<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>            dfs(root.Left, tmpSum*<span class="hljs-number">10</span> + root.Left.Val, sum)<br>        &#125;<br>        <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>            dfs(root.Right, tmpSum*<span class="hljs-number">10</span> + root.Right.Val, sum)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-将二叉搜索树变平衡"><a href="#2-将二叉搜索树变平衡" class="headerlink" title="2. 将二叉搜索树变平衡"></a>2. 将二叉搜索树变平衡</h3><p><strong>1382. Balance a Binary Search Tree</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary search tree, return <em>a <strong>balanced</strong> binary search tree with the same node values</em>. If there is more than one answer, return <strong>any of them</strong>.</p>
<p>A binary search tree is <strong>balanced</strong> if the depth of the two subtrees of every node never differs by more than <code>1</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">balanceBST</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>   <span class="hljs-comment">// 二叉搜索树中序遍历得到有序数组</span><br>	nums := []<span class="hljs-type">int</span>&#123;&#125;<br>   <span class="hljs-comment">// 中序递归遍历二叉树</span><br>	<span class="hljs-keyword">var</span> travel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>	travel = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br>		<span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>		travel(node.Left)<br>		nums = <span class="hljs-built_in">append</span>(nums, node.Val)<br>		travel(node.Right)<br>	&#125;<br>	<span class="hljs-comment">// 二分法保证左右子树高度差不超过一（题目要求返回的仍是二叉搜索树）</span><br>	<span class="hljs-keyword">var</span> buildTree <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, left, right <span class="hljs-type">int</span>)</span></span> *TreeNode<br>	buildTree = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, left, right <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>		<span class="hljs-keyword">if</span> left &gt; right &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>		&#125;<br>		mid := left + (right-left) &gt;&gt; <span class="hljs-number">1</span><br>		root := &amp;TreeNode&#123;Val: nums[mid]&#125;<br>		root.Left = buildTree(nums, left, mid<span class="hljs-number">-1</span>)<br>		root.Right = buildTree(nums, mid+<span class="hljs-number">1</span>, right)<br>		<span class="hljs-keyword">return</span> root<br>	&#125;<br>	travel(root)<br>	<span class="hljs-keyword">return</span> buildTree(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>1.先排序</p>
<p>2.二分法插入</p>
<h3 id="3-填充每个节点的下一个右侧节点指针"><a href="#3-填充每个节点的下一个右侧节点指针" class="headerlink" title="3. 填充每个节点的下一个右侧节点指针"></a>3. 填充每个节点的下一个右侧节点指针</h3><p><strong>116. Populating Next Right Pointers in Each Node</strong></p>
<p><strong>Q：</strong>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 迭代法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(root *Node)</span></span> *Node &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    stack := <span class="hljs-built_in">make</span>([]*Node, <span class="hljs-number">0</span>)<br>    stack = <span class="hljs-built_in">append</span>(stack, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 如果stack里面有元素的话</span><br>        n := <span class="hljs-built_in">len</span>(stack) <span class="hljs-comment">// 记录当前层节点个数</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>            node := stack[<span class="hljs-number">0</span>] <span class="hljs-comment">// 依次弹出节点</span><br>            stack = stack[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> i == n - <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 如果是这层最右的节点，next指向nil</span><br>                node.Next = <span class="hljs-literal">nil</span> <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node.Next = stack[<span class="hljs-number">0</span>] <span class="hljs-comment">// 如果不是最右的节点，next指向右边的节点</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果存在左子节点，放入栈中</span><br>                stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果存在右子节点，放入栈中</span><br>                stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其左子树指向其父节点的右子树</p>
<p>其右子树指向其父节点next的左子树</p>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="1-N皇后II"><a href="#1-N皇后II" class="headerlink" title="1. N皇后II"></a>1. N皇后II</h3><p><strong>52. N-Queens II</strong></p>
<p><strong>Q：</strong>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code>chessboard such that no two queens attack each other.</p>
<p>Given an integer <code>n</code>, return <em>the number of distinct solutions to the <strong>n-queens puzzle</strong></em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    idx := []<span class="hljs-type">int</span>&#123;&#125;<br>    res := <span class="hljs-number">0</span><br>    dfs(n, <span class="hljs-number">0</span>, idx, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(n, row <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> row == n &#123;<br>        *res++<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>        <span class="hljs-keyword">if</span> isValid(row, col, n, idx) &#123;<br>            idx = <span class="hljs-built_in">append</span>(idx, col)<br>            dfs(n, row + <span class="hljs-number">1</span>, idx, res)<br>            idx = idx[:<span class="hljs-built_in">len</span>(idx) - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(row, col, n <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    col45 := col<br>    col135 := col<br>    <span class="hljs-comment">// 检查列</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(idx); i++ &#123;<br>        <span class="hljs-keyword">if</span> col == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查45˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col45++<br>        <span class="hljs-keyword">if</span> col45 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查135˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col135--<br>        <span class="hljs-keyword">if</span> col135 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>跟8皇后一样，原来是显示棋盘，现在就是统计数量。</p>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="1-Dota2-参议院"><a href="#1-Dota2-参议院" class="headerlink" title="1. Dota2 参议院"></a>1. Dota2 参议院</h3><p><strong>649. Dota2 Senate</strong></p>
<p><strong>Q：</strong>In the world of Dota2, there are two parties: the Radiant and the Dire.</p>
<p>The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise <strong>one</strong> of the two rights:</p>
<ul>
<li><strong>Ban one senator’s right:</strong> A senator can make another senator lose all his rights in this and all the following rounds.</li>
<li><strong>Announce the victory:</strong> If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.</li>
</ul>
<p>Given a string <code>senate</code> representing each senator’s party belonging. The character <code>&#39;R&#39;</code> and <code>&#39;D&#39;</code> represent the Radiant party and the Dire party. Then if there are <code>n</code> senators, the size of the given string will be <code>n</code>.</p>
<p>The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.</p>
<p>Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be <code>&quot;Radiant&quot;</code> or <code>&quot;Dire&quot;</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">predictPartyVictory</span><span class="hljs-params">(senateStr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-comment">// R = true表示本轮循环结束后，字符串里依然有R。D同理</span><br>	R, D := <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>	<span class="hljs-comment">// 当flag大于0时，R在D前出现，R可以消灭D。当flag小于0时，D在R前出现，D可以消灭R</span><br>	flag := <span class="hljs-number">0</span><br><br>	senate := []<span class="hljs-type">byte</span>(senateStr)<br>	<span class="hljs-keyword">for</span> R &amp;&amp; D &#123; <span class="hljs-comment">// 一旦R或者D为false，就结束循环，说明本轮结束后只剩下R或者D了</span><br>		R = <span class="hljs-literal">false</span><br>		D = <span class="hljs-literal">false</span><br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(senate); i++ &#123;<br>			<span class="hljs-keyword">if</span> senate[i] == <span class="hljs-string">&#x27;R&#x27;</span> &#123;<br>				<span class="hljs-keyword">if</span> flag &lt; <span class="hljs-number">0</span>  &#123;<br>					 senate[i] = <span class="hljs-number">0</span>  <span class="hljs-comment">// 消灭R，R此时为false</span><br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					R = <span class="hljs-literal">true</span> <span class="hljs-comment">// 如果没被消灭，本轮循环结束有R</span><br>				&#125;<br>				flag++;<br>			&#125;<br>			<span class="hljs-keyword">if</span> senate[i] == <span class="hljs-string">&#x27;D&#x27;</span> &#123;<br>				<span class="hljs-keyword">if</span> flag &gt; <span class="hljs-number">0</span> &#123;<br>					senate[i] = <span class="hljs-number">0</span><br>				&#125; <span class="hljs-keyword">else</span>  &#123;<br>					D = <span class="hljs-literal">true</span><br>				&#125;<br>				flag--<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 循环结束之后，R和D只能有一个为true</span><br>	<span class="hljs-keyword">if</span> R &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Radiant&quot;</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dire&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>例如输入”RRDDD”，执行过程应该是什么样呢？</p>
<ul>
<li>第一轮：senate[0]的R消灭senate[2]的D，senate[1]的R消灭senate[3]的D，senate[4]的D消灭senate[0]的R，此时剩下”RD”，第一轮结束！</li>
<li>第二轮：senate[0]的R消灭senate[1]的D，第二轮结束</li>
<li>第三轮：只有R了，R胜利</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="1-最长回文子串"><a href="#1-最长回文子串" class="headerlink" title="1. 最长回文子串"></a>1. 最长回文子串</h3><p><strong>5. Longest Palindromic Substring</strong></p>
<p><strong>Q：</strong>Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    maxLen := <span class="hljs-number">0</span><br>    left := <span class="hljs-number">0</span><br>    length := <span class="hljs-number">0</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(s))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>,<span class="hljs-built_in">len</span>(s))<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; <span class="hljs-built_in">len</span>(s); j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i] == s[j]&#123;<br>                <span class="hljs-keyword">if</span> j-i &lt;= <span class="hljs-number">1</span>&#123;<br>                    length = j-i<br>                    dp[i][j]=<span class="hljs-literal">true</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]&#123; <span class="hljs-comment">// 根据前一个状态推导</span><br>                    length = j-i<br>                    dp[i][j]=<span class="hljs-literal">true</span><br>                &#125;<br>                fmt.Print(<span class="hljs-string">&quot;i: &quot;</span>)<br>                fmt.Println(i)<br>                fmt.Print(<span class="hljs-string">&quot;j: &quot;</span>)<br>                fmt.Println(j)<br>                fmt.Print(<span class="hljs-string">&quot;tmp_s: &quot;</span>)<br>                fmt.Println(s[i:j+<span class="hljs-number">1</span>])<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> length &gt; maxLen &#123;<br>            maxLen = length<br>            left = i<br>        &#125;<br>        fmt.Println(<span class="hljs-string">&quot;-----------&quot;</span>)<br>        fmt.Print(<span class="hljs-string">&quot;left: &quot;</span>)<br>        fmt.Println(left)<br>        fmt.Print(<span class="hljs-string">&quot;maxLen: &quot;</span>)<br>        fmt.Println(maxLen)<br>    &#125;<br>    <span class="hljs-keyword">return</span> s[left:left+maxLen+<span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p>
<p>当s[i]与s[j]不相等，那没啥好说的了，dp[i] [j]一定是false。</p>
<p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<ul>
<li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li>
<li>情况二：下标i 与 j相差为1，例如aa，也是文子串</li>
<li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true。</li>
</ul>
<p>遍历顺序可有有点讲究了。</p>
<p>首先从递推公式中可以看出，情况三是根据dp[i + 1] [j - 1]是否为true，在对dp[i] [j]进行赋值true的。</p>
<p>dp[i + 1] [j - 1] 在 dp[i] [j]的左下角，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210121171032473.jpg" srcset="/img/loading.gif" lazyload alt="647.回文子串"></p>
<p>如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的dp[i + 1] [j - 1]，也就是根据不确定是不是回文的区间[i+1, j-1]，来判断了[i,j]是不是回文，那结果一定是不对的。</p>
<p><strong>所以一定要从下到上，从左到右遍历，这样保证dp[i + 1] [j - 1]都是经过计算的</strong>。</p>
<h3 id="2-最长递增子序列的个数"><a href="#2-最长递增子序列的个数" class="headerlink" title="2. 最长递增子序列的个数"></a>2. 最长递增子序列的个数</h3><p><strong>673. Number of Longest Increasing Subsequence</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code>, return <em>the number of longest increasing subsequences.</em></p>
<p><strong>Notice</strong> that the sequence has to be <strong>strictly</strong> increasing.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findNumberOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	size := <span class="hljs-built_in">len</span>(nums)<br>	<span class="hljs-keyword">if</span> size &lt;= <span class="hljs-number">1</span>  &#123;<br>		<span class="hljs-keyword">return</span> size<br>	&#125;<br><br>	dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, size);<br>	<span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>		dp[i] = <span class="hljs-number">1</span><br>	&#125;<br>	count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, size);<br>	<span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> count &#123;<br>		count[i] = <span class="hljs-number">1</span><br>	&#125;<br><br>	maxCount := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; size; i++ &#123;<br>		<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>			<span class="hljs-keyword">if</span> nums[i] &gt; nums[j] &#123;<br>				<span class="hljs-keyword">if</span> dp[j] + <span class="hljs-number">1</span> &gt; dp[i] &#123;<br>					dp[i] = dp[j] + <span class="hljs-number">1</span><br>					count[i] = count[j] <span class="hljs-comment">// 如果长度变了那么就是新的规格了</span><br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dp[j] + <span class="hljs-number">1</span> == dp[i] &#123;<br>					count[i] += count[j] <span class="hljs-comment">// 同一个规格，不同的组合</span><br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> dp[i] &gt; maxCount &#123;<br>				maxCount = dp[i] <span class="hljs-comment">// 记录最长子序列的长度</span><br>			&#125;<br>		&#125;<br>	&#125;<br>    <br>    <span class="hljs-comment">// 找最长的</span><br>	result := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>		<span class="hljs-keyword">if</span> maxCount == dp[i] &#123;<br>			result += count[i]<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<p>即：位置i的最长递增子序列长度 等于j从0到i-1各个位置的最长升序子序列 + 1的最大值。</p>
<p>本题就没那么简单了，我们要考虑两个维度，一个是dp[i]的更新，一个是count[i]的更新。</p>
<p>那么如何更新count[i]呢？</p>
<p>以nums[i]为结尾的字符串，最长递增子序列的个数为count[i]。</p>
<p>那么在nums[i] &gt; nums[j]前提下，如果在[0, i-1]的范围内，找到了j，使得dp[j] + 1 &gt; dp[i]，说明找到了一个更长的递增子序列。</p>
<p>那么以j为结尾的子串的最长递增子序列的个数，就是最新的以i为结尾的子串的最长递增子序列的个数，即：count[i] = count[j]。</p>
<p>在nums[i] &gt; nums[j]前提下，如果在[0, i-1]的范围内，找到了j，使得dp[j] + 1 == dp[i]，说明找到了两个相同长度的递增子序列。</p>
<p>那么以i为结尾的子串的最长递增子序列的个数 就应该加上以j为结尾的子串的最长递增子序列的个数，即：count[i] += count[j];</p>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="1-钥匙和房间"><a href="#1-钥匙和房间" class="headerlink" title="1. 钥匙和房间"></a>1. 钥匙和房间</h3><p><strong>841. Keys and Rooms</strong></p>
<p><strong>Q：</strong>There are <code>n</code> rooms labeled from <code>0</code> to <code>n - 1</code> and all the rooms are locked except for room <code>0</code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p>
<p>When you visit a room, you may find a set of <strong>distinct keys</strong> in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p>
<p>Given an array <code>rooms</code> where <code>rooms[i]</code> is the set of keys that you can obtain if you visited room <code>i</code>, return <code>true</code> <em>if you can visit <strong>all</strong> the rooms, or</em> <code>false</code><em>otherwise</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(key <span class="hljs-type">int</span>, rooms [][]<span class="hljs-type">int</span>, visited []<span class="hljs-type">bool</span> )</span></span> &#123;<br>	<span class="hljs-keyword">if</span> visited[key] &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	visited[key] = <span class="hljs-literal">true</span><br>	keys := rooms[key]<br>	<span class="hljs-keyword">for</span> _ , key := <span class="hljs-keyword">range</span> keys &#123;<br>		<span class="hljs-comment">// 深度优先搜索遍历</span><br>		dfs(key, rooms, visited);<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canVisitAllRooms</span><span class="hljs-params">(rooms [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>	visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(rooms));<br>	dfs(<span class="hljs-number">0</span>, rooms, visited);<br>	<span class="hljs-comment">//检查是否都访问到了</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(visited); i++ &#123;<br>		<span class="hljs-keyword">if</span> !visited[i] &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>本题其实给我们是一个有向图， 意识到这是有向图很重要！</p>
<p>图中给我的两个示例： <code>[[1],[2],[3],[]]</code> <code>[[1,3],[3,0,1],[2],[0]]</code>，画成对应的图如下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220714101414.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我们可以看出图1的所有节点都是链接的，而图二中，节点2 是孤立的。</p>
<p>这就很容易让我们想起岛屿问题，只要发现独立的岛，就是不能进入所有房间。</p>
<p>此时也容易想到用并查集的方式去解决。</p>
<p><strong>但本题是有向图</strong>，在有向图中，即使所有节点都是链接的，但依然不可能从0出发遍历所有边。 给大家举一个例子：</p>
<p>图3：[[5], [], [1, 3], [5]] ，如图：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220714102201.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在图3中，大家可以发现，节点0只能到节点5，然后就哪也去不了了。</p>
<p>所以本题是一个有向图搜索全路径的问题。 只能用深搜（BFS）或者广搜（DFS）来搜。</p>
<h3 id="2-单词接龙"><a href="#2-单词接龙" class="headerlink" title="2. 单词接龙"></a>2. 单词接龙</h3><p><strong>127. Word Ladder</strong></p>
<p><strong>Q：</strong>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that:</p>
<ul>
<li>Every adjacent pair of words differs by a single letter.</li>
<li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>
<li><code>sk == endWord</code></li>
</ul>
<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em><code>beginWord</code> <em>to</em> <code>endWord</code><em>, or</em> <code>0</code> <em>if no such sequence exists.</em></p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(beginWord <span class="hljs-type">string</span>, endWord <span class="hljs-type">string</span>, wordList []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	wordMap, que, depth := getWordMap(wordList, beginWord), []<span class="hljs-type">string</span>&#123;beginWord&#125;, <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(que) &gt; <span class="hljs-number">0</span> &#123;<br>		depth++<br>		qLen := <span class="hljs-built_in">len</span>(que)<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; qLen; i++ &#123;<br>			word := que[<span class="hljs-number">0</span>]<br>			que = que[<span class="hljs-number">1</span>:]<br>			candidates := getCandidates(word)<br>			<span class="hljs-keyword">for</span> _, candidate := <span class="hljs-keyword">range</span> candidates &#123;<br>				<span class="hljs-keyword">if</span> _, exist := wordMap[candidate]; exist &#123;<br>					<span class="hljs-keyword">if</span> candidate == endWord &#123;<br>						<span class="hljs-keyword">return</span> depth + <span class="hljs-number">1</span><br>					&#125;<br>					<span class="hljs-built_in">delete</span>(wordMap, candidate)<br>					que = <span class="hljs-built_in">append</span>(que, candidate)<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getWordMap</span><span class="hljs-params">(wordList []<span class="hljs-type">string</span>, beginWord <span class="hljs-type">string</span>)</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>	wordMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>	<span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> wordList &#123;<br>		<span class="hljs-keyword">if</span> _, exist := wordMap[word]; !exist &#123;<br>			<span class="hljs-keyword">if</span> word != beginWord &#123;<br>				wordMap[word] = i<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> wordMap<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getCandidates</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++ &#123;<br>		<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(word); j++ &#123;<br>			<span class="hljs-keyword">if</span> word[j] != <span class="hljs-type">byte</span>(<span class="hljs-type">int</span>(<span class="hljs-string">&#x27;a&#x27;</span>)+i) &#123;<br>				res = <span class="hljs-built_in">append</span>(res, word[:j]+<span class="hljs-type">string</span>(<span class="hljs-type">int</span>(<span class="hljs-string">&#x27;a&#x27;</span>)+i)+word[j+<span class="hljs-number">1</span>:])<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后就是求起点和终点的最短路径长度，<strong>这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径</strong>。因为广搜就是以起点中心向四周扩散的搜索。</p>
<ul>
<li>这一题要求输出从 <code>beginWord</code> 变换到 <code>endWord</code> 最短变换次数。可以用 BFS，从 <code>beginWord</code> 开始变换，把该单词的每个字母都用 <code>&#39;a&#39;~&#39;z&#39;</code> 变换一次，生成的数组到 <code>wordList</code> 中查找，这里用 Map 来记录查找。找得到就入队列，找不到就输出 0 。入队以后按照 BFS 的算法依次遍历完，当所有单词都 <code>len(queue)&lt;=0</code> 出队以后，整个程序结束。</li>
<li>这一题题目中虽然说了要求找到一条最短的路径，但是实际上最短的路径的寻找方法已经告诉你了：<ol>
<li>每次只变换一个字母</li>
<li>每次变换都必须在 <code>wordList</code> 中<br>所以不需要单独考虑何种方式是最短的。</li>
</ol>
</li>
</ul>
<p>相当于一个一个的找，找到一层，就筛选所有的可能的结果，再找到就下一层。</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="1-冗余连接"><a href="#1-冗余连接" class="headerlink" title="1. 冗余连接"></a>1. 冗余连接</h3><p><strong>684. Redundant Connection</strong></p>
<p><strong>Q：</strong>In this problem, a tree is an <strong>undirected graph</strong> that is connected and has no cycles.</p>
<p>You are given a graph that started as a tree with <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, with one additional edge added. The added edge has two <strong>different</strong>vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed. The graph is represented as an array <code>edges</code> of length <code>n</code> where <code>edges[i] = [ai, bi]</code> indicates that there is an edge between nodes <code>ai</code> and <code>bi</code> in the graph.</p>
<p>Return <em>an edge that can be removed so that the resulting graph is a tree of</em> <code>n</code><em>nodes</em>. If there are multiple answers, return the answer that occurs last in the input.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">var</span> (<br>    n = <span class="hljs-number">1005</span> <span class="hljs-comment">// 节点数量3 到 1000</span><br>    father = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1005</span>)<br>)<br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>		father[i] = i<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find</span><span class="hljs-params">(u <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> u == father[u] &#123;<br>		<span class="hljs-keyword">return</span> u<br>	&#125;<br>	father[u] = find(father[u])<br>	<span class="hljs-keyword">return</span> father[u]<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">join</span><span class="hljs-params">(u, v <span class="hljs-type">int</span>)</span></span> &#123;<br>	u = find(u)<br>	v = find(v)<br>	<span class="hljs-keyword">if</span> u == v &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	father[v] = u<br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根，本题用不上</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">same</span><span class="hljs-params">(u, v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>	u = find(u)<br>	v = find(v)<br>	<span class="hljs-keyword">return</span> u == v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(edges [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>	initialize()<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(edges); i++ &#123;<br>		<span class="hljs-keyword">if</span> same(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]) &#123;<br>			<span class="hljs-keyword">return</span> edges[i]<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			join(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>并查集主要有三个功能。</p>
<ol>
<li>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</li>
<li>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上</li>
<li>判断两个节点是否在同一个集合，函数：same(int u, int v)，就是判断两个节点是不是同一个根节点</li>
</ol>
<p>简单介绍并查集之后，我们再来看一下这道题目。</p>
<p>题目说是无向图，返回一条可以删去的边，使得结果图是一个有着N个节点的树。</p>
<p>如果有多个答案，则返回二维数组中最后出现的边。</p>
<p>那么我们就可以从前向后遍历每一条边，边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。</p>
<p>如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，如果再加入这条边一定就出现环了。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/algorithm/">algorithm</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/LeetCode/">LeetCode</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/07/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">go语言笔记</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/20/SQL-Study/">
                        <span class="hidden-mobile">SQL Study</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> & <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
