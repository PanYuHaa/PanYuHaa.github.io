

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon1.png">
  <link rel="icon" href="/img/favicon1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Peter Pan">
  <meta name="keywords" content="">
  
    <meta name="description" content="第3章 数组3.2 二分查找704. Binary Search Q: Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return">
<meta property="og:type" content="article">
<meta property="og:title" content="代码随想录">
<meta property="og:url" content="http://example.com/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/index.html">
<meta property="og:site_name" content="PPStudy">
<meta property="og:description" content="第3章 数组3.2 二分查找704. Binary Search Q: Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/spiraln.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/removelinked-list.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/rev1ex1.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/circularlinkedlist.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/java-hashset-hierarchy.png">
<meta property="article:published_time" content="2022-04-21T01:38:37.000Z">
<meta property="article:modified_time" content="2022-05-06T02:23:15.234Z">
<meta property="article:author" content="Peter Pan">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/spiraln.jpg">
  
  
  <title>代码随想录 - PPStudy</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="代码随想录">
              
                代码随想录
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-21 09:38" pubdate>
        April 21, 2022 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      24k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      203 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">代码随想录</h1>
            
            <div class="markdown-body">
              <h1 id="第3章-数组"><a href="#第3章-数组" class="headerlink" title="第3章 数组"></a>第3章 数组</h1><h2 id="3-2-二分查找"><a href="#3-2-二分查找" class="headerlink" title="3.2 二分查找"></a>3.2 二分查找</h2><p><strong>704. Binary Search</strong></p>
<p><strong>Q:</strong> Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> pivot, left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>      pivot = left + (right - left) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[pivot] == target) <span class="hljs-keyword">return</span> pivot;<br>      <span class="hljs-keyword">if</span> (target &lt; nums[pivot]) right = pivot - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> left = pivot + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中 (left + right) / 2 = left + (right / 2) - (left / 2) = left + (right - left) / 2</p>
<p>我采用的是 [left, right] 闭区间，所以判断条件是 &lt;= ，left和right相等的时候有意义。</p>
<h2 id="3-3-移除元素"><a href="#3-3-移除元素" class="headerlink" title="3.3 移除元素"></a><strong>3.3 移除元素</strong></h2><p><strong>27. Remove Element</strong></p>
<p><strong>Q: </strong>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a>. The relative order of the elements may be changed.</p>
<p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p>
<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] != val) &#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>1⃣️ 由于有空间复杂度的限制，所以不能建立另外一个数组来进行赋值，暗示我们用双指针法，双指针法是常用的降低时间复杂度的方法。</p>
<p>2⃣️ nums = [0, 1 ,4 ,0 ,3 , _ , _] 因为数组中的元素在内存地址上是连续的，不能单独删除数组中的某个元素，只能覆盖。</p>
<h2 id="3-4-长度最小的子数组"><a href="#3-4-长度最小的子数组" class="headerlink" title="3.4 长度最小的子数组"></a>3.4 长度最小的子数组</h2><p><strong>209. Minimum Size Subarray Sum</strong></p>
<p><strong>Q: </strong>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>
<p><strong>A1:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span> MAX;<br>        <span class="hljs-type">int</span> subSum;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历数组中的每一个作为开头</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            subSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-comment">// 求子数组的和</span><br>                subSum += nums[j];<br>                <span class="hljs-keyword">if</span> (subSum &gt;= target) &#123;<br>                    subLength = j - i + <span class="hljs-number">1</span>;<br>                    resultLength = resultLength &gt; subLength ? subLength : resultLength;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span>= MAX ? <span class="hljs-number">0</span> : resultLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>暴力解法，不过也有巧妙思路，通过MAX这个变量增加了判断是否返回0的方法，是flag的另一种用法。</p>
<p><strong>A2:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span> MAX;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 标记左边的起始位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 用j标记的是窗口右边指针的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            subSum += nums[j];<br>            <span class="hljs-comment">// 保证窗口内的sum值永远是大于等于target的</span><br>            <span class="hljs-keyword">while</span> (subSum &gt;= target) &#123;<br>                <span class="hljs-comment">// 获取子数组的长度并判断是否是最小的，+1是因为数组是从0开始的</span><br>                subLength = j - i + <span class="hljs-number">1</span>;<br>                resultLength = resultLength &gt; subLength ? subLength : resultLength;<br>                <span class="hljs-comment">// 收缩左边的指针的位置</span><br>                subSum -= nums[i++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span>= MAX ? <span class="hljs-number">0</span> : resultLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要考虑三个问题：</p>
<p>1⃣️ 窗口内的元素是什么？</p>
<p>2⃣️ 窗口的起始位置？</p>
<p>3⃣️ 窗口的结束位置？</p>
<p>滑动窗口的精妙之处在于根据当前子数组和的大小，不断调节子数组的起始位置，从而将时间复杂度从O(n^2)变成O(n)。</p>
<p>subLength和resultLength必须在满足subSum &gt;= target的时候才有意义，所以放在内部。</p>
<h2 id="3-5-螺旋矩阵"><a href="#3-5-螺旋矩阵" class="headerlink" title="3.5 螺旋矩阵"></a>3.5 螺旋矩阵</h2><p><strong>59. Spiral Matrix II</strong></p>
<p><strong>Q: </strong>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n2</code> in spiral order.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/spiraln.jpg" srcset="/img/loading.gif" lazyload alt="spiraln"></p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] Matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义列边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义行边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 填充值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> row;<br>        <span class="hljs-type">int</span> col;<br><br>        <span class="hljs-keyword">while</span> (value != (n * n) + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 从左向右走</span><br>            <span class="hljs-keyword">for</span> (col = left; col &lt;= right; col++) &#123;<br>                Matrix[up][col] = value;<br>                value++;<br>            &#125;<br>            up++;<br>            <span class="hljs-comment">// 从上向下走</span><br>            <span class="hljs-keyword">for</span> (row = up; row &lt;= down; row++) &#123;<br>                Matrix[row][right] = value;<br>                value++;<br>            &#125;<br>            right--;<br>            <span class="hljs-comment">// 从右向左走</span><br>            <span class="hljs-keyword">for</span> (col = right; col &gt;= left; col--) &#123;<br>                Matrix[down][col] = value;<br>                value++;<br>            &#125;<br>            down--;<br>            <span class="hljs-comment">// 从下向上走</span><br>            <span class="hljs-keyword">for</span> (row = down; row &gt;= up; row--) &#123;<br>                Matrix[row][left] = value;<br>                value++;<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>规定出四个边界，每个方向遍历一次以后通过 ++ 操作来使此行或者此列不再遍历。循环终止的方法有两种，其一是方阵的情况下进行特殊判断，其二是不规则矩阵的情况下进行每个方向上的判断。</p>
<h1 id="第4章-链表"><a href="#第4章-链表" class="headerlink" title="第4章 链表"></a>第4章 链表</h1><h2 id="4-2-虚拟头节点链表删除"><a href="#4-2-虚拟头节点链表删除" class="headerlink" title="4.2 虚拟头节点链表删除"></a>4.2 虚拟头节点链表删除</h2><p><strong>203. Remove Linked List Elements</strong></p>
<p><strong>Q: </strong>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/removelinked-list.jpg" srcset="/img/loading.gif" lazyload alt="removelinked-list"></p>
<p><strong>A1: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>		<span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 虚拟头结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fakeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        fakeHead.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> fakeHead, cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>                pre.next = cur.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = pre.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过加入虚拟头节点来解决如果是第一位就要删除的pre和cur不好指向的问题</p>
<p><strong>A2:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        head.next = removeElements(head.next, val);<br>        <span class="hljs-keyword">return</span> head.val == val ? head.next : head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>递归的方法实现，先递归到最底层，然后往回一点点走，每次都判断，如果有要删除的值就返回前一个，没有要删除的就返回当前的结点，直到回到最初的位置。</p>
<h2 id="4-3-链表常见的六个操作"><a href="#4-3-链表常见的六个操作" class="headerlink" title="4.3 链表常见的六个操作"></a>4.3 链表常见的六个操作</h2><p><strong>707. Design Linked List</strong></p>
<p><strong>Q: </strong>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.<br>A node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code>is the value of the current node, and <code>next</code> is a pointer/reference to the next node.<br>If you want to use the doubly linked list, you will need one more attribute <code>prev</code>to indicate the previous node in the linked list. Assume all nodes in the linked list are <strong>0-indexed</strong>.</p>
<p>Implement the <code>MyLinkedList</code> class:</p>
<ul>
<li><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</li>
<li><code>int get(int index)</code> Get the value of the <code>indexth</code> node in the linked list. If the index is invalid, return <code>-1</code>.</li>
<li><code>void addAtHead(int val)</code> Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>
<li><code>void addAtTail(int val)</code> Append a node of value <code>val</code> as the last element of the linked list.</li>
<li><code>void addAtIndex(int index, int val)</code> Add a node of value <code>val</code>before the <code>indexth</code> node in the linked list. If <code>index</code> equals the length of the linked list, the node will be appended to the end of the linked list. If <code>index</code> is greater than the length, the node <strong>will not be inserted</strong>.</li>
<li><code>void deleteAtIndex(int index)</code> Delete the <code>indexth</code> node in the linked list, if the index is valid.</li>
</ul>
<p><strong>A:</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br>	Node head;<br>	<span class="hljs-type">int</span> length;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-type">int</span> val;<br>        Node next;<br>        <br>        Node(<span class="hljs-type">int</span> val)&#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLinkedList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span>(index &gt;= length)<br>        	<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(counter &lt; index) &#123;<br>        	counter++;<br>        	cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val);<br>        newNode.next = head;<br>        head = newNode;<br>        length++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) &#123;<br>        	addAtHead(val);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>        	<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        	<span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span>)<br>        		cur = cur.next;<br>        	<span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val);<br>        	cur.next = newNode;<br>        	length++;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>    	<span class="hljs-keyword">if</span>(index &gt; length)<br>    		<span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>)<br>        	addAtHead(val);<br>        <span class="hljs-keyword">else</span> &#123;<br>        	<span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        	<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        	<span class="hljs-keyword">while</span>(counter &lt; index) &#123;<br>        		cur = cur.next;<br>        		counter++;<br>        	&#125;<br>        	<span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val);<br>        	<span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>        	cur.next = newNode;<br>        	newNode.next = next;<br>        	length++;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span>(index &gt;= length)<br>        	<span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) &#123;<br>        	head = head.next;<br>        	length--;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>        	<span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        	<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        	<span class="hljs-keyword">while</span>(counter &lt; index) &#123;<br>        		counter++;<br>        		cur = cur.next;<br>        	&#125;<br>        	cur.next = cur.next.next;<br>        	length--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-4-反转链表"><a href="#4-4-反转链表" class="headerlink" title="4.4 反转链表"></a>4.4 反转链表</h2><p><strong>206. Reverse Linked List</strong></p>
<p><strong>Q:</strong> Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/rev1ex1.jpg" srcset="/img/loading.gif" lazyload alt="rev1ex1"></p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tempHead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            tempHead = <span class="hljs-built_in">this</span>.addFirst(tempHead, cur.val);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tempHead;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addFirst</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        newNode.next = head;<br>        head = newNode;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用头插法实现倒叙插入</p>
<h2 id="4-5-删除倒数第n个字节"><a href="#4-5-删除倒数第n个字节" class="headerlink" title="4.5 删除倒数第n个字节"></a>4.5 删除倒数第n个字节</h2><p><strong>19. Remove Nth Node From End of List</strong></p>
<p><strong>Q: </strong>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head. </p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// fakeHead</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fakeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        fakeHead.next = head;<br>        <span class="hljs-comment">// fast &amp; slow, fast pointer faster than slow pointer n steps.</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> fakeHead;<br>        <span class="hljs-comment">// set the position of the fast pointer.</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// n represent the times of loop, if &#x27;i&#x27; start from 0.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> fakeHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过双指针的间距来找到倒数第n个的位置，我让fast提前等于head再往后走，是为了在找到最后的null的时候，slow正好是要删除的结点的前一个。</p>
<h2 id="4-6-环形链表"><a href="#4-6-环形链表" class="headerlink" title="4.6 环形链表"></a>4.6 环形链表</h2><p><strong>142. Linked List Cycle II</strong></p>
<p><strong>Q: </strong>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return</em> <code>null</code>.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>
<p><strong>Do not modify</strong> the linked list.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/circularlinkedlist.png" srcset="/img/loading.gif" lazyload alt="circularlinkedlist"></p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> fast;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1.next;<br>                    index2 = index2.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index2; <span class="hljs-comment">// 返回环的入口</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>双指针的思想，具体推导过程见书P66。</p>
<p>1⃣️判断是否有环？</p>
<p>2⃣️判断环的入口在哪里？</p>
<p>x为起始位置到循环入口的距离，y为循环入口到fast和slow的相遇位置，z为相遇位置到循环入口处的距离。</p>
<p><strong>x = (n - 1)(y + z) + z</strong>，当n = 1时x = z。代表着走了一圈就相遇了。若n &gt; 1的话，道理一样，总之是index2会比index1少转一圈并且相遇。</p>
<p>z是fast相遇的位置开始走，最起码要走一圈，多的就是在入口点前相遇的时候，转了几圈y + z代表的是走一圈要的距离。</p>
<p>ps: n一定大于等于1，因为index1必须最起码走一圈才能够和index2相遇。</p>
<h1 id="第5章-哈希表"><a href="#第5章-哈希表" class="headerlink" title="第5章 哈希表"></a>第5章 哈希表</h1><h2 id="5-2-有效的字母异位词"><a href="#5-2-有效的字母异位词" class="headerlink" title="5.2 有效的字母异位词"></a>5.2 有效的字母异位词</h2><p><strong>242. Valid Anagram</strong></p>
<p><strong>Q: </strong>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code><em>otherwise</em>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            record[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            record[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里用到了一个常用的处理字符出现次数的方法。字符 - ‘a’也算是一种哈希函数，它可以把字符串通过ASCII转换，用26位的数组存储他们出现的次数。</p>
<h2 id="5-3-两个数组的交集"><a href="#5-3-两个数组的交集" class="headerlink" title="5.3 两个数组的交集"></a>5.3 两个数组的交集</h2><p><strong>349. Intersection of Two Arrays</strong></p>
<p><strong>Q: </strong>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; intersect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;<br>            set.add(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(nums2[i])) &#123;<br>                intersect.add(nums2[i]);<br>            &#125;<br>        &#125;<br>  			<span class="hljs-comment">// set turn to the int[]</span><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[intersect.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer num : intersect) &#123;<br>            result[i++] = num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/java-hashset-hierarchy.png" srcset="/img/loading.gif" lazyload alt="java-hashset-hierarchy"></p>
<ul>
<li><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p>
</li>
<li><p>HashSet 允许有 null 值。</p>
</li>
<li><p>HashSet 是无序的，即不会记录插入的顺序。</p>
</li>
<li><p>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。</p>
</li>
<li><p>HashSet 实现了 Set 接口。</p>
</li>
</ul>
<p>进行了两步，第一步初筛有哪些value，第二步确定相交的value又有哪些。</p>
<h2 id="5-4-两数之和"><a href="#5-4-两数之和" class="headerlink" title="5.4 两数之和"></a>5.4 两数之和</h2><p><strong>1. Two Sum</strong></p>
<p><strong>Q: </strong>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>
<p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the <em>same</em> element twice.</p>
<p>You can return the answer in any order.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(target - nums[i]), i&#125;;<br>            &#125;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;No two sum solution&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>思路</p>
<p>标签：哈希映射</p>
<ul>
<li>这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n^2)</li>
<li>由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度</li>
<li>遍历数组 nums, i为当前下标，每个值都判断map中是否存在 target - nums[i] 的 key 值</li>
<li>如果存在则找到了两个值，如果不存在则将当前的 (nums[i], i) 存入 map 中，继续遍历直到找到为止</li>
</ul>
<p>每次都是先判断已有的map里面是否有答案，若没有答案就放进map里，这样只要找到答案立马可以得到结果（通过 target - nums[i] 和此时的 i 得到对应的下标）并且有最优的空间复杂度。之所以用map也是因为我们需要的答案是下标，map可以存储每个数组的下标，而单一的数组是做不到的。</p>
<h2 id="5-5-四数相加"><a href="#5-5-四数相加" class="headerlink" title="5.5 四数相加"></a>5.5 四数相加</h2><p><strong>454. 4Sum II</strong></p>
<p><strong>Q:</strong> Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span>[] B, <span class="hljs-type">int</span>[] C, <span class="hljs-type">int</span>[] D)</span> &#123;<br>        Map&lt;Integer,Integer&gt; sums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : B) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a + b;<br>                <span class="hljs-keyword">if</span>(sums.containsKey(sum)) &#123;<br>                    sums.put(sum, sums.get(sum)+<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    sums.put(sum, <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : C) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : D)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> -(c + d);<br>                <span class="hljs-keyword">if</span> (sums.containsKey(sum)) &#123;<br>                    count+=sums.get(sum);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>利用两数之和的思想，先把四个数组融合成两个，把前两个数组可以组成的所有都放在一个map里面，利用双层遍历把后续的两个数组都进行做差查找。</p>
<h2 id="5-6-三数之和"><a href="#5-6-三数之和" class="headerlink" title="5.6 三数之和"></a>5.6 三数之和</h2><p><strong>15. 3Sum</strong></p>
<p><strong>Q: </strong>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + <span class="hljs-number">2</span> &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;              <span class="hljs-comment">// skip same result</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, k = nums.length - <span class="hljs-number">1</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> -nums[i];<br>        <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] + nums[k] == target) &#123;<br>                res.add(Arrays.asList(nums[i], nums[j], nums[k]));<br>                j++;<br>                k--;<br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) j++;  <span class="hljs-comment">// skip same result</span><br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]) k--;  <span class="hljs-comment">// skip same result</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j] + nums[k] &gt; target) &#123;<br>                k--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Array.sort(int[] arr)用来sort数组默认是从小到大。</p>
<p>res.add(Arrays.asList(nums[i], nums[j], nums[k]));这是List加入一系列数的方法。</p>
<p>把三个动点变成一个定点，两个动点。定点作为循环条件，在循环的基础上进行判断，一个左指针和一个右指针来判断在定点基础上，有没有组合使结果成立。这个的优点是判断了一个重复的情况直接跳过，因为题目说了不能有重复的三元组。</p>
<h2 id="5-7-四数之和"><a href="#5-7-四数之和" class="headerlink" title="5.7 四数之和"></a>5.7 四数之和</h2><p><strong>18. 4Sum</strong></p>
<p><strong>Q: </strong>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong>quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>You may return the answer in <strong>any order</strong>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> targetDiff;<br>        <span class="hljs-type">int</span> left, right;<br>        <span class="hljs-comment">// sort input</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-comment">// skip the same result, if the cur value is same as the former value, the skip the cur value.</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 在 nums[i] 基础上，从 i + 1 处开始遍历，继续三数之和的思想</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-comment">// skip the same result</span><br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                left = j + <span class="hljs-number">2</span>;<br>                right = nums.length - <span class="hljs-number">1</span>;<br>                targetDiff = target - nums[i] - nums[j];<br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-comment">// 若包含的元素能够做差满足问题</span><br>                    <span class="hljs-keyword">if</span> (targetDiff - nums[left] - nums[right] == <span class="hljs-number">0</span>) &#123;<br>                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));<br>                        left++;<br>                        right--;<br>                        <span class="hljs-comment">// skip the same result</span><br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="hljs-number">1</span>]) &#123; left++; &#125;<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="hljs-number">1</span>]) &#123; right--; &#125;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetDiff - nums[left] - nums[right] &gt; <span class="hljs-number">0</span>) &#123;<br>                        left++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在三数之和的基础上，增加了一个维度，他的时间复杂度的增加完全是因为固定的前两位，若是五数之和时间复杂度再*n。</p>
<h1 id="第6章-字符串"><a href="#第6章-字符串" class="headerlink" title="第6章 字符串"></a>第6章 字符串</h1><h2 id="6-2-反转字符串"><a href="#6-2-反转字符串" class="headerlink" title="6.2 反转字符串"></a>6.2 反转字符串</h2><p><strong>344. Reverse String</strong></p>
<p><strong>Q: </strong>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>
<p>You must do this by modifying the input array <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> with <code>O(1)</code> extra memory.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">char</span> temp;<br>      <br>        <span class="hljs-keyword">while</span>(i &lt;= j)&#123;<br>            temp = s[i];<br>            s[i] = s[j];<br>            s[j] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>基本的swap思想，关注点在于 i &lt;= j 和 i &lt; j 都是成立的，但是后者可以少判断一个i = j，可以节省判断的一点点时间。</p>
<h2 id="6-3-反转字符串-II"><a href="#6-3-反转字符串-II" class="headerlink" title="6.3 反转字符串 II"></a>6.3 反转字符串 II</h2><p><strong>541. Reverse String II</strong></p>
<p><strong>Q: </strong>Given a string <code>s</code> and an integer <code>k</code>, reverse the first <code>k</code> characters for every <code>2k</code> characters counting from the start of the string.</p>
<p>If there are fewer than <code>k</code> characters left, reverse all of them. If there are less than <code>2k</code> but greater than or equal to <code>k</code> characters, then reverse the first <code>k</code>characters and leave the other as original.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] charArr = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i += (<span class="hljs-number">2</span> * k)) &#123;<br>            <span class="hljs-comment">// the rest is less than the k, reverse all the rest</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> s.length() - i;<br>            <span class="hljs-keyword">if</span> (rest &lt; k) &#123;<br>                reverseChar(charArr, i, s.length() - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArr);<br>            &#125; <br><br>            <span class="hljs-comment">// 交换的位置是左边i，右边i + (k - 1)</span><br>            reverseChar(charArr, i, (i + k) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArr);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseChar</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">char</span> temp;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            temp = arr[left];<br>            arr[left] = arr[right];<br>            arr[right] = temp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>思路：先分析出交换的方法总共就有两种，交换前k个和交换所有，交换剩余所有是特殊的，所以我们把它放在前面当作特殊条件，只要出现了直接得到结果不用进行多余的判断。</p>
<h2 id="6-4-反转字符串里的单词"><a href="#6-4-反转字符串里的单词" class="headerlink" title="6.4 反转字符串里的单词"></a>6.4 反转字符串里的单词</h2><p><strong>151. Reverse Words in a String</strong></p>
<p><strong>Q: </strong>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>
<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>
<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>
<p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>      <span class="hljs-type">char</span>[] a = s.toCharArray();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length;<br><br>      <span class="hljs-comment">// step 1. reverse the whole string</span><br>      reverse(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// step 2. reverse each word</span><br>      reverseWords(a, n);<br>      <span class="hljs-comment">// step 3. clean up spaces</span><br>      <span class="hljs-keyword">return</span> cleanSpaces(a, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j || i &lt; n &amp;&amp; a[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++; <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; i || j &lt; n &amp;&amp; a[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++; <span class="hljs-comment">// skip non spaces</span><br>        reverse(a, i, j - <span class="hljs-number">1</span>);                      <span class="hljs-comment">// reverse the word</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// trim leading, trailing and multiple spaces</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">cleanSpaces</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="hljs-string">&#x27; &#x27;</span>) j++;             <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] != <span class="hljs-string">&#x27; &#x27;</span>) a[i++] = a[j++]; <span class="hljs-comment">// keep non spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="hljs-string">&#x27; &#x27;</span>) j++;             <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">if</span> (j &lt; n) a[i++] = <span class="hljs-string">&#x27; &#x27;</span>;                      <span class="hljs-comment">// keep only one space</span><br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(a).substring(<span class="hljs-number">0</span>, i);<br>    &#125;<br><br>    <span class="hljs-comment">// reverse a[] from a[i] to a[j]</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>      <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[i];<br>        a[i++] = a[j];<br>        a[j--] = t;<br>      &#125;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>三大关键部分：字符串反转，单词反转，去除空格。</p>
<p>reverseWords部分，i &lt; j 和 j &lt; i 的目的是为了当i在前面的时候，j要去追他，i 和 j - 1 区间就是单词的位置，i不用++是因为前面已经加过了。</p>
<p>CleanSpace部分，把循环里面的步骤分为：1⃣️ 跳过空格，直到找到非空停止。2⃣️ 把非空的值填入到数组的头部，一直重复，直到找到下一个空格。(j &lt; n) 就是用来防止如果后面不再出现空格了，如何退出循环。<3⃣️ 找到下次非空的话，代表有下一个需要进行处理的字母，就将之前填充好的字母的下一位填充一个空格，结束本次循环> </p>
<h2 id="6-6-使用KMP匹配字符串"><a href="#6-6-使用KMP匹配字符串" class="headerlink" title="6.6 使用KMP匹配字符串"></a>6.6 使用KMP匹配字符串</h2><p><strong>28. Implement strStr()</strong></p>
<p><strong>Q: </strong>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>
<p><strong>Clarification:</strong></p>
<p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/cstring/strstr/">strstr()</a> and Java’s <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String">indexOf()</a>).</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span>(haystack == <span class="hljs-literal">null</span> || needle == <span class="hljs-literal">null</span> || needle.length() &gt; haystack.length()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-type">int</span>[] next = kmpPreprocess(needle);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; haystack.length() &amp;&amp; j &lt; needle.length()) &#123;<br>          	<span class="hljs-comment">// 找到了就继续往后找</span><br>            <span class="hljs-keyword">if</span>(haystack.charAt(i) == needle.charAt(j)) &#123;<br>                i++; j++;<br>            <span class="hljs-comment">// 如果匹配串中此位置不相等，匹配串就回退next数组的j - 1位置的值</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 如果字符串没有找到匹配串中的值，并且匹配串还未成功匹配</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span>= needle.length() ? i - j : -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] kmpPreprocess(String pattern) &#123;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[pattern.length()];<br>        <span class="hljs-keyword">while</span>(i &lt; pattern.length()) &#123;<br>          	<span class="hljs-comment">// 用i来控制后缀的最后一位，j来控制前缀的最后一位</span><br>            <span class="hljs-keyword">if</span>(pattern.charAt(i) == pattern.charAt(j)) &#123;<br>                next[i] = j+<span class="hljs-number">1</span>;<br>                i++; j++;<br>            <span class="hljs-comment">// 如果没有一样的并且j没有回到起始点，就返回上一个状态</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                j = next[j-<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 如果回到了原点，就使当前下标i的next数组为0，继续往后找</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                next[i] = <span class="hljs-number">0</span>;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>KMP思想，利用next数组作为匹配的方法。两种构造next数组方法的区别就在于匹配的地方，如果由前缀表统一减一来构造next数组，那么遇到不匹配的地方直接回归对应下标的next数组的数值就行了；不减一的方法，遇到不匹配的地方就查找前一位下标的next数组对应的数值进行回退。</p>
<p>之所以为什么是next[j - 1]是因为，由于当前j位置是不匹配的但j - 1的位置之前的都是匹配的，所以我们要回到尽可能远离起始的位置（根据相同前后缀），也就是next[j - 1]存储的位置信息。</p>
<h2 id="6-7-找到重复的子字符串"><a href="#6-7-找到重复的子字符串" class="headerlink" title="6.7 找到重复的子字符串"></a>6.7 找到重复的子字符串</h2><p><strong>459. Repeated Substring Pattern</strong></p>
<p><strong>Q: </strong>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] next = kmpPreprocess(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % (len - (next[len - <span class="hljs-number">1</span>])) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] kmpPreprocess(String s) &#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-comment">// 直接用前缀表作next数组</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>          	<span class="hljs-comment">// 向前回退，在j = 0或者s[i] == s[j]时退出</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 找到相同的前后缀</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-comment">// 将j(前缀的长度)赋给next[i]</span><br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果len % (len - (next[len - 1])) == 0，则说明(数组长度 - 最长相等前后缀的长度)正好可以被数组的长度整除，该字符串中有重复的数组。</p>
<p>len - 1代表的是最后一位next数组。用前缀表不用-1，因为前缀表本身就+1了。</p>
<p>Cral哥写的这种比较好理解，我一直让j充当相同的j前缀的长度，如果往后遍历的i一直是后缀的起始位置。不用考虑i和j之间的元素，只需要看i和j的位置。基本步调是(和初始是一样的)i在前面，j在后面，如果相同了i继续走一个，j++跟上，如果出现了不一样的，则一直往前回退到有相同的(也可能一直回退到开头)，然后继续按之前的步调走，直到后缀遍历完成。</p>
<p>PS：其中对于前缀表减1的那种方法和这种方法主要的区别是前缀表那种，预处理方便，前缀表减少1那种，遍历的时候方便。方便指好思考。</p>
<h1 id="第7章-栈与队列"><a href="#第7章-栈与队列" class="headerlink" title="第7章 栈与队列"></a>第7章 栈与队列</h1><h2 id="7-2-用栈组成队列"><a href="#7-2-用栈组成队列" class="headerlink" title="7.2 用栈组成队列"></a>7.2 用栈组成队列</h2><p><strong>232. Implement Queue using Stacks</strong></p>
<p><strong>Q: </strong>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyQueue</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>
<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>
<li><code>int peek()</code> Returns the element at the front of the queue.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code>otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</li>
</ul>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <br>    <span class="hljs-comment">// 待处理part</span><br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">stkIn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <span class="hljs-comment">// 预备输出part</span><br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">stkOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stkIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 只有当stkOut为空的时候才导入stkIn的peek</span><br>        <span class="hljs-keyword">if</span> (stkOut.empty()) &#123;<br>            <span class="hljs-comment">// 导入全部的stkIn</span><br>            <span class="hljs-keyword">while</span> (!stkIn.empty()) &#123;<br>                stkOut.push(stkIn.peek());<br>                stkIn.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出栈不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) stkOut.peek();<br>        stkOut.pop();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 只有当stkOut为空的时候才导入stkIn的peek</span><br>        <span class="hljs-keyword">if</span> (stkOut.empty()) &#123;<br>            <span class="hljs-comment">// 导入全部的stkIn</span><br>            <span class="hljs-keyword">while</span> (!stkIn.empty()) &#123;<br>                stkOut.push(stkIn.peek());<br>                stkIn.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出栈不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) stkOut.peek();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (stkIn.empty() &amp;&amp; stkOut.empty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>要使用两个队列，一个用来输入一个用来输出。特别要注意的是关注输出栈是不是空的，如果非空要优先处理输出栈的（pop和peek方法）</p>
<h2 id="7-3-用队列组成栈"><a href="#7-3-用队列组成栈" class="headerlink" title="7.3 用队列组成栈"></a>7.3 用队列组成栈</h2><p><strong>225. Implement Stack using Queues</strong></p>
<p><strong>Q: </strong></p>
<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyStack</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>
<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>
<li><code>int top()</code> Returns the element on the top of the stack.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code>otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code>operations are valid.</li>
<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</li>
</ul>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// Push element x onto stack.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue.add(x);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)<br>            queue.add(queue.poll());<br>            n--;<br>    &#125;<br><br>    <span class="hljs-comment">// Removes the element on top of the stack.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        queue.poll();<br>    &#125;<br><br>    <span class="hljs-comment">// Get the top element.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br><br>    <span class="hljs-comment">// Return whether the stack is empty.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里和之前的用栈组成队列不太一样，可以只使用一个，总体来讲是个缓存的思想，将队头的元素重新放回到队尾(双队列也如此)。</p>
<h2 id="7-4-匹配括号"><a href="#7-4-匹配括号" class="headerlink" title="7.4 匹配括号"></a>7.4 匹配括号</h2><p><strong>20. Valid Parentheses</strong></p>
<p><strong>Q: </strong>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code>and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Character&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>      <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() != c)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先学会一点，匹配对的问题可以用栈来解决(先出现的左符号要最后匹配右符号，这样正好符合栈的特点)。对于这道题我们反过来想，当匹配到左符号，就将对应的右符号压入栈，然后往后匹配看看后面有没有对应的右符号。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/algorithm/">algorithm</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/LeetCode/">LeetCode</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/20/SQL-Study/">
                        <span class="hidden-mobile">SQL Study</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> & <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
