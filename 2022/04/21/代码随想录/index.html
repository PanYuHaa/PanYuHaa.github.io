

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon1.png">
  <link rel="icon" href="/img/favicon1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Peter Pan">
  <meta name="keywords" content="">
  
    <meta name="description" content="第3章 数组3.2 二分查找704. Binary Search Q: Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return">
<meta property="og:type" content="article">
<meta property="og:title" content="代码随想录">
<meta property="og:url" content="http://example.com/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/index.html">
<meta property="og:site_name" content="PPStudy">
<meta property="og:description" content="第3章 数组3.2 二分查找704. Binary Search Q: Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/spiraln.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/removelinked-list.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/rev1ex1.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/circularlinkedlist.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/java-hashset-hierarchy.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201123195242899.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201123200304469.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201123202736384.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201123203735933.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202011232041348.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201124200229824.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201124201331223.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210130182532303.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020111720451790.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020112917480858.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201124154758229.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201201232445286.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201213162821958.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210107093253987.png">
<meta property="article:published_time" content="2022-04-21T01:38:37.000Z">
<meta property="article:modified_time" content="2022-07-18T02:11:38.279Z">
<meta property="article:author" content="Peter Pan">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/spiraln.jpg">
  
  
  <title>代码随想录 - PPStudy</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="代码随想录">
              
                代码随想录
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-21 09:38" pubdate>
        April 21, 2022 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      83k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      692 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">代码随想录</h1>
            
            <div class="markdown-body">
              <h1 id="第3章-数组"><a href="#第3章-数组" class="headerlink" title="第3章 数组"></a>第3章 数组</h1><h2 id="3-2-二分查找"><a href="#3-2-二分查找" class="headerlink" title="3.2 二分查找"></a>3.2 二分查找</h2><p><strong>704. Binary Search</strong></p>
<p><strong>Q:</strong> Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> pivot, left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>      pivot = left + (right - left) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[pivot] == target) <span class="hljs-keyword">return</span> pivot;<br>      <span class="hljs-keyword">if</span> (target &lt; nums[pivot]) right = pivot - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> left = pivot + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中 (left + right) / 2 = left + (right / 2) - (left / 2) = left + (right - left) / 2</p>
<p>我采用的是 [left, right] 闭区间，所以判断条件是 &lt;= ，left和right相等的时候有意义。</p>
<h2 id="3-3-移除元素"><a href="#3-3-移除元素" class="headerlink" title="3.3 移除元素"></a><strong>3.3 移除元素</strong></h2><p><strong>27. Remove Element</strong></p>
<p><strong>Q: </strong>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <strong>in-place</strong>. The relative order of the elements may be changed.</p>
<p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p>
<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] != val) &#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>1⃣️ 由于有空间复杂度的限制，所以不能建立另外一个数组来进行赋值，暗示我们用双指针法，双指针法是常用的降低时间复杂度的方法。</p>
<p>2⃣️ nums = [0, 1 ,4 ,0 ,3 , _ , _] 因为数组中的元素在内存地址上是连续的，不能单独删除数组中的某个元素，只能覆盖。</p>
<h2 id="3-4-长度最小的子数组"><a href="#3-4-长度最小的子数组" class="headerlink" title="3.4 长度最小的子数组"></a>3.4 长度最小的子数组</h2><p><strong>209. Minimum Size Subarray Sum</strong></p>
<p><strong>Q: </strong>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>
<p><strong>A1:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span> MAX;<br>        <span class="hljs-type">int</span> subSum;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历数组中的每一个作为开头</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            subSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-comment">// 求子数组的和</span><br>                subSum += nums[j];<br>                <span class="hljs-keyword">if</span> (subSum &gt;= target) &#123;<br>                    subLength = j - i + <span class="hljs-number">1</span>;<br>                    resultLength = resultLength &gt; subLength ? subLength : resultLength;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span>= MAX ? <span class="hljs-number">0</span> : resultLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>暴力解法，不过也有巧妙思路，通过MAX这个变量增加了判断是否返回0的方法，是flag的另一种用法。</p>
<p><strong>A2:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span> MAX;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 标记左边的起始位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 用j标记的是窗口右边指针的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            subSum += nums[j];<br>            <span class="hljs-comment">// 保证窗口内的sum值永远是大于等于target的</span><br>            <span class="hljs-keyword">while</span> (subSum &gt;= target) &#123;<br>                <span class="hljs-comment">// 获取子数组的长度并判断是否是最小的，+1是因为数组是从0开始的</span><br>                subLength = j - i + <span class="hljs-number">1</span>;<br>                resultLength = resultLength &gt; subLength ? subLength : resultLength;<br>                <span class="hljs-comment">// 收缩左边的指针的位置</span><br>                subSum -= nums[i++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span>= MAX ? <span class="hljs-number">0</span> : resultLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要考虑三个问题：</p>
<p>1⃣️ 窗口内的元素是什么？</p>
<p>2⃣️ 窗口的起始位置？</p>
<p>3⃣️ 窗口的结束位置？</p>
<p>滑动窗口的精妙之处在于根据当前子数组和的大小，不断调节子数组的起始位置，从而将时间复杂度从O(n^2)变成O(n)。</p>
<p>subLength和resultLength必须在满足subSum &gt;= target的时候才有意义，所以放在内部。</p>
<h2 id="3-5-螺旋矩阵"><a href="#3-5-螺旋矩阵" class="headerlink" title="3.5 螺旋矩阵"></a>3.5 螺旋矩阵</h2><p><strong>59. Spiral Matrix II</strong></p>
<p><strong>Q: </strong>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n2</code> in spiral order.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/spiraln.jpg" srcset="/img/loading.gif" lazyload alt="spiraln"></p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] Matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义列边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义行边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 填充值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> row;<br>        <span class="hljs-type">int</span> col;<br><br>        <span class="hljs-keyword">while</span> (value != (n * n) + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 从左向右走</span><br>            <span class="hljs-keyword">for</span> (col = left; col &lt;= right; col++) &#123;<br>                Matrix[up][col] = value;<br>                value++;<br>            &#125;<br>            up++;<br>            <span class="hljs-comment">// 从上向下走</span><br>            <span class="hljs-keyword">for</span> (row = up; row &lt;= down; row++) &#123;<br>                Matrix[row][right] = value;<br>                value++;<br>            &#125;<br>            right--;<br>            <span class="hljs-comment">// 从右向左走</span><br>            <span class="hljs-keyword">for</span> (col = right; col &gt;= left; col--) &#123;<br>                Matrix[down][col] = value;<br>                value++;<br>            &#125;<br>            down--;<br>            <span class="hljs-comment">// 从下向上走</span><br>            <span class="hljs-keyword">for</span> (row = down; row &gt;= up; row--) &#123;<br>                Matrix[row][left] = value;<br>                value++;<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>规定出四个边界，每个方向遍历一次以后通过 ++ 操作来使此行或者此列不再遍历。循环终止的方法有两种，其一是方阵的情况下进行特殊判断，其二是不规则矩阵的情况下进行每个方向上的判断。</p>
<h1 id="第4章-链表"><a href="#第4章-链表" class="headerlink" title="第4章 链表"></a>第4章 链表</h1><h2 id="4-2-虚拟头节点链表删除"><a href="#4-2-虚拟头节点链表删除" class="headerlink" title="4.2 虚拟头节点链表删除"></a>4.2 虚拟头节点链表删除</h2><p><strong>203. Remove Linked List Elements</strong></p>
<p><strong>Q: </strong>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/removelinked-list.jpg" srcset="/img/loading.gif" lazyload alt="removelinked-list"></p>
<p><strong>A1: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>		<span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 虚拟头结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fakeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        fakeHead.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> fakeHead, cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>                pre.next = cur.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = pre.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过加入虚拟头节点来解决如果是第一位就要删除的pre和cur不好指向的问题</p>
<p><strong>A2:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        head.next = removeElements(head.next, val);<br>        <span class="hljs-keyword">return</span> head.val == val ? head.next : head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>递归的方法实现，先递归到最底层，然后往回一点点走，每次都判断，如果有要删除的值就返回前一个，没有要删除的就返回当前的结点，直到回到最初的位置。</p>
<h2 id="4-3-链表常见的六个操作"><a href="#4-3-链表常见的六个操作" class="headerlink" title="4.3 链表常见的六个操作"></a>4.3 链表常见的六个操作</h2><p><strong>707. Design Linked List</strong></p>
<p><strong>Q: </strong>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.<br>A node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code>is the value of the current node, and <code>next</code> is a pointer/reference to the next node.<br>If you want to use the doubly linked list, you will need one more attribute <code>prev</code>to indicate the previous node in the linked list. Assume all nodes in the linked list are <strong>0-indexed</strong>.</p>
<p>Implement the <code>MyLinkedList</code> class:</p>
<ul>
<li><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</li>
<li><code>int get(int index)</code> Get the value of the <code>indexth</code> node in the linked list. If the index is invalid, return <code>-1</code>.</li>
<li><code>void addAtHead(int val)</code> Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>
<li><code>void addAtTail(int val)</code> Append a node of value <code>val</code> as the last element of the linked list.</li>
<li><code>void addAtIndex(int index, int val)</code> Add a node of value <code>val</code>before the <code>indexth</code> node in the linked list. If <code>index</code> equals the length of the linked list, the node will be appended to the end of the linked list. If <code>index</code> is greater than the length, the node <strong>will not be inserted</strong>.</li>
<li><code>void deleteAtIndex(int index)</code> Delete the <code>indexth</code> node in the linked list, if the index is valid.</li>
</ul>
<p><strong>A:</strong> </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyLinkedList <span class="hljs-keyword">struct</span> &#123;<br>	head *Node<br>&#125;<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>	Val  <span class="hljs-type">int</span><br>	Next *Node<br>	Prev *Node<br>&#125;<br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyLinkedList &#123;<br>	<span class="hljs-keyword">return</span> MyLinkedList&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> Get(index <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>	curr := this.head<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>		curr = curr.Next<br>	&#125;<br>	<span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> curr.Val<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="hljs-type">int</span>) &#123;<br>	node := &amp;Node&#123;Val: val&#125;<br>	node.Next = this.head<br>	<span class="hljs-keyword">if</span> this.head != <span class="hljs-literal">nil</span> &#123;<br>		this.head.Prev = node<br>	&#125;<br>	this.head = node<br>&#125;<br><br><span class="hljs-comment">/** Append a node of value val to the last element of the linked list. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="hljs-type">int</span>) &#123;<br>	<span class="hljs-keyword">if</span> this.head == <span class="hljs-literal">nil</span> &#123;<br>		this.AddAtHead(val)<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	node := &amp;Node&#123;Val: val&#125;<br>	curr := this.head<br>	<span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &amp;&amp; curr.Next != <span class="hljs-literal">nil</span> &#123;<br>		curr = curr.Next<br>	&#125;<br>	node.Prev = curr<br>	curr.Next = node<br>&#125;<br><br><span class="hljs-comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="hljs-type">int</span>, val <span class="hljs-type">int</span>) &#123;<br>	<span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>		this.AddAtHead(val)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		node := &amp;Node&#123;Val: val&#125;<br>		curr := this.head<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index<span class="hljs-number">-1</span> &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>			curr = curr.Next<br>		&#125;<br>		<span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &#123;<br>			node.Next = curr.Next<br>			node.Prev = curr<br>			<span class="hljs-keyword">if</span> node.Next != <span class="hljs-literal">nil</span> &#123;<br>				node.Next.Prev = node<br>			&#125;<br>			curr.Next = node<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/** Delete the index-th node in the linked list, if the index is valid. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="hljs-type">int</span>) &#123;<br>	<span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>		this.head = this.head.Next<br>		<span class="hljs-keyword">if</span> this.head != <span class="hljs-literal">nil</span> &#123;<br>			this.head.Prev = <span class="hljs-literal">nil</span><br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		curr := this.head<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index<span class="hljs-number">-1</span> &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>			curr = curr.Next<br>		&#125;<br>		<span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &amp;&amp; curr.Next != <span class="hljs-literal">nil</span> &#123;<br>			curr.Next = curr.Next.Next<br>			<span class="hljs-keyword">if</span> curr.Next != <span class="hljs-literal">nil</span> &#123;<br>				curr.Next.Prev = curr<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * param_1 := obj.Get(index);</span><br><span class="hljs-comment"> * obj.AddAtHead(val);</span><br><span class="hljs-comment"> * obj.AddAtTail(val);</span><br><span class="hljs-comment"> * obj.AddAtIndex(index,val);</span><br><span class="hljs-comment"> * obj.DeleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h2 id="4-4-反转链表"><a href="#4-4-反转链表" class="headerlink" title="4.4 反转链表"></a>4.4 反转链表</h2><p><strong>206. Reverse Linked List</strong></p>
<p><strong>Q:</strong> Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/rev1ex1.jpg" srcset="/img/loading.gif" lazyload alt="rev1ex1"></p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tempHead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            tempHead = <span class="hljs-built_in">this</span>.addFirst(tempHead, cur.val);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tempHead;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addFirst</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        newNode.next = head;<br>        head = newNode;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用头插法实现倒叙插入</p>
<h2 id="4-5-删除倒数第n个字节"><a href="#4-5-删除倒数第n个字节" class="headerlink" title="4.5 删除倒数第n个字节"></a>4.5 删除倒数第n个字节</h2><p><strong>19. Remove Nth Node From End of List</strong></p>
<p><strong>Q: </strong>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head. </p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// fakeHead</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fakeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        fakeHead.next = head;<br>        <span class="hljs-comment">// fast &amp; slow, fast pointer faster than slow pointer n steps.</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> fakeHead;<br>        <span class="hljs-comment">// set the position of the fast pointer.</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// n represent the times of loop, if &#x27;i&#x27; start from 0.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> fakeHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过双指针的间距来找到倒数第n个的位置，我让fast提前等于head再往后走，是为了在找到最后的null的时候，slow正好是要删除的结点的前一个。</p>
<h2 id="4-6-环形链表"><a href="#4-6-环形链表" class="headerlink" title="4.6 环形链表"></a>4.6 环形链表</h2><p><strong>142. Linked List Cycle II</strong></p>
<p><strong>Q: </strong>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return</em> <code>null</code>.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>
<p><strong>Do not modify</strong> the linked list.</p>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/circularlinkedlist.png" srcset="/img/loading.gif" lazyload alt="circularlinkedlist"></p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<span class="hljs-comment">// 有环</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> fast;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span><br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1.next;<br>                    index2 = index2.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>双指针的思想，具体推导过程见书P66。</p>
<p>1⃣️判断是否有环？</p>
<p>2⃣️判断环的入口在哪里？</p>
<p>x为起始位置到循环入口的距离，y为循环入口到fast和slow的相遇位置，z为相遇位置到循环入口处的距离。</p>
<p><strong>x = (n - 1)(y + z) + z</strong>，当n = 1时x = z。代表着走了一圈就相遇了。若n &gt; 1的话，道理一样，总之是index2会比index1少转一圈并且相遇。</p>
<p>z是fast相遇的位置开始走，最起码要走一圈，多的就是在入口点前相遇的时候，转了几圈y + z代表的是走一圈要的距离。</p>
<p>ps: n一定大于等于1，因为index1必须最起码走一圈才能够和index2相遇。</p>
<h1 id="第5章-哈希表"><a href="#第5章-哈希表" class="headerlink" title="第5章 哈希表"></a>第5章 哈希表</h1><h2 id="5-2-有效的字母异位词"><a href="#5-2-有效的字母异位词" class="headerlink" title="5.2 有效的字母异位词"></a>5.2 有效的字母异位词</h2><p><strong>242. Valid Anagram</strong></p>
<p><strong>Q: </strong>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code><em>otherwise</em>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            record[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            record[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里用到了一个常用的处理字符出现次数的方法。字符 - ‘a’也算是一种哈希函数，它可以把字符串通过ASCII转换，用26位的数组存储他们出现的次数。</p>
<h2 id="5-3-两个数组的交集"><a href="#5-3-两个数组的交集" class="headerlink" title="5.3 两个数组的交集"></a>5.3 两个数组的交集</h2><p><strong>349. Intersection of Two Arrays</strong></p>
<p><strong>Q: </strong>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; intersect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;<br>            set.add(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(nums2[i])) &#123;<br>                intersect.add(nums2[i]);<br>            &#125;<br>        &#125;<br>  			<span class="hljs-comment">// set turn to the int[]</span><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[intersect.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer num : intersect) &#123;<br>            result[i++] = num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/java-hashset-hierarchy.png" srcset="/img/loading.gif" lazyload alt="java-hashset-hierarchy"></p>
<ul>
<li><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p>
</li>
<li><p>HashSet 允许有 null 值。</p>
</li>
<li><p>HashSet 是无序的，即不会记录插入的顺序。</p>
</li>
<li><p>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。</p>
</li>
<li><p>HashSet 实现了 Set 接口。</p>
</li>
</ul>
<p>进行了两步，第一步初筛有哪些value，第二步确定相交的value又有哪些。</p>
<h2 id="5-4-两数之和"><a href="#5-4-两数之和" class="headerlink" title="5.4 两数之和"></a>5.4 两数之和</h2><p><strong>1. Two Sum</strong></p>
<p><strong>Q: </strong>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>
<p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the <em>same</em> element twice.</p>
<p>You can return the answer in any order.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(target - nums[i]), i&#125;;<br>            &#125;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;No two sum solution&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>思路</p>
<p>标签：哈希映射</p>
<ul>
<li>这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n^2)</li>
<li>由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度</li>
<li>遍历数组 nums, i为当前下标，每个值都判断map中是否存在 target - nums[i] 的 key 值</li>
<li>如果存在则找到了两个值，如果不存在则将当前的 (nums[i], i) 存入 map 中，继续遍历直到找到为止</li>
</ul>
<p>每次都是先判断已有的map里面是否有答案，若没有答案就放进map里，这样只要找到答案立马可以得到结果（通过 target - nums[i] 和此时的 i 得到对应的下标）并且有最优的空间复杂度。之所以用map也是因为我们需要的答案是下标，map可以存储每个数组的下标，而单一的数组是做不到的。</p>
<h2 id="5-5-四数相加"><a href="#5-5-四数相加" class="headerlink" title="5.5 四数相加"></a>5.5 四数相加</h2><p><strong>454. 4Sum II</strong></p>
<p><strong>Q:</strong> Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span>[] B, <span class="hljs-type">int</span>[] C, <span class="hljs-type">int</span>[] D)</span> &#123;<br>        Map&lt;Integer,Integer&gt; sums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : B) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a + b;<br>                <span class="hljs-keyword">if</span>(sums.containsKey(sum)) &#123;<br>                    sums.put(sum, sums.get(sum)+<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    sums.put(sum, <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : C) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : D)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> -(c + d);<br>                <span class="hljs-keyword">if</span> (sums.containsKey(sum)) &#123;<br>                    count+=sums.get(sum);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>利用两数之和的思想，先把四个数组融合成两个，把前两个数组可以组成的所有都放在一个map里面，利用双层遍历把后续的两个数组都进行做差查找。</p>
<h2 id="5-6-三数之和"><a href="#5-6-三数之和" class="headerlink" title="5.6 三数之和"></a>5.6 三数之和</h2><p><strong>15. 3Sum</strong></p>
<p><strong>Q: </strong>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + <span class="hljs-number">2</span> &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;              <span class="hljs-comment">// skip same result</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, k = nums.length - <span class="hljs-number">1</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> -nums[i];<br>        <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] + nums[k] == target) &#123;<br>                res.add(Arrays.asList(nums[i], nums[j], nums[k]));<br>                j++;<br>                k--;<br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) j++;  <span class="hljs-comment">// skip same result</span><br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]) k--;  <span class="hljs-comment">// skip same result</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j] + nums[k] &gt; target) &#123;<br>                k--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Array.sort(int[] arr)用来sort数组默认是从小到大。</p>
<p>res.add(Arrays.asList(nums[i], nums[j], nums[k]));这是List加入一系列数的方法。</p>
<p>把三个动点变成一个定点，两个动点。定点作为循环条件，在循环的基础上进行判断，一个左指针和一个右指针来判断在定点基础上，有没有组合使结果成立。这个的优点是判断了一个重复的情况直接跳过，因为题目说了不能有重复的三元组。</p>
<h2 id="5-7-四数之和"><a href="#5-7-四数之和" class="headerlink" title="5.7 四数之和"></a>5.7 四数之和</h2><p><strong>18. 4Sum</strong></p>
<p><strong>Q: </strong>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong>quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>You may return the answer in <strong>any order</strong>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> targetDiff;<br>        <span class="hljs-type">int</span> left, right;<br>        <span class="hljs-comment">// sort input</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-comment">// skip the same result, if the cur value is same as the former value, the skip the cur value.</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 在 nums[i] 基础上，从 i + 1 处开始遍历，继续三数之和的思想</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-comment">// skip the same result</span><br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                left = j + <span class="hljs-number">2</span>;<br>                right = nums.length - <span class="hljs-number">1</span>;<br>                targetDiff = target - nums[i] - nums[j];<br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-comment">// 若包含的元素能够做差满足问题</span><br>                    <span class="hljs-keyword">if</span> (targetDiff - nums[left] - nums[right] == <span class="hljs-number">0</span>) &#123;<br>                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));<br>                        left++;<br>                        right--;<br>                        <span class="hljs-comment">// skip the same result</span><br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="hljs-number">1</span>]) &#123; left++; &#125;<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="hljs-number">1</span>]) &#123; right--; &#125;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetDiff - nums[left] - nums[right] &gt; <span class="hljs-number">0</span>) &#123;<br>                        left++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在三数之和的基础上，增加了一个维度，他的时间复杂度的增加完全是因为固定的前两位，若是五数之和时间复杂度再*n。</p>
<h1 id="第6章-字符串"><a href="#第6章-字符串" class="headerlink" title="第6章 字符串"></a>第6章 字符串</h1><h2 id="6-2-反转字符串"><a href="#6-2-反转字符串" class="headerlink" title="6.2 反转字符串"></a>6.2 反转字符串</h2><p><strong>344. Reverse String</strong></p>
<p><strong>Q: </strong>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>
<p>You must do this by modifying the input array <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> with <code>O(1)</code> extra memory.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">char</span> temp;<br>      <br>        <span class="hljs-keyword">while</span>(i &lt;= j)&#123;<br>            temp = s[i];<br>            s[i] = s[j];<br>            s[j] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>基本的swap思想，关注点在于 i &lt;= j 和 i &lt; j 都是成立的，但是后者可以少判断一个i = j，可以节省判断的一点点时间。</p>
<h2 id="6-3-反转字符串-II"><a href="#6-3-反转字符串-II" class="headerlink" title="6.3 反转字符串 II"></a>6.3 反转字符串 II</h2><p><strong>541. Reverse String II</strong></p>
<p><strong>Q: </strong>Given a string <code>s</code> and an integer <code>k</code>, reverse the first <code>k</code> characters for every <code>2k</code> characters counting from the start of the string.</p>
<p>If there are fewer than <code>k</code> characters left, reverse all of them. If there are less than <code>2k</code> but greater than or equal to <code>k</code> characters, then reverse the first <code>k</code>characters and leave the other as original.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] charArr = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i += (<span class="hljs-number">2</span> * k)) &#123;<br>            <span class="hljs-comment">// the rest is less than the k, reverse all the rest</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> s.length() - i;<br>            <span class="hljs-keyword">if</span> (rest &lt; k) &#123;<br>                reverseChar(charArr, i, s.length() - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArr);<br>            &#125; <br><br>            <span class="hljs-comment">// 交换的位置是左边i，右边i + (k - 1)</span><br>            reverseChar(charArr, i, (i + k) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArr);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseChar</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">char</span> temp;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            temp = arr[left];<br>            arr[left] = arr[right];<br>            arr[right] = temp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>思路：先分析出交换的方法总共就有两种，交换前k个和交换所有，交换剩余所有是特殊的，所以我们把它放在前面当作特殊条件，只要出现了直接得到结果不用进行多余的判断。</p>
<h2 id="6-4-反转字符串里的单词"><a href="#6-4-反转字符串里的单词" class="headerlink" title="6.4 反转字符串里的单词"></a>6.4 反转字符串里的单词</h2><p><strong>151. Reverse Words in a String</strong></p>
<p><strong>Q: </strong>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>
<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>
<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>
<p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>      <span class="hljs-type">char</span>[] a = s.toCharArray();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length;<br><br>      <span class="hljs-comment">// step 1. reverse the whole string</span><br>      reverse(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// step 2. reverse each word</span><br>      reverseWords(a, n);<br>      <span class="hljs-comment">// step 3. clean up spaces</span><br>      <span class="hljs-keyword">return</span> cleanSpaces(a, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j || i &lt; n &amp;&amp; a[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++; <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; i || j &lt; n &amp;&amp; a[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++; <span class="hljs-comment">// skip non spaces</span><br>        reverse(a, i, j - <span class="hljs-number">1</span>);                      <span class="hljs-comment">// reverse the word</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// trim leading, trailing and multiple spaces</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">cleanSpaces</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="hljs-string">&#x27; &#x27;</span>) j++;             <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] != <span class="hljs-string">&#x27; &#x27;</span>) a[i++] = a[j++]; <span class="hljs-comment">// keep non spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="hljs-string">&#x27; &#x27;</span>) j++;             <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">if</span> (j &lt; n) a[i++] = <span class="hljs-string">&#x27; &#x27;</span>;                      <span class="hljs-comment">// keep only one space</span><br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(a).substring(<span class="hljs-number">0</span>, i);<br>    &#125;<br><br>    <span class="hljs-comment">// reverse a[] from a[i] to a[j]</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>      <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[i];<br>        a[i++] = a[j];<br>        a[j--] = t;<br>      &#125;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>三大关键部分：字符串反转，单词反转，去除空格。</p>
<p>reverseWords部分，i代表的是字符串的起点，j代表的是字符串的终点，i先跳过空格，j再跳过所有字符。</p>
<p>CleanSpace部分，把循环里面的步骤分为：1⃣️ 跳过空格，直到找到非空停止。2⃣️ 把非空的值填入到数组的头部，一直重复，直到找到下一个空格。(j &lt; n) 就是用来防止如果后面不再出现空格了，如何退出循环。<3⃣️ 找到下次非空的话，代表有下一个需要进行处理的字母，就将之前填充好的字母的下一位填充一个空格，结束本次循环> </p>
<h2 id="6-6-使用KMP匹配字符串"><a href="#6-6-使用KMP匹配字符串" class="headerlink" title="6.6 使用KMP匹配字符串"></a>6.6 使用KMP匹配字符串</h2><p><strong>28. Implement strStr()</strong></p>
<p><strong>Q: </strong>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>
<p><strong>Clarification:</strong></p>
<p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/cstring/strstr/">strstr()</a> and Java’s <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String">indexOf()</a>).</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span>(haystack == <span class="hljs-literal">null</span> || needle == <span class="hljs-literal">null</span> || needle.length() &gt; haystack.length()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-type">int</span>[] next = kmpPreprocess(needle);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; haystack.length() &amp;&amp; j &lt; needle.length()) &#123;<br>          	<span class="hljs-comment">// 找到了就继续往后找</span><br>            <span class="hljs-keyword">if</span>(haystack.charAt(i) == needle.charAt(j)) &#123;<br>                i++; j++;<br>            <span class="hljs-comment">// 如果匹配串中此位置不相等，匹配串就回退next数组的j - 1位置的值</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 如果字符串没有找到匹配串中的值，并且匹配串还未成功匹配</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span>= needle.length() ? i - j : -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] kmpPreprocess(String s) &#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-comment">// 直接用前缀表作next数组</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>          	<span class="hljs-comment">// 向前回退，在j = 0或者s[i] == s[j]时退出</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 找到相同的前后缀</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-comment">// 将j(前缀的长度)赋给next[i]</span><br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>KMP思想，利用next数组作为匹配的方法。两种构造next数组方法的区别就在于匹配的地方，如果由前缀表统一减一来构造next数组，那么遇到不匹配的地方直接回归对应下标的next数组的数值就行了；不减一的方法，遇到不匹配的地方就查找前一位下标的next数组对应的数值进行回退。</p>
<p>之所以为什么是next[j - 1]是因为，由于当前j位置是不匹配的但j - 1的位置之前的都是匹配的，所以我们要回到尽可能远离起始的位置（根据相同前后缀），也就是next[j - 1]存储的位置信息。</p>
<h2 id="6-7-找到重复的子字符串"><a href="#6-7-找到重复的子字符串" class="headerlink" title="6.7 找到重复的子字符串"></a>6.7 找到重复的子字符串</h2><p><strong>459. Repeated Substring Pattern</strong></p>
<p><strong>Q: </strong>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] next = kmpPreprocess(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % (len - (next[len - <span class="hljs-number">1</span>])) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] kmpPreprocess(String s) &#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-comment">// 直接用前缀表作next数组</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>          	<span class="hljs-comment">// 向前回退，在j = 0或者s[i] == s[j]时退出</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 找到相同的前后缀</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-comment">// 将j(前缀的长度)赋给next[i]</span><br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果len % (len - (next[len - 1])) == 0，则说明(数组长度 - 最长相等前后缀的长度)正好可以被数组的长度整除，该字符串中有重复的数组。</p>
<p>len - 1代表的是最后一位next数组。用前缀表不用-1，因为前缀表本身就+1了。</p>
<p>Cral哥写的这种比较好理解，我一直让j充当相同的j前缀的长度，如果往后遍历的i一直是后缀的起始位置。不用考虑i和j之间的元素，只需要看i和j的位置。基本步调是(和初始是一样的)i在前面，j在后面，如果相同了j++跟上，i继续走一个，如果出现了不一样的，则一直往前回退到有相同的(也可能一直回退到开头)，然后继续按之前的步调走，直到后缀遍历完成。</p>
<p>PS：其中对于前缀表减1的那种方法和这种方法主要的区别是前缀表那种，预处理方便，前缀表减少1那种，遍历的时候方便。方便指好思考。</p>
<h1 id="第7章-栈与队列"><a href="#第7章-栈与队列" class="headerlink" title="第7章 栈与队列"></a>第7章 栈与队列</h1><h2 id="7-2-用栈组成队列"><a href="#7-2-用栈组成队列" class="headerlink" title="7.2 用栈组成队列"></a>7.2 用栈组成队列</h2><p><strong>232. Implement Queue using Stacks</strong></p>
<p><strong>Q: </strong>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyQueue</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>
<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>
<li><code>int peek()</code> Returns the element at the front of the queue.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code>otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</li>
</ul>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <br>    <span class="hljs-comment">// 待处理part</span><br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">stkIn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <span class="hljs-comment">// 预备输出part</span><br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">stkOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stkIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 只有当stkOut为空的时候才导入stkIn的peek</span><br>        <span class="hljs-keyword">if</span> (stkOut.empty()) &#123;<br>            <span class="hljs-comment">// 导入全部的stkIn</span><br>            <span class="hljs-keyword">while</span> (!stkIn.empty()) &#123;<br>                stkOut.push(stkIn.peek());<br>                stkIn.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出栈不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) stkOut.peek();<br>        stkOut.pop();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 只有当stkOut为空的时候才导入stkIn的peek</span><br>        <span class="hljs-keyword">if</span> (stkOut.empty()) &#123;<br>            <span class="hljs-comment">// 导入全部的stkIn</span><br>            <span class="hljs-keyword">while</span> (!stkIn.empty()) &#123;<br>                stkOut.push(stkIn.peek());<br>                stkIn.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出栈不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) stkOut.peek();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (stkIn.empty() &amp;&amp; stkOut.empty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>要使用两个队列，一个用来输入一个用来输出。特别要注意的是关注输出栈是不是空的，如果非空要优先处理输出栈的（pop和peek方法）</p>
<h2 id="7-3-用队列组成栈"><a href="#7-3-用队列组成栈" class="headerlink" title="7.3 用队列组成栈"></a>7.3 用队列组成栈</h2><p><strong>225. Implement Stack using Queues</strong></p>
<p><strong>Q: </strong></p>
<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyStack</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>
<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>
<li><code>int top()</code> Returns the element on the top of the stack.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code>otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code>operations are valid.</li>
<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</li>
</ul>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// Push element x onto stack.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue.add(x);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)<br>            queue.add(queue.poll());<br>            n--;<br>    &#125;<br><br>    <span class="hljs-comment">// Removes the element on top of the stack.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        queue.poll();<br>    &#125;<br><br>    <span class="hljs-comment">// Get the top element.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br><br>    <span class="hljs-comment">// Return whether the stack is empty.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里和之前的用栈组成队列不太一样，可以只使用一个，总体来讲是个缓存的思想，将队头的元素重新放回到队尾(双队列也如此)。</p>
<h2 id="7-4-匹配括号"><a href="#7-4-匹配括号" class="headerlink" title="7.4 匹配括号"></a>7.4 匹配括号</h2><p><strong>20. Valid Parentheses</strong></p>
<p><strong>Q: </strong>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code>and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Character&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>      <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() != c)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先学会一点，匹配对的问题可以用栈来解决(先出现的左符号要最后匹配右符号，这样正好符合栈的特点)。对于这道题我们反过来想，当匹配到左符号，就将对应的右符号压入栈，然后往后匹配看看后面有没有对应的右符号。</p>
<h2 id="7-5-逆波兰表达式"><a href="#7-5-逆波兰表达式" class="headerlink" title="7.5 逆波兰表达式"></a>7.5 逆波兰表达式</h2><p><strong>150. Evaluate Reverse Polish Notation</strong></p>
<p><strong>Q: </strong>Evaluate the value of an arithmetic expression in <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</p>
<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer or another expression.</p>
<p><strong>Note</strong> that division between two integers should truncate toward zero.</p>
<p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        <span class="hljs-type">int</span> a,b;<br>		Stack&lt;Integer&gt; S = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>		<span class="hljs-keyword">for</span> (String s : tokens) &#123;<br>			<span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;+&quot;</span>)) &#123;<br>				S.add(S.pop()+S.pop());<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>				b = S.pop();<br>				a = S.pop();<br>				S.add(a / b);<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;*&quot;</span>)) &#123;<br>				S.add(S.pop() * S.pop());<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>				b = S.pop();<br>				a = S.pop();<br>				S.add(a - b);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				S.add(Integer.parseInt(s));<br>			&#125;<br>		&#125;	<br>		<span class="hljs-keyword">return</span> S.pop();<br>	  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用栈来存之前的路径，如果是数字就入栈，如果是符号就出栈前两位数字进行计算，将结果再入栈。</p>
<h2 id="7-6-滑动窗口最大值"><a href="#7-6-滑动窗口最大值" class="headerlink" title="7.6 滑动窗口最大值"></a>7.6 滑动窗口最大值</h2><p><strong>239. Sliding Window Maximum</strong></p>
<p><strong>Q: </strong>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code>which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return <em>the max sliding window</em>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义数组</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-comment">//弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出</span><br>    <span class="hljs-comment">//同时判断队列当前是否为空</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; val == deque.peek()) &#123;<br>            deque.poll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出</span><br>    <span class="hljs-comment">//保证队列元素单调递减</span><br>    <span class="hljs-comment">//比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.add(val);<br>    &#125;<br>    <span class="hljs-comment">//队列队顶元素始终为最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> deque.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//存放结果元素的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//自定义队列</span><br>        <span class="hljs-type">MyQueue</span> <span class="hljs-variable">myQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br>        <span class="hljs-comment">//先将前k的元素放入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            myQueue.add(nums[i]);<br>        &#125;<br>        res[num++] = myQueue.peek();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//滑动窗口移除最前面的元素，移除是判断该元素是否放入队列</span><br>            myQueue.poll(nums[i - k]);<br>            <span class="hljs-comment">//滑动窗口加入最后面的元素</span><br>            myQueue.add(nums[i]);<br>            <span class="hljs-comment">//记录对应的最大值</span><br>            res[num++] = myQueue.peek();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//解法二</span><br><span class="hljs-comment">//利用双端队列手动实现单调队列</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可</span><br><span class="hljs-comment"> * 单调队列类似 （tail --&gt;） 3 --&gt; 2 --&gt; 1 --&gt; 0 (--&gt; head) (右边为头结点，元素存的是下标)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        ArrayDeque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span><br>            <span class="hljs-comment">// 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="hljs-number">1</span>)&#123;<br>                deque.poll();<br>            &#125;<br>            <span class="hljs-comment">// 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br><br>            deque.offer(i);<br><br>            <span class="hljs-comment">// 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span><br>            <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>)&#123;<br>                res[idx++] = nums[deque.peek()];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>deque 双端队列：如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名 <strong>Deque</strong> 。 <strong>Java</strong>集合提供了接口 <strong>Deque</strong> 来实现一个双端队列，它的功能是： 既可以添加到队尾，也可以添加到队首； 既可以从队首获取，又可以从队尾获取。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Queue</th>
<th style="text-align:left">Deque</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">添加元素到队尾</td>
<td style="text-align:left">add(E e) / offer(E e)</td>
<td style="text-align:left">addLast(E e) / offerLast(E e)</td>
</tr>
<tr>
<td style="text-align:left">取队首元素并删除</td>
<td style="text-align:left">E remove() / E poll()</td>
<td style="text-align:left">E removeFirst() / E pollFirst()</td>
</tr>
<tr>
<td style="text-align:left">取队首元素但不删除</td>
<td style="text-align:left">E element() / E peek()</td>
<td style="text-align:left">E getFirst() / E peekFirst()</td>
</tr>
<tr>
<td style="text-align:left">添加元素到队首</td>
<td style="text-align:left">无</td>
<td style="text-align:left">addFirst(E e) / offerFirst(E e)</td>
</tr>
<tr>
<td style="text-align:left">取队尾元素并删除</td>
<td style="text-align:left">无</td>
<td style="text-align:left">E removeLast() / E pollLast()</td>
</tr>
<tr>
<td style="text-align:left">取队尾元素但不删除</td>
<td style="text-align:left">无</td>
<td style="text-align:left">E getLast() / E peekLast()</td>
</tr>
</tbody>
</table>
</div>
<h2 id="7-7-前k个高频元素"><a href="#7-7-前k个高频元素" class="headerlink" title="7.7 前k个高频元素"></a>7.7 前k个高频元素</h2><p><strong>347. Top K Frequent Elements</strong></p>
<p><strong>Q: </strong>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-comment">// 记录频率</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();<br>        <span class="hljs-comment">// 根据map的value值正序排，相当于一个小顶堆</span><br>        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;<br>            queue.offer(entry);<br>            <span class="hljs-keyword">if</span> (queue.size() &gt; k) &#123;<br>                queue.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = queue.poll().getKey();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这道题目主要涉及到如下三块内容：</p>
<ol>
<li>要统计元素出现频率</li>
<li>对频率排序</li>
<li>找出前K个高频元素</li>
</ol>
<h2 id="7-8-接雨水"><a href="#7-8-接雨水" class="headerlink" title="7.8 接雨水"></a>7.8 接雨水</h2><p><strong>42. Trapping Rain Water</strong></p>
<p><strong>Q: </strong>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>
<p><strong>A: </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftMax[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> rightMax[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        rightMax[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; n;i++) &#123;<br>            leftMax[i] = Math.max(leftMax[i - <span class="hljs-number">1</span>], height[i]);<br>            rightMax[n - i - <span class="hljs-number">1</span>] = Math.max(rightMax[n - i], height[n - i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">trappedWater</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            trappedWater += Math.min(leftMax[i], rightMax[i]) - height[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> trappedWater;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>每一列雨水的高度主要取决于左侧最高的柱子和右侧的最高的柱子之间的最矮的柱子的高度</p>
<p>由于决定当前坐标的位置盛水的高度只取决于其左右两边的围栏的最小值（木桶效应），所以我们需要建立两个数组用来存储当前位置的其左右两边的水桶的高度最大值。</p>
<p>Step1: 我们先将同一个坐标位置下的左右两边最大的高度存储下来</p>
<p>Step2: 我们求解水量 Math.min(leftMax[i], rightMax[i]) - height[i]</p>
<h1 id="第8章-二叉树"><a href="#第8章-二叉树" class="headerlink" title="第8章 二叉树"></a>第8章 二叉树</h1><h2 id="8-1-二叉树前中后序遍历"><a href="#8-1-二叉树前中后序遍历" class="headerlink" title="8.1 二叉树前中后序遍历"></a>8.1 二叉树前中后序遍历</h2><h3 id="8-1-1-前序遍历"><a href="#8-1-1-前序遍历" class="headerlink" title="8.1.1 前序遍历"></a>8.1.1 前序遍历</h3><p><strong>144. Binary Tree Preorder Traversal</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>		<span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        preorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        result.add(root.val);   <span class="hljs-comment">// get value of root</span><br>        preorder(root.left, result); <span class="hljs-comment">// left</span><br>        preorder(root.right, result); <span class="hljs-comment">// right</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>根左右顺序递归进去，遍历树和图还是比较好想的，因为可以正向思维往深了走。</p>
<h3 id="8-1-2-中序遍历"><a href="#8-1-2-中序遍历" class="headerlink" title="8.1.2 中序遍历"></a><strong>8.1.2 中序遍历</strong></h3><p><strong>94. Binary Tree Inorder Traversal</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p>
<p><strong>A:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        inorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorder(root.left, result);    <span class="hljs-comment">// left</span><br>        result.add(root.val); <span class="hljs-comment">// get value of root</span><br>        inorder(root.right, result); <span class="hljs-comment">// right</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>左根右顺序递归进去</p>
<h3 id="8-1-3-后序遍历"><a href="#8-1-3-后序遍历" class="headerlink" title="8.1.3 后序遍历"></a><strong>8.1.3 后序遍历</strong></h3><p><strong>145. Binary Tree Postorder Traversal</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the postorder traversal of its nodes’ values</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        postorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorder(root.left, result); <span class="hljs-comment">// left</span><br>        postorder(root.right, result); <span class="hljs-comment">// right</span><br>        result.add(root.val); <span class="hljs-comment">// get value of root</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-2-二叉树层序遍历"><a href="#8-2-二叉树层序遍历" class="headerlink" title="8.2 二叉树层序遍历"></a>8.2 二叉树层序遍历</h2><p><strong>102. Binary Tree Level Order Traversal</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p>
<p><strong>A：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;  <br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();  <br>        queue.add(root);  <br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;  <br>          List&lt;Integer&gt; itemList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>          <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();  <br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;  <br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();  <br>            itemList.add(node.val);  <br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;  <br>              queue.offer(node.left);  <br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;  <br>              queue.offer(node.right);  <br>            &#125;  <br>          &#125;  <br>          res.add(itemList);   <br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>层序遍历的关键在于队列的使用。我们先将根放入队列中，然后终止判定为队列为空，那么如何保证他不会空呢？由于每次出栈一个元素后就把他的左右子树放进队列（如果有的话），这样可以保证队列不会空而退出循环，并且是按照左右子树的顺序也保证了后面的层序遍历仍然是从左往右。</p>
<p>跟行有关的二叉树可以优先选择层序遍历。</p>
<p><strong>EXTEND QUESTIONS:</strong></p>
<p>107、199、637、429、515、116、104</p>
<h2 id="8-11-二叉树的所有路径"><a href="#8-11-二叉树的所有路径" class="headerlink" title="8.11 二叉树的所有路径"></a>8.11 二叉树的所有路径</h2><p><strong>257. Binary Tree Paths</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>A:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>      	<span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>    &#125;<br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>      	<span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;strconv.Itoa(root.Val)&#125;<br>    &#125;<br>    tmpLeft := binaryTreePaths(root.Left)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmpLeft); i++ &#123;<br>      	res = <span class="hljs-built_in">append</span>(res, strconv.Itoa(root.Val)+<span class="hljs-string">&quot;-&gt;&quot;</span>+tmpLeft[i])<br>    &#125;<br>    tmpRight := binaryTreePaths(root.Right)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmpRight); i++ &#123;<br>      	res = <span class="hljs-built_in">append</span>(res, strconv.Itoa(root.Val)+<span class="hljs-string">&quot;-&gt;&quot;</span>+tmpRight[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也是递归的思想，从根向子节点遍历的话用前序遍历（根左右）。tmpLeft代表的是左边收集到的路径，同理tmpRight就是右边收集到的路径。</p>
<h2 id="8-12-路径总和"><a href="#8-12-路径总和" class="headerlink" title="8.12 路径总和"></a>8.12 路径总和</h2><p><strong>112. Path Sum</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> pathSum(root, targetSum - root.Val)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, count <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &amp;&amp; count == <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 遇到叶子结点，并且计数为0</span><br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 遇到叶子节点,Count不为0，直接返回</span><br>    <br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        count -= root.Left.Val  <span class="hljs-comment">// 递归，处理节点</span><br>        <span class="hljs-keyword">if</span> pathSum(root.Left, count) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        count += root.Left.Val  <span class="hljs-comment">// 回溯，撤销处理结果</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        count -= root.Right.Val  <span class="hljs-comment">// 递归，处理节点</span><br>        <span class="hljs-keyword">if</span> pathSum(root.Right, count) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        count += root.Right.Val  <span class="hljs-comment">// 回溯，撤销处理结果</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>递归和回溯是要在一起的，每一次递归都要有对应的回溯，这里用到的是根左右的形式。递归的话不要仔细去想具体的每一步是怎么样的，而是要关注三部曲，1⃣️入口的样子，2⃣️终止条件，3⃣️中间的处理逻辑。本篇通过leetcode上 <strong>112. 路径总和</strong> 和 <strong>113. 路径总和ii</strong> 详细的讲解了递归函数什么时候需要返回值，什么不需要返回值。</p>
<p><strong>113. Path Sum II</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals</em> <code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p>
<p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, sum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">var</span> slice [][]<span class="hljs-type">int</span><br>	slice = findPath(root, sum, slice, []<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>))<br>    fmt.Println(slice)<br>	<span class="hljs-keyword">return</span> slice<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPath</span><span class="hljs-params">(root *TreeNode, sum <span class="hljs-type">int</span>, slice [][]<span class="hljs-type">int</span>, path []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;    <br>      	<span class="hljs-keyword">return</span> slice<br>    &#125;<br>    sum -= root.Val  <span class="hljs-comment">// 进入一个节点就用当前val减少sum的值</span><br>    path = <span class="hljs-built_in">append</span>(path, root.Val)  <span class="hljs-comment">// 将当前val这个结果加入（一个切片）</span><br>    <span class="hljs-keyword">if</span> sum == <span class="hljs-number">0</span> &amp;&amp; root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// 如果摸到了最末端一个节点并且sum已经被减光</span><br>      	slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, path...))  <span class="hljs-comment">// 把之前栈的结果全部导入到slice里面</span><br>        <span class="hljs-keyword">return</span> slice<br>    &#125;<br>    slice = findPath(root.Left, sum, slice, path)<br>    slice = findPath(root.Right, sum, slice, path)<br>    <span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure>
<p>学习的别人的思路，整体采用的是根左右也就是从上向下遍历的过程。slice是要输出的结果，path用来存储之前走过的路径。只有当sum == 0完全符合条件的时候才将之前存的所有路径都放入切片。</p>
<p>PS: slice的切片是左闭右开的，所以<code>len(stack) - 1</code>相当于退出去了一位数。</p>
<h2 id="8-13-构造一颗二叉树"><a href="#8-13-构造一颗二叉树" class="headerlink" title="8.13 构造一颗二叉树"></a>8.13 构造一颗二叉树</h2><p><strong>106. Construct Binary Tree from Inorder and Postorder Traversal</strong></p>
<p><strong>Q：</strong>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(inorder []<span class="hljs-type">int</span>, postorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>   	postorderLen := <span class="hljs-built_in">len</span>(postorder)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>		root := &amp;TreeNode&#123;Val: postorder[postorderLen<span class="hljs-number">-1</span>]&#125;<br>    postorder = postorder[:postorderLen<span class="hljs-number">-1</span>]<br>    <br>    <span class="hljs-keyword">for</span> pos, node := <span class="hljs-keyword">range</span> inorder &#123;<br>        <span class="hljs-keyword">if</span> node == root.Val &#123;<br>            root.Left = buildTree(inorder[:pos], postorder[:<span class="hljs-built_in">len</span>(inorder[:pos])])<br>            root.Right = buildTree(inorder[pos+<span class="hljs-number">1</span>:], postorder[<span class="hljs-built_in">len</span>(inorder[:pos]):])<br>        &#125;<br>		&#125;<br>	  <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>来看一下一共分几步：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到当前节点在中序的位置，此处节点看为根</li>
<li>第四步：<code>root.Left = buildTree(inorder[:pos], postorder[:len(inorder[:pos])])</code>区间是左闭右开，所以我们进行切片，取中序中此点的左侧，和后序中的左边。</li>
<li>第五步：<code>root.Right = buildTree(inorder[pos+1:], postorder[len(inorder[:pos]):])</code>区间是左闭右开，进行切片，取中序中此点的右侧，和后序列中的右边（因为已经抛开了根节点，所以右侧的所有都是右子树的所有内容。</li>
</ul>
<p>全程都是抠出来后序遍历中的数值制作节点，root.Left = [ return root ] 同理right也是这样，我们每一层叠戴的都是下一层的某一个根节点</p>
<p><strong>105. Construct Binary Tree from Preorder and Inorder Traversal</strong></p>
<p><strong>Q：</strong>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    root := &amp;TreeNode&#123; Val: preorder[<span class="hljs-number">0</span>] &#125;    <br>    preorder = preorder[<span class="hljs-number">1</span>:]  <span class="hljs-comment">// poll the first preorder value</span><br>    <br>    <span class="hljs-keyword">for</span> pos, node := <span class="hljs-keyword">range</span> inorder &#123; <span class="hljs-comment">// preorder:(before) N L R (now) L R</span><br>        <span class="hljs-keyword">if</span> node == root.Val &#123;<br>            root.Left = buildTree(preorder[:pos], inorder[:pos])<br>            root.Right = buildTree(preorder[pos:], inorder[pos+<span class="hljs-number">1</span>:])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同理上面的不同的是，pos这里是inorder中L的长度。</p>
<h2 id="8-14-合并两个二叉树"><a href="#8-14-合并两个二叉树" class="headerlink" title="8.14 合并两个二叉树"></a>8.14 合并两个二叉树</h2><p><strong>617. Merge Two Binary Trees</strong></p>
<p><strong>Q：</strong>You are given two binary trees <code>root1</code> and <code>root2</code>.</p>
<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>
<p>Return <em>the merged tree</em>.</p>
<p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTrees</span><span class="hljs-params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root2 &#125;<br>    <span class="hljs-keyword">if</span> root2 == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root1 &#125;<br>    <br>    root1.Val += root2.Val<br>    root1.Left = mergeTrees(root1.Left, root2.Left)<br>    root1.Right = mergeTrees(root1.Right, root2.Right)<br>    <span class="hljs-keyword">return</span> root1<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以其中一个为根，以其中一个为参照物进行合并。</p>
<ul>
<li>简单题。采用深搜的思路，分别从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。两个二叉树的对应节点可能存在以下三种情况：<ul>
<li>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</li>
<li>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</li>
<li>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</li>
</ul>
</li>
<li>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。用递归实现即可</li>
</ul>
<h2 id="8-15-二叉搜索树中的搜索"><a href="#8-15-二叉搜索树中的搜索" class="headerlink" title="8.15 二叉搜索树中的搜索"></a>8.15 二叉搜索树中的搜索</h2><p><strong>700. Search in a Binary Search Tree</strong></p>
<p><strong>Q：</strong>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p>
<p>Find the node in the BST that the node’s value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || root.Val == val &#123; <span class="hljs-keyword">return</span> root &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Val &gt; val &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.Left, val)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt; val &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.Right, val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<p><strong>因为搜索到目标节点了，就要立即return了，这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。</strong></p>
<p>（如果你没有写return那么就算找到了我们也没有回去的路了，相当于是停在了找到的点那里）</p>
<h2 id="8-16-验证二叉搜索树"><a href="#8-16-验证二叉搜索树" class="headerlink" title="8.16 验证二叉搜索树"></a>8.16 验证二叉搜索树</h2><p><strong>98. Validate Binary Search Tree</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>
<p>A <strong>valid BST</strong> is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong>the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;&#125;<br>    inOrder(root, &amp;arr)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>        <span class="hljs-keyword">if</span> arr[i - <span class="hljs-number">1</span>] &gt;= arr[i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, arr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, arr)<br>    *arr = <span class="hljs-built_in">append</span>(*arr, root.Val)<br>    inOrder(root.Right, arr)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。</strong></p>
<p>中序遍历，验证遍历的元素是不是从小到大。我们先存储左根右的数组序列，然后check他的顺序是否是对的。</p>
<p><code>*arr = append(*arr, root.Val)</code>这里如果不加*的话，代表arr就是个指向isValidBST的arr的一个指针，加了星号才能提取到他指向的内容，并且操作他指向的内容！</p>
<h2 id="8-17-二叉搜索树的最小绝对值差"><a href="#8-17-二叉搜索树的最小绝对值差" class="headerlink" title="8.17 二叉搜索树的最小绝对值差"></a>8.17 二叉搜索树的最小绝对值差</h2><p><strong>530. Minimum Absolute Difference in BST</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum absolute difference between the values of any two different nodes in the tree</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;&#125;<br>    inOrder(root, &amp;arr)<br>    diff := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>        diff = <span class="hljs-built_in">append</span>(diff, abs(arr[i - <span class="hljs-number">1</span>] - arr[i]))<br>    &#125;<br>    fmt.Print(<span class="hljs-string">&quot;diff: &quot;</span>)<br>    fmt.Println(diff)<br>    min := diff[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(diff); j++ &#123;<br>        <span class="hljs-keyword">if</span> diff[j] &lt; min &#123;<br>            min = diff[j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> min<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -a<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, arr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, arr)<br>    *arr = <span class="hljs-built_in">append</span>(*arr, root.Val)<br>    inOrder(root.Right, arr)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>由于是 BST 树，利用它有序的性质，中根遍历的结果是有序的。中根遍历过程中动态维护前后两个节点的差值，即可找到最小差值。</li>
<li>此题与第 783 题完全相同。</li>
</ul>
<h2 id="8-18-二叉搜索树中的众数"><a href="#8-18-二叉搜索树中的众数" class="headerlink" title="8.18 二叉搜索树中的众数"></a>8.18 二叉搜索树中的众数</h2><p><strong>501. Find Mode in Binary Search Tree</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary search tree (BST) with duplicates, return <em>all the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mode_(statistics">mode(s)</a>) (i.e., the most frequently occurred element) in it</em>.</p>
<p>If the tree has more than one mode, return them in <strong>any order</strong>.</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMode</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    inOrder(root, m)<br>    max := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">if</span> val &gt;= max &#123;<br>            max = val<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">if</span> val == max &#123;<br>            res = <span class="hljs-built_in">append</span>(res, key)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, m)<br>    <span class="hljs-keyword">if</span> _, exist := m[root.Val]; !exist &#123;<br>        m[root.Val] = <span class="hljs-number">1</span><br>    &#125;<br>    m[root.Val] += <span class="hljs-number">1</span><br>    inOrder(root.Right, m)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-19-二叉树的最近公共祖先"><a href="#8-19-二叉树的最近公共祖先" class="headerlink" title="8.19 二叉树的最近公共祖先"></a>8.19 二叉树的最近公共祖先</h2><p><strong>236. Lowest Common Ancestor of a Binary Tree</strong></p>
<p><strong>Q：</strong>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// stop</span><br>    <span class="hljs-keyword">if</span> root == p || root == q || root == <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-comment">// left</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br>    <span class="hljs-comment">// right</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br>    <span class="hljs-comment">// root</span><br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &amp;&amp; left != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 搜索一条边的写法：</span><br><span class="hljs-keyword">if</span> (递归函数(root.left)) <span class="hljs-keyword">return</span> <br><br><span class="hljs-keyword">if</span> (递归函数(root.right)) <span class="hljs-keyword">return</span> <br><br><span class="hljs-comment">// 搜索整个树写法：</span><br>left = 递归函数(root.left)<br>right = 递归函数(root.right)<br>left与right的逻辑处理<br></code></pre></td></tr></table></figure>
<p>注意：</p>
<p>1、p和q如果写了肯定是在这个BST里面的，所以必然不会有nil的结果。</p>
<p>2、我们为什么要回溯某一个right或者left？如果是最简单的情况，我们找的p和q在同一个子树上面，那么返回的就是他们的祖先，如果不在同一个子树上面，返回的就是他们的根节点。知道了这个规则以后，就很好理解了为什么要返回right或者left了，并且为什么是从下往上找而不是从上往下找。逻辑就是，我从下往上左右去找是否有满足的p和q如果都满足了那么此时的root就是p和q的祖父，如果没有满足就是nil，继续往上找。</p>
<h2 id="8-20-在二叉搜索树中插入一个节点"><a href="#8-20-在二叉搜索树中插入一个节点" class="headerlink" title="8.20 在二叉搜索树中插入一个节点"></a>8.20 在二叉搜索树中插入一个节点</h2><p><strong>701. Insert into a Binary Search Tree</strong></p>
<p><strong>Q：</strong>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p>
<p><strong>Notice</strong> that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: val&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &lt; root.Val &#123;<br>        root.Left = insertIntoBST(root.Left, val)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.Right = insertIntoBST(root.Right, val)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实这道题目其实是一道简单题目，<strong>但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人</strong>，瞬间感觉题目复杂了很多。</p>
<p>其实<strong>可以不考虑题目中提示所说的改变树的结构的插入方式。</strong></p>
<p><strong>有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作</strong>。</p>
<p>思路：我们找的是一条边，如果是空的节点的话就是找到了该插入的位置，插入即可，剩下的返回的都是现存的节点值。</p>
<h2 id="8-21-在二叉搜索树中删除一个节点"><a href="#8-21-在二叉搜索树中删除一个节点" class="headerlink" title="8.21 在二叉搜索树中删除一个节点"></a>8.21 在二叉搜索树中删除一个节点</h2><p><strong>450. Delete Node in a BST</strong></p>
<p><strong>Q：</strong>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.</li>
</ol>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(root *TreeNode, key <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val == key &#123;<br>        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Right<br>        &#125;<br>        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Left<br>        &#125;<br>        tmp := root.Right<br>        <span class="hljs-keyword">for</span> tmp.Left != <span class="hljs-literal">nil</span> &#123;<br>            tmp = tmp.Left<br>        &#125;<br>        tmp.Left = root.Left<br>        <span class="hljs-keyword">return</span> root.Right<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> key &lt; root.Val &#123;<br>        root.Left = deleteNode(root.Left, key)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.Right = deleteNode(root.Right, key)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要的点在于考虑删除节点的位置，有以下五种情况：</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<h2 id="8-22-修剪二叉搜索树"><a href="#8-22-修剪二叉搜索树" class="headerlink" title="8.22 修剪二叉搜索树"></a>8.22 修剪二叉搜索树</h2><p><strong>669. Trim a Binary Search Tree</strong></p>
<p><strong>Q：</strong>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p>
<p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trimBST</span><span class="hljs-params">(root *TreeNode, low <span class="hljs-type">int</span>, high <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Val &lt; low &#123;<br>        right := trimBST(root.Right, low, high)<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &gt; high &#123;<br>        left := trimBST(root.Left, low, high)<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <br>    root.Right = trimBST(root.Right, low, high)<br>    root.Left = trimBST(root.Left, low, high)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>确定终止条件</li>
</ul>
<p>修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。</p>
<p>思路：</p>
<p>1、如果此时的节点值小于了最小边界（因为是闭区间），那这个节点就废掉，我们找比他大的（他的右子树中是否有符合的节点）</p>
<p>2、如果此时的节点值大于了最大边界（因为是闭区间），那这个节点就废掉，我们找比他小的（他的左子树中是否有符合的节点）</p>
<p>3、拼接分支，类似于之前的用法，如果没有裁剪就返回的是root（当前的节点）如果有裁剪，返回的就是获取的left或者right</p>
<h2 id="8-23-构建一棵平衡二叉树"><a href="#8-23-构建一棵平衡二叉树" class="headerlink" title="8.23 构建一棵平衡二叉树"></a>8.23 构建一棵平衡二叉树</h2><p><strong>108. Convert Sorted Array to Binary Search Tree</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a <strong>height-balanced</strong> binary search tree</em>.</p>
<p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> &amp;TreeNode&#123;<br>        Val: nums[<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>], <br>        Left: sortedArrayToBST(nums[:<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>]), <br>        Right: sortedArrayToBST(nums[<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>:])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>删除二叉树节点，增加二叉树节点，都是用递归函数的返回值来完成，这样是比较方便的。</p>
<ul>
<li>确定递归终止条件</li>
</ul>
<p>如果nums的长度为0，则说明没有数需要放入了，利用了go的切片，注意切片是左闭右开</p>
<p>Step：</p>
<p>1、将此时的节点值写成nums的中心</p>
<p>2、左支是此点的左边所有数组</p>
<p>3、右支是此点右边的所有数组</p>
<p>4、迭代，终止条件如上</p>
<h1 id="第9章-回溯算法"><a href="#第9章-回溯算法" class="headerlink" title="第9章 回溯算法"></a>第9章 回溯算法</h1><p>回溯问题的模板</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">backtracking(参数) &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="9-1-组合问题"><a href="#9-1-组合问题" class="headerlink" title="9.1 组合问题"></a>9.1 组合问题</h2><p><strong>77. Combinations</strong></p>
<p><strong>Q：</strong>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers out of the range</em> <code>[1, n]</code>.</p>
<p>You may return the answer in <strong>any order</strong>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span> || k &gt; n &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;  <span class="hljs-comment">// c is combine</span><br>    generateCombinations(n, k, <span class="hljs-number">1</span>, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateCombinations</span><span class="hljs-params">(n, k, start <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == k &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// for i := start; i &lt;= n; i++ 不剪枝头的写法</span><br>    <span class="hljs-keyword">for</span> i := start; i &lt;= n - (k - <span class="hljs-built_in">len</span>(c)) + <span class="hljs-number">1</span>; i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, i)<br>        generateCombinations(n, k, i + <span class="hljs-number">1</span>, c, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195242899.png" srcset="/img/loading.gif" lazyload alt="77. Combinations"></p>
<p><code>i &lt;= n - (k - len(c)) + 1</code>这个条件很关键他可以帮助我们减少分支，去除那些本身为空的答案。n 本身是我们可选项的上限，我们只靠start来控制不重复。</p>
<ol>
<li>已经选择的元素个数：len(c)</li>
<li>还需要的元素个数为: k - len(c)          （从后往前数，最开始一层就是k，所以倒数后k个数是最远的起始位置）</li>
<li><p>在集合n中至多要从该起始位置 : n - (k - len(c)) + 1(start)，开始遍历  </p>
<p>(翻译过来就是如果总共的n个数减去我们还需要的元素后剩余的最大个数，作为我们起始位置的最远端)</p>
</li>
</ol>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
<h2 id="9-2-组合总和-III"><a href="#9-2-组合总和-III" class="headerlink" title="9.2 组合总和 III"></a>9.2 组合总和 III</h2><p><strong>216. Combination Sum III</strong></p>
<p><strong>Q：</strong>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>
<ul>
<li>Only numbers <code>1</code> through <code>9</code> are used.</li>
<li>Each number is used <strong>at most once</strong>.</li>
</ul>
<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum3</span><span class="hljs-params">(k <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span> || k &gt; n &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    generateCombinations(k, n, <span class="hljs-number">1</span>, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateCombinations</span><span class="hljs-params">(k, target, start <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == k &amp;&amp; target == <span class="hljs-number">0</span>&#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>  <br>  	<span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> &#125;<br><br>    <span class="hljs-keyword">for</span> i := start; i &lt;= <span class="hljs-number">9</span>; i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, i)<br>        generateCombinations(k, target - i, i + <span class="hljs-number">1</span>, c, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>雷同77题，不过遇到一个问题就是当对i进行剪枝的时候，他会爆栈。</p>
<h2 id="9-3-电话号码的字母组合"><a href="#9-3-电话号码的字母组合" class="headerlink" title="9.3 电话号码的字母组合"></a>9.3 电话号码的字母组合</h2><p><strong>17. Letter Combinations of a Phone Number</strong></p>
<p><strong>Q：</strong>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>
<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> result []<span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;2&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;3&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;4&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;5&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;j&quot;</span>, <span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;6&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;7&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;8&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;v&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;9&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(digits <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    result = []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> digits == <span class="hljs-string">&quot;&quot;</span> &#123;<br>     	 <span class="hljs-keyword">return</span> result<br>    &#125;<br>    letterFunc(<span class="hljs-string">&quot;&quot;</span>, digits)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterFunc</span><span class="hljs-params">(res <span class="hljs-type">string</span>, digits <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> digits == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        result = <span class="hljs-built_in">append</span>(result, res)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    k := digits[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]	<span class="hljs-comment">// 选取第一个字母</span><br>    digits = digits[<span class="hljs-number">1</span>:]	 <span class="hljs-comment">// 剔除第一个字母</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dict[k]); i++ &#123;<br>        res += dict[k][i]<br>        letterFunc(res, digits)<br>        res = res[:<span class="hljs-built_in">len</span>(res) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于go中string的理解不够深。string的处理使用切片的，并且切片以后才能slice才是可以用append的。</p>
<p><img src="https://img-blog.csdnimg.cn/20201123200304469.png" srcset="/img/loading.gif" lazyload alt="17. 电话号码的字母组合"></p>
<p>剩下的就是按照回溯的公式去套题。for里面装的是每层要处理的子集。</p>
<h2 id="9-4-组合总和（二）"><a href="#9-4-组合总和（二）" class="headerlink" title="9.4 组合总和（二）"></a>9.4 组合总和（二）</h2><p><strong>39. Combination Sum</strong></p>
<p><strong>Q：</strong>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>
<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>
<p>It is <strong>guaranteed</strong> that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    findCombination(candidates, c, target, <span class="hljs-number">0</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCombination</span><span class="hljs-params">(cand, c []<span class="hljs-type">int</span>, target, index <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(cand); i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, cand[i])<br>        findCombination(cand, c, target - cand[i], i, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为元素可以重复，所以index和i组合保证他不往回头（向前）找元素就可以了。</p>
<p>✨<strong>其中为什么一定要有c附魔给b呢？</strong>这里是深复制和浅复制的问题。如果不 copy 一份，直接把 c 加入到 res 结果数组中，下一轮递归过程中，c 会变，这个变化也会影响到 res 里面的值。如果还不明白的话，你可以把 copy c 的那 2 行代码注释掉，直接把 c append 到 res 中，你再看输出结果就能看到原因了。</p>
<p><strong>浅拷贝</strong>: 对于仅仅是复制了引用（地址），换句话说，复制了之后，原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响，为<strong>浅拷贝</strong>。 <strong>深拷贝</strong>：而如果是在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响，为<strong>深拷贝</strong></p>
<p>（简而言之：浅拷贝拷贝的是值，他和原本的指针指的是同一个地方，类似引用，当指针所指内容变了这个拷贝值也变；而深拷贝拷贝的是另一个对象，一个一模一样的对象但是占用的另一个空间，这样就算前者再变也不会影响新拷贝出来的对象）</p>
<h2 id="9-5-组合总和（三）"><a href="#9-5-组合总和（三）" class="headerlink" title="9.5 组合总和（三）"></a>9.5 组合总和（三）</h2><p><strong>40. Combination Sum II</strong></p>
<p><strong>Q：</strong>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate combinations.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum2</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(candidates) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>	&#125;<br>	c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>	sort.Ints(candidates) <span class="hljs-comment">// 这里是去重的关键逻辑</span><br>    findCombination(candidates, c, target, <span class="hljs-number">0</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCombination</span><span class="hljs-params">(cand, c []<span class="hljs-type">int</span>, target, index <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(cand); i++ &#123;<br>        <span class="hljs-comment">// 这里是去重的关键逻辑,本次不取重复数字，下次循环可能会取重复数字</span><br>        <span class="hljs-keyword">if</span> i &gt; index &amp;&amp; cand[i] == cand[i<span class="hljs-number">-1</span>] &#123; <br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>        c = <span class="hljs-built_in">append</span>(c, cand[i])<br>        findCombination(cand, c, target - cand[i], i + <span class="hljs-number">1</span>, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>题目要求出总和为 sum 的所有组合，组合需要去重。这一题是第 39 题的加强版，第 39 题中元素可以重复利用(重复元素可无限次使用)，这一题中元素只能有限次数的利用，因为存在重复元素，并且每个元素只能用一次(重复元素只能使用有限次)</li>
<li>这一题和第 47 题类似，只不过元素可以反复使用。</li>
<li>总体来说需要注意的两个重复位置，第一个是通过取得重复的根，从而得到两个同样的结果，第二个就是出现前后颠倒但集合相同的问题。</li>
</ul>
<p>所以先排好序（保证了结果肯定是递增的顺序，不会出现 [1, 7] 和 [7, 1] 这种组合，再判断。i &gt; index 表示除了本层的第一个选取的数以外的数，并且这个数和前一个数相同的话跳过。本质上这个判断是去除同一层重复获取的数字是forbidden的。</p>
<p>选择过程树形结构如图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20201123202736384.png" srcset="/img/loading.gif" lazyload alt="40.组合总和II"></p>
<h2 id="9-6-分割回文串"><a href="#9-6-分割回文串" class="headerlink" title="9.6 分割回文串"></a>9.6 分割回文串</h2><p><strong>131. Palindrome Partitioning</strong></p>
<p><strong>Q：</strong>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a <strong>palindrome</strong>. Return all possible palindrome partitioning of <code>s</code>.</p>
<p>A <strong>palindrome</strong> string is a string that reads the same backward as forward.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    c, res := []<span class="hljs-type">string</span>&#123;&#125;, [][]<span class="hljs-type">string</span>&#123;&#125;<br>    findPartition(<span class="hljs-number">0</span>, s, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPartition</span><span class="hljs-params">(start <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, c []<span class="hljs-type">string</span>, res *[][]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(s) &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        sub := s[start : i + <span class="hljs-number">1</span>]  <span class="hljs-comment">// partition</span><br>        <span class="hljs-keyword">if</span> IsPalindrome(sub) &#123; <span class="hljs-comment">// combine</span><br>            c = <span class="hljs-built_in">append</span>(c, sub)<br>            findPartition(i + <span class="hljs-number">1</span>, s, c, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    length := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= length/<span class="hljs-number">2</span>; i++ &#123;<br>      	<span class="hljs-keyword">if</span> s[i] != s[length - <span class="hljs-number">1</span> - i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      	&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>其树形结构为下图</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" srcset="/img/loading.gif" lazyload alt="131.分割回文串"></p>
<p>这一题的关键在于分割和组合的思想。要先切割，判断是否符合回文串？符合的话才继续进行组合递归下一层。</p>
<h2 id="9-7-复原IP地址"><a href="#9-7-复原IP地址" class="headerlink" title="9.7 复原IP地址"></a>9.7 复原IP地址</h2><p><strong>93. Restore IP Addresses</strong></p>
<p><strong>Q：</strong>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p>
<ul>
<li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li>
</ul>
<p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into</em> <code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br>		<span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>	&#125;<br>	res, ip := []<span class="hljs-type">string</span>&#123;&#125;, []<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ip, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s <span class="hljs-type">string</span>, start, cut <span class="hljs-type">int</span>, ip []<span class="hljs-type">int</span>, res *[]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> cut == <span class="hljs-number">4</span> &amp;&amp; start == <span class="hljs-built_in">len</span>(s) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ip))<br>        <span class="hljs-built_in">copy</span>(tmp, ip)<br>        resIp := getIp(tmp)<br>        *res = <span class="hljs-built_in">append</span>(*res, resIp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> cut &gt; <span class="hljs-number">4</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        sub := s[start : i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> isValid(sub) &#123;<br>            tmp, _ := strconv.Atoi(sub)<br>            ip = <span class="hljs-built_in">append</span>(ip, tmp)<br>            cut++<br>            dfs(s, i + <span class="hljs-number">1</span>, cut, ip, res)<br>            ip = ip[:<span class="hljs-built_in">len</span>(ip) - <span class="hljs-number">1</span>]<br>            cut--<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; <span class="hljs-built_in">len</span>(s) != <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 0开头的不可以</span><br>    tmp, _ := strconv.Atoi(s)<br>    <span class="hljs-keyword">if</span> (tmp &gt; <span class="hljs-number">255</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIp</span><span class="hljs-params">(ip []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    resIp := strconv.Itoa(ip[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(ip); i++ &#123;<br>      	resIp += <span class="hljs-string">&quot;.&quot;</span> + strconv.Itoa(ip[i])<br>    &#125;<br>		<span class="hljs-keyword">return</span> resIp<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要考虑到如下三点：</p>
<ul>
<li>段位以0为开头的数字不合法</li>
<li>段位里有非正整数字符不合法</li>
<li>段位如果大于255了不合法</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201123203735933.png" srcset="/img/loading.gif" lazyload alt="93.复原IP地址"></p>
<p>对于语法的一些注意点，首先int转string（strconv.Itoa）是返回一个值的；string转int（strconv.Atoi）是返回两个值的。</p>
<p>一些注意点，这道题和分割回文串是很类似的，思想是一样的。首先我们要分割，接着我们要判断分割的sub是否符合条件，如果符合才继续深入到下一层，如果不符合就不继续。</p>
<h2 id="9-8-子集问题（一）"><a href="#9-8-子集问题（一）" class="headerlink" title="9.8 子集问题（一）"></a>9.8 子集问题（一）</h2><p><strong>78. Subsets</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p>
<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    cur, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(<span class="hljs-number">0</span>, nums, cur, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, nums, cur []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>  	<span class="hljs-comment">// 和之前最不一样的地方就是这里，不限制到叶子结点才加入res</span><br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cur))<br>    <span class="hljs-built_in">copy</span>(tmp, cur)<br>    *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>    <br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(nums) &#123; <span class="hljs-keyword">return</span> &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        cur = <span class="hljs-built_in">append</span>(cur, nums[i]) <span class="hljs-comment">// 原来是切掉一部分，现在是找某一个值</span><br>        dfs(i + <span class="hljs-number">1</span>, nums, cur, res)<br>        cur = cur[:<span class="hljs-built_in">len</span>(cur) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p>
<p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p>
<p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong></p>
<p><img src="https://img-blog.csdnimg.cn/202011232041348.png" srcset="/img/loading.gif" lazyload alt="78.子集"></p>
<p>从图中红线部分，可以看出<strong>遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合</strong>。</p>
<h2 id="9-9-子集问题（二）"><a href="#9-9-子集问题（二）" class="headerlink" title="9.9 子集问题（二）"></a><strong>9.9 子集问题（二）</strong></h2><p><strong>90. Subsets II</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible subsets (the power set)</em>.</p>
<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsetsWithDup</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    cur, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    sort.Ints(nums)<br>    dfs(<span class="hljs-number">0</span>, nums, cur, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, nums, cur []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cur))<br>    <span class="hljs-built_in">copy</span>(tmp, cur)<br>    *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>    <br>    <span class="hljs-comment">// if start == len(nums) &#123; return &#125;</span><br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> i &gt; start &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        cur = <span class="hljs-built_in">append</span>(cur, nums[i]) <br>        dfs(i + <span class="hljs-number">1</span>, nums, cur, res)<br>        cur = cur[:<span class="hljs-built_in">len</span>(cur) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于 []int, []float, []string 这种元素类型是基础类型的切片使用 sort 包提供的下面几个函数进行排序。</p>
<p>sort.Ints<br>sort.Floats<br>sort.Strings</p>
<p>用到了之前剪枝的方法，先排序，这样保证如果重复的元素都是挨着的</p>
<h2 id="9-10-递增子序列"><a href="#9-10-递增子序列" class="headerlink" title="9.10 递增子序列"></a>9.10 递增子序列</h2><p><strong>491. Increasing Subsequences</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code>, return all the different possible increasing subsequences of the given array with <strong>at least two elements</strong>. You may return the answer in <strong>any order</strong>.</p>
<p>The given array may contain duplicates, and two equal integers should also be considered a special case of increasing sequence.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findSubsequences</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    c, visited, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> _, ok := visited[nums[i]]; ok &#123;<br>          	<span class="hljs-keyword">continue</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            visited[nums[i]] = <span class="hljs-literal">true</span><br>            generateIncSubsets(nums, i, c, &amp;res)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateIncSubsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, current <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    c = <span class="hljs-built_in">append</span>(c, nums[current])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) &gt;= <span class="hljs-number">2</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>    &#125;<br>    visited := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := current + <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>      	<span class="hljs-comment">// 如果当前数值大于前一个数值，并且没有用过，进入DFS下一层</span><br>        <span class="hljs-keyword">if</span> nums[current] &lt;= nums[i] &#123;<br>            <span class="hljs-keyword">if</span> _, ok := visited[nums[i]]; ok &#123;<br>              	<span class="hljs-keyword">continue</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                visited[nums[i]] = <span class="hljs-literal">true</span><br>                generateIncSubsets(nums, i, c, res)<br>            &#125;<br>        &#125;<br>    &#125;<br>    c = c[:<span class="hljs-built_in">len</span>(c)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>给出一个数组，要求找出这个数组中所有长度大于 2 的非递减子序列。子序列顺序和原数组元素下标必须是顺序的，不能是逆序的。</li>
<li>这一题和第 78 题和第 90 题是类似的题目。第 78 题和第 90 题是求所有子序列，这一题在这两题的基础上增加了非递减和长度大于 2 的条件。需要注意的两点是，原数组中元素可能会重复，最终结果输出的时候需要去重。最终结果输出的去重用 map 处理，数组中重复元素用 DFS 遍历搜索。在每次 DFS 中，用 map 记录遍历过的元素，保证本轮 DFS 中不出现重复的元素，递归到下一层还可以选择值相同，但是下标不同的另外一个元素。外层循环也要加一个 map，这个 map 是过滤每组解因为重复元素导致的重复解，经过过滤以后，起点不同了，最终的解也会不同。</li>
<li>重点在于对于同一层不能够重复</li>
</ul>
<p>树结构</p>
<p><img src="https://img-blog.csdnimg.cn/20201124200229824.png" srcset="/img/loading.gif" lazyload alt="491. 递增子序列1"></p>
<h2 id="9-11-排列问题（一）"><a href="#9-11-排列问题（一）" class="headerlink" title="9.11 排列问题（一）"></a>9.11 排列问题（一）</h2><p><strong>46. Permutations</strong></p>
<p><strong>Q：</strong>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>    	  <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>		&#125;<br>    c, used, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(nums, c, used, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, used <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(tmp, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> !used[nums[i]] &#123;<br>          	used[nums[i]] = <span class="hljs-literal">true</span><br>            c = <span class="hljs-built_in">append</span>(c, nums[i])<br>            dfs(nums, c, used, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>            used[nums[i]] = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>树状图</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" srcset="/img/loading.gif" lazyload alt="46.全排列"></p>
<p>大家此时可以感受出排列问题的不同：</p>
<ul>
<li>每层都是从0开始搜索而不是startIndex</li>
<li>需要used数组记录path里都放了哪些元素了</li>
</ul>
<p>排列问题是回溯算法解决的经典题目。</p>
<p>注意map[key]的返回值（value，isExist）</p>
<h2 id="9-12-排列问题（二）"><a href="#9-12-排列问题（二）" class="headerlink" title="9.12 排列问题（二）"></a>9.12 排列问题（二）</h2><p><strong>47. Permutations II</strong></p>
<p><strong>Q：</strong>Given a collection of numbers, <code>nums</code>, that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permuteUnique</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>    	  <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>		&#125;<br>    c, used, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    sort.Ints(nums)<br>    dfs(nums, c, used, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, used <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(tmp, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> !used[i] &#123;<br>          	<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>] &#123; <span class="hljs-comment">// 关键去重语句</span><br>              	<span class="hljs-comment">// 当前数值的数在前面已经出现过，并且他的前一个数没有被用过才跳过</span><br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            used[i] = <span class="hljs-literal">true</span><br>            c = <span class="hljs-built_in">append</span>(c, nums[i])<br>            dfs(nums, c, used, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>            used[i] = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>树状图</p>
<p><img src="https://img-blog.csdnimg.cn/20201124201331223.png" srcset="/img/loading.gif" lazyload alt="47.全排列II1"></p>
<p>和 9.11 不同的是我们不但要消除纵向的重复，也要消除横向的重复。纵向的重复就不能单单只是消除。</p>
<p><code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]</code>为什么要加 !used[i - 1] 呢？因为每一层都要遍历所有的数，如果只是单单的nums[i] == nums[i-1] 就跳过的话，那么所有的层都会跳过，加入 !used[i - 1] 后代表着，在同一层的情况下（因为同一层如果相同的话只能选择其中一个数字，所以相同的数字只能有一位是 true 其他都是 false）如果当前数字和前一个相同的时候跳过。</p>
<h2 id="9-13-N-皇后问题"><a href="#9-13-N-皇后问题" class="headerlink" title="9.13 N 皇后问题"></a>9.13 N 皇后问题</h2><p><strong>51. N-Queens</strong></p>
<p><strong>Q：</strong>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code>chessboard such that no two queens attack each other.</p>
<p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space, respectively.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    idx, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">string</span>&#123;&#125;<br>    dfs(n, <span class="hljs-number">0</span>, idx, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(n, row <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> row == n &#123;<br>        *res = <span class="hljs-built_in">append</span>(*res, generateBoard(n, idx))<br>        fmt.Println()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>        <span class="hljs-keyword">if</span> isValid(row, col, n, idx) &#123;<br>            idx = <span class="hljs-built_in">append</span>(idx, col)<br>            dfs(n, row + <span class="hljs-number">1</span>, idx, res)<br>            idx = idx[:<span class="hljs-built_in">len</span>(idx) - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(row, col, n <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    col45 := col<br>    col135 := col<br>    <span class="hljs-comment">// 检查列</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(idx); i++ &#123;<br>        <span class="hljs-keyword">if</span> col == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查45˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col45++<br>        <span class="hljs-keyword">if</span> col45 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查135˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col135--<br>        <span class="hljs-keyword">if</span> col135 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateBoard</span><span class="hljs-params">(n <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    board := []<span class="hljs-type">string</span>&#123;&#125;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>      	res += <span class="hljs-string">&quot;.&quot;</span><br>    &#125;<br>    <span class="hljs-comment">// 生成棋盘让所有的内容都是...</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; n; row++ &#123;<br>     	 	board = <span class="hljs-built_in">append</span>(board, res)<br>    &#125;<br>    <span class="hljs-comment">// 按照收集到的位置，进行改写有皇后的位置</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; n; row++ &#123;<br>        tmp := []<span class="hljs-type">byte</span>(board[row]) <span class="hljs-comment">// byte才能够修改string的某一位</span><br>        tmp[idx[row]] = <span class="hljs-string">&#x27;Q&#x27;</span><br>        board[row] = <span class="hljs-type">string</span>(tmp)<br>    &#125;<br>    <span class="hljs-keyword">return</span> board<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先来看一下皇后们的约束条件：</p>
<ol>
<li>不能同行</li>
<li>不能同列</li>
<li>不能同斜线</li>
</ol>
<p>树结构</p>
<p><img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" srcset="/img/loading.gif" lazyload alt="51.N皇后"></p>
<p>这种题的大概dfs流程是这样的，首先确定终止条件，然后是难点在于要判断是否要进入下一层这个判断条件是一个难点，第二个难点就是生成棋盘的时间，我是先记录要放棋子的位置再放在最后来生成，也可以从始至终就生成一点点填充。总体来说这两种方法不同的点在于判断的过程不同。</p>
<h2 id="9-14-解数独"><a href="#9-14-解数独" class="headerlink" title="9.14 解数独"></a>9.14 解数独</h2><p><strong>37. Sudoku Solver</strong></p>
<p><strong>Q：</strong>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p>
<ol>
<li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li>
<li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li>
<li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code>sub-boxes of the grid.</li>
</ol>
<p>The <code>&#39;.&#39;</code> character indicates empty cells.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>)</span></span>  &#123;<br>    dfs(&amp;board)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(board *[][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// scan</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">9</span>; row++ &#123;<br>        <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; <span class="hljs-number">9</span>; col++ &#123;<br>            <span class="hljs-keyword">if</span> (*board)[row][col] != <span class="hljs-string">&#x27;.&#x27;</span> &#123; <span class="hljs-keyword">continue</span> &#125;<br>            <span class="hljs-comment">// fill</span><br>            <span class="hljs-keyword">var</span> num <span class="hljs-type">byte</span><br>            <span class="hljs-keyword">for</span> num = <span class="hljs-string">&#x27;1&#x27;</span>; num &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; num++ &#123;<br>                <span class="hljs-keyword">if</span> isValid(row, col, num, board) &#123;<br>                  (*board)[row][col] = num   <span class="hljs-comment">// 填充</span><br>                  <span class="hljs-keyword">if</span> dfs(board) == <span class="hljs-literal">true</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                  (*board)[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>   <span class="hljs-comment">// 回溯</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 遍历完了都没有false，返回true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(row, col <span class="hljs-type">int</span>, num <span class="hljs-type">byte</span>, board *[][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>		<span class="hljs-comment">// check row</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> num == (*board)[i][col] &#123;<br>          	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// check col</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++ &#123;<br>        <span class="hljs-keyword">if</span> num == (*board)[row][j] &#123;<br>          	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// check inner-9</span><br>    startRow := (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span><br>    startCol := (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">for</span> i := startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> num == (*board)[i][j] &#123;<br>              	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>树状图：</p>
<p><img src="https://img-blog.csdnimg.cn/2020111720451790.png" srcset="/img/loading.gif" lazyload alt="37.解数独"></p>
<p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p>
<p>判断棋盘是否合法有如下三个维度：</p>
<ul>
<li>同行是否重复</li>
<li>同列是否重复</li>
<li>9宫格里是否重复</li>
</ul>
<p>注意如果要提取二维数组的地址的元素的话要写 (*a)[ ] [ ] 这样。</p>
<p>在 check inner-9 的时候遇到检查那9块的问题。首先他们的起始点有 (0, 0) (3, 3) (6, 6)…..通过除 3 以后发现在第一块，但具体的坐标要乘 3 因为毕竟除法过（0，1，2来进行乘法）</p>
<p>答案有可能不唯一，真正退出的位置是在<code>if dfs(board) == true &#123; return true &#125; // 如果找到合适一组立刻返回</code>这一行。</p>
<h1 id="第10章-贪心算法"><a href="#第10章-贪心算法" class="headerlink" title="第10章 贪心算法"></a>第10章 贪心算法</h1><ul>
<li>将问题分解为若子问题。</li>
<li>找出适合的贪心策略。</li>
<li>求解每一个子问题的最优解。</li>
<li>将局部最优堆叠成全局最优</li>
</ul>
<h2 id="10-1-分发饼干"><a href="#10-1-分发饼干" class="headerlink" title="10.1 分发饼干"></a>10.1 分发饼干</h2><p><strong>455. Assign Cookie</strong></p>
<p><strong>Q：</strong>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p>
<p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code>will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(g []<span class="hljs-type">int</span>, s []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	sort.Ints(g)<br>	sort.Ints(s)<br>	gi, si, res := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> gi &lt; <span class="hljs-built_in">len</span>(g) &amp;&amp; si &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>		<span class="hljs-keyword">if</span> s[si] &gt;= g[gi] &#123;<br>			res++<br>			si++<br>			gi++<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			si++<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。</p>
<p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p>
<p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>
<p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p>
<p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p>
<ul>
<li>假设你想给小朋友们饼干，每个小朋友最多能够给一块饼干。每个小朋友都有一个“贪心指数”，称为 <code>g[i]</code>，<code>g[i]</code> 表示的是这名小朋友需要的饼干大小的最小值。同时，每个饼干都有一个大小值 <code>s[i]</code>，如果 <code>s[j] ≥ g[i]</code>，我们将饼干 <code>j</code> 分给小朋友 <code>i</code> 后，小朋友会很开心。给定数组 <code>g[]</code> 和 <code>s[]</code>，问如何分配饼干，能让更多的小朋友开心。</li>
<li>这是一道典型的简单贪心题。贪心题一般都伴随着排序。将 <code>g[]</code> 和 <code>s[]</code> 分别排序。按照最难满足的小朋友开始给饼干，依次往下满足，最终能满足的小朋友数就是最终解。</li>
</ul>
<p>注意一个饼干最多给一个孩子。</p>
<h2 id="10-2-摆动排序"><a href="#10-2-摆动排序" class="headerlink" title="10.2 摆动排序"></a>10.2 摆动排序</h2><p><strong>376. Wiggle Subsequence</strong></p>
<p><strong>Q：</strong>A <strong>wiggle sequence</strong> is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.</p>
<ul>
<li>For example, <code>[1, 7, 4, 9, 2, 5]</code> is a <strong>wiggle sequence</strong> because the differences <code>(6, -3, 5, -7, 3)</code> alternate between positive and negative.</li>
<li>In contrast, <code>[1, 4, 7, 2, 5]</code> and <code>[1, 7, 4, 5, 5]</code> are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.</li>
</ul>
<p>A <strong>subsequence</strong> is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.</p>
<p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>wiggle subsequence</strong> of</em> <code>nums</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br>	&#125;<br>	res := <span class="hljs-number">1</span><br>	prevDiff := nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>]<br>	<span class="hljs-keyword">if</span> prevDiff != <span class="hljs-number">0</span> &#123;<br>		res = <span class="hljs-number">2</span><br>	&#125;<br>    <span class="hljs-comment">// 从第三个数开始，i下标的位置是 前中后 的后</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        diff := nums[i] - nums[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-comment">// 如果是波峰或者波谷的话</span><br>        <span class="hljs-keyword">if</span> diff &gt; <span class="hljs-number">0</span> &amp;&amp; prevDiff &lt;= <span class="hljs-number">0</span> || diff &lt; <span class="hljs-number">0</span> &amp;&amp; prevDiff &gt;= <span class="hljs-number">0</span> &#123;<br>            res++<br>            prevDiff = diff<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>题目要求找到摆动序列最长的子序列。本题可以用贪心的思路，记录当前序列的上升和下降的趋势。扫描数组过程中，每扫描一个元素都判断是“峰”还是“谷”，根据前一个是“峰”还是“谷”做出对应的决定。利用贪心的思想找到最长的摆动子序列。</li>
</ul>
<p><code>diff &gt; 0 &amp;&amp; prevDiff &lt;= 0 || diff &lt; 0 &amp;&amp; prevDiff &gt;= 0</code>这句的判断里面为什么要有等号呢？因为其实你只要保证在 i - 1 位置之前的都是平的，或者与其后面的单调趋势是相反的，就可以保证单调性的不同（平 to 增减，增 to 减，减 to 增）</p>
<h2 id="10-3-最大子序和"><a href="#10-3-最大子序和" class="headerlink" title="10.3 最大子序和"></a>10.3 最大子序和</h2><p><strong>53. Maximum Subarray</strong></p>
<p><strong>Q：</strong>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p>
<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSum := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>      	<span class="hljs-comment">// 就加正数</span><br>        <span class="hljs-keyword">if</span> nums[i] + nums[i<span class="hljs-number">-1</span>] &gt; nums[i] &#123;<br>            nums[i] += nums[i<span class="hljs-number">-1</span>]<br>        &#125;<br>      	<span class="hljs-comment">// 如果当前子序列大于了之前存的总和就存下</span><br>        <span class="hljs-keyword">if</span> nums[i] &gt; maxSum &#123;<br>            maxSum = nums[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>局部最优：</strong>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p>
<p>全局最优：选取最大“连续和”</p>
<p>这个思想主要是不利用额外的存储空间。举例，[-2,1,-3,4,-1,2,1,-5,4] 我们贪心的点在于必须要子序列要是在增加的才加上。尽管倒数第二个 -5 + 6 = 1 是比自身大的但是没有大过 maxSum，也无所谓。所以总结一下就是，我们要加入当前数的前一个数，如果是上升的值就保存，并且如果当前 sum 后整体大于了统计的 max，就更新 max 要不就继续遍历。就像我们的人生一样，我们就记录我们能前进的值，忘掉那些退步的地方，并且记录下我们max的里程碑。</p>
<p>golang的最大值和最小值的定义 <a target="_blank" rel="noopener" href="https://blog.csdn.net/lishanleilixin/article/details/103269904">https://blog.csdn.net/lishanleilixin/article/details/103269904</a></p>
<h2 id="10-4-买卖股票的最佳时机-II"><a href="#10-4-买卖股票的最佳时机-II" class="headerlink" title="10.4 买卖股票的最佳时机 II"></a>10.4 买卖股票的最佳时机 II</h2><p><strong>122. Best Time to Buy and Sell Stock II</strong></p>
<p><strong>Q：</strong>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p>
<p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    profit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        <span class="hljs-keyword">if</span> prices[i] - prices[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &#123;<br>            profit += prices[i] - prices[i - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020112917480858.png" srcset="/img/loading.gif" lazyload alt="122.买卖股票的最佳时机II"></p>
<p>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p>
<p>那么只收集正利润就是贪心所贪的地方！</p>
<p><strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</p>
<h2 id="10-5-跳跃游戏"><a href="#10-5-跳跃游戏" class="headerlink" title="10.5 跳跃游戏"></a>10.5 跳跃游戏</h2><p><strong>55. Jump Game</strong></p>
<p><strong>Q：</strong>You are given an integer array <code>nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p>
<p>Return <code>true</code> <em>if you can reach the last index, or</em> <code>false</code> <em>otherwise</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    cover := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果是跳跃数组的长度为1</span><br>    <span class="hljs-comment">// 每次在当前范围里面找每个数</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= cover; i++ &#123;<br>        cover = max(i + nums[i], cover) <span class="hljs-comment">// 覆盖面的选择，从当前cover范围和当前位置代表的未来cover范围二选一</span><br>        <span class="hljs-keyword">if</span> cover &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果能包含到最后一个位置就代表能跳到</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 没找到就false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> a &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>图片势力</p>
<p><img src="https://img-blog.csdnimg.cn/20201124154758229.png" srcset="/img/loading.gif" lazyload alt="55.跳跃游戏"></p>
<h2 id="10-6-跳跃游戏-II"><a href="#10-6-跳跃游戏-II" class="headerlink" title="10.6 跳跃游戏 II"></a>10.6 跳跃游戏 II</h2><p><strong>45. Jump Game II</strong></p>
<p><strong>Q：</strong>Given an array of non-negative integers <code>nums</code>, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>You can assume that you can always reach the last index.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    curDistance := <span class="hljs-number">0</span> <span class="hljs-comment">// 当前覆盖的最远距离下标</span><br>    step := <span class="hljs-number">0</span> <span class="hljs-comment">// 记录走的最大步数</span><br>    nextDistance := <span class="hljs-number">0</span> <span class="hljs-comment">// 下一步覆盖的最远距离下标</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123; <span class="hljs-comment">// 注意这里是小于等于nums.size() - 2，这是关键所在</span><br>        nextDistance = max(i + nums[i], nextDistance) <span class="hljs-comment">// 更新下一步覆盖的最远距离下标</span><br>        <span class="hljs-keyword">if</span> i == curDistance &#123; <span class="hljs-comment">// 遇到当前覆盖的最远距离下标</span><br>            curDistance = nextDistance <span class="hljs-comment">// 更新当前覆盖的最远距离下标</span><br>            step++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> step<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> a &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>理解本题的关键在于：<strong>以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点</strong>，这个范围内最小步数一定可以跳到，不用管具体是怎么跳的，不纠结于一步究竟跳一个单位还是两个单位。</p>
<p><img src="https://img-blog.csdnimg.cn/20201201232445286.png" srcset="/img/loading.gif" lazyload alt="45.跳跃游戏II2"></p>
<p>一个个找，找每个范围内的最远距离。cur 记录的是当前可以跳的最远距离，所以一旦 i = cur 的时候说明要走下一跳了</p>
<p>（只有 i 到达了上一次记录的最远距离的时候，才更新 cur = next 的最远距离）</p>
<h2 id="10-7-加油站"><a href="#10-7-加油站" class="headerlink" title="10.7 加油站"></a>10.7 加油站</h2><p><strong>134. Gas Station</strong></p>
<p><strong>Q：</strong>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>ith</code> station is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>ith</code> station to its next <code>(i + 1)th</code> station. You begin the journey with an empty tank at one of the gas stations.</p>
<p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong></p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(gas []<span class="hljs-type">int</span>, cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	curSum := <span class="hljs-number">0</span><br>	totalSum := <span class="hljs-number">0</span><br>	start := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(gas); i++ &#123;<br>		curSum += gas[i] - cost[i]<br>		totalSum += gas[i] - cost[i]<br>		<span class="hljs-keyword">if</span> curSum &lt; <span class="hljs-number">0</span> &#123;<br>			start = i+<span class="hljs-number">1</span><br>			curSum = <span class="hljs-number">0</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> totalSum &lt; <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> start<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201213162821958.png" srcset="/img/loading.gif" lazyload alt="134.加油站"></p>
<p>我把所有的差值加一遍只要是能总和大于0肯定能跑完，然后找第一个可以 gas - cost &gt; 0 的位置作为起点</p>
<h2 id="10-8-分发糖果"><a href="#10-8-分发糖果" class="headerlink" title="10.8 分发糖果"></a>10.8 分发糖果</h2><p><strong>135. Candy</strong></p>
<p><strong>Q：</strong>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">candy</span><span class="hljs-params">(ratings []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// initialization</span><br>    candy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ratings))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(ratings); i++ &#123;<br>        candy[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// front to back</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(ratings); i++ &#123;<br>        <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>] &#123;<br>            candy[i] = candy[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    fmt.Println(candy)<br>    <span class="hljs-comment">// back to front</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(ratings) - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] &#123;<br>            candy[i] = max(candy[i], candy[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">// 因为是更新数值，所以用max，并不是单纯的覆盖</span><br>        &#125;<br>    &#125;<br>    fmt.Println(candy)<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> candy &#123;<br>        res += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这在leetcode上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p>
<p>那么本题我采用了两次贪心的策略：</p>
<ul>
<li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li>
<li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li>
</ul>
<p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p>
<h2 id="10-9-柠檬水找零"><a href="#10-9-柠檬水找零" class="headerlink" title="10.9 柠檬水找零"></a>10.9 柠檬水找零</h2><p><strong>860. Lemonade Change</strong></p>
<p><strong>Q：</strong>At a lemonade stand, each lemonade costs <code>$5</code>. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a <code>$5</code>, <code>$10</code>, or <code>$20</code> bill. You must provide the correct change to each customer so that the net transaction is that the customer pays <code>$5</code>.</p>
<p>Note that you do not have any change in hand at first.</p>
<p>Given an integer array <code>bills</code> where <code>bills[i]</code> is the bill the <code>ith</code> customer pays, return <code>true</code> <em>if you can provide every customer with the correct change, or</em> <code>false</code> <em>otherwise</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(bills []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    count5 := <span class="hljs-number">0</span><br>    count10 := <span class="hljs-number">0</span><br>    count20 := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(bills); i++ &#123;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">5</span> &#123;<br>            count5++<br>        &#125;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">if</span> count5 &lt;= <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>            count5--<br>            count10++<br>        &#125;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">20</span> &#123;<br>          	<span class="hljs-comment">// 优先处理10块的，再处理5块的</span><br>            <span class="hljs-keyword">if</span> count5 &gt; <span class="hljs-number">0</span> &amp;&amp; count10 &gt; <span class="hljs-number">0</span> &#123;<br>                count5--<br>                count10--<br>                count20++<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> count10 == <span class="hljs-number">0</span> &amp;&amp; count5 &gt;= <span class="hljs-number">3</span> &#123;<br>                count5 -= <span class="hljs-number">3</span><br>                count20++<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>有如下三种情况：</p>
<ul>
<li>情况一：账单是5，直接收下。</li>
<li>情况二：账单是10，消耗一个5，增加一个10</li>
<li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li>
</ul>
<p>局部最优推算出全局最优</p>
<h2 id="10-10-用最少数量的箭射爆气球"><a href="#10-10-用最少数量的箭射爆气球" class="headerlink" title="10.10 用最少数量的箭射爆气球"></a>10.10 用最少数量的箭射爆气球</h2><p><strong>452. Minimum Number of Arrows to Burst Balloons</strong></p>
<p><strong>Q：</strong>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array <code>points</code> where <code>points[i] = [xstart, xend]</code> denotes a balloon whose <strong>horizontal diameter</strong>stretches between <code>xstart</code> and <code>xend</code>. You do not know the exact y-coordinates of the balloons.</p>
<p>Arrows can be shot up <strong>directly vertically</strong> (in the positive y-direction) from different points along the x-axis. A balloon with <code>xstart</code> and <code>xend</code> is <strong>burst</strong> by an arrow shot at <code>x</code> if <code>xstart &lt;= x &lt;= xend</code>. There is <strong>no limit</strong> to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</p>
<p>Given the array <code>points</code>, return <em>the <strong>minimum</strong> number of arrows that must be shot to burst all balloons</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(points [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// 弓箭数</span><br>    <span class="hljs-comment">// 先按照第一位排序</span><br>    sort.Slice(points, <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> points[i][<span class="hljs-number">0</span>] &lt; points[j][<span class="hljs-number">0</span>]<br>    &#125;)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(points); i++&#123;<br>        <span class="hljs-keyword">if</span> points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; points[i][<span class="hljs-number">0</span>] &#123; <span class="hljs-comment">// 如果前一位的右边界小于后一位的左边界，则一定不重合</span><br>            res++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            points[i][<span class="hljs-number">1</span>] = min(points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], points[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界,覆盖该位置的值，留到下一步使用</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>
<p>贪心，先确定一个思路，再看这个思路是否有bug，没有bug就可以使用贪心</p>
<p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？</p>
<p>尝试一下举反例，发现没有这种情况。</p>
<p>sort.Slice使用指南<a target="_blank" rel="noopener" href="http://books.studygolang.com/Mastering_Go_ZH_CN/eBook/chapter3/03.3.7.html">http://books.studygolang.com/Mastering_Go_ZH_CN/eBook/chapter3/03.3.7.html</a></p>
<h2 id="10-11-合并区间"><a href="#10-11-合并区间" class="headerlink" title="10.11 合并区间"></a>10.11 合并区间</h2><p><strong>56. Merge Intervals</strong></p>
<p><strong>Q：</strong>Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//先从小到大排序</span><br>    sort.Slice(intervals,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>]&lt;intervals[j][<span class="hljs-number">0</span>]<br>    &#125;)<br>    <span class="hljs-comment">//再弄重复的</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(intervals)<span class="hljs-number">-1</span>;i++&#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">1</span>] &gt;= intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&#123;<br>            intervals[i][<span class="hljs-number">1</span>] = max(intervals[i][<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<span class="hljs-comment">//赋值最大值</span><br>            intervals = <span class="hljs-built_in">append</span>(intervals[:i+<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">2</span>:]...)<br>            i--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> intervals<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a &gt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么我按照左边界排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。</p>
<p><code>intervals = append(intervals[:i+1],intervals[i+2:]...)</code>将第一位提取出来，后面跳过下一位把后面的接过来，相当于剔除了第二位。</p>
<h2 id="10-12-单调递增的数字"><a href="#10-12-单调递增的数字" class="headerlink" title="10.12 单调递增的数字"></a>10.12 单调递增的数字</h2><p><strong>738. Monotone Increasing Digits</strong></p>
<p><strong>Q：</strong>An integer has <strong>monotone increasing digits</strong> if and only if each pair of adjacent digits <code>x</code> and <code>y</code> satisfy <code>x &lt;= y</code>.</p>
<p>Given an integer <code>n</code>, return <em>the largest number that is less than or equal to</em> <code>n</code><em>with <strong>monotone increasing digits</strong></em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(N <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    s := strconv.Itoa(N) <span class="hljs-comment">// 将数字转为字符串，方便使用下标</span><br>    ss := []<span class="hljs-type">byte</span>(s) <span class="hljs-comment">// 将字符串转为byte数组，方便更改。</span><br>    n := <span class="hljs-built_in">len</span>(ss)<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> N<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span> ; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> ss[i - <span class="hljs-number">1</span>] &gt; ss[i] &#123; <span class="hljs-comment">// 前一个大于后一位,前一位减1，后面的全部置为9</span><br>            ss[i - <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j := i ; j &lt; n; j++ &#123; <span class="hljs-comment">// 后面的全部置为9</span><br>                ss[j] = <span class="hljs-string">&#x27;9&#x27;</span><br>            &#125;<br>        &#125; <br>    &#125;<br>    res, _ := strconv.Atoi(<span class="hljs-type">string</span>(ss))<br>    <span class="hljs-keyword">return</span> res <br>&#125;<br></code></pre></td></tr></table></figure>
<p>从前往后遍历不行，因为会修改原本的值，但是从后往前不会。</p>
<p>对于go语言如果要修改string的内容最好先转化成byte数组。</p>
<p>前一个大于后一位,前一位减1，后面的全部置为9（因为要求最大）！</p>
<h1 id="第11章-动态规划"><a href="#第11章-动态规划" class="headerlink" title="第11章 动态规划"></a>第11章 动态规划</h1><p>动规五部曲：</p>
<p>这里我们要用一个一维dp数组来保存递归的结果</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>为什么这是一道非常简单的入门题目呢？</p>
<p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></table></figure>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p>
<p>0 1 1 2 3 5 8 13 21 34 55</p>
<p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p>
<h2 id="11-1-斐波那契数列"><a href="#11-1-斐波那契数列" class="headerlink" title="11.1 斐波那契数列"></a>11.1 斐波那契数列</h2><p><strong>509. Fibonacci Number</strong></p>
<p><strong>Q：</strong>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(n)</span></span> = <span class="hljs-built_in">F</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(n - <span class="hljs-number">2</span>), <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure>
<p>Given <code>n</code>, calculate <code>F(n)</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> n&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>      	dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="11-2-爬楼梯"><a href="#11-2-爬楼梯" class="headerlink" title="11.2 爬楼梯"></a>11.2 爬楼梯</h2><p><strong>70. Climbing Stairs</strong></p>
<p><strong>Q：</strong>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>
<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> n&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">// 第一层的方法数量</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span> <span class="hljs-comment">// 第二层的方法数量</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>初始化第一步和第二步，然后递归后面的步子，关键在于递推公式的生成</p>
<p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p>
<p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p>
<p>走一步和走两步的方法总和</p>
<h2 id="11-3-使用最小花费爬楼梯"><a href="#11-3-使用最小花费爬楼梯" class="headerlink" title="11.3 使用最小花费爬楼梯"></a>11.3 使用最小花费爬楼梯</h2><p><strong>746. Min Cost Climbing Stairs</strong></p>
<p><strong>Q：</strong>You are given an integer array <code>cost</code> where <code>cost[i]</code> is the cost of <code>ith</code> step on a staircase. Once you pay the cost, you can either climb one or two steps.</p>
<p>You can either start from the step with index <code>0</code>, or the step with index <code>1</code>.</p>
<p>Return <em>the minimum cost to reach the top of the floor</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cost))<br>    dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>]<br>    dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(cost); i++ &#123;<br>        dp[i] = min(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> min(dp[<span class="hljs-built_in">len</span>(dp) - <span class="hljs-number">1</span>], dp[<span class="hljs-built_in">len</span>(dp) - <span class="hljs-number">2</span>]) <span class="hljs-comment">// 返回的是踏上楼顶的前一步或者前两步</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]</strong>。</p>
<p><strong>可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]</strong>。</p>
<p>那么究竟是选dp[i-1]还是dp[i-2]呢？</p>
<p>一定是选最小的，所以dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];</p>
<p><strong>注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的</strong>，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值</p>
<h2 id="11-4-不同路径-I"><a href="#11-4-不同路径-I" class="headerlink" title="11.4 不同路径 I"></a>11.4 不同路径 I</h2><p><strong>62. Unique Paths</strong></p>
<p><strong>Q：</strong>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>
<p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>
<p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>		dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>		dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>	&#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> dp[<span class="hljs-number">0</span>] &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>] <span class="hljs-comment">// 从左边来的和右边来的数量的总和</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>按照动规五部曲来分析：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i] [j] ：表示从（0 ，0）出发，到(i, j) 有dp[i] [j]条不同的路径。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>想要求dp[i] [j]，只能有两个方向来推导出来，即dp[i - 1] [j] 和 dp[i] [j - 1]。</p>
<p>此时在回顾一下 dp[i - 1] [j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。</p>
<p>那么很自然，dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，因为dp[i] [j]只有这两个方向过来。</p>
<ol>
<li>dp数组的初始化</li>
</ol>
<p>如何初始化呢，首先dp[i] [0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0] [j]也同理。</p>
<p>所以初始化代码为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>这里要看一下递归公式dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，dp[i] [j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p>
<p>这样就可以保证推导dp[i] [j]的时候，dp[i - 1] [j] 和 dp[i] [j - 1]一定是有数值的。</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<h2 id="11-5-不同路径-II"><a href="#11-5-不同路径-II" class="headerlink" title="11.5 不同路径 II"></a>11.5 不同路径 II</h2><p><strong>63. Unique Paths II</strong></p>
<p><strong>Q：</strong>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m-1][n-1]</code>). The robot can only move either down or right at any point in time.</p>
<p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p>
<p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>
<p>The testcases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(obstacleGrid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(obstacleGrid)<br>    n := <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">if</span> obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">for</span> k := i; k &lt; m; k++ &#123;<br>                dp[k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果发现了这一行有一个石头，那么这一行从石头开始后面的全部到达不了</span><br>            &#125;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">for</span> k := j; k &lt; n; k++ &#123;<br>                dp[<span class="hljs-number">0</span>][k] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果发现了这一列有一个石头，那么这一列从石头开始后面的全部到达不了</span><br>            &#125;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span> &#123;   <br>                dp[i][j] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果此点有障碍物，那么这点就不是通路就为0</span><br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有两个关键点，第一个是初始化的时候要注意，如果出现了障碍物，那么剩下的一行或者一列将都是0；第二个是当进行的时候如果当前点是障碍点了，那么就把它置0，因为对于下一个点来说，他并不能帮助下一点到达自己的目的地。</p>
<h2 id="11-6-整数拆分"><a href="#11-6-整数拆分" class="headerlink" title="11.6 整数拆分"></a>11.6 整数拆分</h2><p><strong>343. Integer Break</strong></p>
<p><strong>Q：</strong>Given an integer <code>n</code>, break it into the sum of <code>k</code> <strong>positive integers</strong>, where <code>k &gt;= 2</code>, and maximize the product of those integers.</p>
<p>Return <em>the maximum product you can get</em>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123; <span class="hljs-comment">// 真正dp序列的循环，把n这个数拆出来一个然后分析看看这么拆是不是最小的乘积</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i - <span class="hljs-number">1</span>; j++ &#123; <span class="hljs-comment">// 正整数所以j从1开始，为什么不能到达i-1，比如n是10，那么我能拆开的两个数就是9和1</span><br>            dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)) <span class="hljs-comment">// j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n] <span class="hljs-comment">// 由于前面在比较的同时需要给dp[n]赋值，必须保证当到达dp[n]的时候，其数值是最大的，所以在递推公式中有dp[n]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>动规五部曲，分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p>
<p>dp[i]的定义讲贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！</p>
<ol>
<li>确定递推公式🌟</li>
</ol>
<p>可以想 dp[i]最大乘积是怎么得到的呢？</p>
<p>其实可以从1遍历j，然后有两种渠道得到dp[i].</p>
<p>一个是j * (i - j) 直接相乘。</p>
<p>一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。</p>
<p><strong>也可以这么理解，j <em> (i - j) 是单纯的把整数拆分为两个数相乘，而j </em> dp[i - j]是拆分成两个以及两个以上的个数相乘。</strong></p>
<p>如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了</p>
<ol>
<li>dp的初始化</li>
</ol>
<p>不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？</p>
<p>有的题解里会给出dp[0] = 1，dp[1] = 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。</p>
<p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。</p>
<p>拆分0和拆分1的最大乘积是多少？</p>
<p>这是无解的。</p>
<p>这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) <em> j, dp[i - j] </em> j));</p>
<p>dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。</p>
<p>枚举j的时候，是从1开始的。i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<h2 id="11-7-不同的二叉树搜索树"><a href="#11-7-不同的二叉树搜索树" class="headerlink" title="11.7 不同的二叉树搜索树"></a>11.7 不同的二叉树搜索树</h2><p><strong>96. Unique Binary Search Trees</strong></p>
<p><strong>Q：</strong>Given an integer <code>n</code>, return <em>the number of structurally unique <strong>BST’</strong>s (binary search trees) which has exactly</em> <code>n</code> <em>nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p>
<p><strong>A：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  	dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>) <span class="hljs-comment">// 包含 0 + (1 to n)</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i; j++ &#123; <span class="hljs-comment">// 假如只有左子树或者右子树的时候就会 j = i</span><br>            dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><strong>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]</strong>。</p>
<p>也可以理解是i个的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p>
<p>以下分析如果想不清楚，就来回想一下dp[i]的定义</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p>
<p>j相当于是头结点的元素，从1遍历到i为止。</p>
<p>所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p>
<p>其中第二个循环for j的那个就是为了找寻不同的数量的左子树。之所以右子树的数量为 i - j 是因为左子树加上右子树的总和为 i - 1</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。</p>
<p>那么dp[0]应该是多少呢？</p>
<p>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。</p>
<p>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。</p>
<p>所以初始化dp[0] = 1</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p>
<p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>        dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>n为5时候的dp数组状态如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210107093253987.png" srcset="/img/loading.gif" lazyload alt="96.不同的二叉搜索树3"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/algorithm/">algorithm</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/LeetCode/">LeetCode</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/07/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">go语言笔记</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/20/SQL-Study/">
                        <span class="hidden-mobile">SQL Study</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> & <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
