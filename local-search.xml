<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代码随想录</title>
    <link href="/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    <url>/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>url：<a href="https://www.programmercarl.com">https://www.programmercarl.com</a></p><h1 id="第3章-数组"><a href="#第3章-数组" class="headerlink" title="第3章 数组"></a>第3章 数组</h1><h2 id="3-2-二分查找"><a href="#3-2-二分查找" class="headerlink" title="3.2 二分查找"></a>3.2 二分查找</h2><p><strong>704. Binary Search</strong></p><p><strong>Q:</strong> Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> pivot, left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>      pivot = left + (right - left) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[pivot] == target) <span class="hljs-keyword">return</span> pivot;<br>      <span class="hljs-keyword">if</span> (target &lt; nums[pivot]) right = pivot - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> left = pivot + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 (left + right) / 2 = left + (right / 2) - (left / 2) = left + (right - left) / 2</p><p>我采用的是 [left, right] 闭区间，所以判断条件是 &lt;= ，left和right相等的时候有意义。</p><h2 id="3-3-移除元素"><a href="#3-3-移除元素" class="headerlink" title="3.3 移除元素"></a><strong>3.3 移除元素</strong></h2><p><strong>27. Remove Element</strong></p><p><strong>Q: </strong>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a>. The relative order of the elements may be changed.</p><p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p><p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] != val) &#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1⃣️ 由于有空间复杂度的限制，所以不能建立另外一个数组来进行赋值，暗示我们用双指针法，双指针法是常用的降低时间复杂度的方法。</p><p>2⃣️ nums = [0, 1 ,4 ,0 ,3 , _ , _] 因为数组中的元素在内存地址上是连续的，不能单独删除数组中的某个元素，只能覆盖。</p><h2 id="3-4-长度最小的子数组"><a href="#3-4-长度最小的子数组" class="headerlink" title="3.4 长度最小的子数组"></a>3.4 长度最小的子数组</h2><p><strong>209. Minimum Size Subarray Sum</strong></p><p><strong>Q: </strong>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Study</title>
    <link href="/2022/04/20/SQL-Study/"/>
    <url>/2022/04/20/SQL-Study/</url>
    
    <content type="html"><![CDATA[<h1 id="0-基本书写规范"><a href="#0-基本书写规范" class="headerlink" title="0. 基本书写规范"></a>0. 基本书写规范</h1><p>对于 SQL 初学者，在写 SQL 语句时，只要遵守下面几个书写规则，就可以避免很多错误。这些规则都非常简单，下面我们来逐一介绍。</p><p><strong>SQL 语句要以分号<code>;</code>结尾</strong></p><p>在 RDBMS （关系型数据库）当中，SQL 语句是逐条执行的，一条 SQL 语句代表着数据库的一个操作。</p><p>我们通常在句子的句尾加注标点表示这句话结束，中文句子以句号<code>。</code>结尾，英文以点号<code>.</code>结尾，而 SQL 语句则使用英文分号<code>;</code>结尾。</p><p><strong>SQL 语句不区分大小写</strong></p><p>SQL 不区分关键字的大小写。例如，不管写成 SELECT 还是 select，解释都是一样的。表名和列名也是如此。（但是注意字符串是要分大小写的）</p><p>提示：关键字是数据库事先定义的，有特别意义的单词。</p><p>虽然可以根据个人喜好选择大写还是小写（或大小写混杂），但为了理解起来更加容易，本教程使用以下规则来书写 SQL 语句。</p><ul><li>关键字大写</li><li>数据库名、表名和列名等小写</li></ul><p>需要注意的是，插入到表中的数据是区分大小写的。例如，向数据库中插入单词 Computer、COMPUTER 或 computer，这三个是不一样的数据</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/dbStudy.png" alt="dbStudy"></p><p>自学网网址：<a href="http://www.xuesql.cn/">http://www.xuesql.cn/</a></p><h1 id="1-SQL的SELECT使用"><a href="#1-SQL的SELECT使用" class="headerlink" title="1. SQL的SELECT使用"></a>1. SQL的SELECT使用</h1><h2 id="1-1-条件查询语法"><a href="#1-1-条件查询语法" class="headerlink" title="1.1 条件查询语法"></a>1.1 条件查询语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql"># 条件查询语法<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition<br>    AND/OR another_condition<br>    AND/OR …;<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Operator（操作符）</th><th>Condition（解释）</th><th>Example（例子）</th></tr></thead><tbody><tr><td>=</td><td>Case sensitive exact string comparison (<em>notice the single equals</em>)完全等于</td><td>col_name = “abc”</td></tr><tr><td>!= or &lt;&gt;</td><td>Case sensitive exact string inequality comparison 不等于</td><td>col_name != “abcd”</td></tr><tr><td>LIKE</td><td>Case insensitive exact string comparison 没有用通配符等价于 =</td><td>col_name LIKE “ABC”</td></tr><tr><td>NOT LIKE</td><td>Case insensitive exact string inequality comparison 没有用通配符等价于 !=</td><td>col_name NOT LIKE”ABCD”</td></tr><tr><td>%</td><td>Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) 通配符，代表匹配0个以上的字符</td><td>col_name LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”) “%AT%” 代表AT 前后可以有任意字符</td></tr><tr><td>_</td><td>Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) 和% 相似，代表1个字符</td><td>col_name LIKE “AN_” (matches “AND”, but not “AN”)</td></tr><tr><td>IN (…)</td><td>String exists in a list 在列表</td><td>col_name IN (“A”, “B”, “C”)</td></tr></tbody></table></div><h2 id="1-2-DISTINCT语法"><a href="#1-2-DISTINCT语法" class="headerlink" title="1.2 DISTINCT语法"></a>1.2 DISTINCT语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 选取出唯一的结果的语法<br>SELECT DISTINCT column, another_column, …<br>FROM mytable<br>WHERE condition(s);<br></code></pre></td></tr></table></figure><p>因为 <code>DISTINCT</code> 语法会直接删除重复的行，我们还会学习 <code>GROUP BY</code> 语句， <code>GROUP BY</code> 也会返回唯一的行，不过可以对具有相同的 属性值的行做一些统计计算，比如：求和。</p><h2 id="1-3-结果排序-Ordering-results"><a href="#1-3-结果排序-Ordering-results" class="headerlink" title="1.3 结果排序(Ordering results)"></a>1.3 结果排序(Ordering results)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 结果排序（ordered results）<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition(s)<br>ORDER BY column ASC/DESC;<br></code></pre></td></tr></table></figure><p><code>ORDER BY col_name</code> 这句话的意思就是让结果按照 col_name 列的具体值做 ASC升序 或 DESC 降序，对数字来说就是升序 1，2，3，… 或降序 … 3,2,1。对于文本列，升序和降序指的是按文本的字母序。</p><h2 id="1-4-通过Limit选取部分结果"><a href="#1-4-通过Limit选取部分结果" class="headerlink" title="1.4 通过Limit选取部分结果"></a>1.4 通过Limit选取部分结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># limited查询<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition(s)<br>ORDER BY column ASC/DESC<br>LIMIT num_limit OFFSET num_offset;<br></code></pre></td></tr></table></figure><p><code>LIMIT</code> 和 <code>OFFSET</code> 子句通常和<code>ORDER BY</code> 语句一起使用，当我们对整个结果集排序之后，我们可以 <code>LIMIT</code>来指定只返回多少行结果 ,用 <code>OFFSET</code>来指定从哪一行开始返回。你可以想象一下从一条长绳子剪下一小段的过程，我们通过 <code>OFFSET</code> 指定从哪里开始剪，用 <code>LIMIT</code> 指定剪下多少长度。</p><p>PS：num_offset 是从0开始的</p><h2 id="1-5-数据库范式"><a href="#1-5-数据库范式" class="headerlink" title="1.5 数据库范式"></a>1.5 数据库范式</h2><p>数据库范式是数据表设计的规范，在范式规范下，数据库里每个表存储的<strong>重复数据降到最少（这有助于数据的一致性维护）</strong>，同时在数据库范式下，表和表之间不再有很强的数据耦合，可以独立的增长 (ie. 比如汽车引擎的增长和汽车的增长是完全独立的). 范式带来了很多好处，但随着数据表的分离，意味着我们要查询多个数据属性时，需要更复杂的SQL语句，也就是本节开始介绍的多表连接技术。这样SQL的性能也会面临更多的挑战，特别是当大数据量的表很多的情况下。</p><p>如果一个实体（比如Dog）的属性数据被分散到多个数据表中，我们就需要学习如何通过 <code>JOIN</code>连表技术来整合这些数据并找到我们想要查询的数据项。</p><h2 id="1-6-用JOINs进行多表联合查询"><a href="#1-6-用JOINs进行多表联合查询" class="headerlink" title="1.6 用JOINs进行多表联合查询"></a>1.6 用JOINs进行多表联合查询</h2><p><code>主键(primary key)</code>, 一般关系数据表中，都会有一个属性列设置为 <code>主键(primary key)</code>。主键是唯一标识一条数据的，不会重复复（想象你的身份证号码)。一个最常见的主键就是auto-incrementing integer(自增ID，每写入一行数据ID+1, 当然字符串，hash值等只要是每条数据是唯一的也可以设为主键.</p><p>借助<code>主键(primary key)</code>（当然其他唯一性的属性也可以），我们可以把两个表中具有相同 主键ID的数据连接起来（因为一个ID可以简要的识别一条数据，所以连接之后还是表达的同一条数据）（你可以想象一个左右连线游戏）。具体我们用到 <code>JOIN</code> 关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">用LEFT/RIGHT/FULL JOINs 做多表查询<br>SELECT column, another_column, …<br>FROM mytable<br>INNER/LEFT/RIGHT/FULL JOIN another_table<br>    ON mytable.id = another_table.matching_id<br>WHERE condition(s)<br>ORDER BY column, … ASC/DESC<br>LIMIT num_limit OFFSET num_offset;<br></code></pre></td></tr></table></figure><p>PS：<code>INNER JOIN</code> 可以简写做 <code>JOIN</code>. 两者是相同的意思，但我们还是会继续写作 <code>INNER JOIN</code> 以便和后面的 <code>LEFT JOIN</code>， <code>RIGHT JOIN</code>等相比较。(内连接，左连接，右连接)</p><p>LEFT JOIN：左边的全部存在，右边的有缺失就NULL</p><p>RIGHT JOIN：右边的全部存在，左边的有缺失就NULL</p><h2 id="1-7-查询条件中处理NULL"><a href="#1-7-查询条件中处理NULL" class="headerlink" title="1.7 查询条件中处理NULL"></a>1.7 查询条件中处理NULL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 在查询条件中处理 NULL<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE column IS/IS NOT NULL<br>AND/OR another_condition<br>AND/OR …;<br></code></pre></td></tr></table></figure><p>判断是否为NULL</p><h2 id="1-8-查询中使用表达式"><a href="#1-8-查询中使用表达式" class="headerlink" title="1.8 查询中使用表达式"></a>1.8 查询中使用表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 包含表达式的例子<br>SELECT  particle_speed / 2.0 AS half_particle_speed (对结果做了一个除2）<br>FROM physics_data<br>WHERE ABS(particle_position) * 10.0 &gt;500<br>            （条件要求这个属性绝对值乘以10大于500）;<br>         <br># AS使用别名<br>SELECT col_expression AS expr_description, …<br>FROM mytable;<br><br># 属性列和表取别名的例子<br>SELECT column AS better_column_name, …<br>FROM a_long_widgets_table_name AS mywidgets<br>INNER JOIN widget_sales<br>  ON mywidgets.id = widget_sales.widget_id;<br></code></pre></td></tr></table></figure><p><strong>e.g【难题】John Lasseter导演的每部电影每分钟值多少钱,告诉我最高的3个电影名和价值就可以</strong> </p><p>Table: Movies(Read - Only)</p><div class="table-container"><table><thead><tr><th>Id</th><th>Title</th><th>Director</th><th>Year</th><th>Length_minutes</th></tr></thead><tbody><tr><td>1</td><td>Toy Story</td><td>John Lasseter</td><td>1995</td><td>81</td></tr><tr><td>2</td><td>A Bug’s Life</td><td>John Lasseter</td><td>1998</td><td>95</td></tr><tr><td>3</td><td>Toy Story 2</td><td>John Lasseter</td><td>1999</td><td>93</td></tr><tr><td>4</td><td>Monsters, Inc.</td><td>Pete Docter</td><td>2001</td><td>92</td></tr><tr><td>5</td><td>Finding Nemo</td><td>Finding Nemo</td><td>2003</td><td>107</td></tr><tr><td>6</td><td>The Incredibles</td><td>Brad Bird</td><td>2004</td><td>116</td></tr><tr><td>7</td><td>Cars</td><td>John Lasseter</td><td>2006</td><td>117</td></tr><tr><td>8</td><td>Ratatouille</td><td>Brad Bird</td><td>2007</td><td>115</td></tr><tr><td>9</td><td>WALL-E</td><td>Andrew Stanton</td><td>2008</td><td>104</td></tr><tr><td>10</td><td>Up</td><td>Pete Docter</td><td>2009</td><td>101</td></tr><tr><td>11</td><td>Toy Story 3</td><td>Lee Unkrich</td><td>2010</td><td>103</td></tr><tr><td>12</td><td>Cars 2</td><td>John Lasseter</td><td>2011</td><td>120</td></tr><tr><td>13</td><td>Brave</td><td>Brenda Chapman</td><td>2012</td><td>102</td></tr><tr><td>14</td><td>Monsters University</td><td>Dan Scanlon</td><td>2013</td><td>110</td></tr></tbody></table></div><p>Table: Boxoffice(Read - Only)</p><div class="table-container"><table><thead><tr><th>Movie_id</th><th>Rating</th><th>Domestic_sales</th><th>International_sales</th></tr></thead><tbody><tr><td>5</td><td>8.2</td><td>380843261</td><td>555900000</td></tr><tr><td>14</td><td>7.4</td><td>268492764</td><td>475066843</td></tr><tr><td>8</td><td>8</td><td>206445654</td><td>417277164</td></tr><tr><td>12</td><td>6.4</td><td>191452396</td><td>368400000</td></tr><tr><td>3</td><td>7.9</td><td>245852179</td><td>239163000</td></tr><tr><td>6</td><td>8</td><td>261441092</td><td>370001000</td></tr><tr><td>9</td><td>8.5</td><td>223808164</td><td>297503696</td></tr><tr><td>11</td><td>8.4</td><td>415004880</td><td>648167031</td></tr><tr><td>1</td><td>8.3</td><td>191796233</td><td>170162503</td></tr><tr><td>7</td><td>7.2</td><td>244082982</td><td>217900167</td></tr><tr><td>10</td><td>8.3</td><td>293004164</td><td>438338580</td></tr><tr><td>4</td><td>8.1</td><td>289916256</td><td>272900000</td></tr><tr><td>2</td><td>7.2</td><td>162798565</td><td>200600000</td></tr><tr><td>13</td><td>7.2</td><td>237283207</td><td>301700000</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 输出变量，AS用来起别名<br>SELECT title, ((domestic_sales + international_sales) / length_minutes) AS sale_value FROM movies AS m<br><br># 内连接两个表，ON通过什么属性<br>INNER JOIN boxoffice AS b<br>ON m.id = b.movie_id<br><br># WHERE逻辑控制判断<br>WHERE director = &quot;John Lasseter&quot;<br><br># ORDER BY排序<br>ORDER BY sale_value DESC<br><br># LIMIT限制，OFFSET表示起始位置<br>LIMIT 3 <br></code></pre></td></tr></table></figure><h2 id="1-9-常见的统计函数"><a href="#1-9-常见的统计函数" class="headerlink" title="1.9 常见的统计函数"></a>1.9 常见的统计函数</h2><p>下面介绍几个常用统计函数:</p><div class="table-container"><table><thead><tr><th>Function</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td><strong>COUNT(<em>*</em></strong>)<strong>, </strong>COUNT(<strong><em>column</em></strong>)**</td><td style="text-align:left">计数！COUNT(*) 统计数据行数，COUNT(column) 统计column非NULL的行数。</td></tr><tr><td><strong>MIN(*</strong>column<strong>*)</strong></td><td style="text-align:left">找column最小的一行。</td></tr><tr><td><strong>MAX(*</strong>column<strong>*)</strong></td><td style="text-align:left">找column最大的一行。</td></tr><tr><td><strong>AVG(*</strong>column*)</td><td style="text-align:left">对column所有行取平均值。</td></tr><tr><td><strong>SUM(*</strong>column<strong>*)</strong></td><td style="text-align:left">对column所有行求和。</td></tr></tbody></table></div><p>分组统计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 用分组的方式统计，通过分组的方式对局部特征进行处理<br>SELECT AGG_FUNC(column_or_expression) AS aggregate_description, …<br>FROM mytable<br>WHERE constraint_expression<br>GROUP BY column;<br></code></pre></td></tr></table></figure><p>到目前为止，我们的Query查询已经有点复杂了，不过还好我们已经基本把查询语法介绍完了。在 <code>GROUP BY</code> 分组语法中，我们知道数据库是先对数据做<code>WHERE</code>，然后对结果做分组，如果我们要对分组完的数据再筛选出几条如何办？ （想一下按年份统计电影票房，要筛选出&gt;100万的年份？） </p><p>一个不常用的语法 <code>HAVING</code> 语法将用来解决这个问题，他可以对分组之后的数据再做SELECT筛选.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 用HAVING进行筛选，进行GROUP BY之后的二级分类<br>SELECT group_by_column, AGG_FUNC(column_expression) AS aggregate_result_alias, …<br>FROM mytable<br>WHERE condition<br>GROUP BY column<br>HAVING group_condition;<br></code></pre></td></tr></table></figure><p><strong>e.g【难题】按角色分组算出每个角色按有办公室和没办公室的统计人数(列出角色，数量，有无办公室,注意一个角色如果部分有办公室，部分没有需分开统计）</strong> </p><div class="table-container"><table><thead><tr><th>Role</th><th>Name</th><th>Building</th><th>Years_employed</th></tr></thead><tbody><tr><td>Engineer</td><td>Becky A.</td><td>1e</td><td>4</td></tr><tr><td>Engineer</td><td>Dan B.</td><td>1e</td><td>2</td></tr><tr><td>Engineer</td><td>Sharon F.</td><td>1e</td><td>6</td></tr><tr><td>Engineer</td><td>Dan M.</td><td>1e</td><td>4</td></tr><tr><td>Engineer</td><td>Malcom S.</td><td>1e</td><td>1</td></tr><tr><td>Artist</td><td>Tylar S.</td><td>2w</td><td>2</td></tr><tr><td>Artist</td><td>Sherman D.</td><td>2w</td><td>8</td></tr><tr><td>Artist</td><td>Jakob J.</td><td>2w</td><td>6</td></tr><tr><td>Artist</td><td>Lillia A.</td><td>2w</td><td>7</td></tr><tr><td>Artist</td><td>Brandon J.</td><td>2w</td><td>7</td></tr><tr><td>Manager</td><td>Scott K.</td><td>1e</td><td>9</td></tr><tr><td>Manager</td><td>Shirlee M.</td><td>1e</td><td>3</td></tr><tr><td>Manager</td><td>Daria O.</td><td>2w</td><td>6</td></tr><tr><td>Engineer</td><td>Yancy I.</td><td>null</td><td>0</td></tr><tr><td>Artist</td><td>Oliver P.</td><td>null</td><td>0</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT count(*) as count,Role,building is not null as have_building<br>FROM employees <br>group by Role,building is not null<br></code></pre></td></tr></table></figure><p>这里学到了GROUP BY可以进行二级分类。</p><h2 id="1-10-总结"><a href="#1-10-总结" class="headerlink" title="1.10 总结"></a>1.10 总结</h2><p>集合所有的查询相关的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 这才是完整的SELECT查询<br>SELECT DISTINCT column, AGG_FUNC(column_or_expression), …<br>FROM mytable<br>    JOIN another_table<br>      ON mytable.column = another_table.column<br>    WHERE constraint_expression<br>    GROUP BY column<br>    HAVING constraint_expression<br>    ORDER BY column ASC/DESC<br>    LIMIT count OFFSET COUNT;<br></code></pre></td></tr></table></figure><p>一个查询SQL的执行总是先从数据里按条件选出数据，然后对这些数据再次做一些整理处理，按要求返回成结果，让结果尽可能是简单直接的。因为一个查询SQL由很多部分组成，所以搞清楚这些部分的执行顺序还挺重要的，这有助于我们更深刻的理解SQL执行过程。</p><p><strong>‼️查询执行顺序</strong></p><h3 id="1-FROM-和-JOINs"><a href="#1-FROM-和-JOINs" class="headerlink" title="1. FROM 和 JOINs"></a>1. <code>FROM</code> 和 <code>JOIN</code>s</h3><p><code>FROM</code> 或 <code>JOIN</code>会第一个执行，确定一个整体的数据范围. 如果要JOIN不同表，可能会生成一个临时Table来用于 下面的过程。总之第一步可以简单理解为确定一个数据源表（含临时表)</p><h3 id="2-WHERE"><a href="#2-WHERE" class="headerlink" title="2. WHERE"></a>2. <code>WHERE</code></h3><p>我们确定了数据来源 <code>WHERE</code> 语句就将在这个数据源中按要求进行数据筛选，并丢弃不符合要求的数据行，所有的筛选col属性 只能来自<code>FROM</code>圈定的表. AS别名还不能在这个阶段使用，因为可能别名是一个还没执行的表达式</p><h3 id="3-GROUP-BY"><a href="#3-GROUP-BY" class="headerlink" title="3. GROUP BY"></a>3. <code>GROUP BY</code></h3><p>如果你用了 <code>GROUP BY</code> 分组，那<code>GROUP BY</code> 将对之前的数据进行分组，统计等，并将是结果集缩小为分组数.这意味着 其他的数据在分组后丢弃.</p><h3 id="4-HAVING"><a href="#4-HAVING" class="headerlink" title="4. HAVING"></a>4. <code>HAVING</code></h3><p>如果你用了 <code>GROUP BY</code> 分组, <code>HAVING</code> 会在分组完成后对结果集再次筛选。AS别名也不能在这个阶段使用.</p><h3 id="5-SELECT"><a href="#5-SELECT" class="headerlink" title="5. SELECT"></a>5. <code>SELECT</code></h3><p>确定结果之后，<code>SELECT</code>用来对结果col简单筛选或计算，决定输出什么数据.</p><h3 id="6-DISTINCT"><a href="#6-DISTINCT" class="headerlink" title="6. DISTINCT"></a>6. <code>DISTINCT</code></h3><p>如果数据行有重复<code>DISTINCT</code> 将负责排重.</p><h3 id="7-ORDER-BY"><a href="#7-ORDER-BY" class="headerlink" title="7. ORDER BY"></a>7. <code>ORDER BY</code></h3><p>在结果集确定的情况下，<code>ORDER BY</code> 对结果做排序。因为<code>SELECT</code>中的表达式已经执行完了。此时可以用AS别名.</p><h3 id="8-LIMIT-OFFSET"><a href="#8-LIMIT-OFFSET" class="headerlink" title="8. LIMIT / OFFSET"></a>8. <code>LIMIT</code> / <code>OFFSET</code></h3><p>最后 <code>LIMIT</code> 和 <code>OFFSET</code> 从排序的结果中截取部分数据.</p><p><strong>结论</strong></p><p>不是每一个SQL语句都要用到所有的句法，但灵活运用以上的句法组合和深刻理解SQL执行原理将能在SQL层面更好的解决数据问题，而不用把问题 都抛给程序逻辑.</p><p>Table：Movies(Read - Only)</p><div class="table-container"><table><thead><tr><th>Id</th><th>Title</th><th>Director</th><th>Year</th><th>Length_minutes</th></tr></thead><tbody><tr><td>1</td><td>Toy Story</td><td>John Lasseter</td><td>1995</td><td>81</td></tr><tr><td>2</td><td>A Bug’s Life</td><td>John Lasseter</td><td>1998</td><td>95</td></tr><tr><td>3</td><td>Toy Story 2</td><td>John Lasseter</td><td>1999</td><td>93</td></tr><tr><td>4</td><td>Monsters, Inc.</td><td>Pete Docter</td><td>2001</td><td>92</td></tr><tr><td>5</td><td>Finding Nemo</td><td>Finding Nemo</td><td>2003</td><td>107</td></tr><tr><td>6</td><td>The Incredibles</td><td>Brad Bird</td><td>2004</td><td>116</td></tr><tr><td>7</td><td>Cars</td><td>John Lasseter</td><td>2006</td><td>117</td></tr><tr><td>8</td><td>Ratatouille</td><td>Brad Bird</td><td>2007</td><td>115</td></tr><tr><td>9</td><td>WALL-E</td><td>Andrew Stanton</td><td>2008</td><td>104</td></tr><tr><td>10</td><td>Up</td><td>Pete Docter</td><td>2009</td><td>101</td></tr><tr><td>11</td><td>Toy Story 3</td><td>Lee Unkrich</td><td>2010</td><td>103</td></tr><tr><td>12</td><td>Cars 2</td><td>John Lasseter</td><td>2011</td><td>120</td></tr><tr><td>13</td><td>Brave</td><td>Brenda Chapman</td><td>2012</td><td>102</td></tr><tr><td>14</td><td>Monsters University</td><td>Dan Scanlon</td><td>2013</td><td>110</td></tr></tbody></table></div><p>Table：Boxoffice(Read - Only)</p><div class="table-container"><table><thead><tr><th>Movie_id</th><th>Rating</th><th>Domestic_sales</th><th>International_sales</th></tr></thead><tbody><tr><td>5</td><td>8.2</td><td>380843261</td><td>555900000</td></tr><tr><td>14</td><td>7.4</td><td>268492764</td><td>475066843</td></tr><tr><td>8</td><td>8</td><td>206445654</td><td>417277164</td></tr><tr><td>12</td><td>6.4</td><td>191452396</td><td>368400000</td></tr><tr><td>3</td><td>7.9</td><td>245852179</td><td>239163000</td></tr><tr><td>6</td><td>8</td><td>261441092</td><td>370001000</td></tr><tr><td>9</td><td>8.5</td><td>223808164</td><td>297503696</td></tr><tr><td>11</td><td>8.4</td><td>415004880</td><td>648167031</td></tr><tr><td>1</td><td>8.3</td><td>191796233</td><td>170162503</td></tr><tr><td>7</td><td>7.2</td><td>244082982</td><td>217900167</td></tr><tr><td>10</td><td>8.3</td><td>293004164</td><td>438338580</td></tr><tr><td>4</td><td>8.1</td><td>289916256</td><td>272900000</td></tr><tr><td>2</td><td>7.2</td><td>162798565</td><td>200600000</td></tr><tr><td>13</td><td>7.2</td><td>237283207</td><td>301700000</td></tr></tbody></table></div><p><strong>e.g【难题】按导演分组计算销售总额,求出平均销售额冠军（统计结果过滤掉只有单部电影的导演，列出导演名，总销量，电影数量，平均销量) </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(domestic_sales + international_sales) sum_sale, director,COUNT(*) count, AVG(domestic_sales + international_sales) ave_sale FROM movies m<br>INNER JOIN boxoffice b<br>ON m.id = b.movie_id<br>GROUP BY director<br>HAVING count != 1<br>ORDER BY ave_sale DESC<br>LIMIT 1<br></code></pre></td></tr></table></figure><p><strong>Q：</strong>为什么where里面不能count()而having里面可以</p><p><strong>A：</strong>因为聚合函数是做统计用的，所有的聚合方式使用都是，函数名(字段) 对这一个字段进行聚合。但在mysql内部运行机制中，where后面还没有结果，只有select后面才有结果集。所以聚合函数是不能放在where后面,却可以放在select后面。</p><p><strong>e.g【变态难】找出每部电影和单部电影销售冠军之间的销售差，列出电影名，销售额差额</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT title,<br>(SELECT (Domestic_sales + International_sales) FROM movies m<br>JOIN boxoffice b<br>ON m.id = b.movie_id <br>ORDER BY(Domestic_sales+<br>International_sales) DESC <br>LIMIT 1)<br>  - (Domestic_sales+International_sales) as sale_diff<br>FROM movies m<br>LEFT JOIN boxoffice b<br>ON m.id = b.movie_id <br>ORDER BY sale_diff DESC<br></code></pre></td></tr></table></figure><p>SELECT是可以嵌套的，SELECT是输出的表达式。</p><h1 id="2-SQL的DQL、DDL、DML、DCL使用"><a href="#2-SQL的DQL、DDL、DML、DCL使用" class="headerlink" title="2. SQL的DQL、DDL、DML、DCL使用"></a>2. SQL的DQL、DDL、DML、DCL使用</h1><h2 id="1-数据查询语言DQL"><a href="#1-数据查询语言DQL" class="headerlink" title="1. 数据查询语言DQL"></a><strong>1.</strong> 数据查询语言DQL</h2><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：<br>SELECT &lt;字段名表&gt;<br>FROM &lt;表或视图名&gt;<br>WHERE &lt;查询条件&gt;</p><h2 id="2-数据操纵语言DML"><a href="#2-数据操纵语言DML" class="headerlink" title="2. 数据操纵语言DML"></a>2. 数据操纵语言DML</h2><p><strong>数据库意义： </strong>数据存储，数据管理</p><p>DML：数据操作语言</p><p>添加( INSERT )</p><p>修改( UPDATE )</p><p>删除( DELETE )</p><h2 id="3-数据定义语言DDL"><a href="#3-数据定义语言DDL" class="headerlink" title="3. 数据定义语言DDL"></a>3. 数据定义语言DDL</h2><p>数据定义语言DDL用来创建数据库中的各种对象——-表、视图、<br>索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER<br>          |      |      |      |      |<br>         表   视图  索引  同义词  簇</p><p>DDL操作是隐性提交的！不能rollback </p><h2 id="4-数据控制语言DCL"><a href="#4-数据控制语言DCL" class="headerlink" title="4. 数据控制语言DCL"></a>4. 数据控制语言DCL</h2><p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制<br>数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p><p>1) GRANT：授权。</p><p>2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。<br>   回滚—-ROLLBACK<br>   回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>   SQL&gt;ROLLBACK;</p><p>3) COMMIT [WORK]：提交。</p><p>  在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。</p><h1 id="3-其他数据库对象"><a href="#3-其他数据库对象" class="headerlink" title="3. 其他数据库对象"></a>3. 其他数据库对象</h1>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data base</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Systems: A Programmer‘s Perspective</title>
    <link href="/2022/04/15/Computer-Systems-A-Programmer-s-Perspective/"/>
    <url>/2022/04/15/Computer-Systems-A-Programmer-s-Perspective/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-A-Tour-of-Computer-System"><a href="#Chapter-1-A-Tour-of-Computer-System" class="headerlink" title="Chapter 1: A Tour of Computer System"></a>Chapter 1: A Tour of Computer System</h1><p><strong>由一个helloworld的整个生命周期来演示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/The-Compilation-System.png" alt="The-Compilation-System"></p><p><strong>为什么我们要理解编译系统？</strong></p><p>1⃣️ Optimizing program performance(优化程序性能)</p><p>e.g. 一个switch语句是不是要比一连串的if-else要高效的多？</p><p>2⃣️ Understanding link-time errors(理解链接时出现的错误)</p><p>e.g. 静态变量和全局变量的区别是什么？</p><p>3⃣️ Avoiding security holes(避免安全漏洞)</p><p>e.g. 缓冲区溢出错误产生？</p><p><strong>计算机硬件组成系统以及完成hello world程序的硬件处理过程</strong></p><p>PC(Program Count)：程序计数器，大小为一个字的存储区域。32位系统中，1 word = 4 byte，64位系统中，1 word = 8byte。</p><p>Register file：寄存器。</p><p>ALU：处理器。</p><p>Bus interface：总线。</p><p>Disk：磁盘。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP1-INPUT.png" alt="STEP1-INPUT"></p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP2-DMA.png" alt="STEP2-DMA"></p><p>DMA技术：数据可以不经过处理器，直接从磁盘抵达内存。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP3-Display.png" alt="STEP3-Display"></p><p>tips：1⃣️ 大容量的设备会比小容量设备运行速度更慢。2⃣️ 运行速度更快的设备比低速设备更贵。</p><p>e.g. 内存虽小但价格和外存的价格差不多。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/Memory%20Hierarchy.png" alt="Memory Hierarchy"></p><p>L1、L2、L3为我们常说的三级缓存。</p><p><strong>操作系统在应用程序和硬件系统之间的角色</strong></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/The%20Operating%20System%20Manages%20Hardware.png" alt="The Operating System Manages Hardware"></h4><p>1⃣️ 防止硬件被失控的应用程序滥用</p><p>2⃣️ 操作系统提供统一的机制来控制这些复杂的底层硬件</p><p>—————————————————————————————————————</p><h2 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位 + 上下文"></a>1.1 信息就是位 + 上下文</h2><p>1⃣️ <strong>何为上下文？</strong></p><p>上下文，也就是执行任务所需要的相关信息。这个任务可以是一段代码，一个线程，一个进程，一个函数。当这个“任务”，相关信息需要保存下来，就可以使用Context来记录了。</p><h2 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h2><p>1⃣️<strong>GNU是什么？</strong></p><p>GNU是项目开发工具它包含了：EMACS编译器、GCC编译器、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其它一些部件。目前随着发展已经支持许多不同的语言了。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2022/04/12/%E5%89%91%E6%8C%87offer/"/>
    <url>/2022/04/12/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h1 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h1><h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3. 数组中重复的数字"></a>3. 数组中重复的数字</h2><h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4. 二维数组中的查找"></a>4. 二维数组中的查找</h2><p><strong>描述</strong></p><p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p><p>[[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]] </p><p>给定 target = 7，返回 true。 </p><p>给定 target = 3，返回 false。</p><p><strong>思路</strong></p><p>(1)对于数组 arr [row] [col] 的row和col，我们是按先行后列来看的。用二维数组举例，arr.length 表示的是row的长度，arr[0].length 表示的是列的长度。</p><p>(2)这种问题的通常思路一般是双循环，时间复杂度自然到达了o(n^2)，所以最直接的优化方式就是降低时间复杂度，把二维数组的处理展平变成一围的地图然后通过排序的规律来找到突破口。</p><p><strong>解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> [][] array)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> search;<br>      <br><span class="hljs-comment">//不越界的情况下search</span><br>    <span class="hljs-keyword">while</span>(row &lt;= (array.length - <span class="hljs-number">1</span>) &amp;&amp; col &gt;= <span class="hljs-number">0</span>)&#123;<br>        search = array[row][col]; <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">if</span>(search == target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(search &gt; target)&#123;<br>            col--;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(search &lt; target)&#123;<br>            row++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5. 替换空格"></a>5. 替换空格</h2><p><strong>描述</strong></p><p>请实现一个函数，将一个字符串s中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p><strong>思路</strong></p><p>最先学会的是分清楚String, StringBuffer, StringBuilder。</p><p>操作<strong>少量的数据</strong>:适用String</p><p><strong>单线程</strong>操作字符串缓冲区下操作<strong>大量数据</strong>:适用StringBuilder(线程不安全)</p><p><strong>多线程</strong>操作字符串缓冲区下操作<strong>大量数据</strong>:适用StringBuffer(线程安全)</p><p>String长度不可变，其余两个长度可变，默认长度为16</p><p>实际上是实现了java中String.replace(String1, String2)的功能</p><p><strong>解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span> <span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//如果本来就是空字符串那我们返回就好。</span><br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">null</span> || s.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-comment">//使用StringBuilder在遍历过程中构建新的字符串。</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">blank</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i)!=blank)<br>                builder.append(s.charAt(i));<br>            <span class="hljs-keyword">else</span><br>                builder.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h2><p><strong>描述</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p><p><strong>思路</strong></p><p>简单来说，就是不断地收缩矩阵的边界，确定边界，锁一动一<br>定义四个变量代表范围，up、down、left、right</p><ol><li>向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错 </li><li>向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错 </li><li>向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错 </li><li>向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错</li></ol><p><strong>解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">printMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span> [][] matrix)</span> &#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> matrix.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">// 最上面一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> left; col &lt;= right; col++)&#123;<br>                list.add(matrix[up][col]);<br>            &#125;<br>            <span class="hljs-comment">// 向下逼近</span><br>            up++;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(up &gt; down)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最右边一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> up; row &lt;= down; row++)&#123;<br>                list.add(matrix[row][right]);<br>            &#125;<br>            <span class="hljs-comment">// 向左逼近</span><br>            right--;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最下面一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> right; col &gt;= left; col--)&#123;<br>                list.add(matrix[down][col]);<br>            &#125;<br>            <span class="hljs-comment">// 向上逼近</span><br>            down--;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(up &gt; down)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最左边一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> down; row &gt;= up; row--)&#123;<br>                list.add(matrix[row][left]);<br>            &#125;<br>            <span class="hljs-comment">// 向右逼近</span><br>            left++;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="50-第一个只出现一次的字符位置"><a href="#50-第一个只出现一次的字符位置" class="headerlink" title="50. 第一个只出现一次的字符位置"></a>50. 第一个只出现一次的字符位置</h2><p><strong>描述</strong></p><p>在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）（从0开始计数）</p><p><strong>思路</strong></p><p>1、用indexOf和lastIndexOf来实现，若找到直接返回下标，若没找到返回-1，indexOf为最先出现的位置，lastIndexOf为最后一次出现的位置。</p><p>2、用Map，Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</p><ul><li>需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li><li>Map中常用的集合为HashMap集合、LinkedHashMap集合。</li></ul><p><strong>解法1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">FirstNotRepeatingChar</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;                    <span class="hljs-keyword">if</span>(str.indexOf(str.charAt(i)) != str.lastIndexOf(str.charAt(i)))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">FirstNotRepeatingChar</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">//ArrayList list=new ArrayList;</span><br>        java.util.HashMap&lt;Character,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.HashMap&lt;&gt;();<br>        <span class="hljs-type">char</span> [] arr=str.toCharArray();<br>        <span class="hljs-comment">//把数组中的值添加到map集合中，并且记录出现的次数</span><br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            <span class="hljs-comment">//containsKey返回布尔类型</span><br>             <span class="hljs-keyword">if</span>(!map.containsKey(arr[i]))&#123;<br>                 map.put(arr[i],<span class="hljs-number">1</span>);<br>             &#125;<span class="hljs-keyword">else</span>&#123;<br>                 <span class="hljs-type">int</span> count=map.get(arr[i]);<br>                <span class="hljs-comment">//replace替换的事value而不是key，key是唯一的</span><br>                 map.replace(arr[i],count+<span class="hljs-number">1</span>);<br>             &#125;<br>         &#125;<br>        <span class="hljs-comment">//根据map集合中的key，寻找value，返回第一个出现第一次的值，返回i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(arr[i])==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;      <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
