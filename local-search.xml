<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Gee系列实现</title>
    <link href="/2022/06/29/Gee%E7%B3%BB%E5%88%97%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/06/29/Gee%E7%B3%BB%E5%88%97%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Web框架-Gee"><a href="#Web框架-Gee" class="headerlink" title="Web框架 - Gee"></a>Web框架 - Gee</h1><h2 id="0-1-基本的net包"><a href="#0-1-基本的net包" class="headerlink" title="0.1 基本的net包"></a>0.1 基本的net包</h2><p>建立tcp连接的步骤(server端)</p><ol><li>设置tcp地址</li><li>设立监听对象</li><li>建立连接</li></ol><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs go">tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>listener, _ := net.ListenTCP(<span class="hljs-string">&quot;tcp&quot;</span>, tcpAddr)<br>conn, err := listener.AcceptTCP()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 创建好一个tcp的服务端</span><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优化，循环链接，要处理很多tcp请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>    listener, _ := net.ListenTCP(<span class="hljs-string">&quot;tcp&quot;</span>, tcpAddr)<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.AcceptTCP()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>          fmt.Println(err)<br>          <span class="hljs-keyword">return</span><br>          <span class="hljs-comment">// handle error</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> handleConnection(conn)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn *net.TCPConn)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>n, err := conn.Read(buf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>        <span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(conn.RemoteAddr().String() + <span class="hljs-type">string</span>(buf[<span class="hljs-number">0</span> : n])) <span class="hljs-comment">// 获取连接进来的地址 + 字符串</span><br>str := <span class="hljs-string">&quot;received success! message: &quot;</span> + <span class="hljs-type">string</span>(buf[<span class="hljs-number">0</span> : n])<br>conn.Write([]<span class="hljs-type">byte</span>(str))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(dial端)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>    conn, _ := net.DialTCP(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-literal">nil</span>, tcpAddr)<br>    reader := bufio.NewReader(os.Stdin)<br>    <span class="hljs-keyword">for</span> &#123;<br>        bytes, _, _ := reader.ReadLine()<br>        conn.Write(bytes)<br>        rb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>        rn, _ := conn.Read(rb)<br>        fmt.Println(<span class="hljs-type">string</span>(rb[<span class="hljs-number">0</span> : rn])) <span class="hljs-comment">// string处理要不就是ASCII码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0-2-Http包"><a href="#0-2-Http包" class="headerlink" title="0.2 Http包"></a>0.2 Http包</h2><p><strong>Get请求的实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;<br>res.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;我收到了给你返回&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/test&quot;</span>, handler)<br>    server := http.Server&#123;<br>      Addr: <span class="hljs-string">&quot;:8080&quot;</span>,<br>      Handler: <span class="hljs-literal">nil</span>,<br>    &#125;<br>    server.ListenAndServe()<br>    <span class="hljs-comment">// http.ListenAndServe(&quot;:8080&quot;, nil)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么不用判断req的方法就可以实现呢get呢？因为默认是get请求？</p><p>其中为什么前者response不是指针，而后者request是指针呢？因为request是外部传来的（这个有待以后check源码）</p><p><strong>server</strong> 服务，包含地址、端口、处理器等等</p><p><strong>conn</strong> 链接，用户请求来的</p><p><strong>response</strong> 返回信息</p><p><strong>request</strong> 用户的请求信息</p><p><strong>Handle</strong> 对于接收的信息进行处理并且返回的一个处理器</p><p>Step：</p><p>1、通过 Header() 来设置头map</p><p>2、通过 WriteHeader(code) 来设置状态码</p><p>3、通过 Write 写入这个io.writer 来控制返回值</p><p>4、通过 req.Body 以请求过来的body内容</p><p>5、剩下的就是组装，e.g. 一个内置的方法，把路径当静态显示</p><p>http.Handle(“/“, http.FileServer(http.dir(“/“)))</p><p>res是我们要返回的值，req是前端传给我们的值。</p><pre><code class=" mermaid">graph LR;http请求 --&gt; DefaultServeMux;DefaultServeMux --&gt; Handler1;DefaultServeMux --&gt; Handler2;DefaultServeMux --&gt; ......;DefaultServeMux --&gt; Handler3;</code></pre><p>有自定义的handler的话就是这个样子。</p><pre><code class=" mermaid">graph LR;http请求 --&gt; myHandler;</code></pre><p>Multiplexer（多路复用器）</p><p>他也是一个handler</p><p><strong>url通用格式</strong></p><p>Scheme : // [ userinfo@ ] host / path [ ?query ] [ #fragment ]</p><p>如果从浏览器发出的请求，那么你无法提取处 Fragment 字段的值（浏览器在发送请求时会把 fragment 部分去掉）</p><h3 id="FORM-表单"><a href="#FORM-表单" class="headerlink" title="FORM 表单"></a>FORM 表单</h3><h4 id="表单的-enctype-属性"><a href="#表单的-enctype-属性" class="headerlink" title="表单的 enctype 属性"></a>表单的 enctype 属性</h4><ul><li>如果 enctype 是 application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。例如：</li></ul><p>​            frist_name=peter&amp;last_name=pan</p><ul><li><p>如果 enctype 是 multipart/form-data，那么</p><p>​     每一个 name-value 对都会被转换为一个MIME消息部分</p><p>​     每一个部分都有自己的 Content Type 和 Content Dispostion</p></li></ul><p><strong>如何选择呢？</strong></p><p>简单文本：表单URL编码</p><p>大量数据，例如上传文件：multipart-MIME</p><p>​        甚至可以把二进制数据通过base64编码，来当作文本进行发送</p><h4 id="FORM-字段"><a href="#FORM-字段" class="headerlink" title="FORM 字段"></a>FORM 字段</h4><p>提取Request上的字段有三个，Form，PostForm，MultipartForm</p><p>通常做法调用 ParseForm 或 ParseMultipartForm 来解析 Request，然后相应的访问 Form、PostForm 或 MultipartForm 字段</p><h4 id="PostForm-字段"><a href="#PostForm-字段" class="headerlink" title="PostForm 字段"></a>PostForm 字段</h4><p>由于表单和 URL 里有同样的 Key，那么他们都会放在一个 slice 里面，（表单在前面，url的在后面）。如果只想要表单的 key - value 对，不要 URL 的，可以使用PostForm 字段</p><p>PostForm 和 Form 只支持 application/x-www-form-urlencoded</p><p>MultipartForm 字段支持 multipart key-value 对，返回类型是个 struct 不是 map。1⃣️ key—-string，value—-[]string 2⃣️ 空的（key—-string，value—-文件）所以这个是用来传输文件的</p><p>FormValue 方法会返回 Form 字段中指定 key 对应的第一个 value，无需调用ParseForm（无需解析）</p><p>PostFromValue 相同，但如果 enctype 设为 multipart/form-data</p><h4 id="FromFile方法"><a href="#FromFile方法" class="headerlink" title="FromFile方法"></a>FromFile方法</h4><p>上传文件还有一个简便方法：FormFile（例子）</p><p>​        无需调用 ParseMultipartForm 方法</p><p>​        返回指定 key 对应的第一个 value</p><p>​        同时返回 File 和FileHeader，以及错误信息</p><p>​        如果只上传一个文件，那么这种方式会快一些        </p><h3 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a>ResponseWriter</h3><p>从服务器向客户端返回响应需要使用 ResponseWriter</p><p>ResponseWriter 是一个接口，handler 用它来返回响应</p><p>真正支撑 ResponseWriter 的幕后 struct 是非导出的 http.response</p><p><strong>Q：为什么 Handler 的 ServeHTTP(w ResponseWriter, r *Request)，只有一个是指针类型？而 w 是按值传递的吗？</strong></p><p><strong>A：</strong>ResponseWriter是一个接口它代表了一个指针，w 和 r 都是按照引用传递的</p><h4 id="Header-方法"><a href="#Header-方法" class="headerlink" title="Header 方法"></a>Header 方法</h4><p>Header 方法返回 headers 的 map，可以进行修改</p><p>修改后的 headers 将会体现在返回给客户端的 HTTP 响应里</p><h4 id="Write-方法"><a href="#Write-方法" class="headerlink" title="Write 方法"></a>Write 方法</h4><p>写入body</p><h4 id="WriteHeader-方法"><a href="#WriteHeader-方法" class="headerlink" title="WriteHeader 方法"></a>WriteHeader 方法</h4><p>WriteHeader 方法接受一个整数类型（HTTP 状态码）作为参数，并把它作为 HTTP 响应的状态码返回</p><p>如果该方法没有显式调用，那么在第一次调用 Write 方法前，会隐式的调用 WriteHeader（http.StatusOK）</p><p>​        所以 WriteHeader 主要用来发送错误类的 HTTP 状态码</p><p>调用完 WriteHeader 方法之后，仍然可以写入到 ResponseWriter，但无法再修改 header 了</p><h4 id="内置的-Response"><a href="#内置的-Response" class="headerlink" title="内置的 Response"></a>内置的 Response</h4><p>NotFound 函数，404 + 额外的信息</p><p>ServeFile 函数，从文件系统提供文件，返回给请求者</p><p>ServeContent 函数，可以请求range内的内容</p><p>Redirect 函数，重定向</p><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><pre><code class=" mermaid">graph LR;模版 --&gt; 模版引擎;数据 --&gt; 模版引擎;模版引擎 --&gt; HTML</code></pre><p>两种理想的模版引擎：1、无逻辑模版引擎 2、逻辑嵌入模版引擎</p><p>go使用的是text/template，HTML相关部分用的是html/template，是混合体</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="controller的角色"><a href="#controller的角色" class="headerlink" title="controller的角色"></a>controller的角色</h4><p>main()：设置类工作</p><p>controller：</p><p>​        静态资源</p><p>​        把不同的请求送到不同的controller进行处理</p><pre><code class=" mermaid">graph LR;前置controller --&gt; home_handler;前置controller --&gt; page1_handler;前置controller --&gt; page2_handler;</code></pre><h4 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h4><p>静态路由：一个路径对应一个页面</p><p>/home</p><p>/about</p><p>带参数的路由：根据路由参数，创建出一族不同的页面</p><p>/companies/123</p><p>/companies/Microsoft</p><h4 id="第三方路由器"><a href="#第三方路由器" class="headerlink" title="第三方路由器"></a>第三方路由器</h4><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><p>Marshal和Unmarshal</p><p>Marshal（编码）：把 go struct 转化为 json 格式</p><p>​        MarshalIndent，（内容，换行，缩进）</p><p>Unmarshal（解码）：把 json 转化为 go struct</p><p><strong>针对 string 或 bytes：</strong></p><p>​        Marshal =&gt; String</p><p>​        Unmarshal &lt;= String</p><p><strong>针对stream：</strong></p><p>​        Encode =&gt; Stream，把数据写入到 io.Writer</p><p>​        Decode &lt;= Stream，从 io.Reader 读取数据</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>创建中间件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyMiddleware <span class="hljs-keyword">struct</span> &#123;<br>  Next http.Handler<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyMiddleware)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>  <span class="hljs-comment">// 在 next handler之前做一些事情</span><br>  m.Next.ServeHTTP(w,r)<br>  <span class="hljs-comment">// 在 next handler之后做一些事情（处理一些响应里面的内容）</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中间件的用途"><a href="#中间件的用途" class="headerlink" title="中间件的用途"></a>中间件的用途</h4><ul><li><p>Logging 日志</p></li><li><p>安全</p></li><li><p>请求超时</p></li><li><p>响应压缩</p></li><li><p>拦截器</p></li></ul><h3 id="使用请求上下文"><a href="#使用请求上下文" class="headerlink" title="使用请求上下文"></a>使用请求上下文</h3><h4 id="Request-Context"><a href="#Request-Context" class="headerlink" title="Request Context"></a>Request Context</h4><p>func(*Request) Context() context.Context</p><p>​        返回当前请求的上下文</p><p>func(*Request) WithContext(ctx context.Context) context.Context</p><p>​        基于 Context 进行 ”修改“，（实际上）创建一个新的 Context</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br><br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br>    Err() <span class="hljs-type">error</span><br><br>    Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些方法都是用于读的，要更新的话得创建新的context</p><h4 id="Context-API-可以返回新-Context"><a href="#Context-API-可以返回新-Context" class="headerlink" title="Context API - 可以返回新 Context"></a>Context API - 可以返回新 Context</h4><p>WithCancel()，它有一个 CancelFunc</p><p>WithDeadline()，带有一个时间戳（time.Time）</p><p>WithTimeout()，带有一个具体的时间段（time.Duration)</p><p>WithValue()，在里面添加一些值</p><p>PS：new创建结构体返回的是一个对应类型的指针，而普通结构体的创建需要加&amp;才能是指针要不就是个普通的结构体无人指向它</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>TLS —— 传输层安全</p><h4 id="HTTP-Listener"><a href="#HTTP-Listener" class="headerlink" title="HTTP Listener"></a>HTTP Listener</h4><p>http.ListenAndServe 函数</p><p>http.ListenAndServeTLS 函数</p><p>用 https 会让http协议从1.1升级到2</p><p>他建立长连接，所以分成各种frame，可以数据类型来进行优化从而提高处理效率。</p><p>Server Push可以提前预加载好要加载的文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> pusher, ok := w.(http.Pusher); ok &#123;<br>    pusher.Push(<span class="hljs-string">&quot;/css/app.css&quot;</span>, &amp;http.PushOptions&#123;<br>      Header: http.Header&#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;text/css&quot;</span>&#125;&#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试model层</p><p>user<strong>_test</strong>.go</p><ul><li><p>测试代码所在文件的名称以 _test 结尾</p></li><li><p>对于生产编译，不会包含以 _test 结尾的文件</p></li><li><p>对于测试编译，会包含以 _test 结尾的文件</p></li></ul><p>func <strong>Test</strong>UpdatesModifiedTime( <strong>t *testing.T</strong> )</p><ul><li>测试函数名应以 Test 开头（需要导出）</li><li>函数名需要表达出被验证的特征</li><li>测试函数的参数类型是 *testing.T，它会提供测试相关的一些工具</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>Import _ “net/http/pprof”</p><ul><li>设置一些监听的 URL，它们会提供各类诊断信息</li></ul><p>go tool pprof <a href="http://localhost:8080/debug/pprof/heap">http://localhost:8080/debug/pprof/heap</a> // 内存</p><ul><li>从应用获取内存dump：应用在使用哪些内存，他们会去哪</li></ul><p>go tool pprof <a href="http://localhost:8080/debug/pprof/profile">http://localhost:8080/debug/pprof/profile</a> // CPU</p><ul><li>CPU的快照，可以看到谁在用 CPU</li></ul><p>go tool pprof <a href="http://localhost:8080/debug/pprof/block">http://localhost:8080/debug/pprof/block</a> // goroutine</p><ul><li>看到阻塞的 goroutine</li></ul><p>go tool pprof <a href="http://localhost:8080/debug/pprof/trace?second=5">http://localhost:8080/debug/pprof/trace?second=5</a> // trace</p><ul><li>监控这段时间内，什么在执行，什么在调用什么</li></ul><p><a href="http://localhost:8080/debug/pprof">http://localhost:8080/debug/pprof</a> // 网址</p><h2 id="Day-1-HTTP基础"><a href="#Day-1-HTTP基础" class="headerlink" title="Day 1 HTTP基础"></a>Day 1 HTTP基础</h2><p>在实现<code>Engine</code>之前，我们调用 <em>http.HandleFunc</em> 实现了路由和Handler的映射，也就是只能针对具体的路由写处理逻辑。比如<code>/hello</code>。但是在实现<code>Engine</code>之后，我们拦截了所有的HTTP请求，拥有了统一的控制入口。在这里我们可以自由定义路由映射的规则，也可以统一添加一些处理逻辑，例如日志、异常处理等</p><p><code>gee.go</code>内容</p><ul><li>首先定义了类型<code>HandlerFunc</code>，这是提供给框架用户的，用来定义路由映射的处理方法。我们在<code>Engine</code>中，添加了一张路由映射表<code>router</code>，key 由请求方法和静态路由地址构成，例如<code>GET-/</code>、<code>GET-/hello</code>、<code>POST-/hello</code>，这样针对相同的路由，如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法。</li><li>当用户调用<code>(*Engine).GET()</code>方法时，会将路由和处理方法注册到映射表 <em>router</em>中，<code>(*Engine).Run()</code>方法，是 <em>ListenAndServe</em> 的包装。</li><li><code>Engine</code>实现的 <em>ServeHTTP</em> 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 <em>404 NOT FOUND</em> 。</li></ul><p>第二个参数类型是接口类型 <code>http.Handler</code>，<code>Handler</code> 的定义博文中已经贴了，是从 <code>http</code> 的源码中找到的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>    ServeHTTP(w ResponseWriter, r *Request)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(address <span class="hljs-type">string</span>, h Handler)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><p>在 Go 语言中，实现了接口方法的 struct 都可以强制转换为接口类型。你可以这么写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">handler := (http.Handler)(engine) <span class="hljs-comment">// 手动转换为借口类型</span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:9999&quot;</span>, handler))<br></code></pre></td></tr></table></figure><p>然后，<code>ListenAndServe</code> 方法里面会去调用 <code>handler.ServeHTTP()</code> 方法，你感兴趣，可以在 http 的源码中找到调用的地方。但是这么写是多余的，传参时，会自动进行参数转换的。所以直接传入engine 即可。</p><p>在没有 engine 的情况下我们默认的是一个 DefaultServeMux 他负责识别所有的 handler，但他不能给 handler 分类，所以我们要引入 engine。</p><p><a href="https://blog.csdn.net/liuqun0319/article/details/106136338">https://blog.csdn.net/liuqun0319/article/details/106136338</a> 详解 type func() 用法分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>one(<span class="hljs-number">2</span>, callback)<br>&#125;<br><br><span class="hljs-comment">//需要传递函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">callback</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;i am callBack&quot;</span>)<br>fmt.Println(i)<br>&#125;<br><br><span class="hljs-comment">//main 中调用的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">one</span><span class="hljs-params">(i <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span>) &#123;<br>two(i,fun(f))<br>&#125;<br><br><span class="hljs-comment">//one() 中调用的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">two</span><span class="hljs-params">(i <span class="hljs-type">int</span>, c Call)</span></span> &#123;<br>c.call(i)<br>&#125;<br><br><span class="hljs-comment">//定义的type函数</span><br><span class="hljs-keyword">type</span> fun <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><br><span class="hljs-comment">//fun实现的Call接口的call()函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f fun)</span></span> call(i <span class="hljs-type">int</span>) &#123;<br>f(i)<br>&#125;<br><br><span class="hljs-comment">//call接口</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">interface</span> &#123;<br>call(<span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里解释清楚了上述的调用关系。首先 one() 参数中的函数调用 two() 参数中的接口，并且通过该接口为这个函数赋值，但最终真正运行的还是 one() 中的函数 callback，只不过 callback 代表着一个 fun 函数实现了一个接口，接口的功能是用来给 fun 函数赋值。如下转换</p><p><strong>流程图：</strong></p><pre><code class=" mermaid">graph LR;http请求 --&gt; engine;engine --&gt; GET请求;engine --&gt; POST请求;</code></pre><p>其中 engine 是用来鉴别请求的（有两部分），它里面有一个路由map，用来存放我们设定好的路由。第二部分就是一个ServeHTTP方法（这个是在 GET 和 POST 方法中转换的，因为go中结构体放入函数中的参数接口可以自动转换为别的类型）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 所有的handler都要有SeverHTTP这样一个函数，还要有ResponseWriter, *Request这两个参数）</span><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>   ServeHTTP(ResponseWriter, *Request)<br>&#125;<br></code></pre></td></tr></table></figure><p>engine 中的 ServeHTTP 目的是为了实现转换成 handler 的 engine 该有的接口。第一步通过 listenAndServer 将 engine 变成 handler 接口。因为变成了handler接口（如上），所以第二步 engine 也要实现 ServeHTTP 函数。第三步里面实现的内容就是 1.查找是否有对应的路由注册 2. 若查找到就直接为这个 handlerFunc 赋入参 3. 没找到就404</p><p>其中为什么可以直接写成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> handler, ok := e.Router[key]; ok &#123;<br>handler(w, r) <span class="hljs-comment">// 调用存储在 map 中的函数，执行并赋值。</span><br></code></pre></td></tr></table></figure><p>handler 本身就是个 func 类型，所以这一步就是赋值并运行。</p><h2 id="Day-2-上下文"><a href="#Day-2-上下文" class="headerlink" title="Day 2 上下文"></a>Day 2 上下文</h2><p><strong>设计Context必要性</strong></p><ol><li>对Web服务来说，无非是根据请求<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写大量重复，繁杂的代码，而且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。</li></ol><p>用返回 JSON 数据作比较，感受下封装前后的差距。</p><p>封装前</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">obj = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;geektutu&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1234&quot;</span>,<br>&#125;<br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>w.WriteHeader(http.StatusOK)<br>encoder := json.NewEncoder(w)<br><span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>    http.Error(w, err.Error(), <span class="hljs-number">500</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>VS 封装后：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">c.JSON(http.StatusOK, gee.H&#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: c.PostForm(<span class="hljs-string">&quot;username&quot;</span>),<br>    <span class="hljs-string">&quot;password&quot;</span>: c.PostForm(<span class="hljs-string">&quot;password&quot;</span>),<br>&#125;)<br></code></pre></td></tr></table></figure><p>流程图</p><pre><code class=" mermaid">graph LR;http请求 --&gt; engine;engine --&gt; router-get\post;router-get\post --&gt; PostForm;router-get\post --&gt; Query;router-get\post --&gt; Status;router-get\post --&gt; SetHeader;router-get\post --&gt; String;router-get\post --&gt; JSON;router-get\post --&gt; Data;router-get\post --&gt; HTML;</code></pre><p>最重要的还是通过实现了 ServeHTTP 接口，接管了所有的 HTTP 请求。</p><p>后面集成了常用的方法，比如JSON，HTML等等，为的就是前文提到的，这样再处理JSON请求的时候不用重复的写一遍怎么将数据转成JSON，统一转换成JSON然后响应JSON请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// origin objects</span><br>Writer http.ResponseWriter<br>Req    *http.Request<br><span class="hljs-comment">// request info</span><br>Path   <span class="hljs-type">string</span><br>Method <span class="hljs-type">string</span><br><span class="hljs-comment">// response info</span><br>StatusCode <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>本质上没有变就是在 w 和 r 的上面又封装了一层 context，这个 context 包含了一些属性比如请求中的路径和方法，响应的状态码。</p><p>把状态码的设置，响应头的内容的设置封装在 context 的方法中，Context 就像一次会话的百宝箱，可以找到任何东西。</p><ul><li>给<code>map[string]interface&#123;&#125;</code>起了一个别名<code>gee.H</code>，构建JSON数据时，显得更简洁。</li><li><code>Context</code>目前只包含了<code>http.ResponseWriter</code>和<code>*http.Request</code>，另外提供了对 Method 和 Path 这两个常用属性的直接访问。</li><li>提供了访问Query和PostForm参数的方法。</li><li>提供了快速构造String/Data/JSON/HTML响应的方法。</li></ul><p>二、区别：</p><p>1、json.NewDecoder是从一个<code>流</code>里面直接进行解码，代码精干；<br>2、json.Unmarshal是从已存在与内存中的json进行解码；<br>3、相对于解码，json.NewEncoder进行大JSON的编码比json.marshal性能高，因为内部使用pool。</p><p>三、场景应用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">encoder := json.NewEncoder(c.Writer)<br><span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>1、json.NewDecoder用于http连接与socket连接的读取与写入，或者文件读取；<br>2、json.Unmarshal用于直接是byte的输入。</p><h2 id="Day-3-前缀树路由"><a href="#Day-3-前缀树路由" class="headerlink" title="Day 3 前缀树路由"></a>Day 3 前缀树路由</h2><p>所有的路由地址其实是虚拟的地址，就是map存储，相当于一个标识。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">parts := strings.Split(url, <span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样之后 parts[0] = “”，是一个nil</p><p>我们对于路由的修改变成了，添加路由和查找路由，查找路由比较复杂一点，因为要考虑到通配符的问题。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h3><p>addRouter -&gt; getRouter -&gt; handle 在看一遍代码 走一遍流程就明了多了, 说白了就是 用前缀树结构存 前缀树结构取, 用GET /a/asd/c || GET a/s/c 匹配到路由(GET-/a/:param/c)对应的HandlerFunc 并把asd || s 存在context的Params里。</p><h3 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a><strong>BUG</strong></h3><p><strong>Q：</strong></p><p><strong>第一个 bug</strong></p><p>在 <code>trie.go</code> 里的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> insert(pattern <span class="hljs-type">string</span>, parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height &#123;<br>n.pattern = pattern<br><span class="hljs-keyword">return</span><br>&#125;<br>part := parts[height]<br>child := n.matchChild(part)<br><span class="hljs-keyword">if</span> child == <span class="hljs-literal">nil</span> &#123;<br>child = &amp;node&#123;part: part, isWild: part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> || part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span>&#125;<br>n.children = <span class="hljs-built_in">append</span>(n.children, child)<br>&#125;<br>child.insert(pattern, parts, height+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果第一次插入的<code>pattern</code>为<code>/:age</code>，<code>method</code> 为 <code>GET</code>，<code>handlefunc</code> 为 <code>handleAge()</code></p><p>那么会生成一个这样的 <code>node</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;:age&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br></code></pre></td></tr></table></figure><p>第二次插入的 <code>pattern</code> 为 <code>/18</code> ,<code>method</code> 与第一次相同，仍然为 <code>GET</code>，<code>handlefunc</code>为 <code>handle18()</code>，此时并不会修改之前的 <code>node</code>，而是修改了之前 <code>nodeAge</code> 的 <code>pattern</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;18&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br>handlers[<span class="hljs-string">&quot;GET-18&quot;</span>] =  handle18<br></code></pre></td></tr></table></figure><p>接下来看看<code>handle()</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;<br>n, params := r.getRoute(c.Method, c.Path)<br><span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>c.Params = params<br>key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + n.pattern<br>r.handlers[key](c)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.String(http.StatusNotFound, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当有一个 <code>/19</code> 的请求到来时，将会匹配到 <code>nodeAge</code>，但是由于 <code>nodeAge</code> 的 <code>pattern</code>变成了 <code>18</code>，因此将会被 <code>handle18()</code> 处理，这不太合适。</p><p><strong><code>GIN</code>的做法是将冲突的路由直接<code>panic</code>了。</strong></p><p><strong>第二个bug</strong></p><p><code>router</code>的 <code>handle</code> 方法貌似不是协程安全的</p><p>假设此时只有一个<code>/:age</code>的<code>router</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;:age&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br></code></pre></td></tr></table></figure><p>此时有两个请求地址分别为 <code>/18</code> 和 <code>/19</code>的请求到达。</p><p><code>handle()</code> 内的 <code>getRoute()</code> 函数得到的 <code>params</code> 分别为 <code>key:age value:18</code> 和 <code>key:age value:19</code>，它们会对<strong>同一个</strong> <code>context</code> 进行写入，因此不太安全。</p><p>在 <code>http</code> 包内的 <code>server.go</code> 文件中的 <code>Serve</code> 函数内，有这样一段注释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Serve accepts incoming connections on the Listener l, creating a</span><br><span class="hljs-comment">// new service goroutine for each. The service goroutines read requests and</span><br><span class="hljs-comment">// then call srv.Handler to reply to them.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// HTTP/2 support is only enabled if the Listener returns *tls.Conn</span><br><span class="hljs-comment">// connections and they were configured with &quot;h2&quot; in the TLS</span><br><span class="hljs-comment">// Config.NextProtos.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Serve always returns a non-nil error and closes l.</span><br><span class="hljs-comment">// After Shutdown or Close, the returned error is ErrServerClosed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><p>可见，<code>http.ListenAndServe()</code> 是有可能开启多个协程的。</p><p><strong>A：</strong></p><p>第一个bug，存在覆盖的问题，gin 的做法才是对的，应该把问题暴露给用户。<br>第二个问题，http 请求是并发的，但每一个请求都会调用 <code>ServeHTTP</code> ，这个方法中，context 每次都创建新的，不会对同一个context进行写入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>c := newContext(w, req)<br>engine.router.handle(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点：比较 parts 的长度有没有相匹配的深度就可以知道是否匹配上了，因为通配符也占位</p><h2 id="Day-4-分组控制"><a href="#Day-4-分组控制" class="headerlink" title="Day 4 分组控制"></a>Day 4 分组控制</h2><h3 id="分组的意义"><a href="#分组的意义" class="headerlink" title="分组的意义"></a>分组的意义</h3><p>分组控制(Group Control)是 Web 框架应提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如：</p><ul><li>以<code>/post</code>开头的路由匿名可访问。</li><li>以<code>/admin</code>开头的路由需要鉴权。</li><li>以<code>/api</code>开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</li></ul><p>ps：RESTful风格是 —— <strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</strong></p><p>parent 之前设计是用来拼接 prefix 的，每个 group 只记录自己的部分，最后通过 parent 层层回溯拼接。不过后来改用 <code>group.prefix + prefix</code> 的方式 group 初始化时已经拼接了完整的 prefix，所以不需要 <code>parent</code> 了，可以删除。</p><h2 id="Day-5-中间件"><a href="#Day-5-中间件" class="headerlink" title="Day 5 中间件"></a>Day 5 中间件</h2><p>Gee 的中间件的定义与路由映射的 Handler 一致，处理的输入是<code>Context</code>对象。插入点是框架接收到请求初始化<code>Context</code>对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对<code>Context</code>进行二次加工。c.Next()<code>表示等待执行其他的中间件或用户的</code>Handler</p><p>假设我们应用了中间件 A 和 B，和路由映射的 Handler。<code>c.handlers</code>是这样的[A, B, Handler]，<code>c.index</code>初始化为-1。调用<code>c.Next()</code>，接下来的流程是这样的：</p><ul><li>c.index++，c.index 变为 0</li><li>0 &lt; 3，调用 c.handlers[0]，即 A</li><li>执行 part1，调用 c.Next()</li><li>c.index++，c.index 变为 1</li><li>1 &lt; 3，调用 c.handlers[1]，即 B</li><li>执行 part3，调用 c.Next()</li><li>c.index++，c.index 变为 2</li><li>2 &lt; 3，调用 c.handlers[2]，即Handler</li><li>Handler 调用完毕，返回到 B 中的 part4，执行 part4</li><li>part4 执行完毕，返回到 A 中的 part2，执行 part2</li><li>part2 执行完毕，结束。</li></ul><p>一句话说清楚重点，最终的顺序是<code>part1 -&gt; part3 -&gt; Handler -&gt; part 4 -&gt; part2</code>。恰恰满足了我们对中间件的要求，接下来看调用部分的代码，就能全部串起来了。</p><p>目前的结构：</p><pre><code class=" mermaid">graph LR;http请求 --&gt; RouterGroup;RouterGroup --&gt; Engine;Engine --&gt; Context-get\post;Context-get\post --&gt; Next;Context-get\post --&gt; Param;Context-get\post --&gt; PostForm;Context-get\post --&gt; Query;Context-get\post --&gt; Status;Context-get\post --&gt; SetHeader;Context-get\post --&gt; String;Context-get\post --&gt; JSON;Context-get\post --&gt; Data;Context-get\post --&gt; HTML;</code></pre><p>每一个use都会append一个中间件，并且存储在router group中，在实现serveHTTP的时候将这些中间件函数递给context</p><p>最后在next()中启动第一个handler</p><h2 id="Day-6-模版-Template"><a href="#Day-6-模版-Template" class="headerlink" title="Day 6 模版 Template"></a>Day 6 模版 Template</h2><p>那如果我么将所有的静态文件放在<code>/usr/web</code>目录下，那么<code>filepath</code>的值即是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。</p><p>找到文件后，如何返回这一步，<code>net/http</code>库已经实现了。因此，gee 框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给<code>http.FileServer</code>处理就好了</p><p>Golang 內建提供 <a href="https://golang.org/pkg/net/http/#FileServer">http.FileServer</a> ，可以方便地透過 HTTP 存取檔案系統(file system)，例如以下程式碼執行之後，就可以透過瀏覽器打開網址 <code>http://localhost:8080</code> 瀏覽 <code>/usr/share/doc</code> 資料夾內的檔案。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, http.FileServer(http.Dir(<span class="hljs-string">&quot;/usr/share/doc&quot;</span>)))<br>&#125;<br></code></pre></td></tr></table></figure><p>可以挂载一个文件路径通过ip来访问规定的地址。</p><p>如果是一个普通的结构体是需要加指针的</p><p>如果是一个map类型他自己就是个对象不用加指针</p><p>首先为 Engine 示例添加了 <code>*template.Template</code> 和 <code>template.FuncMap</code>对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。</p><p>另外，给用户分别提供了设置自定义渲染函数<code>funcMap</code>和加载模板的方法。</p><p>接下来，对原来的 <code>(*Context).HTML()</code>方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p><p>这一块设计比较简单，RouterGroup 只做路由的事情，Engine 做全局的事情。<code>LoadHTMLGlob</code> 设计成全局的了，你可以尝试下，实现 RouterGroup 级别的模板。</p><p><code>e.HtmlTemplates = template.Must(template.New(&quot;&quot;).Funcs(e.FuncMap).ParseGlob(pattern))</code></p><p><a href="https://www.cnblogs.com/f-ck-need-u/p/10035768.html">https://www.cnblogs.com/f-ck-need-u/p/10035768.html</a></p><p><strong>使用template.New()函数可以创建一个空的、无解析数据的模板，同时还会创建一个common，也就是模板组</strong>。</p><p>也就是说，<strong>template.New()函数不仅创建了一个模板，还创建了一个空的common结构(模板组)。需要注意，新创建的common是空的，只有进行模板解析(Parse()，ParseFiles()等操作)之后，才会将模板添加到common的tmpl字段(map结构)中</strong>。</p><p>Parse()只能解析字符串，要解析文件中的内容，需要使用ParseFiles()或ParseGlob()。</p><p>template内置了一系列函数，但这些函数毕竟有限，可能无法满足特殊的需求。template允许我们定义自己的函数，添加到common中，然后就可以在待解析的内容中像使用内置函数一样使用自定义的函数。</p><p>自定义函数的优先级高于内置的函数优先级，即先检索自定义函数，再检索内置函数。也就是说，如果自定义函数的函数名和内置函数名相同，则内置函数将失效。</p><p>本文只对此稍作解释，本文的重点不是template的具体语法和用法。</p><p><strong>Golang Template</strong></p><p><a href="https://blog.csdn.net/lengyuezuixue/article/details/79367825?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;utm_relevant_index=1">https://blog.csdn.net/lengyuezuixue/article/details/79367825?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;utm_relevant_index=1</a></p><h2 id="Day-7-错误恢复"><a href="#Day-7-错误恢复" class="headerlink" title="Day 7 错误恢复"></a>Day 7 错误恢复</h2><p>Gee 的错误处理机制</p><p>对一个 Web 框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。</p><p>我们在第六天实现的框架并没有加入异常处理机制，如果代码中存在会触发 panic 的 BUG，很容易宕掉。</p><h1 id="分布式缓存-GeeCache"><a href="#分布式缓存-GeeCache" class="headerlink" title="分布式缓存 - GeeCache"></a>分布式缓存 - GeeCache</h1><h2 id="Day-1-LRU缓存机制"><a href="#Day-1-LRU缓存机制" class="headerlink" title="Day 1 LRU缓存机制"></a>Day 1 LRU缓存机制</h2><h3 id="1-核心数据结构"><a href="#1-核心数据结构" class="headerlink" title="1. 核心数据结构"></a>1. 核心数据结构</h3><p><img src="https://geektutu.com/post/geecache-day1/lru.jpg" alt="implement lru algorithm with golang"></p><p>这张图很好地表示了 LRU 算法最核心的 2 个数据结构</p><ul><li>绿色的是字典(map)，存储键和值的映射关系。这样根据某个键(key)查找对应的值(value)的复杂是<code>O(1)</code>，在字典中插入一条记录的复杂度也是<code>O(1)</code>。</li><li>红色的是双向链表(double linked list)实现的队列。将所有的值放到双向链表中，这样，当访问到某个值时，将其移动到队尾的复杂度是<code>O(1)</code>，在队尾新增一条记录以及删除一条记录的复杂度均为<code>O(1)</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Cache is a LRU cache. It is not safe for concurrent access.</span><br><span class="hljs-keyword">type</span> Cache <span class="hljs-keyword">struct</span> &#123;<br>maxBytes <span class="hljs-type">int64</span><br>nbytes   <span class="hljs-type">int64</span><br>ll       *list.List<br>cache    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element<br><span class="hljs-comment">// optional and executed when an entry is purged.</span><br>OnEvicted <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>, value Value)</span></span> <span class="hljs-comment">// 驱逐</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这里我们直接使用 Go 语言标准库实现的双向链表<code>list.List</code>。</li><li>字典的定义是 <code>map[string]*list.Element</code>，键是字符串，值是双向链表中对应节点的指针。</li><li><code>maxBytes</code> 是允许使用的最大内存，<code>nbytes</code> 是当前已使用的内存，<code>OnEvicted</code> 是某条记录被移除时的回调函数，可以为 nil。</li><li>键值对 <code>entry</code> 是双向链表节点的数据类型，在链表中仍保存每个值对应的 key 的好处在于，淘汰队首节点时，需要用 key 从字典中删除对应的映射。</li><li>为了通用性，我们允许值是实现了 <code>Value</code> 接口的任意类型，该接口只包含了一个方法 <code>Len() int</code>，用于返回值所占用的内存大小。</li></ul><h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h3><p>查找主要有 2 个步骤，第一步是从字典中找到对应的双向链表的节点，第二步，将该节点移动到队尾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get look ups a key&#x27;s value</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Get(key <span class="hljs-type">string</span>) (value Value, ok <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;<br>c.ll.MoveToFront(ele)<br>kv := ele.Value.(*entry)<br><span class="hljs-keyword">return</span> kv.value, <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果键对应的链表节点存在，则将对应节点移动到队尾，并返回查找到的值。</li><li><code>c.ll.MoveToFront(ele)</code>，即将链表中的节点 <code>ele</code> 移动到队尾（双向链表作为队列，队首队尾是相对的，在这里约定 front 为队尾）</li></ul><p>其中<code>kv := ele.Value.(*entry)</code></p><p>一个简单的断言表达式：</p><p>var s = x.(T)</p><p>如果 x 不是 nil，且 x 可以转换成 T 类型，就会断言成功，返回 T 类型的变量 s。如果 T 不是接口类型，则要求 x 的类型就是 T（或者包含x），如果 T 是一个接口，要求 x 实现了 T 接口。</p><p>如果断言类型成立，则表达式返回值就是 T 类型的 x，如果断言失败就会触发 panic。</p><p>上述表所示再断言失败就会 panic，go 提供了另外一种带返回是否成立的断言语法：</p><p>s, ok := x.(T)</p><p>该方法和第一种差不多一样，但是 ok 会返回是否断言成功不会出现 panic，ok 就表示是否是成功了。</p><h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3. 删除"></a>3. 删除</h3><p>这里的删除，实际上是缓存淘汰。即移除最近最少访问的节点（队首）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RemoveOldest removes the oldest item</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> RemoveOldest() &#123;<br>ele := c.ll.Back()<br><span class="hljs-keyword">if</span> ele != <span class="hljs-literal">nil</span> &#123;<br>c.ll.Remove(ele)<br>kv := ele.Value.(*entry)<br><span class="hljs-built_in">delete</span>(c.cache, kv.key)<br>c.nbytes -= <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(kv.key)) + <span class="hljs-type">int64</span>(kv.value.Len())<br><span class="hljs-keyword">if</span> c.OnEvicted != <span class="hljs-literal">nil</span> &#123;<br>c.OnEvicted(kv.key, kv.value)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>c.ll.Back()</code> 取到队首节点，从链表中删除。</li><li><code>delete(c.cache, kv.key)</code>，从字典中 <code>c.cache</code> 删除该节点的映射关系。</li><li>更新当前所用的内存 <code>c.nbytes</code>。</li><li>如果回调函数 <code>OnEvicted</code> 不为 nil，则调用回调函数。</li></ul><h3 id="4-新增-修改"><a href="#4-新增-修改" class="headerlink" title="4. 新增/修改"></a>4. 新增/修改</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Add adds a value to the cache.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Add(key <span class="hljs-type">string</span>, value Value) &#123;<br><span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;<br>c.ll.MoveToFront(ele)<br>kv := ele.Value.(*entry)<br>c.nbytes += <span class="hljs-type">int64</span>(value.Len()) - <span class="hljs-type">int64</span>(kv.value.Len())<br>kv.value = value<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)<br>c.cache[key] = ele<br>c.nbytes += <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(key)) + <span class="hljs-type">int64</span>(value.Len())<br>&#125;<br><span class="hljs-keyword">for</span> c.maxBytes != <span class="hljs-number">0</span> &amp;&amp; c.maxBytes &lt; c.nbytes &#123;<br>c.RemoveOldest()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果键存在，则更新对应节点的值，并将该节点移到队尾。</li><li>不存在则是新增场景，首先队尾添加新节点 <code>&amp;entry&#123;key, value&#125;</code>, 并字典中添加 key 和节点的映射关系。</li><li>更新 <code>c.nbytes</code>，如果超过了设定的最大值 <code>c.maxBytes</code>，则移除最少访问的节点。</li></ul><p>最后，为了方便测试，我们实现 <code>Len()</code> 用来获取添加了多少条数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Len the number of cache entries</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> c.ll.Len()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Day-2-单机并发缓存"><a href="#Day-2-单机并发缓存" class="headerlink" title="Day 2 单机并发缓存"></a>Day 2 单机并发缓存</h2><h3 id="1-支持并发读写"><a href="#1-支持并发读写" class="headerlink" title="1. 支持并发读写"></a>1. 支持并发读写</h3><p>接下来我们使用 <code>sync.Mutex</code> 封装 LRU 的几个方法，使之支持并发的读写。在这之前，我们抽象了一个只读数据结构 <code>ByteView</code> 用来表示缓存值，是 GeeCache 主要的数据结构之一。</p><ul><li>ByteView 只有一个数据成员，<code>b []byte</code>，b 将会存储真实的缓存值。选择 byte 类型是为了能够支持任意的数据类型的存储，例如字符串、图片等。</li><li>实现 <code>Len() int</code> 方法，我们在 lru.Cache 的实现中，要求被缓存对象必须实现 Value 接口，即 <code>Len() int</code> 方法，返回其所占的内存大小。</li><li><code>b</code> 是只读的，使用 <code>ByteSlice()</code> 方法返回一个拷贝，防止缓存值被外部程序修改。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Backend development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP, UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang原理</title>
    <link href="/2022/06/18/golang%E5%8E%9F%E7%90%86/"/>
    <url>/2022/06/18/golang%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Slice"><a href="#1-Slice" class="headerlink" title="1. Slice"></a>1. Slice</h1><p>slice的扩容的内存分配，两大部分，先进行容量预估，再进行内存分配。</p><p>第一步查看是否是扩容后的cap是否大于原来cap的两倍，如果大于则更新为扩容后cap；如果小于的话则进行第二步。</p><p>第二步查看更新后的cap的大小，如果cap &lt; 1024 则 cap <em> 2，如果cap &gt; 1024 则 cap </em> 1.25。</p><p>第三步根据内存分配进行选择，内存占用为cap * 对应数据结构的字节数，向上取整</p><h1 id="2-结构体和内存对齐"><a href="#2-结构体和内存对齐" class="headerlink" title="2. 结构体和内存对齐"></a>2. 结构体和内存对齐</h1><p>8根地址总线，对应256个地址，可以操作256个地址，所以可以用的最高的内存数为256byte</p><p>32根地址总线，对应2^32 - 1个地址，可以操作4G个地址，所以可以用的最高的内存数为4G</p><p>（<strong>32位系统</strong> <strong>32位系统</strong>使用<strong>32位</strong>地址线的<strong>最大</strong>寻址空间为2的<strong>32</strong>次方bytes，计算后即4294967296 Bytes，也就是我们常说的4096MB，<strong>32位</strong>地址线的寻址空间封顶即为4GB）</p><p>64根地址总线，对应2^64 - 1个地址，可以操作128G个地址，所以可以用的最高的内存数为128G</p><p>（相对来说，<strong>64位</strong>操作<strong>系统</strong>支持的<strong>内存</strong>大小是2的<strong>64</strong>次方，相当于128GB<strong>内存</strong>，<strong>最大</strong>支持32<strong>位系统</strong>的32倍数，现在来说，128GB<strong>内存</strong>支持是理论值，但是在实际运用过程中很少需要这么大的，现阶段主流电脑一般都是8GB<strong>内存</strong>大一些16GB/32GB）</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>编程语言规定自己的数据类型的长度，比如int16长度为2字节（2*8byte）</p><p><strong>换算关系 </strong> 8bit(位)=1Byte(<strong>字节</strong>)； 1024Byte(<strong>字节</strong>)=1KB； 1024KB=1MB； 1024MB=1GB</p><p>1字节（byte）= 8位（bit）</p><p>RegSize是对齐边界</p><div class="table-container"><table><thead><tr><th></th><th>64位平台</th><th></th><th>32位平台</th><th></th></tr></thead><tbody><tr><td>类型</td><td>大小</td><td>RegSize</td><td>大小</td><td>RegSize</td></tr><tr><td>int8</td><td>1 byte ✅</td><td>8 byte</td><td>1 byte ✅</td><td>4 byte</td></tr><tr><td>int16</td><td>2 byte ✅</td><td>8 byte</td><td>2 byte ✅</td><td>4 byte</td></tr><tr><td>int32</td><td>4 byte ✅</td><td>8 byte</td><td>4 byte ✅</td><td>4 byte</td></tr><tr><td>int64</td><td>8 byte ✅</td><td>8 byte</td><td>8 byte</td><td>4 byte ✅</td></tr><tr><td>string</td><td>16 byte</td><td>8 byte ✅</td><td>8 byte</td><td>4 byte ✅</td></tr><tr><td>Slice</td><td>24 byte</td><td>8 byte ✅</td><td>12 byte</td><td>4 byte ✅</td></tr></tbody></table></div><p>这样的对齐方式不会浪费内存</p><h2 id="结构体的内存对齐"><a href="#结构体的内存对齐" class="headerlink" title="结构体的内存对齐"></a>结构体的内存对齐</h2><p><img src="https://cdn.jsdeliver.net/gh/PanyuHaa/PicGo/img/Screen%20Shot%202022-06-21%20at%2015.03.58.png" alt="Screen Shot 2022-06-21 at 15.03.58"></p><p>大于8byte的一定要内存对齐，要不后续查找的性能会降低，不是整数倍的话就会查询两次（甚至更多）再拼接。</p><p>结构体都是按顺序连续存储的。</p><h1 id="3-map"><a href="#3-map" class="headerlink" title="3. map"></a>3. map</h1><p>哈希放入的方法：1、取模法 2、与运算</p><p>解决哈希冲突的方法：1、开放地址法 2、拉链法 </p><p>哈希冲突就算能解决但是他的存在就是会影响速度，通常把存储键值对的数目与桶的数目有比值，称为负载因子。</p><p>负载因子是用来判断是否扩容的标准。</p><p>渐进式扩容，可以避免一次性扩容带来的性能瞬时抖动。他的过程：先分配足够多的新桶，用一个字段记录旧桶的位置，还有当前迁移的进度，每次读写的时候都进行一部分迁移，等到全部迁移完成后就是扩容完毕。</p><p><img src="https://cdn.jsdeliver.net/gh/PanyuHaa/PicGo/img/hmap.png" alt="hmap"></p><p><strong>tophash是</strong>一个长度为8的数组，它不仅仅用来存放key的哈希高8位，在不同场景下它还可以标记迁移状态，bucket是否为空等。</p><p>取k1的高八位（bit）hash值放在tophash里面。</p><p><code>bmap</code> 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。</p><p><img src="https://user-images.githubusercontent.com/7698088/57576986-acd87600-749f-11e9-8710-75e423c7efdb.png" alt="hashmap bmap"></p><p><strong>扩容规则</strong></p><p><code>B</code> 是 buckets 数组的长度的对数，也就是说 buckets 数组的长度就是 2^B。</p><p>count/(2^B) &gt; 6.5 ———-&gt; 翻倍扩容hmap.B++</p><p>LoadFactor没超标 ————&gt; 等量扩容</p><p>noverflow 较多 B &lt;= 15 noverflow &gt;= 2^B; B &gt; 15 noverflow &gt;= 2^15</p><p>等量扩容的意义，因为不需要太多的溢出桶，所以新桶可以整合之前还存在的KV，可以删除之前残存的内部碎片</p><h1 id="4-函数调用栈"><a href="#4-函数调用栈" class="headerlink" title="4. 函数调用栈"></a>4. 函数调用栈</h1><p>call指令记录有函数调用存在，ret用来返回函数调用的位置。</p><p>函数执行时，局部变量，参数和返回值，都存在虚拟地址中的栈。上面是高地址</p><p><a href="https://static.cyub.vip/images/202105/go-stack-sum.png"><img src="https://static.cyub.vip/images/202105/go-stack-sum.png" alt="main函数调用栈"></a></p><p>栈底也称栈基bp，局部变量，返回值，参数，返回地址</p><p>栈指针sp，偏移 + sp</p><p>go中的函数栈的分配是一次性的，这样不会出现函数栈溢出的问题。</p><p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-06-21 at 16.51.03.png" alt="Screen Shot 2022-06-21 at 16.51.03"></p><p>先存储下一个要去的位置，然后开始跳转到调用处继续执行，不过在栈底的位置的高地址处，存入调用者的栈基和向下移动的移动位置（用于向上移动回去），然后执行ret返回之前存储的状态。本质上是实现了一个跳转的过程。</p><p>之所以值拷贝不能够改变具体的值的原因是，值拷贝的话他的参数是局部变量的值而不是指向他们的地址，所以举例swap函数，他的确交换了，但交换的只是参数里面的a和b，并没有对局部变量的a和b的值进行交换，所以没有变化。</p><p><strong>匿名返回值</strong>——返回值先赋值，再调用defer函数。</p><p><strong>命名返回值</strong>——如果返回的是一个具体的参数b且defer里面有对b的操作，那么defer里面的调用是会影响到返回值的。</p><p>如果A调用了函数B和C，那么函数栈帧的大小要依照最大的空间需求函数，并且栈顶指针的位置是统一的，这样会更方便后续的虚拟地址查询。（栈底在上，栈顶在下）</p><h1 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5. 闭包"></a>5. 闭包</h1><p>堆存储的是函数的地址</p><p>闭包函数里面的变量要和外部函数保持一致，他们使用同一片变量</p><h1 id="6-方法"><a href="#6-方法" class="headerlink" title="6. 方法"></a>6. 方法</h1><h1 id="7-defer"><a href="#7-defer" class="headerlink" title="7. defer"></a>7. defer</h1><p>defer是用头插法链表连接起来的。</p>]]></content>
    
    
    <categories>
      
      <category>Backend development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend development, Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言笔记</title>
    <link href="/2022/06/07/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/07/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、控制并发的两种方式"><a href="#一、控制并发的两种方式" class="headerlink" title="一、控制并发的两种方式"></a>一、控制并发的两种方式</h1><h2 id="1-使用WaitGroup"><a href="#1-使用WaitGroup" class="headerlink" title="1. 使用WaitGroup"></a>1. 使用WaitGroup</h2><p><strong>应用场景：多个Goroutine执行同一件事情</strong></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>   wg.Add(<span class="hljs-number">2</span>)<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>      fmt.Println(<span class="hljs-string">&quot;job 1 done.&quot;</span>)<br>      wg.Done()<br>   &#125;()<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>      fmt.Println(<span class="hljs-string">&quot;job 2 done.&quot;</span>)<br>      wg.Done()<br>   &#125;()<br>   wg.Wait()<br>   fmt.Println(<span class="hljs-string">&quot;All Done.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何主动停止呢？</strong><br>使用Channel，Channel + Select的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- stop:<br>fmt.Println(<span class="hljs-string">&quot;got the stop channel&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;still working&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;stop the goroutine&quot;</span>)<br>stop &lt;- <span class="hljs-literal">true</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>多个Goroutine或Goroutine内又有Goroutine</p><p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-06-07 at 22.49.10.png" alt="Screen Shot 2022-06-07 at 22.49.10"></p><p>这种方式很难用嵌套的。</p><h2 id="2-使用Context"><a href="#2-使用Context" class="headerlink" title="2. 使用Context"></a>2. 使用Context</h2><p>简单改写没有嵌套。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithCancel(context.Background()) <span class="hljs-comment">// context.Background() 是root节点，将root节点放在channel里</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;got the stop channel&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;still working&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;stop the goroutine&quot;</span>)<br>cancel()<br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>多个进程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithCancel(context.Background()) <span class="hljs-comment">// context.Background() 是root节点，将root节点放在channel里</span><br><br><span class="hljs-keyword">go</span> worker(ctx, <span class="hljs-string">&quot;node01&quot;</span>)<br><span class="hljs-keyword">go</span> worker(ctx, <span class="hljs-string">&quot;node02&quot;</span>)<br><span class="hljs-keyword">go</span> worker(ctx, <span class="hljs-string">&quot;node03&quot;</span>)<br><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;stop the goroutine&quot;</span>)<br>cancel()<br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br><br><span class="hljs-comment">// 参数为context和进程的name</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(ctx context.Context, name <span class="hljs-type">string</span>)</span></span>  &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;got the stop channel&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;still working&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、初识gRPC"><a href="#二、初识gRPC" class="headerlink" title="二、初识gRPC"></a>二、初识gRPC</h1><p><strong>任务背景：</strong></p><p>描述一个向导服务，服务名为RouteGuide</p><p>定义四种不同的信息类型分别为Point，Rectangle，Feature，RouteSummary以及Chat。</p><p>定义四个方法：</p><p><img src="https://cdn.jsdeliver.net/gh/PanyuHaa/PicGo/img/Screen%20Shot%202022-06-09%20at%2016.13.15.png" alt="Screen Shot 2022-06-09 at 16.13.15"></p><p>定义一个service</p><h2 id="1-gRPC四种服务类型"><a href="#1-gRPC四种服务类型" class="headerlink" title="1. gRPC四种服务类型"></a>1. gRPC四种服务类型</h2><h3 id="1-1-Unary"><a href="#1-1-Unary" class="headerlink" title="1.1 Unary"></a>1.1 Unary</h3><h3 id="1-2-Client-side-streaming"><a href="#1-2-Client-side-streaming" class="headerlink" title="1.2 Client-side streaming"></a>1.2 Client-side streaming</h3><h3 id="1-3-Server-side-streaming"><a href="#1-3-Server-side-streaming" class="headerlink" title="1.3 Server-side streaming"></a>1.3 Server-side streaming</h3><h3 id="1-4-Bidirectional-streaming"><a href="#1-4-Bidirectional-streaming" class="headerlink" title="1.4 Bidirectional streaming"></a>1.4 Bidirectional streaming</h3><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><p><a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">https://developers.google.com/protocol-buffers/docs/reference/go-generated</a></p><p>一、先写好proto文件</p><p>二、在terminal里面写</p><p>安装protoc</p><p><code>$ brew install protobuf</code><br><code>$ protoc --version</code> (最新版本)</p><p>.是当前文件的意思</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">protoc --go_out=. --go_opt=paths=source_relative --<span class="hljs-keyword">go</span>-grpc_out. --<span class="hljs-keyword">go</span>-grpc_opt=paths=source_relative route.proto<br></code></pre></td></tr></table></figure><p>前面的go_out输出的是message的代码文件</p><p>后面的go-rpc_out输出的是service的代码文件</p>]]></content>
    
    
    <categories>
      
      <category>Backend development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend development</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录</title>
    <link href="/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    <url>/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="第3章-数组"><a href="#第3章-数组" class="headerlink" title="第3章 数组"></a>第3章 数组</h1><h2 id="3-2-二分查找"><a href="#3-2-二分查找" class="headerlink" title="3.2 二分查找"></a>3.2 二分查找</h2><p><strong>704. Binary Search</strong></p><p><strong>Q:</strong> Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> pivot, left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>      pivot = left + (right - left) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[pivot] == target) <span class="hljs-keyword">return</span> pivot;<br>      <span class="hljs-keyword">if</span> (target &lt; nums[pivot]) right = pivot - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> left = pivot + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 (left + right) / 2 = left + (right / 2) - (left / 2) = left + (right - left) / 2</p><p>我采用的是 [left, right] 闭区间，所以判断条件是 &lt;= ，left和right相等的时候有意义。</p><h2 id="3-3-移除元素"><a href="#3-3-移除元素" class="headerlink" title="3.3 移除元素"></a><strong>3.3 移除元素</strong></h2><p><strong>27. Remove Element</strong></p><p><strong>Q: </strong>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <strong>in-place</strong>. The relative order of the elements may be changed.</p><p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p><p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] != val) &#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1⃣️ 由于有空间复杂度的限制，所以不能建立另外一个数组来进行赋值，暗示我们用双指针法，双指针法是常用的降低时间复杂度的方法。</p><p>2⃣️ nums = [0, 1 ,4 ,0 ,3 , _ , _] 因为数组中的元素在内存地址上是连续的，不能单独删除数组中的某个元素，只能覆盖。</p><h2 id="3-4-长度最小的子数组"><a href="#3-4-长度最小的子数组" class="headerlink" title="3.4 长度最小的子数组"></a>3.4 长度最小的子数组</h2><p><strong>209. Minimum Size Subarray Sum</strong></p><p><strong>Q: </strong>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p><p><strong>A1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span> MAX;<br>        <span class="hljs-type">int</span> subSum;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历数组中的每一个作为开头</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            subSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-comment">// 求子数组的和</span><br>                subSum += nums[j];<br>                <span class="hljs-keyword">if</span> (subSum &gt;= target) &#123;<br>                    subLength = j - i + <span class="hljs-number">1</span>;<br>                    resultLength = resultLength &gt; subLength ? subLength : resultLength;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span>= MAX ? <span class="hljs-number">0</span> : resultLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>暴力解法，不过也有巧妙思路，通过MAX这个变量增加了判断是否返回0的方法，是flag的另一种用法。</p><p><strong>A2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span> MAX;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 标记左边的起始位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 用j标记的是窗口右边指针的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            subSum += nums[j];<br>            <span class="hljs-comment">// 保证窗口内的sum值永远是大于等于target的</span><br>            <span class="hljs-keyword">while</span> (subSum &gt;= target) &#123;<br>                <span class="hljs-comment">// 获取子数组的长度并判断是否是最小的，+1是因为数组是从0开始的</span><br>                subLength = j - i + <span class="hljs-number">1</span>;<br>                resultLength = resultLength &gt; subLength ? subLength : resultLength;<br>                <span class="hljs-comment">// 收缩左边的指针的位置</span><br>                subSum -= nums[i++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span>= MAX ? <span class="hljs-number">0</span> : resultLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要考虑三个问题：</p><p>1⃣️ 窗口内的元素是什么？</p><p>2⃣️ 窗口的起始位置？</p><p>3⃣️ 窗口的结束位置？</p><p>滑动窗口的精妙之处在于根据当前子数组和的大小，不断调节子数组的起始位置，从而将时间复杂度从O(n^2)变成O(n)。</p><p>subLength和resultLength必须在满足subSum &gt;= target的时候才有意义，所以放在内部。</p><h2 id="3-5-螺旋矩阵"><a href="#3-5-螺旋矩阵" class="headerlink" title="3.5 螺旋矩阵"></a>3.5 螺旋矩阵</h2><p><strong>59. Spiral Matrix II</strong></p><p><strong>Q: </strong>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n2</code> in spiral order.</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/spiraln.jpg" alt="spiraln"></p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] Matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义列边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义行边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 填充值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> row;<br>        <span class="hljs-type">int</span> col;<br><br>        <span class="hljs-keyword">while</span> (value != (n * n) + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 从左向右走</span><br>            <span class="hljs-keyword">for</span> (col = left; col &lt;= right; col++) &#123;<br>                Matrix[up][col] = value;<br>                value++;<br>            &#125;<br>            up++;<br>            <span class="hljs-comment">// 从上向下走</span><br>            <span class="hljs-keyword">for</span> (row = up; row &lt;= down; row++) &#123;<br>                Matrix[row][right] = value;<br>                value++;<br>            &#125;<br>            right--;<br>            <span class="hljs-comment">// 从右向左走</span><br>            <span class="hljs-keyword">for</span> (col = right; col &gt;= left; col--) &#123;<br>                Matrix[down][col] = value;<br>                value++;<br>            &#125;<br>            down--;<br>            <span class="hljs-comment">// 从下向上走</span><br>            <span class="hljs-keyword">for</span> (row = down; row &gt;= up; row--) &#123;<br>                Matrix[row][left] = value;<br>                value++;<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>规定出四个边界，每个方向遍历一次以后通过 ++ 操作来使此行或者此列不再遍历。循环终止的方法有两种，其一是方阵的情况下进行特殊判断，其二是不规则矩阵的情况下进行每个方向上的判断。</p><h1 id="第4章-链表"><a href="#第4章-链表" class="headerlink" title="第4章 链表"></a>第4章 链表</h1><h2 id="4-2-虚拟头节点链表删除"><a href="#4-2-虚拟头节点链表删除" class="headerlink" title="4.2 虚拟头节点链表删除"></a>4.2 虚拟头节点链表删除</h2><p><strong>203. Remove Linked List Elements</strong></p><p><strong>Q: </strong>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/removelinked-list.jpg" alt="removelinked-list"></p><p><strong>A1: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 虚拟头结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fakeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        fakeHead.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> fakeHead, cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>                pre.next = cur.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = pre.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过加入虚拟头节点来解决如果是第一位就要删除的pre和cur不好指向的问题</p><p><strong>A2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        head.next = removeElements(head.next, val);<br>        <span class="hljs-keyword">return</span> head.val == val ? head.next : head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归的方法实现，先递归到最底层，然后往回一点点走，每次都判断，如果有要删除的值就返回前一个，没有要删除的就返回当前的结点，直到回到最初的位置。</p><h2 id="4-3-链表常见的六个操作"><a href="#4-3-链表常见的六个操作" class="headerlink" title="4.3 链表常见的六个操作"></a>4.3 链表常见的六个操作</h2><p><strong>707. Design Linked List</strong></p><p><strong>Q: </strong>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.<br>A node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code>is the value of the current node, and <code>next</code> is a pointer/reference to the next node.<br>If you want to use the doubly linked list, you will need one more attribute <code>prev</code>to indicate the previous node in the linked list. Assume all nodes in the linked list are <strong>0-indexed</strong>.</p><p>Implement the <code>MyLinkedList</code> class:</p><ul><li><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</li><li><code>int get(int index)</code> Get the value of the <code>indexth</code> node in the linked list. If the index is invalid, return <code>-1</code>.</li><li><code>void addAtHead(int val)</code> Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li><li><code>void addAtTail(int val)</code> Append a node of value <code>val</code> as the last element of the linked list.</li><li><code>void addAtIndex(int index, int val)</code> Add a node of value <code>val</code>before the <code>indexth</code> node in the linked list. If <code>index</code> equals the length of the linked list, the node will be appended to the end of the linked list. If <code>index</code> is greater than the length, the node <strong>will not be inserted</strong>.</li><li><code>void deleteAtIndex(int index)</code> Delete the <code>indexth</code> node in the linked list, if the index is valid.</li></ul><p><strong>A:</strong> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyLinkedList <span class="hljs-keyword">struct</span> &#123;<br>head *Node<br>&#125;<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>Val  <span class="hljs-type">int</span><br>Next *Node<br>Prev *Node<br>&#125;<br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyLinkedList &#123;<br><span class="hljs-keyword">return</span> MyLinkedList&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> Get(index <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>curr := this.head<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>curr = curr.Next<br>&#125;<br><span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> curr.Val<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="hljs-type">int</span>) &#123;<br>node := &amp;Node&#123;Val: val&#125;<br>node.Next = this.head<br><span class="hljs-keyword">if</span> this.head != <span class="hljs-literal">nil</span> &#123;<br>this.head.Prev = node<br>&#125;<br>this.head = node<br>&#125;<br><br><span class="hljs-comment">/** Append a node of value val to the last element of the linked list. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> this.head == <span class="hljs-literal">nil</span> &#123;<br>this.AddAtHead(val)<br><span class="hljs-keyword">return</span><br>&#125;<br>node := &amp;Node&#123;Val: val&#125;<br>curr := this.head<br><span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &amp;&amp; curr.Next != <span class="hljs-literal">nil</span> &#123;<br>curr = curr.Next<br>&#125;<br>node.Prev = curr<br>curr.Next = node<br>&#125;<br><br><span class="hljs-comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="hljs-type">int</span>, val <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>this.AddAtHead(val)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>node := &amp;Node&#123;Val: val&#125;<br>curr := this.head<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index<span class="hljs-number">-1</span> &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>curr = curr.Next<br>&#125;<br><span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &#123;<br>node.Next = curr.Next<br>node.Prev = curr<br><span class="hljs-keyword">if</span> node.Next != <span class="hljs-literal">nil</span> &#123;<br>node.Next.Prev = node<br>&#125;<br>curr.Next = node<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/** Delete the index-th node in the linked list, if the index is valid. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>this.head = this.head.Next<br><span class="hljs-keyword">if</span> this.head != <span class="hljs-literal">nil</span> &#123;<br>this.head.Prev = <span class="hljs-literal">nil</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>curr := this.head<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index<span class="hljs-number">-1</span> &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>curr = curr.Next<br>&#125;<br><span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &amp;&amp; curr.Next != <span class="hljs-literal">nil</span> &#123;<br>curr.Next = curr.Next.Next<br><span class="hljs-keyword">if</span> curr.Next != <span class="hljs-literal">nil</span> &#123;<br>curr.Next.Prev = curr<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * param_1 := obj.Get(index);</span><br><span class="hljs-comment"> * obj.AddAtHead(val);</span><br><span class="hljs-comment"> * obj.AddAtTail(val);</span><br><span class="hljs-comment"> * obj.AddAtIndex(index,val);</span><br><span class="hljs-comment"> * obj.DeleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="4-4-反转链表"><a href="#4-4-反转链表" class="headerlink" title="4.4 反转链表"></a>4.4 反转链表</h2><p><strong>206. Reverse Linked List</strong></p><p><strong>Q:</strong> Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/rev1ex1.jpg" alt="rev1ex1"></p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tempHead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            tempHead = <span class="hljs-built_in">this</span>.addFirst(tempHead, cur.val);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tempHead;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addFirst</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        newNode.next = head;<br>        head = newNode;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用头插法实现倒叙插入</p><h2 id="4-5-删除倒数第n个字节"><a href="#4-5-删除倒数第n个字节" class="headerlink" title="4.5 删除倒数第n个字节"></a>4.5 删除倒数第n个字节</h2><p><strong>19. Remove Nth Node From End of List</strong></p><p><strong>Q: </strong>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head. </p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// fakeHead</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fakeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        fakeHead.next = head;<br>        <span class="hljs-comment">// fast &amp; slow, fast pointer faster than slow pointer n steps.</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> fakeHead;<br>        <span class="hljs-comment">// set the position of the fast pointer.</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// n represent the times of loop, if &#x27;i&#x27; start from 0.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> fakeHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过双指针的间距来找到倒数第n个的位置，我让fast提前等于head再往后走，是为了在找到最后的null的时候，slow正好是要删除的结点的前一个。</p><h2 id="4-6-环形链表"><a href="#4-6-环形链表" class="headerlink" title="4.6 环形链表"></a>4.6 环形链表</h2><p><strong>142. Linked List Cycle II</strong></p><p><strong>Q: </strong>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return</em> <code>null</code>.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p><p><strong>Do not modify</strong> the linked list.</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/circularlinkedlist.png" alt="circularlinkedlist"></p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<span class="hljs-comment">// 有环</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> fast;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span><br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1.next;<br>                    index2 = index2.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针的思想，具体推导过程见书P66。</p><p>1⃣️判断是否有环？</p><p>2⃣️判断环的入口在哪里？</p><p>x为起始位置到循环入口的距离，y为循环入口到fast和slow的相遇位置，z为相遇位置到循环入口处的距离。</p><p><strong>x = (n - 1)(y + z) + z</strong>，当n = 1时x = z。代表着走了一圈就相遇了。若n &gt; 1的话，道理一样，总之是index2会比index1少转一圈并且相遇。</p><p>z是fast相遇的位置开始走，最起码要走一圈，多的就是在入口点前相遇的时候，转了几圈y + z代表的是走一圈要的距离。</p><p>ps: n一定大于等于1，因为index1必须最起码走一圈才能够和index2相遇。</p><h1 id="第5章-哈希表"><a href="#第5章-哈希表" class="headerlink" title="第5章 哈希表"></a>第5章 哈希表</h1><h2 id="5-2-有效的字母异位词"><a href="#5-2-有效的字母异位词" class="headerlink" title="5.2 有效的字母异位词"></a>5.2 有效的字母异位词</h2><p><strong>242. Valid Anagram</strong></p><p><strong>Q: </strong>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code><em>otherwise</em>.</p><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            record[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            record[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用到了一个常用的处理字符出现次数的方法。字符 - ‘a’也算是一种哈希函数，它可以把字符串通过ASCII转换，用26位的数组存储他们出现的次数。</p><h2 id="5-3-两个数组的交集"><a href="#5-3-两个数组的交集" class="headerlink" title="5.3 两个数组的交集"></a>5.3 两个数组的交集</h2><p><strong>349. Intersection of Two Arrays</strong></p><p><strong>Q: </strong>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; intersect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;<br>            set.add(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(nums2[i])) &#123;<br>                intersect.add(nums2[i]);<br>            &#125;<br>        &#125;<br>  <span class="hljs-comment">// set turn to the int[]</span><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[intersect.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer num : intersect) &#123;<br>            result[i++] = num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/java-hashset-hierarchy.png" alt="java-hashset-hierarchy"></p><ul><li><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p></li><li><p>HashSet 允许有 null 值。</p></li><li><p>HashSet 是无序的，即不会记录插入的顺序。</p></li><li><p>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。</p></li><li><p>HashSet 实现了 Set 接口。</p></li></ul><p>进行了两步，第一步初筛有哪些value，第二步确定相交的value又有哪些。</p><h2 id="5-4-两数之和"><a href="#5-4-两数之和" class="headerlink" title="5.4 两数之和"></a>5.4 两数之和</h2><p><strong>1. Two Sum</strong></p><p><strong>Q: </strong>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(target - nums[i]), i&#125;;<br>            &#125;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;No two sum solution&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路</p><p>标签：哈希映射</p><ul><li>这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n^2)</li><li>由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度</li><li>遍历数组 nums, i为当前下标，每个值都判断map中是否存在 target - nums[i] 的 key 值</li><li>如果存在则找到了两个值，如果不存在则将当前的 (nums[i], i) 存入 map 中，继续遍历直到找到为止</li></ul><p>每次都是先判断已有的map里面是否有答案，若没有答案就放进map里，这样只要找到答案立马可以得到结果（通过 target - nums[i] 和此时的 i 得到对应的下标）并且有最优的空间复杂度。之所以用map也是因为我们需要的答案是下标，map可以存储每个数组的下标，而单一的数组是做不到的。</p><h2 id="5-5-四数相加"><a href="#5-5-四数相加" class="headerlink" title="5.5 四数相加"></a>5.5 四数相加</h2><p><strong>454. 4Sum II</strong></p><p><strong>Q:</strong> Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span>[] B, <span class="hljs-type">int</span>[] C, <span class="hljs-type">int</span>[] D)</span> &#123;<br>        Map&lt;Integer,Integer&gt; sums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : B) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a + b;<br>                <span class="hljs-keyword">if</span>(sums.containsKey(sum)) &#123;<br>                    sums.put(sum, sums.get(sum)+<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    sums.put(sum, <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : C) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : D)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> -(c + d);<br>                <span class="hljs-keyword">if</span> (sums.containsKey(sum)) &#123;<br>                    count+=sums.get(sum);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>利用两数之和的思想，先把四个数组融合成两个，把前两个数组可以组成的所有都放在一个map里面，利用双层遍历把后续的两个数组都进行做差查找。</p><h2 id="5-6-三数之和"><a href="#5-6-三数之和" class="headerlink" title="5.6 三数之和"></a>5.6 三数之和</h2><p><strong>15. 3Sum</strong></p><p><strong>Q: </strong>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p><p>Notice that the solution set must not contain duplicate triplets.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + <span class="hljs-number">2</span> &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;              <span class="hljs-comment">// skip same result</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, k = nums.length - <span class="hljs-number">1</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> -nums[i];<br>        <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] + nums[k] == target) &#123;<br>                res.add(Arrays.asList(nums[i], nums[j], nums[k]));<br>                j++;<br>                k--;<br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) j++;  <span class="hljs-comment">// skip same result</span><br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]) k--;  <span class="hljs-comment">// skip same result</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j] + nums[k] &gt; target) &#123;<br>                k--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>Array.sort(int[] arr)用来sort数组默认是从小到大。</p><p>res.add(Arrays.asList(nums[i], nums[j], nums[k]));这是List加入一系列数的方法。</p><p>把三个动点变成一个定点，两个动点。定点作为循环条件，在循环的基础上进行判断，一个左指针和一个右指针来判断在定点基础上，有没有组合使结果成立。这个的优点是判断了一个重复的情况直接跳过，因为题目说了不能有重复的三元组。</p><h2 id="5-7-四数之和"><a href="#5-7-四数之和" class="headerlink" title="5.7 四数之和"></a>5.7 四数之和</h2><p><strong>18. 4Sum</strong></p><p><strong>Q: </strong>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong>quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>You may return the answer in <strong>any order</strong>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> targetDiff;<br>        <span class="hljs-type">int</span> left, right;<br>        <span class="hljs-comment">// sort input</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-comment">// skip the same result, if the cur value is same as the former value, the skip the cur value.</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 在 nums[i] 基础上，从 i + 1 处开始遍历，继续三数之和的思想</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-comment">// skip the same result</span><br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                left = j + <span class="hljs-number">2</span>;<br>                right = nums.length - <span class="hljs-number">1</span>;<br>                targetDiff = target - nums[i] - nums[j];<br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-comment">// 若包含的元素能够做差满足问题</span><br>                    <span class="hljs-keyword">if</span> (targetDiff - nums[left] - nums[right] == <span class="hljs-number">0</span>) &#123;<br>                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));<br>                        left++;<br>                        right--;<br>                        <span class="hljs-comment">// skip the same result</span><br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="hljs-number">1</span>]) &#123; left++; &#125;<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="hljs-number">1</span>]) &#123; right--; &#125;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetDiff - nums[left] - nums[right] &gt; <span class="hljs-number">0</span>) &#123;<br>                        left++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在三数之和的基础上，增加了一个维度，他的时间复杂度的增加完全是因为固定的前两位，若是五数之和时间复杂度再*n。</p><h1 id="第6章-字符串"><a href="#第6章-字符串" class="headerlink" title="第6章 字符串"></a>第6章 字符串</h1><h2 id="6-2-反转字符串"><a href="#6-2-反转字符串" class="headerlink" title="6.2 反转字符串"></a>6.2 反转字符串</h2><p><strong>344. Reverse String</strong></p><p><strong>Q: </strong>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p><p>You must do this by modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> with <code>O(1)</code> extra memory.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">char</span> temp;<br>      <br>        <span class="hljs-keyword">while</span>(i &lt;= j)&#123;<br>            temp = s[i];<br>            s[i] = s[j];<br>            s[j] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本的swap思想，关注点在于 i &lt;= j 和 i &lt; j 都是成立的，但是后者可以少判断一个i = j，可以节省判断的一点点时间。</p><h2 id="6-3-反转字符串-II"><a href="#6-3-反转字符串-II" class="headerlink" title="6.3 反转字符串 II"></a>6.3 反转字符串 II</h2><p><strong>541. Reverse String II</strong></p><p><strong>Q: </strong>Given a string <code>s</code> and an integer <code>k</code>, reverse the first <code>k</code> characters for every <code>2k</code> characters counting from the start of the string.</p><p>If there are fewer than <code>k</code> characters left, reverse all of them. If there are less than <code>2k</code> but greater than or equal to <code>k</code> characters, then reverse the first <code>k</code>characters and leave the other as original.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] charArr = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i += (<span class="hljs-number">2</span> * k)) &#123;<br>            <span class="hljs-comment">// the rest is less than the k, reverse all the rest</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> s.length() - i;<br>            <span class="hljs-keyword">if</span> (rest &lt; k) &#123;<br>                reverseChar(charArr, i, s.length() - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArr);<br>            &#125; <br><br>            <span class="hljs-comment">// 交换的位置是左边i，右边i + (k - 1)</span><br>            reverseChar(charArr, i, (i + k) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArr);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseChar</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">char</span> temp;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            temp = arr[left];<br>            arr[left] = arr[right];<br>            arr[right] = temp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路：先分析出交换的方法总共就有两种，交换前k个和交换所有，交换剩余所有是特殊的，所以我们把它放在前面当作特殊条件，只要出现了直接得到结果不用进行多余的判断。</p><h2 id="6-4-反转字符串里的单词"><a href="#6-4-反转字符串里的单词" class="headerlink" title="6.4 反转字符串里的单词"></a>6.4 反转字符串里的单词</h2><p><strong>151. Reverse Words in a String</strong></p><p><strong>Q: </strong>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p><p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p><p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p><p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>      <span class="hljs-type">char</span>[] a = s.toCharArray();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length;<br><br>      <span class="hljs-comment">// step 1. reverse the whole string</span><br>      reverse(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// step 2. reverse each word</span><br>      reverseWords(a, n);<br>      <span class="hljs-comment">// step 3. clean up spaces</span><br>      <span class="hljs-keyword">return</span> cleanSpaces(a, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j || i &lt; n &amp;&amp; a[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++; <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; i || j &lt; n &amp;&amp; a[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++; <span class="hljs-comment">// skip non spaces</span><br>        reverse(a, i, j - <span class="hljs-number">1</span>);                      <span class="hljs-comment">// reverse the word</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// trim leading, trailing and multiple spaces</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">cleanSpaces</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="hljs-string">&#x27; &#x27;</span>) j++;             <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] != <span class="hljs-string">&#x27; &#x27;</span>) a[i++] = a[j++]; <span class="hljs-comment">// keep non spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="hljs-string">&#x27; &#x27;</span>) j++;             <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">if</span> (j &lt; n) a[i++] = <span class="hljs-string">&#x27; &#x27;</span>;                      <span class="hljs-comment">// keep only one space</span><br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(a).substring(<span class="hljs-number">0</span>, i);<br>    &#125;<br><br>    <span class="hljs-comment">// reverse a[] from a[i] to a[j]</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>      <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[i];<br>        a[i++] = a[j];<br>        a[j--] = t;<br>      &#125;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>三大关键部分：字符串反转，单词反转，去除空格。</p><p>reverseWords部分，i代表的是字符串的起点，j代表的是字符串的终点，i先跳过空格，j再跳过所有字符。</p><p>CleanSpace部分，把循环里面的步骤分为：1⃣️ 跳过空格，直到找到非空停止。2⃣️ 把非空的值填入到数组的头部，一直重复，直到找到下一个空格。(j &lt; n) 就是用来防止如果后面不再出现空格了，如何退出循环。<3⃣️ 找到下次非空的话，代表有下一个需要进行处理的字母，就将之前填充好的字母的下一位填充一个空格，结束本次循环> </p><h2 id="6-6-使用KMP匹配字符串"><a href="#6-6-使用KMP匹配字符串" class="headerlink" title="6.6 使用KMP匹配字符串"></a>6.6 使用KMP匹配字符串</h2><p><strong>28. Implement strStr()</strong></p><p><strong>Q: </strong>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p><p><strong>Clarification:</strong></p><p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String">indexOf()</a>).</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span>(haystack == <span class="hljs-literal">null</span> || needle == <span class="hljs-literal">null</span> || needle.length() &gt; haystack.length()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-type">int</span>[] next = kmpPreprocess(needle);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; haystack.length() &amp;&amp; j &lt; needle.length()) &#123;<br>          <span class="hljs-comment">// 找到了就继续往后找</span><br>            <span class="hljs-keyword">if</span>(haystack.charAt(i) == needle.charAt(j)) &#123;<br>                i++; j++;<br>            <span class="hljs-comment">// 如果匹配串中此位置不相等，匹配串就回退next数组的j - 1位置的值</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 如果字符串没有找到匹配串中的值，并且匹配串还未成功匹配</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span>= needle.length() ? i - j : -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] kmpPreprocess(String s) &#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-comment">// 直接用前缀表作next数组</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>          <span class="hljs-comment">// 向前回退，在j = 0或者s[i] == s[j]时退出</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 找到相同的前后缀</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-comment">// 将j(前缀的长度)赋给next[i]</span><br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>KMP思想，利用next数组作为匹配的方法。两种构造next数组方法的区别就在于匹配的地方，如果由前缀表统一减一来构造next数组，那么遇到不匹配的地方直接回归对应下标的next数组的数值就行了；不减一的方法，遇到不匹配的地方就查找前一位下标的next数组对应的数值进行回退。</p><p>之所以为什么是next[j - 1]是因为，由于当前j位置是不匹配的但j - 1的位置之前的都是匹配的，所以我们要回到尽可能远离起始的位置（根据相同前后缀），也就是next[j - 1]存储的位置信息。</p><h2 id="6-7-找到重复的子字符串"><a href="#6-7-找到重复的子字符串" class="headerlink" title="6.7 找到重复的子字符串"></a>6.7 找到重复的子字符串</h2><p><strong>459. Repeated Substring Pattern</strong></p><p><strong>Q: </strong>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] next = kmpPreprocess(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % (len - (next[len - <span class="hljs-number">1</span>])) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] kmpPreprocess(String s) &#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-comment">// 直接用前缀表作next数组</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>          <span class="hljs-comment">// 向前回退，在j = 0或者s[i] == s[j]时退出</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 找到相同的前后缀</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-comment">// 将j(前缀的长度)赋给next[i]</span><br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果len % (len - (next[len - 1])) == 0，则说明(数组长度 - 最长相等前后缀的长度)正好可以被数组的长度整除，该字符串中有重复的数组。</p><p>len - 1代表的是最后一位next数组。用前缀表不用-1，因为前缀表本身就+1了。</p><p>Cral哥写的这种比较好理解，我一直让j充当相同的j前缀的长度，如果往后遍历的i一直是后缀的起始位置。不用考虑i和j之间的元素，只需要看i和j的位置。基本步调是(和初始是一样的)i在前面，j在后面，如果相同了j++跟上，i继续走一个，如果出现了不一样的，则一直往前回退到有相同的(也可能一直回退到开头)，然后继续按之前的步调走，直到后缀遍历完成。</p><p>PS：其中对于前缀表减1的那种方法和这种方法主要的区别是前缀表那种，预处理方便，前缀表减少1那种，遍历的时候方便。方便指好思考。</p><h1 id="第7章-栈与队列"><a href="#第7章-栈与队列" class="headerlink" title="第7章 栈与队列"></a>第7章 栈与队列</h1><h2 id="7-2-用栈组成队列"><a href="#7-2-用栈组成队列" class="headerlink" title="7.2 用栈组成队列"></a>7.2 用栈组成队列</h2><p><strong>232. Implement Queue using Stacks</strong></p><p><strong>Q: </strong>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p><p>Implement the <code>MyQueue</code> class:</p><ul><li><code>void push(int x)</code> Pushes element x to the back of the queue.</li><li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li><li><code>int peek()</code> Returns the element at the front of the queue.</li><li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code>otherwise.</li></ul><p><strong>Notes:</strong></p><ul><li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li><li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</li></ul><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <br>    <span class="hljs-comment">// 待处理part</span><br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">stkIn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <span class="hljs-comment">// 预备输出part</span><br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">stkOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stkIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 只有当stkOut为空的时候才导入stkIn的peek</span><br>        <span class="hljs-keyword">if</span> (stkOut.empty()) &#123;<br>            <span class="hljs-comment">// 导入全部的stkIn</span><br>            <span class="hljs-keyword">while</span> (!stkIn.empty()) &#123;<br>                stkOut.push(stkIn.peek());<br>                stkIn.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出栈不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) stkOut.peek();<br>        stkOut.pop();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 只有当stkOut为空的时候才导入stkIn的peek</span><br>        <span class="hljs-keyword">if</span> (stkOut.empty()) &#123;<br>            <span class="hljs-comment">// 导入全部的stkIn</span><br>            <span class="hljs-keyword">while</span> (!stkIn.empty()) &#123;<br>                stkOut.push(stkIn.peek());<br>                stkIn.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出栈不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) stkOut.peek();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (stkIn.empty() &amp;&amp; stkOut.empty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用两个队列，一个用来输入一个用来输出。特别要注意的是关注输出栈是不是空的，如果非空要优先处理输出栈的（pop和peek方法）</p><h2 id="7-3-用队列组成栈"><a href="#7-3-用队列组成栈" class="headerlink" title="7.3 用队列组成栈"></a>7.3 用队列组成栈</h2><p><strong>225. Implement Stack using Queues</strong></p><p><strong>Q: </strong></p><p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p><p>Implement the <code>MyStack</code> class:</p><ul><li><code>void push(int x)</code> Pushes element x to the top of the stack.</li><li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li><li><code>int top()</code> Returns the element on the top of the stack.</li><li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code>otherwise.</li></ul><p><strong>Notes:</strong></p><ul><li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code>operations are valid.</li><li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</li></ul><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// Push element x onto stack.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue.add(x);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)<br>            queue.add(queue.poll());<br>            n--;<br>    &#125;<br><br>    <span class="hljs-comment">// Removes the element on top of the stack.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        queue.poll();<br>    &#125;<br><br>    <span class="hljs-comment">// Get the top element.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br><br>    <span class="hljs-comment">// Return whether the stack is empty.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里和之前的用栈组成队列不太一样，可以只使用一个，总体来讲是个缓存的思想，将队头的元素重新放回到队尾(双队列也如此)。</p><h2 id="7-4-匹配括号"><a href="#7-4-匹配括号" class="headerlink" title="7.4 匹配括号"></a>7.4 匹配括号</h2><p><strong>20. Valid Parentheses</strong></p><p><strong>Q: </strong>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code>and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Character&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>      <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() != c)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先学会一点，匹配对的问题可以用栈来解决(先出现的左符号要最后匹配右符号，这样正好符合栈的特点)。对于这道题我们反过来想，当匹配到左符号，就将对应的右符号压入栈，然后往后匹配看看后面有没有对应的右符号。</p><h2 id="7-5-逆波兰表达式"><a href="#7-5-逆波兰表达式" class="headerlink" title="7.5 逆波兰表达式"></a>7.5 逆波兰表达式</h2><p><strong>150. Evaluate Reverse Polish Notation</strong></p><p><strong>Q: </strong>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</p><p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer or another expression.</p><p><strong>Note</strong> that division between two integers should truncate toward zero.</p><p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        <span class="hljs-type">int</span> a,b;<br>Stack&lt;Integer&gt; S = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br><span class="hljs-keyword">for</span> (String s : tokens) &#123;<br><span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;+&quot;</span>)) &#123;<br>S.add(S.pop()+S.pop());<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>b = S.pop();<br>a = S.pop();<br>S.add(a / b);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;*&quot;</span>)) &#123;<br>S.add(S.pop() * S.pop());<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>b = S.pop();<br>a = S.pop();<br>S.add(a - b);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>S.add(Integer.parseInt(s));<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> S.pop();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用栈来存之前的路径，如果是数字就入栈，如果是符号就出栈前两位数字进行计算，将结果再入栈。</p><h2 id="7-6-滑动窗口最大值"><a href="#7-6-滑动窗口最大值" class="headerlink" title="7.6 滑动窗口最大值"></a>7.6 滑动窗口最大值</h2><p><strong>239. Sliding Window Maximum</strong></p><p><strong>Q: </strong>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code>which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p><p>Return <em>the max sliding window</em>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义数组</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-comment">//弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出</span><br>    <span class="hljs-comment">//同时判断队列当前是否为空</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; val == deque.peek()) &#123;<br>            deque.poll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出</span><br>    <span class="hljs-comment">//保证队列元素单调递减</span><br>    <span class="hljs-comment">//比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.add(val);<br>    &#125;<br>    <span class="hljs-comment">//队列队顶元素始终为最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> deque.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//存放结果元素的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//自定义队列</span><br>        <span class="hljs-type">MyQueue</span> <span class="hljs-variable">myQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br>        <span class="hljs-comment">//先将前k的元素放入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            myQueue.add(nums[i]);<br>        &#125;<br>        res[num++] = myQueue.peek();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//滑动窗口移除最前面的元素，移除是判断该元素是否放入队列</span><br>            myQueue.poll(nums[i - k]);<br>            <span class="hljs-comment">//滑动窗口加入最后面的元素</span><br>            myQueue.add(nums[i]);<br>            <span class="hljs-comment">//记录对应的最大值</span><br>            res[num++] = myQueue.peek();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//解法二</span><br><span class="hljs-comment">//利用双端队列手动实现单调队列</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可</span><br><span class="hljs-comment"> * 单调队列类似 （tail --&gt;） 3 --&gt; 2 --&gt; 1 --&gt; 0 (--&gt; head) (右边为头结点，元素存的是下标)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        ArrayDeque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span><br>            <span class="hljs-comment">// 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="hljs-number">1</span>)&#123;<br>                deque.poll();<br>            &#125;<br>            <span class="hljs-comment">// 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br><br>            deque.offer(i);<br><br>            <span class="hljs-comment">// 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span><br>            <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>)&#123;<br>                res[idx++] = nums[deque.peek()];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>deque 双端队列：如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名 <strong>Deque</strong> 。 <strong>Java</strong>集合提供了接口 <strong>Deque</strong> 来实现一个双端队列，它的功能是： 既可以添加到队尾，也可以添加到队首； 既可以从队首获取，又可以从队尾获取。</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Queue</th><th style="text-align:left">Deque</th></tr></thead><tbody><tr><td style="text-align:left">添加元素到队尾</td><td style="text-align:left">add(E e) / offer(E e)</td><td style="text-align:left">addLast(E e) / offerLast(E e)</td></tr><tr><td style="text-align:left">取队首元素并删除</td><td style="text-align:left">E remove() / E poll()</td><td style="text-align:left">E removeFirst() / E pollFirst()</td></tr><tr><td style="text-align:left">取队首元素但不删除</td><td style="text-align:left">E element() / E peek()</td><td style="text-align:left">E getFirst() / E peekFirst()</td></tr><tr><td style="text-align:left">添加元素到队首</td><td style="text-align:left">无</td><td style="text-align:left">addFirst(E e) / offerFirst(E e)</td></tr><tr><td style="text-align:left">取队尾元素并删除</td><td style="text-align:left">无</td><td style="text-align:left">E removeLast() / E pollLast()</td></tr><tr><td style="text-align:left">取队尾元素但不删除</td><td style="text-align:left">无</td><td style="text-align:left">E getLast() / E peekLast()</td></tr></tbody></table></div><h2 id="7-7-前k个高频元素"><a href="#7-7-前k个高频元素" class="headerlink" title="7.7 前k个高频元素"></a>7.7 前k个高频元素</h2><p><strong>347. Top K Frequent Elements</strong></p><p><strong>Q: </strong>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-comment">// 记录频率</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();<br>        <span class="hljs-comment">// 根据map的value值正序排，相当于一个小顶堆</span><br>        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;<br>            queue.offer(entry);<br>            <span class="hljs-keyword">if</span> (queue.size() &gt; k) &#123;<br>                queue.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = queue.poll().getKey();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题目主要涉及到如下三块内容：</p><ol><li>要统计元素出现频率</li><li>对频率排序</li><li>找出前K个高频元素</li></ol><h2 id="7-8-接雨水"><a href="#7-8-接雨水" class="headerlink" title="7.8 接雨水"></a>7.8 接雨水</h2><p><strong>42. Trapping Rain Water</strong></p><p><strong>Q: </strong>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftMax[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> rightMax[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        rightMax[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; n;i++) &#123;<br>            leftMax[i] = Math.max(leftMax[i - <span class="hljs-number">1</span>], height[i]);<br>            rightMax[n - i - <span class="hljs-number">1</span>] = Math.max(rightMax[n - i], height[n - i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">trappedWater</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            trappedWater += Math.min(leftMax[i], rightMax[i]) - height[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> trappedWater;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一列雨水的高度主要取决于左侧最高的柱子和右侧的最高的柱子之间的最矮的柱子的高度</p><p>由于决定当前坐标的位置盛水的高度只取决于其左右两边的围栏的最小值（木桶效应），所以我们需要建立两个数组用来存储当前位置的其左右两边的水桶的高度最大值。</p><p>Step1: 我们先将同一个坐标位置下的左右两边最大的高度存储下来</p><p>Step2: 我们求解水量 Math.min(leftMax[i], rightMax[i]) - height[i]</p><h1 id="第8章-二叉树"><a href="#第8章-二叉树" class="headerlink" title="第8章 二叉树"></a>第8章 二叉树</h1><h2 id="8-1-二叉树前中后序遍历"><a href="#8-1-二叉树前中后序遍历" class="headerlink" title="8.1 二叉树前中后序遍历"></a>8.1 二叉树前中后序遍历</h2><h3 id="8-1-1-前序遍历"><a href="#8-1-1-前序遍历" class="headerlink" title="8.1.1 前序遍历"></a>8.1.1 前序遍历</h3><p><strong>144. Binary Tree Preorder Traversal</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        preorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        result.add(root.val);   <span class="hljs-comment">// get value of root</span><br>        preorder(root.left, result); <span class="hljs-comment">// left</span><br>        preorder(root.right, result); <span class="hljs-comment">// right</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根左右顺序递归进去，遍历树和图还是比较好想的，因为可以正向思维往深了走。</p><h3 id="8-1-2-中序遍历"><a href="#8-1-2-中序遍历" class="headerlink" title="8.1.2 中序遍历"></a><strong>8.1.2 中序遍历</strong></h3><p><strong>94. Binary Tree Inorder Traversal</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        inorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorder(root.left, result);    <span class="hljs-comment">// left</span><br>        result.add(root.val); <span class="hljs-comment">// get value of root</span><br>        inorder(root.right, result); <span class="hljs-comment">// right</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>左根右顺序递归进去</p><h3 id="8-1-3-后序遍历"><a href="#8-1-3-后序遍历" class="headerlink" title="8.1.3 后序遍历"></a><strong>8.1.3 后序遍历</strong></h3><p><strong>145. Binary Tree Postorder Traversal</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the postorder traversal of its nodes’ values</em>.</p><p><strong>A：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        postorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorder(root.left, result); <span class="hljs-comment">// left</span><br>        postorder(root.right, result); <span class="hljs-comment">// right</span><br>        result.add(root.val); <span class="hljs-comment">// get value of root</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-2-二叉树层序遍历"><a href="#8-2-二叉树层序遍历" class="headerlink" title="8.2 二叉树层序遍历"></a>8.2 二叉树层序遍历</h2><p><strong>102. Binary Tree Level Order Traversal</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p><p><strong>A：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;  <br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();  <br>        queue.add(root);  <br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;  <br>          List&lt;Integer&gt; itemList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>          <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();  <br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;  <br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();  <br>            itemList.add(node.val);  <br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;  <br>              queue.offer(node.left);  <br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;  <br>              queue.offer(node.right);  <br>            &#125;  <br>          &#125;  <br>          res.add(itemList);   <br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>层序遍历的关键在于队列的使用。我们先将根放入队列中，然后终止判定为队列为空，那么如何保证他不会空呢？由于每次出栈一个元素后就把他的左右子树放进队列（如果有的话），这样可以保证队列不会空而退出循环，并且是按照左右子树的顺序也保证了后面的层序遍历仍然是从左往右。</p><p>跟行有关的二叉树可以优先选择层序遍历。</p><p><strong>EXTEND QUESTIONS:</strong></p><p>107、199、637、429、515、116、104</p><h2 id="8-11-二叉树的所有路径"><a href="#8-11-二叉树的所有路径" class="headerlink" title="8.11 二叉树的所有路径"></a>8.11 二叉树的所有路径</h2><p><strong>257. Binary Tree Paths</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p><p>A <strong>leaf</strong> is a node with no children.</p><p><strong>A:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>    &#125;<br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;strconv.Itoa(root.Val)&#125;<br>    &#125;<br>    tmpLeft := binaryTreePaths(root.Left)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmpLeft); i++ &#123;<br>      res = <span class="hljs-built_in">append</span>(res, strconv.Itoa(root.Val)+<span class="hljs-string">&quot;-&gt;&quot;</span>+tmpLeft[i])<br>    &#125;<br>    tmpRight := binaryTreePaths(root.Right)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmpRight); i++ &#123;<br>      res = <span class="hljs-built_in">append</span>(res, strconv.Itoa(root.Val)+<span class="hljs-string">&quot;-&gt;&quot;</span>+tmpRight[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>也是递归的思想，从根向子节点遍历的话用前序遍历（根左右）。tmpLeft代表的是左边收集到的路径，同理tmpRight就是右边收集到的路径。</p><h2 id="8-12-路径总和"><a href="#8-12-路径总和" class="headerlink" title="8.12 路径总和"></a>8.12 路径总和</h2><p><strong>112. Path Sum</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p><p>A <strong>leaf</strong> is a node with no children.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> pathSum(root, targetSum - root.Val)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, count <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &amp;&amp; count == <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 遇到叶子结点，并且计数为0</span><br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 遇到叶子节点,Count不为0，直接返回</span><br>    <br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        count -= root.Left.Val  <span class="hljs-comment">// 递归，处理节点</span><br>        <span class="hljs-keyword">if</span> pathSum(root.Left, count) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        count += root.Left.Val  <span class="hljs-comment">// 回溯，撤销处理结果</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        count -= root.Right.Val  <span class="hljs-comment">// 递归，处理节点</span><br>        <span class="hljs-keyword">if</span> pathSum(root.Right, count) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        count += root.Right.Val  <span class="hljs-comment">// 回溯，撤销处理结果</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>递归和回溯是要在一起的，每一次递归都要有对应的回溯，这里用到的是根左右的形式。递归的话不要仔细去想具体的每一步是怎么样的，而是要关注三部曲，1⃣️入口的样子，2⃣️终止条件，3⃣️中间的处理逻辑。本篇通过leetcode上 <strong>112. 路径总和</strong> 和 <strong>113. 路径总和ii</strong> 详细的讲解了递归函数什么时候需要返回值，什么不需要返回值。</p><p><strong>113. Path Sum II</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals</em> <code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p><p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, sum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> slice [][]<span class="hljs-type">int</span><br>slice = findPath(root, sum, slice, []<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>))<br>    fmt.Println(slice)<br><span class="hljs-keyword">return</span> slice<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPath</span><span class="hljs-params">(root *TreeNode, sum <span class="hljs-type">int</span>, slice [][]<span class="hljs-type">int</span>, path []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;    <br>      <span class="hljs-keyword">return</span> slice<br>    &#125;<br>    sum -= root.Val  <span class="hljs-comment">// 进入一个节点就用当前val减少sum的值</span><br>    path = <span class="hljs-built_in">append</span>(path, root.Val)  <span class="hljs-comment">// 将当前val这个结果加入（一个切片）</span><br>    <span class="hljs-keyword">if</span> sum == <span class="hljs-number">0</span> &amp;&amp; root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// 如果摸到了最末端一个节点并且sum已经被减光</span><br>      slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, path...))  <span class="hljs-comment">// 把之前栈的结果全部导入到slice里面</span><br>        <span class="hljs-keyword">return</span> slice<br>    &#125;<br>    slice = findPath(root.Left, sum, slice, path)<br>    slice = findPath(root.Right, sum, slice, path)<br>    <span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure><p>学习的别人的思路，整体采用的是根左右也就是从上向下遍历的过程。slice是要输出的结果，path用来存储之前走过的路径。只有当sum == 0完全符合条件的时候才将之前存的所有路径都放入切片。</p><p>PS: slice的切片是左闭右开的，所以<code>len(stack) - 1</code>相当于退出去了一位数。</p><h2 id="8-13-构造一颗二叉树"><a href="#8-13-构造一颗二叉树" class="headerlink" title="8.13 构造一颗二叉树"></a>8.13 构造一颗二叉树</h2><p><strong>106. Construct Binary Tree from Inorder and Postorder Traversal</strong></p><p><strong>Q：</strong>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(inorder []<span class="hljs-type">int</span>, postorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>   postorderLen := <span class="hljs-built_in">len</span>(postorder)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>root := &amp;TreeNode&#123;Val: postorder[postorderLen<span class="hljs-number">-1</span>]&#125;<br>    postorder = postorder[:postorderLen<span class="hljs-number">-1</span>]<br>    <br>    <span class="hljs-keyword">for</span> pos, node := <span class="hljs-keyword">range</span> inorder &#123;<br>        <span class="hljs-keyword">if</span> node == root.Val &#123;<br>            root.Left = buildTree(inorder[:pos], postorder[:<span class="hljs-built_in">len</span>(inorder[:pos])])<br>            root.Right = buildTree(inorder[pos+<span class="hljs-number">1</span>:], postorder[<span class="hljs-built_in">len</span>(inorder[:pos]):])<br>        &#125;<br>&#125;<br>  <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>来看一下一共分几步：</p><ul><li>第一步：如果数组大小为零的话，说明是空节点了。</li><li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li><li>第三步：找到当前节点在中序的位置，此处节点看为根</li><li>第四步：<code>root.Left = buildTree(inorder[:pos], postorder[:len(inorder[:pos])])</code>区间是左闭右开，所以我们进行切片，取中序中此点的左侧，和后序中的左边。</li><li>第五步：<code>root.Right = buildTree(inorder[pos+1:], postorder[len(inorder[:pos]):])</code>区间是左闭右开，进行切片，取中序中此点的右侧，和后序列中的右边（因为已经抛开了根节点，所以右侧的所有都是右子树的所有内容。</li></ul><p>全程都是抠出来后序遍历中的数值制作节点，root.Left = [ return root ] 同理right也是这样，我们每一层叠戴的都是下一层的某一个根节点</p><p><strong>105. Construct Binary Tree from Preorder and Inorder Traversal</strong></p><p><strong>Q：</strong>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    root := &amp;TreeNode&#123; Val: preorder[<span class="hljs-number">0</span>] &#125;    <br>    preorder = preorder[<span class="hljs-number">1</span>:]  <span class="hljs-comment">// poll the first preorder value</span><br>    <br>    <span class="hljs-keyword">for</span> pos, node := <span class="hljs-keyword">range</span> inorder &#123; <span class="hljs-comment">// preorder:(before) N L R (now) L R</span><br>        <span class="hljs-keyword">if</span> node == root.Val &#123;<br>            root.Left = buildTree(preorder[:pos], inorder[:pos])<br>            root.Right = buildTree(preorder[pos:], inorder[pos+<span class="hljs-number">1</span>:])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>同理上面的不同的是，pos这里是inorder中L的长度。</p><h2 id="8-14-合并两个二叉树"><a href="#8-14-合并两个二叉树" class="headerlink" title="8.14 合并两个二叉树"></a>8.14 合并两个二叉树</h2><p><strong>617. Merge Two Binary Trees</strong></p><p><strong>Q：</strong>You are given two binary trees <code>root1</code> and <code>root2</code>.</p><p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p><p>Return <em>the merged tree</em>.</p><p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTrees</span><span class="hljs-params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root2 &#125;<br>    <span class="hljs-keyword">if</span> root2 == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root1 &#125;<br>    <br>    root1.Val += root2.Val<br>    root1.Left = mergeTrees(root1.Left, root2.Left)<br>    root1.Right = mergeTrees(root1.Right, root2.Right)<br>    <span class="hljs-keyword">return</span> root1<br>&#125;<br></code></pre></td></tr></table></figure><p>以其中一个为根，以其中一个为参照物进行合并。</p><ul><li>简单题。采用深搜的思路，分别从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。两个二叉树的对应节点可能存在以下三种情况：<ul><li>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</li><li>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</li><li>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</li></ul></li><li>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。用递归实现即可</li></ul><h2 id="8-15-二叉搜索树中的搜索"><a href="#8-15-二叉搜索树中的搜索" class="headerlink" title="8.15 二叉搜索树中的搜索"></a>8.15 二叉搜索树中的搜索</h2><p><strong>700. Search in a Binary Search Tree</strong></p><p><strong>Q：</strong>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p><p>Find the node in the BST that the node’s value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || root.Val == val &#123; <span class="hljs-keyword">return</span> root &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Val &gt; val &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.Left, val)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt; val &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.Right, val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p><strong>因为搜索到目标节点了，就要立即return了，这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。</strong></p><p>（如果你没有写return那么就算找到了我们也没有回去的路了，相当于是停在了找到的点那里）</p><h2 id="8-16-验证二叉搜索树"><a href="#8-16-验证二叉搜索树" class="headerlink" title="8.16 验证二叉搜索树"></a>8.16 验证二叉搜索树</h2><p><strong>98. Validate Binary Search Tree</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p><p>A <strong>valid BST</strong> is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong>the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;&#125;<br>    inOrder(root, &amp;arr)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>        <span class="hljs-keyword">if</span> arr[i - <span class="hljs-number">1</span>] &gt;= arr[i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, arr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, arr)<br>    *arr = <span class="hljs-built_in">append</span>(*arr, root.Val)<br>    inOrder(root.Right, arr)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。</strong></p><p>中序遍历，验证遍历的元素是不是从小到大。我们先存储左根右的数组序列，然后check他的顺序是否是对的。</p><p><code>*arr = append(*arr, root.Val)</code>这里如果不加*的话，代表arr就是个指向isValidBST的arr的一个指针，加了星号才能提取到他指向的内容，并且操作他指向的内容！</p><h2 id="8-17-二叉搜索树的最小绝对值差"><a href="#8-17-二叉搜索树的最小绝对值差" class="headerlink" title="8.17 二叉搜索树的最小绝对值差"></a>8.17 二叉搜索树的最小绝对值差</h2><p><strong>530. Minimum Absolute Difference in BST</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum absolute difference between the values of any two different nodes in the tree</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;&#125;<br>    inOrder(root, &amp;arr)<br>    diff := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>        diff = <span class="hljs-built_in">append</span>(diff, abs(arr[i - <span class="hljs-number">1</span>] - arr[i]))<br>    &#125;<br>    fmt.Print(<span class="hljs-string">&quot;diff: &quot;</span>)<br>    fmt.Println(diff)<br>    min := diff[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(diff); j++ &#123;<br>        <span class="hljs-keyword">if</span> diff[j] &lt; min &#123;<br>            min = diff[j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> min<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -a<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, arr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, arr)<br>    *arr = <span class="hljs-built_in">append</span>(*arr, root.Val)<br>    inOrder(root.Right, arr)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>由于是 BST 树，利用它有序的性质，中根遍历的结果是有序的。中根遍历过程中动态维护前后两个节点的差值，即可找到最小差值。</li><li>此题与第 783 题完全相同。</li></ul><h2 id="8-18-二叉搜索树中的众数"><a href="#8-18-二叉搜索树中的众数" class="headerlink" title="8.18 二叉搜索树中的众数"></a>8.18 二叉搜索树中的众数</h2><p><strong>501. Find Mode in Binary Search Tree</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary search tree (BST) with duplicates, return <em>all the <a href="https://en.wikipedia.org/wiki/Mode_(statistics">mode(s)</a>) (i.e., the most frequently occurred element) in it</em>.</p><p>If the tree has more than one mode, return them in <strong>any order</strong>.</p><p>Assume a BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMode</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    inOrder(root, m)<br>    max := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">if</span> val &gt;= max &#123;<br>            max = val<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">if</span> val == max &#123;<br>            res = <span class="hljs-built_in">append</span>(res, key)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, m)<br>    <span class="hljs-keyword">if</span> _, exist := m[root.Val]; !exist &#123;<br>        m[root.Val] = <span class="hljs-number">1</span><br>    &#125;<br>    m[root.Val] += <span class="hljs-number">1</span><br>    inOrder(root.Right, m)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-19-二叉树的最近公共祖先"><a href="#8-19-二叉树的最近公共祖先" class="headerlink" title="8.19 二叉树的最近公共祖先"></a>8.19 二叉树的最近公共祖先</h2><p><strong>236. Lowest Common Ancestor of a Binary Tree</strong></p><p><strong>Q：</strong>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// stop</span><br>    <span class="hljs-keyword">if</span> root == p || root == q || root == <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-comment">// left</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br>    <span class="hljs-comment">// right</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br>    <span class="hljs-comment">// root</span><br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &amp;&amp; left != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 搜索一条边的写法：</span><br><span class="hljs-keyword">if</span> (递归函数(root.left)) <span class="hljs-keyword">return</span> <br><br><span class="hljs-keyword">if</span> (递归函数(root.right)) <span class="hljs-keyword">return</span> <br><br><span class="hljs-comment">// 搜索整个树写法：</span><br>left = 递归函数(root.left)<br>right = 递归函数(root.right)<br>left与right的逻辑处理<br></code></pre></td></tr></table></figure><p>注意：</p><p>1、p和q如果写了肯定是在这个BST里面的，所以必然不会有nil的结果。</p><p>2、我们为什么要回溯某一个right或者left？如果是最简单的情况，我们找的p和q在同一个子树上面，那么返回的就是他们的祖先，如果不在同一个子树上面，返回的就是他们的根节点。知道了这个规则以后，就很好理解了为什么要返回right或者left了，并且为什么是从下往上找而不是从上往下找。逻辑就是，我从下往上左右去找是否有满足的p和q如果都满足了那么此时的root就是p和q的祖父，如果没有满足就是nil，继续往上找。</p><h2 id="8-20-在二叉搜索树中插入一个节点"><a href="#8-20-在二叉搜索树中插入一个节点" class="headerlink" title="8.20 在二叉搜索树中插入一个节点"></a>8.20 在二叉搜索树中插入一个节点</h2><p><strong>701. Insert into a Binary Search Tree</strong></p><p><strong>Q：</strong>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p><p><strong>Notice</strong> that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: val&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &lt; root.Val &#123;<br>        root.Left = insertIntoBST(root.Left, val)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.Right = insertIntoBST(root.Right, val)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这道题目其实是一道简单题目，<strong>但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人</strong>，瞬间感觉题目复杂了很多。</p><p>其实<strong>可以不考虑题目中提示所说的改变树的结构的插入方式。</strong></p><p><strong>有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作</strong>。</p><p>思路：我们找的是一条边，如果是空的节点的话就是找到了该插入的位置，插入即可，剩下的返回的都是现存的节点值。</p><h2 id="8-21-在二叉搜索树中删除一个节点"><a href="#8-21-在二叉搜索树中删除一个节点" class="headerlink" title="8.21 在二叉搜索树中删除一个节点"></a>8.21 在二叉搜索树中删除一个节点</h2><p><strong>450. Delete Node in a BST</strong></p><p><strong>Q：</strong>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p><p>Basically, the deletion can be divided into two stages:</p><ol><li>Search for a node to remove.</li><li>If the node is found, delete the node.</li></ol><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(root *TreeNode, key <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val == key &#123;<br>        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Right<br>        &#125;<br>        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Left<br>        &#125;<br>        tmp := root.Right<br>        <span class="hljs-keyword">for</span> tmp.Left != <span class="hljs-literal">nil</span> &#123;<br>            tmp = tmp.Left<br>        &#125;<br>        tmp.Left = root.Left<br>        <span class="hljs-keyword">return</span> root.Right<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> key &lt; root.Val &#123;<br>        root.Left = deleteNode(root.Left, key)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.Right = deleteNode(root.Right, key)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>主要的点在于考虑删除节点的位置，有以下五种情况：</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li></ul></li></ul><h2 id="8-22-修剪二叉搜索树"><a href="#8-22-修剪二叉搜索树" class="headerlink" title="8.22 修剪二叉搜索树"></a>8.22 修剪二叉搜索树</h2><p><strong>669. Trim a Binary Search Tree</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p><p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trimBST</span><span class="hljs-params">(root *TreeNode, low <span class="hljs-type">int</span>, high <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Val &lt; low &#123;<br>        right := trimBST(root.Right, low, high)<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &gt; high &#123;<br>        left := trimBST(root.Left, low, high)<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <br>    root.Right = trimBST(root.Right, low, high)<br>    root.Left = trimBST(root.Left, low, high)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。</p><p>思路：</p><p>1、如果此时的节点值小于了最小边界（因为是闭区间），那这个节点就废掉，我们找比他大的（他的右子树中是否有符合的节点）</p><p>2、如果此时的节点值大于了最大边界（因为是闭区间），那这个节点就废掉，我们找比他小的（他的左子树中是否有符合的节点）</p><p>3、拼接分支，类似于之前的用法，如果没有裁剪就返回的是root（当前的节点）如果有裁剪，返回的就是获取的left或者right</p><h2 id="8-23-构建一棵平衡二叉树"><a href="#8-23-构建一棵平衡二叉树" class="headerlink" title="8.23 构建一棵平衡二叉树"></a>8.23 构建一棵平衡二叉树</h2><p><strong>108. Convert Sorted Array to Binary Search Tree</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a <strong>height-balanced</strong> binary search tree</em>.</p><p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;TreeNode&#123;<br>        Val: nums[<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>], <br>        Left: sortedArrayToBST(nums[:<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>]), <br>        Right: sortedArrayToBST(nums[<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>:])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除二叉树节点，增加二叉树节点，都是用递归函数的返回值来完成，这样是比较方便的。</p><ul><li>确定递归终止条件</li></ul><p>如果nums的长度为0，则说明没有数需要放入了，利用了go的切片，注意切片是左闭右开</p><p>Step：</p><p>1、将此时的节点值写成nums的中心</p><p>2、左支是此点的左边所有数组</p><p>3、右支是此点右边的所有数组</p><p>4、迭代，终止条件如上</p><h1 id="第9章-回溯算法"><a href="#第9章-回溯算法" class="headerlink" title="第9章 回溯算法"></a>第9章 回溯算法</h1><p>回溯问题的模板</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">backtracking(参数) &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-1-组合问题"><a href="#9-1-组合问题" class="headerlink" title="9.1 组合问题"></a>9.1 组合问题</h2><p><strong>77. Combinations</strong></p><p><strong>Q：</strong>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers out of the range</em> <code>[1, n]</code>.</p><p>You may return the answer in <strong>any order</strong>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span> || k &gt; n &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;  <span class="hljs-comment">// c is combine</span><br>    generateCombinations(n, k, <span class="hljs-number">1</span>, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateCombinations</span><span class="hljs-params">(n, k, start <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == k &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// for i := start; i &lt;= n; i++ 不剪枝头的写法</span><br>    <span class="hljs-keyword">for</span> i := start; i &lt;= n - (k - <span class="hljs-built_in">len</span>(c)) + <span class="hljs-number">1</span>; i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, i)<br>        generateCombinations(n, k, i + <span class="hljs-number">1</span>, c, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20201123195242899.png" alt="77. Combinations"></p><p><code>i &lt;= n - (k - len(c)) + 1</code>这个条件很关键他可以帮助我们减少分支，去除那些本身为空的答案。n 本身是我们可选项的上限，我们只靠start来控制不重复。</p><ol><li>已经选择的元素个数：len(c)</li><li>还需要的元素个数为: k - len(c)          （从后往前数，最开始一层就是k，所以倒数后k个数是最远的起始位置）</li><li><p>在集合n中至多要从该起始位置 : n - (k - len(c)) + 1(start)，开始遍历  </p><p>(翻译过来就是如果总共的n个数减去我们还需要的元素后剩余的最大个数，作为我们起始位置的最远端)</p></li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><h2 id="9-2-组合总和-III"><a href="#9-2-组合总和-III" class="headerlink" title="9.2 组合总和 III"></a>9.2 组合总和 III</h2><p><strong>216. Combination Sum III</strong></p><p><strong>Q：</strong>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p><ul><li>Only numbers <code>1</code> through <code>9</code> are used.</li><li>Each number is used <strong>at most once</strong>.</li></ul><p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum3</span><span class="hljs-params">(k <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span> || k &gt; n &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    generateCombinations(k, n, <span class="hljs-number">1</span>, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateCombinations</span><span class="hljs-params">(k, target, start <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == k &amp;&amp; target == <span class="hljs-number">0</span>&#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>  <br>  <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> &#125;<br><br>    <span class="hljs-keyword">for</span> i := start; i &lt;= <span class="hljs-number">9</span>; i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, i)<br>        generateCombinations(k, target - i, i + <span class="hljs-number">1</span>, c, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>雷同77题，不过遇到一个问题就是当对i进行剪枝的时候，他会爆栈。</p><h2 id="9-3-电话号码的字母组合"><a href="#9-3-电话号码的字母组合" class="headerlink" title="9.3 电话号码的字母组合"></a>9.3 电话号码的字母组合</h2><p><strong>17. Letter Combinations of a Phone Number</strong></p><p><strong>Q：</strong>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> result []<span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;2&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;3&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;4&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;5&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;j&quot;</span>, <span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;6&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;7&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;8&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;v&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;9&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(digits <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    result = []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> digits == <span class="hljs-string">&quot;&quot;</span> &#123;<br>      <span class="hljs-keyword">return</span> result<br>    &#125;<br>    letterFunc(<span class="hljs-string">&quot;&quot;</span>, digits)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterFunc</span><span class="hljs-params">(res <span class="hljs-type">string</span>, digits <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> digits == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        result = <span class="hljs-built_in">append</span>(result, res)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    k := digits[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<span class="hljs-comment">// 选取第一个字母</span><br>    digits = digits[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 剔除第一个字母</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dict[k]); i++ &#123;<br>        res += dict[k][i]<br>        letterFunc(res, digits)<br>        res = res[:<span class="hljs-built_in">len</span>(res) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于go中string的理解不够深。string的处理使用切片的，并且切片以后才能slice才是可以用append的。</p><p><img src="https://img-blog.csdnimg.cn/20201123200304469.png" alt="17. 电话号码的字母组合"></p><p>剩下的就是按照回溯的公式去套题。for里面装的是每层要处理的子集。</p><h2 id="9-4-组合总和（二）"><a href="#9-4-组合总和（二）" class="headerlink" title="9.4 组合总和（二）"></a>9.4 组合总和（二）</h2><p><strong>39. Combination Sum</strong></p><p><strong>Q：</strong>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p><p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p><p>It is <strong>guaranteed</strong> that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    findCombination(candidates, c, target, <span class="hljs-number">0</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCombination</span><span class="hljs-params">(cand, c []<span class="hljs-type">int</span>, target, index <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(cand); i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, cand[i])<br>        findCombination(cand, c, target - cand[i], i, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为元素可以重复，所以index和i组合保证他不往回头（向前）找元素就可以了。</p><p>✨<strong>其中为什么一定要有c附魔给b呢？</strong>这里是深复制和浅复制的问题。如果不 copy 一份，直接把 c 加入到 res 结果数组中，下一轮递归过程中，c 会变，这个变化也会影响到 res 里面的值。如果还不明白的话，你可以把 copy c 的那 2 行代码注释掉，直接把 c append 到 res 中，你再看输出结果就能看到原因了。</p><p><strong>浅拷贝</strong>: 对于仅仅是复制了引用（地址），换句话说，复制了之后，原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响，为<strong>浅拷贝</strong>。 <strong>深拷贝</strong>：而如果是在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响，为<strong>深拷贝</strong></p><p>（简而言之：浅拷贝拷贝的是值，他和原本的指针指的是同一个地方，类似引用，当指针所指内容变了这个拷贝值也变；而深拷贝拷贝的是另一个对象，一个一模一样的对象但是占用的另一个空间，这样就算前者再变也不会影响新拷贝出来的对象）</p><h2 id="9-5-组合总和（三）"><a href="#9-5-组合总和（三）" class="headerlink" title="9.5 组合总和（三）"></a>9.5 组合总和（三）</h2><p><strong>40. Combination Sum II</strong></p><p><strong>Q：</strong>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.</p><p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p><p><strong>Note:</strong> The solution set must not contain duplicate combinations.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum2</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(candidates) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br>c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>sort.Ints(candidates) <span class="hljs-comment">// 这里是去重的关键逻辑</span><br>    findCombination(candidates, c, target, <span class="hljs-number">0</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCombination</span><span class="hljs-params">(cand, c []<span class="hljs-type">int</span>, target, index <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(cand); i++ &#123;<br>        <span class="hljs-comment">// 这里是去重的关键逻辑,本次不取重复数字，下次循环可能会取重复数字</span><br>        <span class="hljs-keyword">if</span> i &gt; index &amp;&amp; cand[i] == cand[i<span class="hljs-number">-1</span>] &#123; <br><span class="hljs-keyword">continue</span><br>&#125;<br>        c = <span class="hljs-built_in">append</span>(c, cand[i])<br>        findCombination(cand, c, target - cand[i], i + <span class="hljs-number">1</span>, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>题目要求出总和为 sum 的所有组合，组合需要去重。这一题是第 39 题的加强版，第 39 题中元素可以重复利用(重复元素可无限次使用)，这一题中元素只能有限次数的利用，因为存在重复元素，并且每个元素只能用一次(重复元素只能使用有限次)</li><li>这一题和第 47 题类似，只不过元素可以反复使用。</li><li>总体来说需要注意的两个重复位置，第一个是通过取得重复的根，从而得到两个同样的结果，第二个就是出现前后颠倒但集合相同的问题。</li></ul><p>所以先排好序（保证了结果肯定是递增的顺序，不会出现 [1, 7] 和 [7, 1] 这种组合，再判断。i &gt; index 表示除了本层的第一个选取的数以外的数，并且这个数和前一个数相同的话跳过。本质上这个判断是去除同一层重复获取的数字是forbidden的。</p><p>选择过程树形结构如图所示</p><p><img src="https://img-blog.csdnimg.cn/20201123202736384.png" alt="40.组合总和II"></p><h2 id="9-6-分割回文串"><a href="#9-6-分割回文串" class="headerlink" title="9.6 分割回文串"></a>9.6 分割回文串</h2><p><strong>131. Palindrome Partitioning</strong></p><p><strong>Q：</strong>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a <strong>palindrome</strong>. Return all possible palindrome partitioning of <code>s</code>.</p><p>A <strong>palindrome</strong> string is a string that reads the same backward as forward.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    c, res := []<span class="hljs-type">string</span>&#123;&#125;, [][]<span class="hljs-type">string</span>&#123;&#125;<br>    findPartition(<span class="hljs-number">0</span>, s, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPartition</span><span class="hljs-params">(start <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, c []<span class="hljs-type">string</span>, res *[][]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(s) &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        sub := s[start : i + <span class="hljs-number">1</span>]  <span class="hljs-comment">// partition</span><br>        <span class="hljs-keyword">if</span> IsPalindrome(sub) &#123; <span class="hljs-comment">// combine</span><br>            c = <span class="hljs-built_in">append</span>(c, sub)<br>            findPartition(i + <span class="hljs-number">1</span>, s, c, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    length := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= length/<span class="hljs-number">2</span>; i++ &#123;<br>      <span class="hljs-keyword">if</span> s[i] != s[length - <span class="hljs-number">1</span> - i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其树形结构为下图</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p><p>这一题的关键在于分割和组合的思想。要先切割，判断是否符合回文串？符合的话才继续进行组合递归下一层。</p><h2 id="9-7-复原IP地址"><a href="#9-7-复原IP地址" class="headerlink" title="9.7 复原IP地址"></a>9.7 复原IP地址</h2><p><strong>93. Restore IP Addresses</strong></p><p><strong>Q：</strong>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p><ul><li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li></ul><p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into</em> <code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>&#125;<br>res, ip := []<span class="hljs-type">string</span>&#123;&#125;, []<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ip, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s <span class="hljs-type">string</span>, start, cut <span class="hljs-type">int</span>, ip []<span class="hljs-type">int</span>, res *[]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> cut == <span class="hljs-number">4</span> &amp;&amp; start == <span class="hljs-built_in">len</span>(s) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ip))<br>        <span class="hljs-built_in">copy</span>(tmp, ip)<br>        resIp := getIp(tmp)<br>        *res = <span class="hljs-built_in">append</span>(*res, resIp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> cut &gt; <span class="hljs-number">4</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        sub := s[start : i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> isValid(sub) &#123;<br>            tmp, _ := strconv.Atoi(sub)<br>            ip = <span class="hljs-built_in">append</span>(ip, tmp)<br>            cut++<br>            dfs(s, i + <span class="hljs-number">1</span>, cut, ip, res)<br>            ip = ip[:<span class="hljs-built_in">len</span>(ip) - <span class="hljs-number">1</span>]<br>            cut--<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; <span class="hljs-built_in">len</span>(s) != <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 0开头的不可以</span><br>    tmp, _ := strconv.Atoi(s)<br>    <span class="hljs-keyword">if</span> (tmp &gt; <span class="hljs-number">255</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIp</span><span class="hljs-params">(ip []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    resIp := strconv.Itoa(ip[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(ip); i++ &#123;<br>      resIp += <span class="hljs-string">&quot;.&quot;</span> + strconv.Itoa(ip[i])<br>    &#125;<br><span class="hljs-keyword">return</span> resIp<br>&#125;<br></code></pre></td></tr></table></figure><p>主要考虑到如下三点：</p><ul><li>段位以0为开头的数字不合法</li><li>段位里有非正整数字符不合法</li><li>段位如果大于255了不合法</li></ul><p><img src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p><p>对于语法的一些注意点，首先int转string（strconv.Itoa）是返回一个值的；string转int（strconv.Atoi）是返回两个值的。</p><p>一些注意点，这道题和分割回文串是很类似的，思想是一样的。首先我们要分割，接着我们要判断分割的sub是否符合条件，如果符合才继续深入到下一层，如果不符合就不继续。</p><h2 id="9-8-子集问题（一）"><a href="#9-8-子集问题（一）" class="headerlink" title="9.8 子集问题（一）"></a>9.8 子集问题（一）</h2><p><strong>78. Subsets</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    cur, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(<span class="hljs-number">0</span>, nums, cur, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, nums, cur []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>  <span class="hljs-comment">// 和之前最不一样的地方就是这里，不限制到叶子结点才加入res</span><br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cur))<br>    <span class="hljs-built_in">copy</span>(tmp, cur)<br>    *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>    <br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(nums) &#123; <span class="hljs-keyword">return</span> &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        cur = <span class="hljs-built_in">append</span>(cur, nums[i]) <span class="hljs-comment">// 原来是切掉一部分，现在是找某一个值</span><br>        dfs(i + <span class="hljs-number">1</span>, nums, cur, res)<br>        cur = cur[:<span class="hljs-built_in">len</span>(cur) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p><p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong></p><p><img src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p><p>从图中红线部分，可以看出<strong>遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合</strong>。</p><h2 id="9-9-子集问题（二）"><a href="#9-9-子集问题（二）" class="headerlink" title="9.9 子集问题（二）"></a><strong>9.9 子集问题（二）</strong></h2><p><strong>90. Subsets II</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsetsWithDup</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    cur, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    sort.Ints(nums)<br>    dfs(<span class="hljs-number">0</span>, nums, cur, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, nums, cur []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cur))<br>    <span class="hljs-built_in">copy</span>(tmp, cur)<br>    *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>    <br>    <span class="hljs-comment">// if start == len(nums) &#123; return &#125;</span><br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> i &gt; start &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        cur = <span class="hljs-built_in">append</span>(cur, nums[i]) <br>        dfs(i + <span class="hljs-number">1</span>, nums, cur, res)<br>        cur = cur[:<span class="hljs-built_in">len</span>(cur) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 []int, []float, []string 这种元素类型是基础类型的切片使用 sort 包提供的下面几个函数进行排序。</p><p>sort.Ints<br>sort.Floats<br>sort.Strings</p><p>用到了之前剪枝的方法，先排序，这样保证如果重复的元素都是挨着的</p><h2 id="9-10-递增子序列"><a href="#9-10-递增子序列" class="headerlink" title="9.10 递增子序列"></a>9.10 递增子序列</h2><p><strong>491. Increasing Subsequences</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code>, return all the different possible increasing subsequences of the given array with <strong>at least two elements</strong>. You may return the answer in <strong>any order</strong>.</p><p>The given array may contain duplicates, and two equal integers should also be considered a special case of increasing sequence.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findSubsequences</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    c, visited, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> _, ok := visited[nums[i]]; ok &#123;<br>          <span class="hljs-keyword">continue</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            visited[nums[i]] = <span class="hljs-literal">true</span><br>            generateIncSubsets(nums, i, c, &amp;res)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateIncSubsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, current <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    c = <span class="hljs-built_in">append</span>(c, nums[current])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) &gt;= <span class="hljs-number">2</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>    &#125;<br>    visited := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := current + <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>      <span class="hljs-comment">// 如果当前数值大于前一个数值，并且没有用过，进入DFS下一层</span><br>        <span class="hljs-keyword">if</span> nums[current] &lt;= nums[i] &#123;<br>            <span class="hljs-keyword">if</span> _, ok := visited[nums[i]]; ok &#123;<br>              <span class="hljs-keyword">continue</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                visited[nums[i]] = <span class="hljs-literal">true</span><br>                generateIncSubsets(nums, i, c, res)<br>            &#125;<br>        &#125;<br>    &#125;<br>    c = c[:<span class="hljs-built_in">len</span>(c)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>给出一个数组，要求找出这个数组中所有长度大于 2 的非递减子序列。子序列顺序和原数组元素下标必须是顺序的，不能是逆序的。</li><li>这一题和第 78 题和第 90 题是类似的题目。第 78 题和第 90 题是求所有子序列，这一题在这两题的基础上增加了非递减和长度大于 2 的条件。需要注意的两点是，原数组中元素可能会重复，最终结果输出的时候需要去重。最终结果输出的去重用 map 处理，数组中重复元素用 DFS 遍历搜索。在每次 DFS 中，用 map 记录遍历过的元素，保证本轮 DFS 中不出现重复的元素，递归到下一层还可以选择值相同，但是下标不同的另外一个元素。外层循环也要加一个 map，这个 map 是过滤每组解因为重复元素导致的重复解，经过过滤以后，起点不同了，最终的解也会不同。</li><li>重点在于对于同一层不能够重复</li></ul><p>树结构</p><p><img src="https://img-blog.csdnimg.cn/20201124200229824.png" alt="491. 递增子序列1"></p><h2 id="9-11-排列问题（一）"><a href="#9-11-排列问题（一）" class="headerlink" title="9.11 排列问题（一）"></a>9.11 排列问题（一）</h2><p><strong>46. Permutations</strong></p><p><strong>Q：</strong>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br>    c, used, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(nums, c, used, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, used <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(tmp, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> !used[nums[i]] &#123;<br>          used[nums[i]] = <span class="hljs-literal">true</span><br>            c = <span class="hljs-built_in">append</span>(c, nums[i])<br>            dfs(nums, c, used, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>            used[nums[i]] = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>树状图</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p><p>大家此时可以感受出排列问题的不同：</p><ul><li>每层都是从0开始搜索而不是startIndex</li><li>需要used数组记录path里都放了哪些元素了</li></ul><p>排列问题是回溯算法解决的经典题目。</p><p>注意map[key]的返回值（value，isExist）</p><h2 id="9-12-排列问题（二）"><a href="#9-12-排列问题（二）" class="headerlink" title="9.12 排列问题（二）"></a>9.12 排列问题（二）</h2><p><strong>47. Permutations II</strong></p><p><strong>Q：</strong>Given a collection of numbers, <code>nums</code>, that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permuteUnique</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br>    c, used, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    sort.Ints(nums)<br>    dfs(nums, c, used, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, used <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(tmp, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> !used[i] &#123;<br>          <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>] &#123; <span class="hljs-comment">// 关键去重语句</span><br>              <span class="hljs-comment">// 当前数值的数在前面已经出现过，并且他的前一个数没有被用过才跳过</span><br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            used[i] = <span class="hljs-literal">true</span><br>            c = <span class="hljs-built_in">append</span>(c, nums[i])<br>            dfs(nums, c, used, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>            used[i] = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>树状图</p><p><img src="https://img-blog.csdnimg.cn/20201124201331223.png" alt="47.全排列II1"></p><p>和 9.11 不同的是我们不但要消除纵向的重复，也要消除横向的重复。纵向的重复就不能单单只是消除。</p><p><code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]</code>为什么要加 !used[i - 1] 呢？因为每一层都要遍历所有的数，如果只是单单的nums[i] == nums[i-1] 就跳过的话，那么所有的层都会跳过，加入 !used[i - 1] 后代表着，在同一层的情况下（因为同一层如果相同的话只能选择其中一个数字，所以相同的数字只能有一位是 true 其他都是 false）如果当前数字和前一个相同的时候跳过。</p><h2 id="9-13-N-皇后问题"><a href="#9-13-N-皇后问题" class="headerlink" title="9.13 N 皇后问题"></a>9.13 N 皇后问题</h2><p><strong>51. N-Queens</strong></p><p><strong>Q：</strong>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code>chessboard such that no two queens attack each other.</p><p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p><p>Each solution contains a distinct board configuration of the n-queens’ placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space, respectively.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    idx, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">string</span>&#123;&#125;<br>    dfs(n, <span class="hljs-number">0</span>, idx, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(n, row <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> row == n &#123;<br>        *res = <span class="hljs-built_in">append</span>(*res, generateBoard(n, idx))<br>        fmt.Println()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>        <span class="hljs-keyword">if</span> isValid(row, col, n, idx) &#123;<br>            idx = <span class="hljs-built_in">append</span>(idx, col)<br>            dfs(n, row + <span class="hljs-number">1</span>, idx, res)<br>            idx = idx[:<span class="hljs-built_in">len</span>(idx) - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(row, col, n <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    col45 := col<br>    col135 := col<br>    <span class="hljs-comment">// 检查列</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(idx); i++ &#123;<br>        <span class="hljs-keyword">if</span> col == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查45˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col45++<br>        <span class="hljs-keyword">if</span> col45 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查135˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col135--<br>        <span class="hljs-keyword">if</span> col135 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateBoard</span><span class="hljs-params">(n <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    board := []<span class="hljs-type">string</span>&#123;&#125;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>      res += <span class="hljs-string">&quot;.&quot;</span><br>    &#125;<br>    <span class="hljs-comment">// 生成棋盘让所有的内容都是...</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; n; row++ &#123;<br>      board = <span class="hljs-built_in">append</span>(board, res)<br>    &#125;<br>    <span class="hljs-comment">// 按照收集到的位置，进行改写有皇后的位置</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; n; row++ &#123;<br>        tmp := []<span class="hljs-type">byte</span>(board[row]) <span class="hljs-comment">// byte才能够修改string的某一位</span><br>        tmp[idx[row]] = <span class="hljs-string">&#x27;Q&#x27;</span><br>        board[row] = <span class="hljs-type">string</span>(tmp)<br>    &#125;<br>    <span class="hljs-keyword">return</span> board<br>&#125;<br></code></pre></td></tr></table></figure><p>首先来看一下皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>树结构</p><p><img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后"></p><p>这种题的大概dfs流程是这样的，首先确定终止条件，然后是难点在于要判断是否要进入下一层这个判断条件是一个难点，第二个难点就是生成棋盘的时间，我是先记录要放棋子的位置再放在最后来生成，也可以从始至终就生成一点点填充。总体来说这两种方法不同的点在于判断的过程不同。</p><h2 id="9-14-解数独"><a href="#9-14-解数独" class="headerlink" title="9.14 解数独"></a>9.14 解数独</h2><p><strong>37. Sudoku Solver</strong></p><p><strong>Q：</strong>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p><ol><li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li><li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li><li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code>sub-boxes of the grid.</li></ol><p>The <code>&#39;.&#39;</code> character indicates empty cells.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>)</span></span>  &#123;<br>    dfs(&amp;board)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(board *[][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// scan</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">9</span>; row++ &#123;<br>        <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; <span class="hljs-number">9</span>; col++ &#123;<br>            <span class="hljs-keyword">if</span> (*board)[row][col] != <span class="hljs-string">&#x27;.&#x27;</span> &#123; <span class="hljs-keyword">continue</span> &#125;<br>            <span class="hljs-comment">// fill</span><br>            <span class="hljs-keyword">var</span> num <span class="hljs-type">byte</span><br>            <span class="hljs-keyword">for</span> num = <span class="hljs-string">&#x27;1&#x27;</span>; num &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; num++ &#123;<br>                <span class="hljs-keyword">if</span> isValid(row, col, num, board) &#123;<br>                  (*board)[row][col] = num   <span class="hljs-comment">// 填充</span><br>                  <span class="hljs-keyword">if</span> dfs(board) == <span class="hljs-literal">true</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                  (*board)[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>   <span class="hljs-comment">// 回溯</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 遍历完了都没有false，返回true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(row, col <span class="hljs-type">int</span>, num <span class="hljs-type">byte</span>, board *[][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// check row</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> num == (*board)[i][col] &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// check col</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++ &#123;<br>        <span class="hljs-keyword">if</span> num == (*board)[row][j] &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// check inner-9</span><br>    startRow := (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span><br>    startCol := (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">for</span> i := startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> num == (*board)[i][j] &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>树状图：</p><p><img src="https://img-blog.csdnimg.cn/2020111720451790.png" alt="37.解数独"></p><p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p><p>判断棋盘是否合法有如下三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>9宫格里是否重复</li></ul><p>注意如果要提取二维数组的地址的元素的话要写 (*a)[ ] [ ] 这样。</p><p>在 check inner-9 的时候遇到检查那9块的问题。首先他们的起始点有 (0, 0) (3, 3) (6, 6)…..通过除 3 以后发现在第一块，但具体的坐标要乘 3 因为毕竟除法过（0，1，2来进行乘法）</p><p>答案有可能不唯一，真正退出的位置是在<code>if dfs(board) == true &#123; return true &#125; // 如果找到合适一组立刻返回</code>这一行。</p><h1 id="第10章-贪心算法"><a href="#第10章-贪心算法" class="headerlink" title="第10章 贪心算法"></a>第10章 贪心算法</h1><ul><li>将问题分解为若子问题。</li><li>找出适合的贪心策略。</li><li>求解每一个子问题的最优解。</li><li>将局部最优堆叠成全局最优</li></ul><h2 id="10-1-分发饼干"><a href="#10-1-分发饼干" class="headerlink" title="10.1 分发饼干"></a>10.1 分发饼干</h2><p><strong>455. Assign Cookie</strong></p><p><strong>Q：</strong>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p><p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code>will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(g []<span class="hljs-type">int</span>, s []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sort.Ints(g)<br>sort.Ints(s)<br>gi, si, res := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> gi &lt; <span class="hljs-built_in">len</span>(g) &amp;&amp; si &lt; <span class="hljs-built_in">len</span>(s) &#123;<br><span class="hljs-keyword">if</span> s[si] &gt;= g[gi] &#123;<br>res++<br>si++<br>gi++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>si++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。</p><p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p><p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p><p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p><p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p><ul><li>假设你想给小朋友们饼干，每个小朋友最多能够给一块饼干。每个小朋友都有一个“贪心指数”，称为 <code>g[i]</code>，<code>g[i]</code> 表示的是这名小朋友需要的饼干大小的最小值。同时，每个饼干都有一个大小值 <code>s[i]</code>，如果 <code>s[j] ≥ g[i]</code>，我们将饼干 <code>j</code> 分给小朋友 <code>i</code> 后，小朋友会很开心。给定数组 <code>g[]</code> 和 <code>s[]</code>，问如何分配饼干，能让更多的小朋友开心。</li><li>这是一道典型的简单贪心题。贪心题一般都伴随着排序。将 <code>g[]</code> 和 <code>s[]</code> 分别排序。按照最难满足的小朋友开始给饼干，依次往下满足，最终能满足的小朋友数就是最终解。</li></ul><p>注意一个饼干最多给一个孩子。</p><h2 id="10-2-摆动排序"><a href="#10-2-摆动排序" class="headerlink" title="10.2 摆动排序"></a>10.2 摆动排序</h2><p><strong>376. Wiggle Subsequence</strong></p><p><strong>Q：</strong>A <strong>wiggle sequence</strong> is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.</p><ul><li>For example, <code>[1, 7, 4, 9, 2, 5]</code> is a <strong>wiggle sequence</strong> because the differences <code>(6, -3, 5, -7, 3)</code> alternate between positive and negative.</li><li>In contrast, <code>[1, 4, 7, 2, 5]</code> and <code>[1, 7, 4, 5, 5]</code> are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.</li></ul><p>A <strong>subsequence</strong> is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.</p><p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>wiggle subsequence</strong> of</em> <code>nums</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br>&#125;<br>res := <span class="hljs-number">1</span><br>prevDiff := nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> prevDiff != <span class="hljs-number">0</span> &#123;<br>res = <span class="hljs-number">2</span><br>&#125;<br>    <span class="hljs-comment">// 从第三个数开始，i下标的位置是 前中后 的后</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        diff := nums[i] - nums[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-comment">// 如果是波峰或者波谷的话</span><br>        <span class="hljs-keyword">if</span> diff &gt; <span class="hljs-number">0</span> &amp;&amp; prevDiff &lt;= <span class="hljs-number">0</span> || diff &lt; <span class="hljs-number">0</span> &amp;&amp; prevDiff &gt;= <span class="hljs-number">0</span> &#123;<br>            res++<br>            prevDiff = diff<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>题目要求找到摆动序列最长的子序列。本题可以用贪心的思路，记录当前序列的上升和下降的趋势。扫描数组过程中，每扫描一个元素都判断是“峰”还是“谷”，根据前一个是“峰”还是“谷”做出对应的决定。利用贪心的思想找到最长的摆动子序列。</li></ul><p><code>diff &gt; 0 &amp;&amp; prevDiff &lt;= 0 || diff &lt; 0 &amp;&amp; prevDiff &gt;= 0</code>这句的判断里面为什么要有等号呢？因为其实你只要保证在 i - 1 位置之前的都是平的，或者与其后面的单调趋势是相反的，就可以保证单调性的不同（平 to 增减，增 to 减，减 to 增）</p><h2 id="10-3-最大子序和"><a href="#10-3-最大子序和" class="headerlink" title="10.3 最大子序和"></a>10.3 最大子序和</h2><p><strong>53. Maximum Subarray</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p><p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSum := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>      <span class="hljs-comment">// 就加正数</span><br>        <span class="hljs-keyword">if</span> nums[i] + nums[i<span class="hljs-number">-1</span>] &gt; nums[i] &#123;<br>            nums[i] += nums[i<span class="hljs-number">-1</span>]<br>        &#125;<br>      <span class="hljs-comment">// 如果当前子序列大于了之前存的总和就存下</span><br>        <span class="hljs-keyword">if</span> nums[i] &gt; maxSum &#123;<br>            maxSum = nums[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>局部最优：</strong>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p>全局最优：选取最大“连续和”</p><p>这个思想主要是不利用额外的存储空间。举例，[-2,1,-3,4,-1,2,1,-5,4] 我们贪心的点在于必须要子序列要是在增加的才加上。尽管倒数第二个 -5 + 6 = 1 是比自身大的但是没有大过 maxSum，也无所谓。所以总结一下就是，我们要加入当前数的前一个数，如果是上升的值就保存，并且如果当前 sum 后整体大于了统计的 max，就更新 max 要不就继续遍历。就像我们的人生一样，我们就记录我们能前进的值，忘掉那些退步的地方，并且记录下我们max的里程碑。</p><p>golang的最大值和最小值的定义 <a href="https://blog.csdn.net/lishanleilixin/article/details/103269904">https://blog.csdn.net/lishanleilixin/article/details/103269904</a></p><h2 id="10-4-买卖股票的最佳时机-II"><a href="#10-4-买卖股票的最佳时机-II" class="headerlink" title="10.4 买卖股票的最佳时机 II"></a>10.4 买卖股票的最佳时机 II</h2><p><strong>122. Best Time to Buy and Sell Stock II</strong></p><p><strong>Q：</strong>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p><p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    profit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        <span class="hljs-keyword">if</span> prices[i] - prices[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &#123;<br>            profit += prices[i] - prices[i - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II"></p><p>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p><p>那么只收集正利润就是贪心所贪的地方！</p><p><strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</p><h2 id="10-5-跳跃游戏"><a href="#10-5-跳跃游戏" class="headerlink" title="10.5 跳跃游戏"></a>10.5 跳跃游戏</h2><p><strong>55. Jump Game</strong></p><p><strong>Q：</strong>You are given an integer array <code>nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p><p>Return <code>true</code> <em>if you can reach the last index, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    cover := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果是跳跃数组的长度为1</span><br>    <span class="hljs-comment">// 每次在当前范围里面找每个数</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= cover; i++ &#123;<br>        cover = max(i + nums[i], cover) <span class="hljs-comment">// 覆盖面的选择，从当前cover范围和当前位置代表的未来cover范围二选一</span><br>        <span class="hljs-keyword">if</span> cover &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果能包含到最后一个位置就代表能跳到</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 没找到就false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> a &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>图片势力</p><p><img src="https://img-blog.csdnimg.cn/20201124154758229.png" alt="55.跳跃游戏"></p><h2 id="10-6-跳跃游戏-II"><a href="#10-6-跳跃游戏-II" class="headerlink" title="10.6 跳跃游戏 II"></a>10.6 跳跃游戏 II</h2><p><strong>45. Jump Game II</strong></p><p><strong>Q：</strong>Given an array of non-negative integers <code>nums</code>, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Your goal is to reach the last index in the minimum number of jumps.</p><p>You can assume that you can always reach the last index.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    curDistance := <span class="hljs-number">0</span> <span class="hljs-comment">// 当前覆盖的最远距离下标</span><br>    step := <span class="hljs-number">0</span> <span class="hljs-comment">// 记录走的最大步数</span><br>    nextDistance := <span class="hljs-number">0</span> <span class="hljs-comment">// 下一步覆盖的最远距离下标</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123; <span class="hljs-comment">// 注意这里是小于等于nums.size() - 2，这是关键所在</span><br>        nextDistance = max(i + nums[i], nextDistance) <span class="hljs-comment">// 更新下一步覆盖的最远距离下标</span><br>        <span class="hljs-keyword">if</span> i == curDistance &#123; <span class="hljs-comment">// 遇到当前覆盖的最远距离下标</span><br>            curDistance = nextDistance <span class="hljs-comment">// 更新当前覆盖的最远距离下标</span><br>            step++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> step<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> a &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>理解本题的关键在于：<strong>以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点</strong>，这个范围内最小步数一定可以跳到，不用管具体是怎么跳的，不纠结于一步究竟跳一个单位还是两个单位。</p><p><img src="https://img-blog.csdnimg.cn/20201201232445286.png" alt="45.跳跃游戏II2"></p><p>一个个找，找每个范围内的最远距离。cur 记录的是当前可以跳的最远距离，所以一旦 i = cur 的时候说明要走下一跳了</p><p>（只有 i 到达了上一次记录的最远距离的时候，才更新 cur = next 的最远距离）</p><h2 id="10-7-加油站"><a href="#10-7-加油站" class="headerlink" title="10.7 加油站"></a>10.7 加油站</h2><p><strong>134. Gas Station</strong></p><p><strong>Q：</strong>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>ith</code> station is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>ith</code> station to its next <code>(i + 1)th</code> station. You begin the journey with an empty tank at one of the gas stations.</p><p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong></p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(gas []<span class="hljs-type">int</span>, cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>curSum := <span class="hljs-number">0</span><br>totalSum := <span class="hljs-number">0</span><br>start := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(gas); i++ &#123;<br>curSum += gas[i] - cost[i]<br>totalSum += gas[i] - cost[i]<br><span class="hljs-keyword">if</span> curSum &lt; <span class="hljs-number">0</span> &#123;<br>start = i+<span class="hljs-number">1</span><br>curSum = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> totalSum &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">return</span> start<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20201213162821958.png" alt="134.加油站"></p><p>我把所有的差值加一遍只要是能总和大于0肯定能跑完，然后找第一个可以 gas - cost &gt; 0 的位置作为起点</p><h2 id="10-8-分发糖果"><a href="#10-8-分发糖果" class="headerlink" title="10.8 分发糖果"></a>10.8 分发糖果</h2><p><strong>135. Candy</strong></p><p><strong>Q：</strong>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p><p>You are giving candies to these children subjected to the following requirements:</p><ul><li>Each child must have at least one candy.</li><li>Children with a higher rating get more candies than their neighbors.</li></ul><p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">candy</span><span class="hljs-params">(ratings []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// initialization</span><br>    candy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ratings))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(ratings); i++ &#123;<br>        candy[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// front to back</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(ratings); i++ &#123;<br>        <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>] &#123;<br>            candy[i] = candy[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    fmt.Println(candy)<br>    <span class="hljs-comment">// back to front</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(ratings) - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] &#123;<br>            candy[i] = max(candy[i], candy[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">// 因为是更新数值，所以用max，并不是单纯的覆盖</span><br>        &#125;<br>    &#125;<br>    fmt.Println(candy)<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> candy &#123;<br>        res += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>这在leetcode上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p><p>那么本题我采用了两次贪心的策略：</p><ul><li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li><li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li></ul><p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p><h2 id="10-9-柠檬水找零"><a href="#10-9-柠檬水找零" class="headerlink" title="10.9 柠檬水找零"></a>10.9 柠檬水找零</h2><p><strong>860. Lemonade Change</strong></p><p><strong>Q：</strong>At a lemonade stand, each lemonade costs <code>$5</code>. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a <code>$5</code>, <code>$10</code>, or <code>$20</code> bill. You must provide the correct change to each customer so that the net transaction is that the customer pays <code>$5</code>.</p><p>Note that you do not have any change in hand at first.</p><p>Given an integer array <code>bills</code> where <code>bills[i]</code> is the bill the <code>ith</code> customer pays, return <code>true</code> <em>if you can provide every customer with the correct change, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(bills []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    count5 := <span class="hljs-number">0</span><br>    count10 := <span class="hljs-number">0</span><br>    count20 := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(bills); i++ &#123;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">5</span> &#123;<br>            count5++<br>        &#125;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">if</span> count5 &lt;= <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>            count5--<br>            count10++<br>        &#125;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">20</span> &#123;<br>          <span class="hljs-comment">// 优先处理10块的，再处理5块的</span><br>            <span class="hljs-keyword">if</span> count5 &gt; <span class="hljs-number">0</span> &amp;&amp; count10 &gt; <span class="hljs-number">0</span> &#123;<br>                count5--<br>                count10--<br>                count20++<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> count10 == <span class="hljs-number">0</span> &amp;&amp; count5 &gt;= <span class="hljs-number">3</span> &#123;<br>                count5 -= <span class="hljs-number">3</span><br>                count20++<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li></ul><p>局部最优推算出全局最优</p><h2 id="10-10-用最少数量的箭射爆气球"><a href="#10-10-用最少数量的箭射爆气球" class="headerlink" title="10.10 用最少数量的箭射爆气球"></a>10.10 用最少数量的箭射爆气球</h2><p><strong>452. Minimum Number of Arrows to Burst Balloons</strong></p><p><strong>Q：</strong>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array <code>points</code> where <code>points[i] = [xstart, xend]</code> denotes a balloon whose <strong>horizontal diameter</strong>stretches between <code>xstart</code> and <code>xend</code>. You do not know the exact y-coordinates of the balloons.</p><p>Arrows can be shot up <strong>directly vertically</strong> (in the positive y-direction) from different points along the x-axis. A balloon with <code>xstart</code> and <code>xend</code> is <strong>burst</strong> by an arrow shot at <code>x</code> if <code>xstart &lt;= x &lt;= xend</code>. There is <strong>no limit</strong> to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</p><p>Given the array <code>points</code>, return <em>the <strong>minimum</strong> number of arrows that must be shot to burst all balloons</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(points [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// 弓箭数</span><br>    <span class="hljs-comment">// 先按照第一位排序</span><br>    sort.Slice(points, <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> points[i][<span class="hljs-number">0</span>] &lt; points[j][<span class="hljs-number">0</span>]<br>    &#125;)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(points); i++&#123;<br>        <span class="hljs-keyword">if</span> points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; points[i][<span class="hljs-number">0</span>] &#123; <span class="hljs-comment">// 如果前一位的右边界小于后一位的左边界，则一定不重合</span><br>            res++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            points[i][<span class="hljs-number">1</span>] = min(points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], points[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界,覆盖该位置的值，留到下一步使用</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><p>贪心，先确定一个思路，再看这个思路是否有bug，没有bug就可以使用贪心</p><p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？</p><p>尝试一下举反例，发现没有这种情况。</p><p>sort.Slice使用指南<a href="http://books.studygolang.com/Mastering_Go_ZH_CN/eBook/chapter3/03.3.7.html">http://books.studygolang.com/Mastering_Go_ZH_CN/eBook/chapter3/03.3.7.html</a></p><h2 id="10-11-合并区间"><a href="#10-11-合并区间" class="headerlink" title="10.11 合并区间"></a>10.11 合并区间</h2><p><strong>56. Merge Intervals</strong></p><p><strong>Q：</strong>Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//先从小到大排序</span><br>    sort.Slice(intervals,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>]&lt;intervals[j][<span class="hljs-number">0</span>]<br>    &#125;)<br>    <span class="hljs-comment">//再弄重复的</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(intervals)<span class="hljs-number">-1</span>;i++&#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">1</span>] &gt;= intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&#123;<br>            intervals[i][<span class="hljs-number">1</span>] = max(intervals[i][<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<span class="hljs-comment">//赋值最大值</span><br>            intervals = <span class="hljs-built_in">append</span>(intervals[:i+<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">2</span>:]...)<br>            i--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> intervals<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a &gt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我按照左边界排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。</p><p><code>intervals = append(intervals[:i+1],intervals[i+2:]...)</code>将第一位提取出来，后面跳过下一位把后面的接过来，相当于剔除了第二位。</p><h2 id="10-12-单调递增的数字"><a href="#10-12-单调递增的数字" class="headerlink" title="10.12 单调递增的数字"></a>10.12 单调递增的数字</h2><p><strong>738. Monotone Increasing Digits</strong></p><p><strong>Q：</strong>An integer has <strong>monotone increasing digits</strong> if and only if each pair of adjacent digits <code>x</code> and <code>y</code> satisfy <code>x &lt;= y</code>.</p><p>Given an integer <code>n</code>, return <em>the largest number that is less than or equal to</em> <code>n</code><em>with <strong>monotone increasing digits</strong></em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(N <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    s := strconv.Itoa(N) <span class="hljs-comment">// 将数字转为字符串，方便使用下标</span><br>    ss := []<span class="hljs-type">byte</span>(s) <span class="hljs-comment">// 将字符串转为byte数组，方便更改。</span><br>    n := <span class="hljs-built_in">len</span>(ss)<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> N<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span> ; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> ss[i - <span class="hljs-number">1</span>] &gt; ss[i] &#123; <span class="hljs-comment">// 前一个大于后一位,前一位减1，后面的全部置为9</span><br>            ss[i - <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j := i ; j &lt; n; j++ &#123; <span class="hljs-comment">// 后面的全部置为9</span><br>                ss[j] = <span class="hljs-string">&#x27;9&#x27;</span><br>            &#125;<br>        &#125; <br>    &#125;<br>    res, _ := strconv.Atoi(<span class="hljs-type">string</span>(ss))<br>    <span class="hljs-keyword">return</span> res <br>&#125;<br></code></pre></td></tr></table></figure><p>从前往后遍历不行，因为会修改原本的值，但是从后往前不会。</p><p>对于go语言如果要修改string的内容最好先转化成byte数组。</p><p>前一个大于后一位,前一位减1，后面的全部置为9（因为要求最大）！</p><h1 id="第11章-动态规划"><a href="#第11章-动态规划" class="headerlink" title="第11章 动态规划"></a>第11章 动态规划</h1><p>动规五部曲：</p><p>这里我们要用一个一维dp数组来保存递归的结果</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol><li>确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p><ol><li>dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></table></figure><ol><li>确定遍历顺序</li></ol><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><h2 id="11-1-斐波那契数列"><a href="#11-1-斐波那契数列" class="headerlink" title="11.1 斐波那契数列"></a>11.1 斐波那契数列</h2><p><strong>509. Fibonacci Number</strong></p><p><strong>Q：</strong>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(n)</span></span> = <span class="hljs-built_in">F</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(n - <span class="hljs-number">2</span>), <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p>Given <code>n</code>, calculate <code>F(n)</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> n&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>      dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-2-爬楼梯"><a href="#11-2-爬楼梯" class="headerlink" title="11.2 爬楼梯"></a>11.2 爬楼梯</h2><p><strong>70. Climbing Stairs</strong></p><p><strong>Q：</strong>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p><p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> n&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">// 第一层的方法数量</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span> <span class="hljs-comment">// 第二层的方法数量</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化第一步和第二步，然后递归后面的步子，关键在于递推公式的生成</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p><p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p><p>走一步和走两步的方法总和</p><h2 id="11-3-使用最小花费爬楼梯"><a href="#11-3-使用最小花费爬楼梯" class="headerlink" title="11.3 使用最小花费爬楼梯"></a>11.3 使用最小花费爬楼梯</h2><p><strong>746. Min Cost Climbing Stairs</strong></p><p><strong>Q：</strong>You are given an integer array <code>cost</code> where <code>cost[i]</code> is the cost of <code>ith</code> step on a staircase. Once you pay the cost, you can either climb one or two steps.</p><p>You can either start from the step with index <code>0</code>, or the step with index <code>1</code>.</p><p>Return <em>the minimum cost to reach the top of the floor</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cost))<br>    dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>]<br>    dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(cost); i++ &#123;<br>        dp[i] = min(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> min(dp[<span class="hljs-built_in">len</span>(dp) - <span class="hljs-number">1</span>], dp[<span class="hljs-built_in">len</span>(dp) - <span class="hljs-number">2</span>]) <span class="hljs-comment">// 返回的是踏上楼顶的前一步或者前两步</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]</strong>。</p><p><strong>可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]</strong>。</p><p>那么究竟是选dp[i-1]还是dp[i-2]呢？</p><p>一定是选最小的，所以dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];</p><p><strong>注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的</strong>，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值</p><h2 id="11-4-不同路径-I"><a href="#11-4-不同路径-I" class="headerlink" title="11.4 不同路径 I"></a>11.4 不同路径 I</h2><p><strong>62. Unique Paths</strong></p><p><strong>Q：</strong>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>&#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> dp[<span class="hljs-number">0</span>] &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>] <span class="hljs-comment">// 从左边来的和右边来的数量的总和</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>按照动规五部曲来分析：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i] [j] ：表示从（0 ，0）出发，到(i, j) 有dp[i] [j]条不同的路径。</p><ol><li>确定递推公式</li></ol><p>想要求dp[i] [j]，只能有两个方向来推导出来，即dp[i - 1] [j] 和 dp[i] [j - 1]。</p><p>此时在回顾一下 dp[i - 1] [j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。</p><p>那么很自然，dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，因为dp[i] [j]只有这两个方向过来。</p><ol><li>dp数组的初始化</li></ol><p>如何初始化呢，首先dp[i] [0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0] [j]也同理。</p><p>所以初始化代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ol><li>确定遍历顺序</li></ol><p>这里要看一下递归公式dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，dp[i] [j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p><p>这样就可以保证推导dp[i] [j]的时候，dp[i - 1] [j] 和 dp[i] [j - 1]一定是有数值的。</p><ol><li>举例推导dp数组</li></ol><h2 id="11-5-不同路径-II"><a href="#11-5-不同路径-II" class="headerlink" title="11.5 不同路径 II"></a>11.5 不同路径 II</h2><p><strong>63. Unique Paths II</strong></p><p><strong>Q：</strong>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m-1][n-1]</code>). The robot can only move either down or right at any point in time.</p><p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p><p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The testcases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(obstacleGrid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(obstacleGrid)<br>    n := <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">if</span> obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">for</span> k := i; k &lt; m; k++ &#123;<br>                dp[k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果发现了这一行有一个石头，那么这一行从石头开始后面的全部到达不了</span><br>            &#125;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">for</span> k := j; k &lt; n; k++ &#123;<br>                dp[<span class="hljs-number">0</span>][k] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果发现了这一列有一个石头，那么这一列从石头开始后面的全部到达不了</span><br>            &#125;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span> &#123;   <br>                dp[i][j] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果此点有障碍物，那么这点就不是通路就为0</span><br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>有两个关键点，第一个是初始化的时候要注意，如果出现了障碍物，那么剩下的一行或者一列将都是0；第二个是当进行的时候如果当前点是障碍点了，那么就把它置0，因为对于下一个点来说，他并不能帮助下一点到达自己的目的地。</p><h2 id="11-6-整数拆分"><a href="#11-6-整数拆分" class="headerlink" title="11.6 整数拆分"></a>11.6 整数拆分</h2><p><strong>343. Integer Break</strong></p><p><strong>Q：</strong>Given an integer <code>n</code>, break it into the sum of <code>k</code> <strong>positive integers</strong>, where <code>k &gt;= 2</code>, and maximize the product of those integers.</p><p>Return <em>the maximum product you can get</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123; <span class="hljs-comment">// 真正dp序列的循环，把n这个数拆出来一个然后分析看看这么拆是不是最小的乘积</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i - <span class="hljs-number">1</span>; j++ &#123; <span class="hljs-comment">// 正整数所以j从1开始，为什么不能到达i-1，比如n是10，那么我能拆开的两个数就是9和1</span><br>            dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)) <span class="hljs-comment">// j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n] <span class="hljs-comment">// 由于前面在比较的同时需要给dp[n]赋值，必须保证当到达dp[n]的时候，其数值是最大的，所以在递推公式中有dp[n]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>动规五部曲，分析如下：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p><p>dp[i]的定义讲贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！</p><ol><li>确定递推公式🌟</li></ol><p>可以想 dp[i]最大乘积是怎么得到的呢？</p><p>其实可以从1遍历j，然后有两种渠道得到dp[i].</p><p>一个是j * (i - j) 直接相乘。</p><p>一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。</p><p><strong>也可以这么理解，j <em> (i - j) 是单纯的把整数拆分为两个数相乘，而j </em> dp[i - j]是拆分成两个以及两个以上的个数相乘。</strong></p><p>如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了</p><ol><li>dp的初始化</li></ol><p>不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？</p><p>有的题解里会给出dp[0] = 1，dp[1] = 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。</p><p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。</p><p>拆分0和拆分1的最大乘积是多少？</p><p>这是无解的。</p><p>这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！</p><ol><li>确定遍历顺序</li></ol><p>确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) <em> j, dp[i - j] </em> j));</p><p>dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。</p><p>枚举j的时候，是从1开始的。i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。</p><ol><li>举例推导dp数组</li></ol><h2 id="11-7-不同的二叉树搜索树"><a href="#11-7-不同的二叉树搜索树" class="headerlink" title="11.7 不同的二叉树搜索树"></a>11.7 不同的二叉树搜索树</h2><p><strong>96. Unique Binary Search Trees</strong></p><p><strong>Q：</strong>Given an integer <code>n</code>, return <em>the number of structurally unique <strong>BST’</strong>s (binary search trees) which has exactly</em> <code>n</code> <em>nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>) <span class="hljs-comment">// 包含 0 + (1 to n)</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i; j++ &#123; <span class="hljs-comment">// 假如只有左子树或者右子树的时候就会 j = i</span><br>            dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]</strong>。</p><p>也可以理解是i个的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p><p>以下分析如果想不清楚，就来回想一下dp[i]的定义</p><ol><li>确定递推公式</li></ol><p>在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p><p>j相当于是头结点的元素，从1遍历到i为止。</p><p>所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p><p>其中第二个循环for j的那个就是为了找寻不同的数量的左子树。之所以右子树的数量为 i - j 是因为左子树加上右子树的总和为 i - 1</p><ol><li>dp数组如何初始化</li></ol><p>初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。</p><p>那么dp[0]应该是多少呢？</p><p>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。</p><p>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。</p><p>所以初始化dp[0] = 1</p><ol><li>确定遍历顺序</li></ol><p>首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p><p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>        dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>举例推导dp数组</li></ol><p>n为5时候的dp数组状态如图：</p><p><img src="https://img-blog.csdnimg.cn/20210107093253987.png" alt="96.不同的二叉搜索树3"></p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Study</title>
    <link href="/2022/04/20/SQL-Study/"/>
    <url>/2022/04/20/SQL-Study/</url>
    
    <content type="html"><![CDATA[<h1 id="基本书写规范"><a href="#基本书写规范" class="headerlink" title="基本书写规范"></a>基本书写规范</h1><p>对于 SQL 初学者，在写 SQL 语句时，只要遵守下面几个书写规则，就可以避免很多错误。这些规则都非常简单，下面我们来逐一介绍。</p><p><strong>SQL 语句要以分号<code>;</code>结尾</strong></p><p>在 RDBMS （关系型数据库）当中，SQL 语句是逐条执行的，一条 SQL 语句代表着数据库的一个操作。</p><p>我们通常在句子的句尾加注标点表示这句话结束，中文句子以句号<code>。</code>结尾，英文以点号<code>.</code>结尾，而 SQL 语句则使用英文分号<code>;</code>结尾。</p><p><strong>SQL 语句不区分大小写</strong></p><p>SQL 不区分关键字的大小写。例如，不管写成 SELECT 还是 select，解释都是一样的。表名和列名也是如此。（但是注意字符串是要分大小写的）</p><p>提示：关键字是数据库事先定义的，有特别意义的单词。</p><p>虽然可以根据个人喜好选择大写还是小写（或大小写混杂），但为了理解起来更加容易，本教程使用以下规则来书写 SQL 语句。</p><ul><li>关键字大写</li><li>数据库名、表名和列名等小写</li></ul><p>需要注意的是，插入到表中的数据是区分大小写的。例如，向数据库中插入单词 Computer、COMPUTER 或 computer，这三个是不一样的数据</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/dbStudy.png" alt="dbStudy"></p><p>自学网网址：<a href="http://www.xuesql.cn/">http://www.xuesql.cn/</a></p><h1 id="一-SQL的SELECT使用"><a href="#一-SQL的SELECT使用" class="headerlink" title="一. SQL的SELECT使用"></a>一. SQL的SELECT使用</h1><h2 id="1-1-条件查询语法"><a href="#1-1-条件查询语法" class="headerlink" title="1.1 条件查询语法"></a>1.1 条件查询语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql"># 条件查询语法<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition<br>    AND/OR another_condition<br>    AND/OR …;<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Operator（操作符）</th><th>Condition（解释）</th><th>Example（例子）</th></tr></thead><tbody><tr><td>=</td><td>Case sensitive exact string comparison (<em>notice the single equals</em>)完全等于</td><td>col_name = “abc”</td></tr><tr><td>!= or &lt;&gt;</td><td>Case sensitive exact string inequality comparison 不等于</td><td>col_name != “abcd”</td></tr><tr><td>LIKE</td><td>Case insensitive exact string comparison 没有用通配符等价于 =</td><td>col_name LIKE “ABC”</td></tr><tr><td>NOT LIKE</td><td>Case insensitive exact string inequality comparison 没有用通配符等价于 !=</td><td>col_name NOT LIKE”ABCD”</td></tr><tr><td>%</td><td>Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) 通配符，代表匹配0个以上的字符</td><td>col_name LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”) “%AT%” 代表AT 前后可以有任意字符</td></tr><tr><td>_</td><td>Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) 和% 相似，代表1个字符</td><td>col_name LIKE “AN_” (matches “AND”, but not “AN”)</td></tr><tr><td>IN (…)</td><td>String exists in a list 在列表</td><td>col_name IN (“A”, “B”, “C”)</td></tr></tbody></table></div><h2 id="1-2-DISTINCT语法"><a href="#1-2-DISTINCT语法" class="headerlink" title="1.2 DISTINCT语法"></a>1.2 DISTINCT语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 选取出唯一的结果的语法<br>SELECT DISTINCT column, another_column, …<br>FROM mytable<br>WHERE condition(s);<br></code></pre></td></tr></table></figure><p>因为 <code>DISTINCT</code> 语法会直接删除重复的行，我们还会学习 <code>GROUP BY</code> 语句， <code>GROUP BY</code> 也会返回唯一的行，不过可以对具有相同的 属性值的行做一些统计计算，比如：求和。</p><h2 id="1-3-结果排序-Ordering-results"><a href="#1-3-结果排序-Ordering-results" class="headerlink" title="1.3 结果排序(Ordering results)"></a>1.3 结果排序(Ordering results)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 结果排序（ordered results）<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition(s)<br>ORDER BY column ASC/DESC;<br></code></pre></td></tr></table></figure><p><code>ORDER BY col_name</code> 这句话的意思就是让结果按照 col_name 列的具体值做 ASC升序 或 DESC 降序，对数字来说就是升序 1，2，3，… 或降序 … 3,2,1。对于文本列，升序和降序指的是按文本的字母序。</p><h2 id="1-4-通过Limit选取部分结果"><a href="#1-4-通过Limit选取部分结果" class="headerlink" title="1.4 通过Limit选取部分结果"></a>1.4 通过Limit选取部分结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># limited查询<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition(s)<br>ORDER BY column ASC/DESC<br>LIMIT num_limit OFFSET num_offset;<br></code></pre></td></tr></table></figure><p><code>LIMIT</code> 和 <code>OFFSET</code> 子句通常和<code>ORDER BY</code> 语句一起使用，当我们对整个结果集排序之后，我们可以 <code>LIMIT</code>来指定只返回多少行结果 ,用 <code>OFFSET</code>来指定从哪一行开始返回。你可以想象一下从一条长绳子剪下一小段的过程，我们通过 <code>OFFSET</code> 指定从哪里开始剪，用 <code>LIMIT</code> 指定剪下多少长度。</p><p>PS：num_offset 是从0开始的</p><h2 id="1-5-数据库范式"><a href="#1-5-数据库范式" class="headerlink" title="1.5 数据库范式"></a>1.5 数据库范式</h2><p>数据库范式是数据表设计的规范，在范式规范下，数据库里每个表存储的<strong>重复数据降到最少（这有助于数据的一致性维护）</strong>，同时在数据库范式下，表和表之间不再有很强的数据耦合，可以独立的增长 (ie. 比如汽车引擎的增长和汽车的增长是完全独立的). 范式带来了很多好处，但随着数据表的分离，意味着我们要查询多个数据属性时，需要更复杂的SQL语句，也就是本节开始介绍的多表连接技术。这样SQL的性能也会面临更多的挑战，特别是当大数据量的表很多的情况下。</p><p>如果一个实体（比如Dog）的属性数据被分散到多个数据表中，我们就需要学习如何通过 <code>JOIN</code>连表技术来整合这些数据并找到我们想要查询的数据项。</p><h2 id="1-6-用JOINs进行多表联合查询"><a href="#1-6-用JOINs进行多表联合查询" class="headerlink" title="1.6 用JOINs进行多表联合查询"></a>1.6 用JOINs进行多表联合查询</h2><p><code>主键(primary key)</code>, 一般关系数据表中，都会有一个属性列设置为 <code>主键(primary key)</code>。主键是唯一标识一条数据的，不会重复复（想象你的身份证号码)。一个最常见的主键就是auto-incrementing integer(自增ID，每写入一行数据ID+1, 当然字符串，hash值等只要是每条数据是唯一的也可以设为主键.</p><p>借助<code>主键(primary key)</code>（当然其他唯一性的属性也可以），我们可以把两个表中具有相同 主键ID的数据连接起来（因为一个ID可以简要的识别一条数据，所以连接之后还是表达的同一条数据）（你可以想象一个左右连线游戏）。具体我们用到 <code>JOIN</code> 关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">用LEFT/RIGHT/FULL JOINs 做多表查询<br>SELECT column, another_column, …<br>FROM mytable<br>INNER/LEFT/RIGHT/FULL JOIN another_table<br>    ON mytable.id = another_table.matching_id<br>WHERE condition(s)<br>ORDER BY column, … ASC/DESC<br>LIMIT num_limit OFFSET num_offset;<br></code></pre></td></tr></table></figure><p>PS：<code>INNER JOIN</code> 可以简写做 <code>JOIN</code>. 两者是相同的意思，但我们还是会继续写作 <code>INNER JOIN</code> 以便和后面的 <code>LEFT JOIN</code>， <code>RIGHT JOIN</code>等相比较。(内连接，左连接，右连接)</p><p>LEFT JOIN：左边的全部存在，右边的有缺失就NULL</p><p>RIGHT JOIN：右边的全部存在，左边的有缺失就NULL</p><h2 id="1-7-查询条件中处理NULL"><a href="#1-7-查询条件中处理NULL" class="headerlink" title="1.7 查询条件中处理NULL"></a>1.7 查询条件中处理NULL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 在查询条件中处理 NULL<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE column IS/IS NOT NULL<br>AND/OR another_condition<br>AND/OR …;<br></code></pre></td></tr></table></figure><p>判断是否为NULL</p><h2 id="1-8-查询中使用表达式"><a href="#1-8-查询中使用表达式" class="headerlink" title="1.8 查询中使用表达式"></a>1.8 查询中使用表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 包含表达式的例子<br>SELECT  particle_speed / 2.0 AS half_particle_speed (对结果做了一个除2）<br>FROM physics_data<br>WHERE ABS(particle_position) * 10.0 &gt;500<br>            （条件要求这个属性绝对值乘以10大于500）;<br>         <br># AS使用别名<br>SELECT col_expression AS expr_description, …<br>FROM mytable;<br><br># 属性列和表取别名的例子<br>SELECT column AS better_column_name, …<br>FROM a_long_widgets_table_name AS mywidgets<br>INNER JOIN widget_sales<br>  ON mywidgets.id = widget_sales.widget_id;<br></code></pre></td></tr></table></figure><p><strong>e.g【难题】John Lasseter导演的每部电影每分钟值多少钱,告诉我最高的3个电影名和价值就可以</strong> </p><p>Table: Movies(Read - Only)</p><div class="table-container"><table><thead><tr><th>Id</th><th>Title</th><th>Director</th><th>Year</th><th>Length_minutes</th></tr></thead><tbody><tr><td>1</td><td>Toy Story</td><td>John Lasseter</td><td>1995</td><td>81</td></tr><tr><td>2</td><td>A Bug’s Life</td><td>John Lasseter</td><td>1998</td><td>95</td></tr><tr><td>3</td><td>Toy Story 2</td><td>John Lasseter</td><td>1999</td><td>93</td></tr><tr><td>4</td><td>Monsters, Inc.</td><td>Pete Docter</td><td>2001</td><td>92</td></tr><tr><td>5</td><td>Finding Nemo</td><td>Finding Nemo</td><td>2003</td><td>107</td></tr><tr><td>6</td><td>The Incredibles</td><td>Brad Bird</td><td>2004</td><td>116</td></tr><tr><td>7</td><td>Cars</td><td>John Lasseter</td><td>2006</td><td>117</td></tr><tr><td>8</td><td>Ratatouille</td><td>Brad Bird</td><td>2007</td><td>115</td></tr><tr><td>9</td><td>WALL-E</td><td>Andrew Stanton</td><td>2008</td><td>104</td></tr><tr><td>10</td><td>Up</td><td>Pete Docter</td><td>2009</td><td>101</td></tr><tr><td>11</td><td>Toy Story 3</td><td>Lee Unkrich</td><td>2010</td><td>103</td></tr><tr><td>12</td><td>Cars 2</td><td>John Lasseter</td><td>2011</td><td>120</td></tr><tr><td>13</td><td>Brave</td><td>Brenda Chapman</td><td>2012</td><td>102</td></tr><tr><td>14</td><td>Monsters University</td><td>Dan Scanlon</td><td>2013</td><td>110</td></tr></tbody></table></div><p>Table: Boxoffice(Read - Only)</p><div class="table-container"><table><thead><tr><th>Movie_id</th><th>Rating</th><th>Domestic_sales</th><th>International_sales</th></tr></thead><tbody><tr><td>5</td><td>8.2</td><td>380843261</td><td>555900000</td></tr><tr><td>14</td><td>7.4</td><td>268492764</td><td>475066843</td></tr><tr><td>8</td><td>8</td><td>206445654</td><td>417277164</td></tr><tr><td>12</td><td>6.4</td><td>191452396</td><td>368400000</td></tr><tr><td>3</td><td>7.9</td><td>245852179</td><td>239163000</td></tr><tr><td>6</td><td>8</td><td>261441092</td><td>370001000</td></tr><tr><td>9</td><td>8.5</td><td>223808164</td><td>297503696</td></tr><tr><td>11</td><td>8.4</td><td>415004880</td><td>648167031</td></tr><tr><td>1</td><td>8.3</td><td>191796233</td><td>170162503</td></tr><tr><td>7</td><td>7.2</td><td>244082982</td><td>217900167</td></tr><tr><td>10</td><td>8.3</td><td>293004164</td><td>438338580</td></tr><tr><td>4</td><td>8.1</td><td>289916256</td><td>272900000</td></tr><tr><td>2</td><td>7.2</td><td>162798565</td><td>200600000</td></tr><tr><td>13</td><td>7.2</td><td>237283207</td><td>301700000</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 输出变量，AS用来起别名<br>SELECT title, ((domestic_sales + international_sales) / length_minutes) AS sale_value FROM movies AS m<br><br># 内连接两个表，ON通过什么属性<br>INNER JOIN boxoffice AS b<br>ON m.id = b.movie_id<br><br># WHERE逻辑控制判断<br>WHERE director = &quot;John Lasseter&quot;<br><br># ORDER BY排序<br>ORDER BY sale_value DESC<br><br># LIMIT限制，OFFSET表示起始位置<br>LIMIT 3 <br></code></pre></td></tr></table></figure><h2 id="1-9-常见的统计函数"><a href="#1-9-常见的统计函数" class="headerlink" title="1.9 常见的统计函数"></a>1.9 常见的统计函数</h2><p>下面介绍几个常用统计函数:</p><div class="table-container"><table><thead><tr><th>Function</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td><strong>COUNT(<em>*</em></strong>)<strong>, </strong>COUNT(<strong><em>column</em></strong>)**</td><td style="text-align:left">计数！COUNT(*) 统计数据行数，COUNT(column) 统计column非NULL的行数。</td></tr><tr><td><strong>MIN(*</strong>column<strong>*)</strong></td><td style="text-align:left">找column最小的一行。</td></tr><tr><td><strong>MAX(*</strong>column<strong>*)</strong></td><td style="text-align:left">找column最大的一行。</td></tr><tr><td><strong>AVG(*</strong>column*)</td><td style="text-align:left">对column所有行取平均值。</td></tr><tr><td><strong>SUM(*</strong>column<strong>*)</strong></td><td style="text-align:left">对column所有行求和。</td></tr></tbody></table></div><p>分组统计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 用分组的方式统计，通过分组的方式对局部特征进行处理<br>SELECT AGG_FUNC(column_or_expression) AS aggregate_description, …<br>FROM mytable<br>WHERE constraint_expression<br>GROUP BY column;<br></code></pre></td></tr></table></figure><p>到目前为止，我们的Query查询已经有点复杂了，不过还好我们已经基本把查询语法介绍完了。在 <code>GROUP BY</code> 分组语法中，我们知道数据库是先对数据做<code>WHERE</code>，然后对结果做分组，如果我们要对分组完的数据再筛选出几条如何办？ （想一下按年份统计电影票房，要筛选出&gt;100万的年份？） </p><p>一个不常用的语法 <code>HAVING</code> 语法将用来解决这个问题，他可以对分组之后的数据再做SELECT筛选.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 用HAVING进行筛选，进行GROUP BY之后的二级分类<br>SELECT group_by_column, AGG_FUNC(column_expression) AS aggregate_result_alias, …<br>FROM mytable<br>WHERE condition<br>GROUP BY column<br>HAVING group_condition;<br></code></pre></td></tr></table></figure><p><strong>e.g【难题】按角色分组算出每个角色按有办公室和没办公室的统计人数(列出角色，数量，有无办公室,注意一个角色如果部分有办公室，部分没有需分开统计）</strong> </p><div class="table-container"><table><thead><tr><th>Role</th><th>Name</th><th>Building</th><th>Years_employed</th></tr></thead><tbody><tr><td>Engineer</td><td>Becky A.</td><td>1e</td><td>4</td></tr><tr><td>Engineer</td><td>Dan B.</td><td>1e</td><td>2</td></tr><tr><td>Engineer</td><td>Sharon F.</td><td>1e</td><td>6</td></tr><tr><td>Engineer</td><td>Dan M.</td><td>1e</td><td>4</td></tr><tr><td>Engineer</td><td>Malcom S.</td><td>1e</td><td>1</td></tr><tr><td>Artist</td><td>Tylar S.</td><td>2w</td><td>2</td></tr><tr><td>Artist</td><td>Sherman D.</td><td>2w</td><td>8</td></tr><tr><td>Artist</td><td>Jakob J.</td><td>2w</td><td>6</td></tr><tr><td>Artist</td><td>Lillia A.</td><td>2w</td><td>7</td></tr><tr><td>Artist</td><td>Brandon J.</td><td>2w</td><td>7</td></tr><tr><td>Manager</td><td>Scott K.</td><td>1e</td><td>9</td></tr><tr><td>Manager</td><td>Shirlee M.</td><td>1e</td><td>3</td></tr><tr><td>Manager</td><td>Daria O.</td><td>2w</td><td>6</td></tr><tr><td>Engineer</td><td>Yancy I.</td><td>null</td><td>0</td></tr><tr><td>Artist</td><td>Oliver P.</td><td>null</td><td>0</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT count(*) as count,Role,building is not null as have_building<br>FROM employees <br>group by Role,building is not null<br></code></pre></td></tr></table></figure><p>这里学到了GROUP BY可以进行二级分类。</p><h2 id="1-10-总结"><a href="#1-10-总结" class="headerlink" title="1.10 总结"></a>1.10 总结</h2><p>集合所有的查询相关的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 这才是完整的SELECT查询<br>SELECT DISTINCT column, AGG_FUNC(column_or_expression), …<br>FROM mytable<br>    JOIN another_table<br>      ON mytable.column = another_table.column<br>    WHERE constraint_expression<br>    GROUP BY column<br>    HAVING constraint_expression<br>    ORDER BY column ASC/DESC<br>    LIMIT count OFFSET COUNT;<br></code></pre></td></tr></table></figure><p>一个查询SQL的执行总是先从数据里按条件选出数据，然后对这些数据再次做一些整理处理，按要求返回成结果，让结果尽可能是简单直接的。因为一个查询SQL由很多部分组成，所以搞清楚这些部分的执行顺序还挺重要的，这有助于我们更深刻的理解SQL执行过程。</p><p><strong>‼️查询执行顺序</strong></p><h3 id="1-FROM-和-JOINs"><a href="#1-FROM-和-JOINs" class="headerlink" title="1. FROM 和 JOINs"></a>1. <code>FROM</code> 和 <code>JOIN</code>s</h3><p><code>FROM</code> 或 <code>JOIN</code>会第一个执行，确定一个整体的数据范围. 如果要JOIN不同表，可能会生成一个临时Table来用于 下面的过程。总之第一步可以简单理解为确定一个数据源表（含临时表)</p><h3 id="2-WHERE"><a href="#2-WHERE" class="headerlink" title="2. WHERE"></a>2. <code>WHERE</code></h3><p>我们确定了数据来源 <code>WHERE</code> 语句就将在这个数据源中按要求进行数据筛选，并丢弃不符合要求的数据行，所有的筛选col属性 只能来自<code>FROM</code>圈定的表. AS别名还不能在这个阶段使用，因为可能别名是一个还没执行的表达式</p><h3 id="3-GROUP-BY"><a href="#3-GROUP-BY" class="headerlink" title="3. GROUP BY"></a>3. <code>GROUP BY</code></h3><p>如果你用了 <code>GROUP BY</code> 分组，那<code>GROUP BY</code> 将对之前的数据进行分组，统计等，并将是结果集缩小为分组数.这意味着 其他的数据在分组后丢弃.</p><h3 id="4-HAVING"><a href="#4-HAVING" class="headerlink" title="4. HAVING"></a>4. <code>HAVING</code></h3><p>如果你用了 <code>GROUP BY</code> 分组, <code>HAVING</code> 会在分组完成后对结果集再次筛选。AS别名也不能在这个阶段使用.</p><h3 id="5-SELECT"><a href="#5-SELECT" class="headerlink" title="5. SELECT"></a>5. <code>SELECT</code></h3><p>确定结果之后，<code>SELECT</code>用来对结果col简单筛选或计算，决定输出什么数据.</p><h3 id="6-DISTINCT"><a href="#6-DISTINCT" class="headerlink" title="6. DISTINCT"></a>6. <code>DISTINCT</code></h3><p>如果数据行有重复<code>DISTINCT</code> 将负责排重.</p><h3 id="7-ORDER-BY"><a href="#7-ORDER-BY" class="headerlink" title="7. ORDER BY"></a>7. <code>ORDER BY</code></h3><p>在结果集确定的情况下，<code>ORDER BY</code> 对结果做排序。因为<code>SELECT</code>中的表达式已经执行完了。此时可以用AS别名.</p><h3 id="8-LIMIT-OFFSET"><a href="#8-LIMIT-OFFSET" class="headerlink" title="8. LIMIT / OFFSET"></a>8. <code>LIMIT</code> / <code>OFFSET</code></h3><p>最后 <code>LIMIT</code> 和 <code>OFFSET</code> 从排序的结果中截取部分数据.</p><p><strong>结论</strong></p><p>不是每一个SQL语句都要用到所有的句法，但灵活运用以上的句法组合和深刻理解SQL执行原理将能在SQL层面更好的解决数据问题，而不用把问题 都抛给程序逻辑.</p><p>Table：Movies(Read - Only)</p><div class="table-container"><table><thead><tr><th>Id</th><th>Title</th><th>Director</th><th>Year</th><th>Length_minutes</th></tr></thead><tbody><tr><td>1</td><td>Toy Story</td><td>John Lasseter</td><td>1995</td><td>81</td></tr><tr><td>2</td><td>A Bug’s Life</td><td>John Lasseter</td><td>1998</td><td>95</td></tr><tr><td>3</td><td>Toy Story 2</td><td>John Lasseter</td><td>1999</td><td>93</td></tr><tr><td>4</td><td>Monsters, Inc.</td><td>Pete Docter</td><td>2001</td><td>92</td></tr><tr><td>5</td><td>Finding Nemo</td><td>Finding Nemo</td><td>2003</td><td>107</td></tr><tr><td>6</td><td>The Incredibles</td><td>Brad Bird</td><td>2004</td><td>116</td></tr><tr><td>7</td><td>Cars</td><td>John Lasseter</td><td>2006</td><td>117</td></tr><tr><td>8</td><td>Ratatouille</td><td>Brad Bird</td><td>2007</td><td>115</td></tr><tr><td>9</td><td>WALL-E</td><td>Andrew Stanton</td><td>2008</td><td>104</td></tr><tr><td>10</td><td>Up</td><td>Pete Docter</td><td>2009</td><td>101</td></tr><tr><td>11</td><td>Toy Story 3</td><td>Lee Unkrich</td><td>2010</td><td>103</td></tr><tr><td>12</td><td>Cars 2</td><td>John Lasseter</td><td>2011</td><td>120</td></tr><tr><td>13</td><td>Brave</td><td>Brenda Chapman</td><td>2012</td><td>102</td></tr><tr><td>14</td><td>Monsters University</td><td>Dan Scanlon</td><td>2013</td><td>110</td></tr></tbody></table></div><p>Table：Boxoffice(Read - Only)</p><div class="table-container"><table><thead><tr><th>Movie_id</th><th>Rating</th><th>Domestic_sales</th><th>International_sales</th></tr></thead><tbody><tr><td>5</td><td>8.2</td><td>380843261</td><td>555900000</td></tr><tr><td>14</td><td>7.4</td><td>268492764</td><td>475066843</td></tr><tr><td>8</td><td>8</td><td>206445654</td><td>417277164</td></tr><tr><td>12</td><td>6.4</td><td>191452396</td><td>368400000</td></tr><tr><td>3</td><td>7.9</td><td>245852179</td><td>239163000</td></tr><tr><td>6</td><td>8</td><td>261441092</td><td>370001000</td></tr><tr><td>9</td><td>8.5</td><td>223808164</td><td>297503696</td></tr><tr><td>11</td><td>8.4</td><td>415004880</td><td>648167031</td></tr><tr><td>1</td><td>8.3</td><td>191796233</td><td>170162503</td></tr><tr><td>7</td><td>7.2</td><td>244082982</td><td>217900167</td></tr><tr><td>10</td><td>8.3</td><td>293004164</td><td>438338580</td></tr><tr><td>4</td><td>8.1</td><td>289916256</td><td>272900000</td></tr><tr><td>2</td><td>7.2</td><td>162798565</td><td>200600000</td></tr><tr><td>13</td><td>7.2</td><td>237283207</td><td>301700000</td></tr></tbody></table></div><p><strong>e.g【难题】按导演分组计算销售总额,求出平均销售额冠军（统计结果过滤掉只有单部电影的导演，列出导演名，总销量，电影数量，平均销量) </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(domestic_sales + international_sales) sum_sale, director,COUNT(*) count, AVG(domestic_sales + international_sales) ave_sale FROM movies m<br>INNER JOIN boxoffice b<br>ON m.id = b.movie_id<br>GROUP BY director<br>HAVING count != 1<br>ORDER BY ave_sale DESC<br>LIMIT 1<br></code></pre></td></tr></table></figure><p><strong>Q：</strong>为什么where里面不能count()而having里面可以</p><p><strong>A：</strong>因为聚合函数是做统计用的，所有的聚合方式使用都是，函数名(字段) 对这一个字段进行聚合。但在mysql内部运行机制中，where后面还没有结果，只有select后面才有结果集。所以聚合函数是不能放在where后面,却可以放在select后面。</p><p><strong>e.g【变态难】找出每部电影和单部电影销售冠军之间的销售差，列出电影名，销售额差额</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT title,<br>(SELECT (Domestic_sales + International_sales) FROM movies m<br>JOIN boxoffice b<br>ON m.id = b.movie_id <br>ORDER BY(Domestic_sales+<br>International_sales) DESC <br>LIMIT 1)<br>  - (Domestic_sales+International_sales) as sale_diff<br>FROM movies m<br>LEFT JOIN boxoffice b<br>ON m.id = b.movie_id <br>ORDER BY sale_diff DESC<br></code></pre></td></tr></table></figure><p>SELECT是可以嵌套的，SELECT是输出的表达式。</p><h1 id="二-SQL的DQL、DDL、DML、DCL使用"><a href="#二-SQL的DQL、DDL、DML、DCL使用" class="headerlink" title="二. SQL的DQL、DDL、DML、DCL使用"></a>二. SQL的DQL、DDL、DML、DCL使用</h1><h2 id="1-数据查询语言DQL"><a href="#1-数据查询语言DQL" class="headerlink" title="1. 数据查询语言DQL"></a><strong>1.</strong> 数据查询语言DQL</h2><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：<br>SELECT &lt;字段名表&gt;<br>FROM &lt;表或视图名&gt;<br>WHERE &lt;查询条件&gt;</p><h2 id="2-数据操纵语言DML"><a href="#2-数据操纵语言DML" class="headerlink" title="2. 数据操纵语言DML"></a>2. 数据操纵语言DML</h2><p><strong>数据库意义： </strong>数据存储，数据管理</p><p>DML：数据操作语言</p><p>添加( INSERT )</p><p>修改( UPDATE )</p><p>删除( DELETE )</p><h2 id="3-数据定义语言DDL"><a href="#3-数据定义语言DDL" class="headerlink" title="3. 数据定义语言DDL"></a>3. 数据定义语言DDL</h2><p>数据定义语言DDL用来创建数据库中的各种对象——-表、视图、<br>索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER<br>          |      |      |      |      |<br>         表   视图  索引  同义词  簇</p><p>DDL操作是隐性提交的！不能rollback </p><h2 id="4-数据控制语言DCL"><a href="#4-数据控制语言DCL" class="headerlink" title="4. 数据控制语言DCL"></a>4. 数据控制语言DCL</h2><p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制<br>数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p><p>1) GRANT：授权。</p><p>2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。<br>   回滚—-ROLLBACK<br>   回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>   SQL&gt;ROLLBACK;</p><p>3) COMMIT [WORK]：提交。</p><p>  在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。</p><h1 id="三-其他数据库对象"><a href="#三-其他数据库对象" class="headerlink" title="三. 其他数据库对象"></a>三. 其他数据库对象</h1><h1 id="四-数据库基本性质"><a href="#四-数据库基本性质" class="headerlink" title="四. 数据库基本性质"></a>四. 数据库基本性质</h1><h2 id="1-事务（Transaction）"><a href="#1-事务（Transaction）" class="headerlink" title="1. 事务（Transaction）"></a>1. 事务（Transaction）</h2><p>概念：是由一组SQL语句组成的一个程序执行单元（Unit），它需要满足ACID特性。<br><strong>ACID：</strong><br>原子性（Atomicity）：事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。\<br>一致性（Consistency）：数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。\<br>隔离性（Isolation）：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其他事务运行结果。\<br>持久性（Durability）：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p><h2 id="2-并发一致性问题"><a href="#2-并发一致性问题" class="headerlink" title="2. 并发一致性问题"></a>2. 并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h3 id="2-1-丢失修改"><a href="#2-1-丢失修改" class="headerlink" title="2.1 丢失修改"></a>2.1 丢失修改</h3><p>T1事务和T2事务同时进行更新操作同一个数据，T1在前，T2在后，T2的修改覆盖了T1的修改。</p><h3 id="2-2-读脏数据"><a href="#2-2-读脏数据" class="headerlink" title="2.2 读脏数据"></a>2.2 读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><h3 id="2-3-不可重复读"><a href="#2-3-不可重复读" class="headerlink" title="2.3 不可重复读"></a>2.3 不可重复读</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h3 id="2-4-幻读"><a href="#2-4-幻读" class="headerlink" title="2.4 幻读"></a>2.4 幻读</h3><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。与不可重复读不同的是，前者是读了更新的数据内容，后者是读了更新的数据项</p><h2 id="3-封锁"><a href="#3-封锁" class="headerlink" title="3. 封锁"></a>3. 封锁</h2><h3 id="3-1-封锁类型"><a href="#3-1-封锁类型" class="headerlink" title="3.1 封锁类型"></a>3.1 封锁类型</h3><h4 id="3-1-1-读写锁"><a href="#3-1-1-读写锁" class="headerlink" title="3.1.1 读写锁"></a>3.1.1 读写锁</h4><ul><li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。<br>有两个规定：<br>1）T 拿到 X 锁的时候，其他的读写数据的请求都要隔离。<br>2）T 拿到 S 锁的时候，其他的更新数据的请求都要隔离。</li></ul><p>XS锁兼容关系<br>|      | X    | S    |<br>| —— | —— | —— |<br>| X    | ❌    | ❌    |<br>| S    | ❌    | ✅    |</p><h4 id="3-1-2-意向锁"><a href="#3-1-2-意向锁" class="headerlink" title="3.1.2 意向锁"></a>3.1.2 意向锁</h4><p>在T对数据加入X锁或者S锁之前要拿到意向锁，确认没有别的事务对数据表和某行数据进行操作意向。</p><h2 id="4-隔离级别"><a href="#4-隔离级别" class="headerlink" title="4. 隔离级别"></a>4. 隔离级别</h2><h3 id="4-1-未提交读（READ-UNCOMMITTED）"><a href="#4-1-未提交读（READ-UNCOMMITTED）" class="headerlink" title="4.1 未提交读（READ UNCOMMITTED）"></a>4.1 未提交读（READ UNCOMMITTED）</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h3 id="4-2-提交读（READ-COMMITTED）"><a href="#4-2-提交读（READ-COMMITTED）" class="headerlink" title="4.2 提交读（READ COMMITTED）"></a>4.2 提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。解决脏读。</p><h3 id="4-3-可重复读（REPEATABLE-READ）"><a href="#4-3-可重复读（REPEATABLE-READ）" class="headerlink" title="4.3 可重复读（REPEATABLE READ）"></a>4.3 可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。解决不可重复读，脏读。</p><h3 id="4-4-可序列化（SERIALIZABLE）"><a href="#4-4-可序列化（SERIALIZABLE）" class="headerlink" title="4.4 可序列化（SERIALIZABLE）"></a>4.4 可序列化（SERIALIZABLE）</h3><p>强制事务串行的执行，并且通过锁来规定同一时间执行的事务只有一个，规定好了执行的秩序。解决脏读、不可重复读、幻读。</p><p>隔离级别能解决的并发一致性问题</p><div class="table-container"><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>提交读</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>可重复读</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>可序列化</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table></div><h2 id="5-多版本并发控制MVCC"><a href="#5-多版本并发控制MVCC" class="headerlink" title="5. 多版本并发控制MVCC"></a>5. 多版本并发控制MVCC</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><p><strong>MVCC</strong>(Multi Version Concurrency Control的简称)，代表<strong>多版本并发控制</strong>。</p><p>MVCC最大的优势：<strong>读不加锁，读写不冲突</strong>。读写不冲突是非常重要的，极大的增加了系统的并发性能。<strong>MVCC机制也是乐观锁的一种体现。</strong></p><p><strong>基本思想</strong></p><p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p><p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p><p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p><h1 id="五-数据库的原理"><a href="#五-数据库的原理" class="headerlink" title="五. 数据库的原理"></a>五. 数据库的原理</h1><h2 id="一、索引优化"><a href="#一、索引优化" class="headerlink" title="一、索引优化"></a>一、索引优化</h2><h3 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;<br></code></pre></td></tr></table></figure><h3 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT film_id, actor_ id FROM sakila.film_actor<br>WHERE actor_id = 1 AND film_id = 1;<br></code></pre></td></tr></table></figure><h3 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,<br>COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,<br>COUNT(*)<br>FROM payment;<br>   staff_id_selectivity: 0.0001<br>customer_id_selectivity: 0.0373<br>               COUNT(*): 16049<br></code></pre></td></tr></table></figure><h3 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引</li></ul><h2 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h2><h3 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有：</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><h4 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h4><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><p><strong>准确自己查询的内容！</strong></p><h4 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h4><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="三、重构查询方式"><a href="#三、重构查询方式" class="headerlink" title="三、重构查询方式"></a>三、重构查询方式</h2><h3 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> messages <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">create</span> &lt; DATE_SUB(NOW(), INTERVAL <span class="hljs-number">3</span> MONTH);<br>rows_affected = 0<br>do &#123;<br>    rows_affected = do_query(<br>    &quot;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> messages <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">create</span>  &lt; DATE_SUB(NOW(), INTERVAL <span class="hljs-number">3</span> MONTH) <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10000</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">&#125; while rows_affected &gt; 0</span><br></code></pre></td></tr></table></figure><h3 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM tag<br>JOIN tag_post ON tag_post.tag_id=tag.id<br>JOIN post ON tag_post.post_id=post.id<br>WHERE tag.tag=&#x27;mysql&#x27;;<br>SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;<br>SELECT * FROM tag_post WHERE tag_id=1234;<br>SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>0、如果语句是<code>select * from T where ID=500</code>，即<strong>主键查询</strong>方式，则只需要搜索ID这棵B+树；</p><p>如果语句是<code>select * from T where k=5</code>，即<strong>普通索引</strong>查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</p><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><p>1、能多列索引就多列索引</p><p>2、把选择性高的放前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>3、索引使用条件：</p><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data base</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Systems: A Programmer‘s Perspective</title>
    <link href="/2022/04/15/Computer-Systems-A-Programmer-s-Perspective/"/>
    <url>/2022/04/15/Computer-Systems-A-Programmer-s-Perspective/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-A-Tour-of-Computer-System"><a href="#Chapter-1-A-Tour-of-Computer-System" class="headerlink" title="Chapter 1: A Tour of Computer System"></a>Chapter 1: A Tour of Computer System</h1><p><strong>由一个helloworld的整个生命周期来演示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/The-Compilation-System.png" alt="The-Compilation-System"></p><p><strong>为什么我们要理解编译系统？</strong></p><p>1⃣️ Optimizing program performance(优化程序性能)</p><p>e.g. 一个switch语句是不是要比一连串的if-else要高效的多？</p><p>2⃣️ Understanding link-time errors(理解链接时出现的错误)</p><p>e.g. 静态变量和全局变量的区别是什么？</p><p>3⃣️ Avoiding security holes(避免安全漏洞)</p><p>e.g. 缓冲区溢出错误产生？</p><p><strong>计算机硬件组成系统以及完成hello world程序的硬件处理过程</strong></p><p>PC(Program Count)：程序计数器，大小为一个字的存储区域。32位系统中，1 word = 4 byte，64位系统中，1 word = 8byte。</p><p>Register file：寄存器。</p><p>ALU：处理器。</p><p>Bus interface：总线。</p><p>Disk：磁盘。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP1-INPUT.png" alt="STEP1-INPUT"></p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP2-DMA.png" alt="STEP2-DMA"></p><p>DMA技术：数据可以不经过处理器，直接从磁盘抵达内存。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP3-Display.png" alt="STEP3-Display"></p><p>tips：1⃣️ 大容量的设备会比小容量设备运行速度更慢。2⃣️ 运行速度更快的设备比低速设备更贵。</p><p>e.g. 内存虽小但价格和外存的价格差不多。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/Memory%20Hierarchy.png" alt="Memory Hierarchy"></p><p>L1、L2、L3为我们常说的三级缓存。</p><p><strong>操作系统在应用程序和硬件系统之间的角色</strong></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/The%20Operating%20System%20Manages%20Hardware.png" alt="The Operating System Manages Hardware"></h4><p>1⃣️ 防止硬件被失控的应用程序滥用</p><p>2⃣️ 操作系统提供统一的机制来控制这些复杂的底层硬件</p><p>—————————————————————————————————————</p><h2 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位 + 上下文"></a>1.1 信息就是位 + 上下文</h2><p>1⃣️ <strong>何为上下文？</strong></p><p>上下文，也就是执行任务所需要的相关信息。这个任务可以是一段代码，一个线程，一个进程，一个函数。当这个“任务”，相关信息需要保存下来，就可以使用Context来记录了。</p><h2 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h2><p>1⃣️<strong>GNU是什么？</strong></p><p>GNU是项目开发工具它包含了：EMACS编译器、GCC编译器、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其它一些部件。目前随着发展已经支持许多不同的语言了。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2022/04/12/%E5%89%91%E6%8C%87offer/"/>
    <url>/2022/04/12/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h1 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h1><h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3. 数组中重复的数字"></a>3. 数组中重复的数字</h2><h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4. 二维数组中的查找"></a>4. 二维数组中的查找</h2><p><strong>描述</strong></p><p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p><p>[[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]] </p><p>给定 target = 7，返回 true。 </p><p>给定 target = 3，返回 false。</p><p><strong>思路</strong></p><p>(1)对于数组 arr [row] [col] 的row和col，我们是按先行后列来看的。用二维数组举例，arr.length 表示的是row的长度，arr[0].length 表示的是列的长度。</p><p>(2)这种问题的通常思路一般是双循环，时间复杂度自然到达了o(n^2)，所以最直接的优化方式就是降低时间复杂度，把二维数组的处理展平变成一围的地图然后通过排序的规律来找到突破口。</p><p><strong>解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> [][] array)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> search;<br>      <br><span class="hljs-comment">//不越界的情况下search</span><br>    <span class="hljs-keyword">while</span>(row &lt;= (array.length - <span class="hljs-number">1</span>) &amp;&amp; col &gt;= <span class="hljs-number">0</span>)&#123;<br>        search = array[row][col]; <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">if</span>(search == target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(search &gt; target)&#123;<br>            col--;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(search &lt; target)&#123;<br>            row++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5. 替换空格"></a>5. 替换空格</h2><p><strong>描述</strong></p><p>请实现一个函数，将一个字符串s中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p><strong>思路</strong></p><p>最先学会的是分清楚String, StringBuffer, StringBuilder。</p><p>操作<strong>少量的数据</strong>:适用String</p><p><strong>单线程</strong>操作字符串缓冲区下操作<strong>大量数据</strong>:适用StringBuilder(线程不安全)</p><p><strong>多线程</strong>操作字符串缓冲区下操作<strong>大量数据</strong>:适用StringBuffer(线程安全)</p><p>String长度不可变，其余两个长度可变，默认长度为16</p><p>实际上是实现了java中String.replace(String1, String2)的功能</p><p><strong>解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span> <span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//如果本来就是空字符串那我们返回就好。</span><br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">null</span> || s.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-comment">//使用StringBuilder在遍历过程中构建新的字符串。</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">blank</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i)!=blank)<br>                builder.append(s.charAt(i));<br>            <span class="hljs-keyword">else</span><br>                builder.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h2><p><strong>描述</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p><p><strong>思路</strong></p><p>简单来说，就是不断地收缩矩阵的边界，确定边界，锁一动一<br>定义四个变量代表范围，up、down、left、right</p><ol><li>向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错 </li><li>向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错 </li><li>向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错 </li><li>向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错</li></ol><p><strong>解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">printMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span> [][] matrix)</span> &#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> matrix.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">// 最上面一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> left; col &lt;= right; col++)&#123;<br>                list.add(matrix[up][col]);<br>            &#125;<br>            <span class="hljs-comment">// 向下逼近</span><br>            up++;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(up &gt; down)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最右边一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> up; row &lt;= down; row++)&#123;<br>                list.add(matrix[row][right]);<br>            &#125;<br>            <span class="hljs-comment">// 向左逼近</span><br>            right--;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最下面一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> right; col &gt;= left; col--)&#123;<br>                list.add(matrix[down][col]);<br>            &#125;<br>            <span class="hljs-comment">// 向上逼近</span><br>            down--;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(up &gt; down)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最左边一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> down; row &gt;= up; row--)&#123;<br>                list.add(matrix[row][left]);<br>            &#125;<br>            <span class="hljs-comment">// 向右逼近</span><br>            left++;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="50-第一个只出现一次的字符位置"><a href="#50-第一个只出现一次的字符位置" class="headerlink" title="50. 第一个只出现一次的字符位置"></a>50. 第一个只出现一次的字符位置</h2><p><strong>描述</strong></p><p>在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）（从0开始计数）</p><p><strong>思路</strong></p><p>1、用indexOf和lastIndexOf来实现，若找到直接返回下标，若没找到返回-1，indexOf为最先出现的位置，lastIndexOf为最后一次出现的位置。</p><p>2、用Map，Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</p><ul><li>需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li><li>Map中常用的集合为HashMap集合、LinkedHashMap集合。</li></ul><p><strong>解法1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">FirstNotRepeatingChar</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;                    <span class="hljs-keyword">if</span>(str.indexOf(str.charAt(i)) != str.lastIndexOf(str.charAt(i)))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">FirstNotRepeatingChar</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">//ArrayList list=new ArrayList;</span><br>        java.util.HashMap&lt;Character,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.HashMap&lt;&gt;();<br>        <span class="hljs-type">char</span> [] arr=str.toCharArray();<br>        <span class="hljs-comment">//把数组中的值添加到map集合中，并且记录出现的次数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            <span class="hljs-comment">//containsKey返回布尔类型</span><br>             <span class="hljs-keyword">if</span>(!map.containsKey(arr[i]))&#123;<br>                 map.put(arr[i],<span class="hljs-number">1</span>);<br>             &#125;<span class="hljs-keyword">else</span>&#123;<br>                 <span class="hljs-type">int</span> count=map.get(arr[i]);<br>                <span class="hljs-comment">//replace替换的是value而不是key，key是唯一的</span><br>                 map.replace(arr[i],count+<span class="hljs-number">1</span>);<br>             &#125;<br>         &#125;<br>        <span class="hljs-comment">//根据map集合中的key，寻找value，返回第一个出现第一次的值，返回i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(arr[i])==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;      <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/12/hello-world/"/>
    <url>/2022/04/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
