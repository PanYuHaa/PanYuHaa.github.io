<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代码随想录</title>
    <link href="/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    <url>/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>url：<a href="https://www.programmercarl.com">https://www.programmercarl.com</a></p><h1 id="第3章-数组"><a href="#第3章-数组" class="headerlink" title="第3章 数组"></a>第3章 数组</h1><h2 id="3-2-二分查找"><a href="#3-2-二分查找" class="headerlink" title="3.2 二分查找"></a>3.2 二分查找</h2><p><strong>704. Binary Search</strong></p><p><strong>Q:</strong> Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> pivot, left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>      pivot = left + (right - left) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[pivot] == target) <span class="hljs-keyword">return</span> pivot;<br>      <span class="hljs-keyword">if</span> (target &lt; nums[pivot]) right = pivot - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> left = pivot + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 (left + right) / 2 = left + (right / 2) - (left / 2) = left + (right - left) / 2</p><p>我采用的是 [left, right] 闭区间，所以判断条件是 &lt;= ，left和right相等的时候有意义。</p><h2 id="3-3-移除元素"><a href="#3-3-移除元素" class="headerlink" title="3.3 移除元素"></a><strong>3.3 移除元素</strong></h2><p><strong>27. Remove Element</strong></p><p><strong>Q: </strong>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a>. The relative order of the elements may be changed.</p><p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p><p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] != val) &#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1⃣️ 由于有空间复杂度的限制，所以不能建立另外一个数组来进行赋值，暗示我们用双指针法，双指针法是常用的降低时间复杂度的方法。</p><p>2⃣️ nums = [0, 1 ,4 ,0 ,3 , _ , _] 因为数组中的元素在内存地址上是连续的，不能单独删除数组中的某个元素，只能覆盖。</p><h2 id="3-4-长度最小的子数组"><a href="#3-4-长度最小的子数组" class="headerlink" title="3.4 长度最小的子数组"></a>3.4 长度最小的子数组</h2><p><strong>209. Minimum Size Subarray Sum</strong></p><p><strong>Q: </strong>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Study</title>
    <link href="/2022/04/20/SQL-Study/"/>
    <url>/2022/04/20/SQL-Study/</url>
    
    <content type="html"><![CDATA[<h1 id="0-基本书写规范"><a href="#0-基本书写规范" class="headerlink" title="0. 基本书写规范"></a>0. 基本书写规范</h1><p>对于 SQL 初学者，在写 SQL 语句时，只要遵守下面几个书写规则，就可以避免很多错误。这些规则都非常简单，下面我们来逐一介绍。</p><p><strong>SQL 语句要以分号<code>;</code>结尾</strong></p><p>在 RDBMS （关系型数据库）当中，SQL 语句是逐条执行的，一条 SQL 语句代表着数据库的一个操作。</p><p>我们通常在句子的句尾加注标点表示这句话结束，中文句子以句号<code>。</code>结尾，英文以点号<code>.</code>结尾，而 SQL 语句则使用英文分号<code>;</code>结尾。</p><p><strong>SQL 语句不区分大小写</strong></p><p>SQL 不区分关键字的大小写。例如，不管写成 SELECT 还是 select，解释都是一样的。表名和列名也是如此。（但是注意字符串是要分大小写的）</p><p>提示：关键字是数据库事先定义的，有特别意义的单词。</p><p>虽然可以根据个人喜好选择大写还是小写（或大小写混杂），但为了理解起来更加容易，本教程使用以下规则来书写 SQL 语句。</p><ul><li>关键字大写</li><li>数据库名、表名和列名等小写</li></ul><p>需要注意的是，插入到表中的数据是区分大小写的。例如，向数据库中插入单词 Computer、COMPUTER 或 computer，这三个是不一样的数据</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/dbStudy.png" alt="dbStudy"></p><h1 id="1-SQL的SELECT使用"><a href="#1-SQL的SELECT使用" class="headerlink" title="1. SQL的SELECT使用"></a>1. SQL的SELECT使用</h1><h2 id="1-1-条件查询语法"><a href="#1-1-条件查询语法" class="headerlink" title="1.1 条件查询语法"></a>1.1 条件查询语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql"># 条件查询语法<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition<br>    AND/OR another_condition<br>    AND/OR …;<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Operator（操作符）</th><th>Condition（解释）</th><th>Example（例子）</th></tr></thead><tbody><tr><td>=</td><td>Case sensitive exact string comparison (<em>notice the single equals</em>)完全等于</td><td>col_name = “abc”</td></tr><tr><td>!= or &lt;&gt;</td><td>Case sensitive exact string inequality comparison 不等于</td><td>col_name != “abcd”</td></tr><tr><td>LIKE</td><td>Case insensitive exact string comparison 没有用通配符等价于 =</td><td>col_name LIKE “ABC”</td></tr><tr><td>NOT LIKE</td><td>Case insensitive exact string inequality comparison 没有用通配符等价于 !=</td><td>col_name NOT LIKE”ABCD”</td></tr><tr><td>%</td><td>Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) 通配符，代表匹配0个以上的字符</td><td>col_name LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”) “%AT%” 代表AT 前后可以有任意字符</td></tr><tr><td>_</td><td>Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) 和% 相似，代表1个字符</td><td>col_name LIKE “AN_” (matches “AND”, but not “AN”)</td></tr><tr><td>IN (…)</td><td>String exists in a list 在列表</td><td>col_name IN (“A”, “B”, “C”)</td></tr></tbody></table></div><h2 id="1-2-DISTINCT语法"><a href="#1-2-DISTINCT语法" class="headerlink" title="1.2 DISTINCT语法"></a>1.2 DISTINCT语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 选取出唯一的结果的语法<br>SELECT DISTINCT column, another_column, …<br>FROM mytable<br>WHERE condition(s);<br></code></pre></td></tr></table></figure><p>因为 <code>DISTINCT</code> 语法会直接删除重复的行，我们还会学习 <code>GROUP BY</code> 语句， <code>GROUP BY</code> 也会返回唯一的行，不过可以对具有相同的 属性值的行做一些统计计算，比如：求和。</p><h2 id="1-3-结果排序-Ordering-results"><a href="#1-3-结果排序-Ordering-results" class="headerlink" title="1.3 结果排序(Ordering results)"></a>1.3 结果排序(Ordering results)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 结果排序（ordered results）<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition(s)<br>ORDER BY column ASC/DESC;<br></code></pre></td></tr></table></figure><p><code>ORDER BY col_name</code> 这句话的意思就是让结果按照 col_name 列的具体值做 ASC升序 或 DESC 降序，对数字来说就是升序 1，2，3，… 或降序 … 3,2,1。对于文本列，升序和降序指的是按文本的字母序。</p><h2 id="1-4-通过Limit选取部分结果"><a href="#1-4-通过Limit选取部分结果" class="headerlink" title="1.4 通过Limit选取部分结果"></a>1.4 通过Limit选取部分结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># limited查询<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition(s)<br>ORDER BY column ASC/DESC<br>LIMIT num_limit OFFSET num_offset;<br></code></pre></td></tr></table></figure><p><code>LIMIT</code> 和 <code>OFFSET</code> 子句通常和<code>ORDER BY</code> 语句一起使用，当我们对整个结果集排序之后，我们可以 <code>LIMIT</code>来指定只返回多少行结果 ,用 <code>OFFSET</code>来指定从哪一行开始返回。你可以想象一下从一条长绳子剪下一小段的过程，我们通过 <code>OFFSET</code> 指定从哪里开始剪，用 <code>LIMIT</code> 指定剪下多少长度。</p><p>PS：num_offset 是从0开始的</p><h2 id="1-5-数据库范式"><a href="#1-5-数据库范式" class="headerlink" title="1.5 数据库范式"></a>1.5 数据库范式</h2><p>数据库范式是数据表设计的规范，在范式规范下，数据库里每个表存储的<strong>重复数据降到最少（这有助于数据的一致性维护）</strong>，同时在数据库范式下，表和表之间不再有很强的数据耦合，可以独立的增长 (ie. 比如汽车引擎的增长和汽车的增长是完全独立的). 范式带来了很多好处，但随着数据表的分离，意味着我们要查询多个数据属性时，需要更复杂的SQL语句，也就是本节开始介绍的多表连接技术。这样SQL的性能也会面临更多的挑战，特别是当大数据量的表很多的情况下。</p><p>如果一个实体（比如Dog）的属性数据被分散到多个数据表中，我们就需要学习如何通过 <code>JOIN</code>连表技术来整合这些数据并找到我们想要查询的数据项。</p><h2 id="1-6-用JOINs进行多表联合查询"><a href="#1-6-用JOINs进行多表联合查询" class="headerlink" title="1.6 用JOINs进行多表联合查询"></a>1.6 用JOINs进行多表联合查询</h2><p><code>主键(primary key)</code>, 一般关系数据表中，都会有一个属性列设置为 <code>主键(primary key)</code>。主键是唯一标识一条数据的，不会重复复（想象你的身份证号码)。一个最常见的主键就是auto-incrementing integer(自增ID，每写入一行数据ID+1, 当然字符串，hash值等只要是每条数据是唯一的也可以设为主键.</p><p>借助<code>主键(primary key)</code>（当然其他唯一性的属性也可以），我们可以把两个表中具有相同 主键ID的数据连接起来（因为一个ID可以简要的识别一条数据，所以连接之后还是表达的同一条数据）（你可以想象一个左右连线游戏）。具体我们用到 <code>JOIN</code> 关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">用LEFT/RIGHT/FULL JOINs 做多表查询<br>SELECT column, another_column, …<br>FROM mytable<br>INNER/LEFT/RIGHT/FULL JOIN another_table<br>    ON mytable.id = another_table.matching_id<br>WHERE condition(s)<br>ORDER BY column, … ASC/DESC<br>LIMIT num_limit OFFSET num_offset;<br></code></pre></td></tr></table></figure><p>PS：<code>INNER JOIN</code> 可以简写做 <code>JOIN</code>. 两者是相同的意思，但我们还是会继续写作 <code>INNER JOIN</code> 以便和后面的 <code>LEFT JOIN</code>， <code>RIGHT JOIN</code>等相比较。(内连接，左连接，右连接)</p><p>LEFT JOIN：左边的全部存在，右边的有缺失就NULL</p><p>RIGHT JOIN：右边的全部存在，左边的有缺失就NULL</p><h2 id="1-7-查询条件中处理NULL"><a href="#1-7-查询条件中处理NULL" class="headerlink" title="1.7 查询条件中处理NULL"></a>1.7 查询条件中处理NULL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 在查询条件中处理 NULL<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE column IS/IS NOT NULL<br>AND/OR another_condition<br>AND/OR …;<br></code></pre></td></tr></table></figure><p>判断是否为NULL</p><h2 id="1-8-查询中使用表达式"><a href="#1-8-查询中使用表达式" class="headerlink" title="1.8 查询中使用表达式"></a>1.8 查询中使用表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 包含表达式的例子<br>SELECT  particle_speed / 2.0 AS half_particle_speed (对结果做了一个除2）<br>FROM physics_data<br>WHERE ABS(particle_position) * 10.0 &gt;500<br>            （条件要求这个属性绝对值乘以10大于500）;<br>         <br># AS使用别名<br>SELECT col_expression AS expr_description, …<br>FROM mytable;<br><br># 属性列和表取别名的例子<br>SELECT column AS better_column_name, …<br>FROM a_long_widgets_table_name AS mywidgets<br>INNER JOIN widget_sales<br>  ON mywidgets.id = widget_sales.widget_id;<br></code></pre></td></tr></table></figure><p><strong>e.g</strong></p><p>【难题】John Lasseter导演的每部电影每分钟值多少钱,告诉我最高的3个电影名和价值就可以 </p><p>Table: Movies(Read - Only)</p><div class="table-container"><table><thead><tr><th>Id</th><th>Title</th><th>Director</th><th>Year</th><th>Length_minutes</th></tr></thead><tbody><tr><td>1</td><td>Toy Story</td><td>John Lasseter</td><td>1995</td><td>81</td></tr><tr><td>2</td><td>A Bug’s Life</td><td>John Lasseter</td><td>1998</td><td>95</td></tr><tr><td>3</td><td>Toy Story 2</td><td>John Lasseter</td><td>1999</td><td>93</td></tr><tr><td>4</td><td>Monsters, Inc.</td><td>Pete Docter</td><td>2001</td><td>92</td></tr><tr><td>5</td><td>Finding Nemo</td><td>Finding Nemo</td><td>2003</td><td>107</td></tr><tr><td>6</td><td>The Incredibles</td><td>Brad Bird</td><td>2004</td><td>116</td></tr><tr><td>7</td><td>Cars</td><td>John Lasseter</td><td>2006</td><td>117</td></tr><tr><td>8</td><td>Ratatouille</td><td>Brad Bird</td><td>2007</td><td>115</td></tr><tr><td>9</td><td>WALL-E</td><td>Andrew Stanton</td><td>2008</td><td>104</td></tr><tr><td>10</td><td>Up</td><td>Pete Docter</td><td>2009</td><td>101</td></tr><tr><td>11</td><td>Toy Story 3</td><td>Lee Unkrich</td><td>2010</td><td>103</td></tr><tr><td>12</td><td>Cars 2</td><td>John Lasseter</td><td>2011</td><td>120</td></tr><tr><td>13</td><td>Brave</td><td>Brenda Chapman</td><td>2012</td><td>102</td></tr><tr><td>14</td><td>Monsters University</td><td>Dan Scanlon</td><td>2013</td><td>110</td></tr></tbody></table></div><p>Table: Boxoffice(Read - Only)</p><div class="table-container"><table><thead><tr><th>Movie_id</th><th>Rating</th><th>Domestic_sales</th><th>International_sales</th></tr></thead><tbody><tr><td>5</td><td>8.2</td><td>380843261</td><td>555900000</td></tr><tr><td>14</td><td>7.4</td><td>268492764</td><td>475066843</td></tr><tr><td>8</td><td>8</td><td>206445654</td><td>417277164</td></tr><tr><td>12</td><td>6.4</td><td>191452396</td><td>368400000</td></tr><tr><td>3</td><td>7.9</td><td>245852179</td><td>239163000</td></tr><tr><td>6</td><td>8</td><td>261441092</td><td>370001000</td></tr><tr><td>9</td><td>8.5</td><td>223808164</td><td>297503696</td></tr><tr><td>11</td><td>8.4</td><td>415004880</td><td>648167031</td></tr><tr><td>1</td><td>8.3</td><td>191796233</td><td>170162503</td></tr><tr><td>7</td><td>7.2</td><td>244082982</td><td>217900167</td></tr><tr><td>10</td><td>8.3</td><td>293004164</td><td>438338580</td></tr><tr><td>4</td><td>8.1</td><td>289916256</td><td>272900000</td></tr><tr><td>2</td><td>7.2</td><td>162798565</td><td>200600000</td></tr><tr><td>13</td><td>7.2</td><td>237283207</td><td>301700000</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 输出变量，AS用来起别名<br>SELECT title, ((domestic_sales + international_sales) / length_minutes) AS sale_value FROM movies AS m<br><br># 内连接两个表，ON通过什么属性<br>INNER JOIN boxoffice AS b<br>ON m.id = b.movie_id<br><br># WHERE逻辑控制判断<br>WHERE director = &quot;John Lasseter&quot;<br><br># ORDER BY排序<br>ORDER BY sale_value DESC<br><br># LIMIT限制，OFFSET表示起始位置<br>LIMIT 3 <br></code></pre></td></tr></table></figure><h1 id="2-SQL的DDL、DML、DCL使用"><a href="#2-SQL的DDL、DML、DCL使用" class="headerlink" title="2. SQL的DDL、DML、DCL使用"></a>2. SQL的DDL、DML、DCL使用</h1><h1 id="3-其他数据库对象"><a href="#3-其他数据库对象" class="headerlink" title="3. 其他数据库对象"></a>3. 其他数据库对象</h1>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data base</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Systems: A Programmer‘s Perspective</title>
    <link href="/2022/04/15/Computer-Systems-A-Programmer-s-Perspective/"/>
    <url>/2022/04/15/Computer-Systems-A-Programmer-s-Perspective/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-A-Tour-of-Computer-System"><a href="#Chapter-1-A-Tour-of-Computer-System" class="headerlink" title="Chapter 1: A Tour of Computer System"></a>Chapter 1: A Tour of Computer System</h1><p><strong>由一个helloworld的整个生命周期来演示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/The-Compilation-System.png" alt="The-Compilation-System"></p><p><strong>为什么我们要理解编译系统？</strong></p><p>1⃣️ Optimizing program performance(优化程序性能)</p><p>e.g. 一个switch语句是不是要比一连串的if-else要高效的多？</p><p>2⃣️ Understanding link-time errors(理解链接时出现的错误)</p><p>e.g. 静态变量和全局变量的区别是什么？</p><p>3⃣️ Avoiding security holes(避免安全漏洞)</p><p>e.g. 缓冲区溢出错误产生？</p><p><strong>计算机硬件组成系统以及完成hello world程序的硬件处理过程</strong></p><p>PC(Program Count)：程序计数器，大小为一个字的存储区域。32位系统中，1 word = 4 byte，64位系统中，1 word = 8byte。</p><p>Register file：寄存器。</p><p>ALU：处理器。</p><p>Bus interface：总线。</p><p>Disk：磁盘。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP1-INPUT.png" alt="STEP1-INPUT"></p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP2-DMA.png" alt="STEP2-DMA"></p><p>DMA技术：数据可以不经过处理器，直接从磁盘抵达内存。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP3-Display.png" alt="STEP3-Display"></p><p>tips：1⃣️ 大容量的设备会比小容量设备运行速度更慢。2⃣️ 运行速度更快的设备比低速设备更贵。</p><p>e.g. 内存虽小但价格和外存的价格差不多。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/Memory%20Hierarchy.png" alt="Memory Hierarchy"></p><p>L1、L2、L3为我们常说的三级缓存。</p><p><strong>操作系统在应用程序和硬件系统之间的角色</strong></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/The%20Operating%20System%20Manages%20Hardware.png" alt="The Operating System Manages Hardware"></h4><p>1⃣️ 防止硬件被失控的应用程序滥用</p><p>2⃣️ 操作系统提供统一的机制来控制这些复杂的底层硬件</p><p>—————————————————————————————————————</p><h2 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位 + 上下文"></a>1.1 信息就是位 + 上下文</h2><p>1⃣️ <strong>何为上下文？</strong></p><p>上下文，也就是执行任务所需要的相关信息。这个任务可以是一段代码，一个线程，一个进程，一个函数。当这个“任务”，相关信息需要保存下来，就可以使用Context来记录了。</p><h2 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h2><p>1⃣️<strong>GNU是什么？</strong></p><p>GNU是项目开发工具它包含了：EMACS编译器、GCC编译器、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其它一些部件。目前随着发展已经支持许多不同的语言了。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2022/04/12/%E5%89%91%E6%8C%87offer/"/>
    <url>/2022/04/12/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h1 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h1><h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3. 数组中重复的数字"></a>3. 数组中重复的数字</h2><h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4. 二维数组中的查找"></a>4. 二维数组中的查找</h2><p><strong>描述</strong></p><p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p><p>[[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]] </p><p>给定 target = 7，返回 true。 </p><p>给定 target = 3，返回 false。</p><p><strong>思路</strong></p><p>(1)对于数组 arr [row] [col] 的row和col，我们是按先行后列来看的。用二维数组举例，arr.length 表示的是row的长度，arr[0].length 表示的是列的长度。</p><p>(2)这种问题的通常思路一般是双循环，时间复杂度自然到达了o(n^2)，所以最直接的优化方式就是降低时间复杂度，把二维数组的处理展平变成一围的地图然后通过排序的规律来找到突破口。</p><p><strong>解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> [][] array)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> search;<br>      <br><span class="hljs-comment">//不越界的情况下search</span><br>    <span class="hljs-keyword">while</span>(row &lt;= (array.length - <span class="hljs-number">1</span>) &amp;&amp; col &gt;= <span class="hljs-number">0</span>)&#123;<br>        search = array[row][col]; <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">if</span>(search == target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(search &gt; target)&#123;<br>            col--;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(search &lt; target)&#123;<br>            row++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5. 替换空格"></a>5. 替换空格</h2><p><strong>描述</strong></p><p>请实现一个函数，将一个字符串s中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p><strong>思路</strong></p><p>最先学会的是分清楚String, StringBuffer, StringBuilder。</p><p>操作<strong>少量的数据</strong>:适用String</p><p><strong>单线程</strong>操作字符串缓冲区下操作<strong>大量数据</strong>:适用StringBuilder(线程不安全)</p><p><strong>多线程</strong>操作字符串缓冲区下操作<strong>大量数据</strong>:适用StringBuffer(线程安全)</p><p>String长度不可变，其余两个长度可变，默认长度为16</p><p>实际上是实现了java中String.replace(String1, String2)的功能</p><p><strong>解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span> <span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//如果本来就是空字符串那我们返回就好。</span><br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">null</span> || s.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-comment">//使用StringBuilder在遍历过程中构建新的字符串。</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">blank</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i)!=blank)<br>                builder.append(s.charAt(i));<br>            <span class="hljs-keyword">else</span><br>                builder.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h2><p><strong>描述</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p><p><strong>思路</strong></p><p>简单来说，就是不断地收缩矩阵的边界，确定边界，锁一动一<br>定义四个变量代表范围，up、down、left、right</p><ol><li>向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错 </li><li>向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错 </li><li>向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错 </li><li>向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错</li></ol><p><strong>解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">printMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span> [][] matrix)</span> &#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> matrix.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">// 最上面一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> left; col &lt;= right; col++)&#123;<br>                list.add(matrix[up][col]);<br>            &#125;<br>            <span class="hljs-comment">// 向下逼近</span><br>            up++;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(up &gt; down)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最右边一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> up; row &lt;= down; row++)&#123;<br>                list.add(matrix[row][right]);<br>            &#125;<br>            <span class="hljs-comment">// 向左逼近</span><br>            right--;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最下面一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> right; col &gt;= left; col--)&#123;<br>                list.add(matrix[down][col]);<br>            &#125;<br>            <span class="hljs-comment">// 向上逼近</span><br>            down--;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(up &gt; down)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最左边一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> down; row &gt;= up; row--)&#123;<br>                list.add(matrix[row][left]);<br>            &#125;<br>            <span class="hljs-comment">// 向右逼近</span><br>            left++;<br>            <span class="hljs-comment">// 判断是否越界</span><br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="50-第一个只出现一次的字符位置"><a href="#50-第一个只出现一次的字符位置" class="headerlink" title="50. 第一个只出现一次的字符位置"></a>50. 第一个只出现一次的字符位置</h2><p><strong>描述</strong></p><p>在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）（从0开始计数）</p><p><strong>思路</strong></p><p>1、用indexOf和lastIndexOf来实现，若找到直接返回下标，若没找到返回-1，indexOf为最先出现的位置，lastIndexOf为最后一次出现的位置。</p><p>2、用Map，Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</p><ul><li>需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li><li>Map中常用的集合为HashMap集合、LinkedHashMap集合。</li></ul><p><strong>解法1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">FirstNotRepeatingChar</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;                    <span class="hljs-keyword">if</span>(str.indexOf(str.charAt(i)) != str.lastIndexOf(str.charAt(i)))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">FirstNotRepeatingChar</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">//ArrayList list=new ArrayList;</span><br>        java.util.HashMap&lt;Character,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.HashMap&lt;&gt;();<br>        <span class="hljs-type">char</span> [] arr=str.toCharArray();<br>        <span class="hljs-comment">//把数组中的值添加到map集合中，并且记录出现的次数</span><br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            <span class="hljs-comment">//containsKey返回布尔类型</span><br>             <span class="hljs-keyword">if</span>(!map.containsKey(arr[i]))&#123;<br>                 map.put(arr[i],<span class="hljs-number">1</span>);<br>             &#125;<span class="hljs-keyword">else</span>&#123;<br>                 <span class="hljs-type">int</span> count=map.get(arr[i]);<br>                <span class="hljs-comment">//replace替换的事value而不是key，key是唯一的</span><br>                 map.replace(arr[i],count+<span class="hljs-number">1</span>);<br>             &#125;<br>         &#125;<br>        <span class="hljs-comment">//根据map集合中的key，寻找value，返回第一个出现第一次的值，返回i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(arr[i])==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;      <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
