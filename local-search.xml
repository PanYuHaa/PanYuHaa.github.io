<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小说游园会 study</title>
    <link href="/2022/11/11/%E5%B0%8F%E8%AF%B4%E6%B8%B8%E5%9B%AD%E4%BC%9A%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/11/11/%E5%B0%8F%E8%AF%B4%E6%B8%B8%E5%9B%AD%E4%BC%9A%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h1><h2 id="项目配置和框架集成"><a href="#项目配置和框架集成" class="headerlink" title="项目配置和框架集成"></a>项目配置和框架集成</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs java">io<br> +- github<br>     +- xxyopen   <br>        +- novel<br>            +- NovelApplication.java -- 项目启动类<br>            |<br>            +- core -- 项目核心模块，包括各种工具、配置和常量等<br>            |   +- common -- 业务无关的通用模块<br>            |   |   +- exception -- 通用异常处理<br>            |   |   +- constant -- 通用常量   <br>            |   |   +- req -- 通用请求数据格式封装，例如分页请求数据  <br>            |   |   +- resp -- 接口响应工具及响应数据格式封装 <br>            |   |   +- util -- 通用工具   <br>            |   | <br>            |   +- auth -- 用户认证授权相关<br>            |   +- config -- 业务相关配置<br>            |   +- constant -- 业务相关常量         <br>            |   +- filter -- 过滤器 <br>            |   +- interceptor -- 拦截器<br>            |   +- task -- 定时任务<br>            |   +- util -- 业务相关工具 <br>            |   +- wrapper -- 装饰器<br>            |<br>            +- dto -- 数据传输对象，包括对各种 Http 请求和响应数据的封装<br>            |   +- req -- Http 请求数据封装<br>            |   +- resp -- Http 响应数据封装<br>            |<br>            +- dao -- 数据访问层，与底层 MySQL 进行数据交互<br>            +- manager -- 通用业务处理层，对第三方平台封装、对 Service 层通用能力的下沉以及对多个 DAO 的组合复用 <br>            +- service -- 相对具体的业务逻辑服务层  <br>            +- controller -- 主要是处理各种 Http 请求，各类基本参数校验，或者不复用的业务简单处理，返回 JSON 数据等<br>            |   +- front -- 小说门户相关接口<br>            |   +- author -- 作家管理后台相关接口<br>            |   +- admin -- 平台管理后台相关接口<br>            |   +- app -- app 接口<br>            |   +- applet -- 小程序接口<br>            |   +- open -- 开放接口，供第三方调用 <br><br></code></pre></td></tr></table></figure><h3 id="通用请求-响应数据格式封装"><a href="#通用请求-响应数据格式封装" class="headerlink" title="通用请求/响应数据格式封装"></a>通用请求/响应数据格式封装</h3><p>分页请求数据格式封装，所有分页请求的 Dto 类都应继承该类</p><p>Dto的解释</p><p><img src="https://i.imgur.com/1JuZ1qI.png" alt="img"></p><p>通俗的解释： VO:(View Object）：视图对象，用于展示层。 DTO（Data Transfer Object）：数据传输对象 DO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。 PO（Persistent Object）：持久化对象，它跟持久层（通常是[、关系型数据库、的数据结构形成一一对应的映射关系。</p><p><strong>以下为自己的浅短理解，主要是用于帮组自己记忆，上边的能理解，就不用看下边的。</strong></p><p>自己的理解：</p><p>方向：后端–&gt;前端 VO：前端页面显示使用的数据，后端传递给前端的。</p><p>方向：前端–&gt;后端 DTO：前端调用后端接口的时候传递给后端 DO：controller中接收到DTO之后，新建一个DO传递给service， PO：service接收到传递的DO之后，转换成一个PO，传给mapper的方法，进行持久化处理。</p><p>两部分一个是通用的请求分页类，一个是请求响应类</p><p><strong>面向切面编程AOP</strong>，一种解除耦合的方法，我们通过注解或者一些代码来将不涉及业务的代码放在切面类中进行处理。</p><h3 id="Rest-接口响应工具及响应数据格式封装"><a href="#Rest-接口响应工具及响应数据格式封装" class="headerlink" title="Rest 接口响应工具及响应数据格式封装"></a>Rest 接口响应工具及响应数据格式封装</h3><p>在<code>io.github.xxyopen.novel.core.common.constant</code>包下创建错误码枚举类</p><p>在<code>io.github.xxyopen.novel.core.common.resp</code>包下创建 Http Rest 响应工具及数据格式封装类</p><h3 id="通用异常处理"><a href="#通用异常处理" class="headerlink" title="通用异常处理"></a>通用异常处理</h3><p><strong>@EqualsAndHashCode</strong>注解</p><p>原文中提到的大致有以下几点：</p><ol><li><p>此注解会生成equals(Object other) 和 hashCode()方法。 </p></li><li><p>它默认使用非静态，非瞬态的属性 </p></li><li><p>可通过参数exclude排除一些属性 </p></li><li><p>可通过参数of指定仅使用哪些属性 </p></li><li><p>它默认仅使用该类中定义的属性且不调用父类的方法 </p></li><li><p>可通过callSuper=true解决上一点问题。让其生成的方法中调用父类的方法。</p></li></ol><p>另：@Data相当于@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode这5个注解的合集。</p><p>通过官方文档，可以得知，当使用@Data注解时，则有了@EqualsAndHashCode注解，那么就会在此类中存在equals(Object other) 和 hashCode()方法，且不会使用父类的属性，这就导致了可能的问题。 </p><p>比如，有多个类有相同的部分属性，把它们定义到父类中，恰好id（数据库主键）也在父类中，那么就会存在部分对象在比较时，它们并不相等，却因为lombok自动生成的equals(Object other) 和 hashCode()方法判定为相等，从而导致出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义业务异常，用于处理用户请求时，业务错误时抛出</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiongxiaoyang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/5/11</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@EqualsAndHashCode(callSuper = true)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BusinessException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ErrorCodeEnum errorCodeEnum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BusinessException</span><span class="hljs-params">(ErrorCodeEnum errorCodeEnum)</span> &#123;<br>        <span class="hljs-comment">// 不调用父类 Throwable的fillInStackTrace() 方法生成栈追踪信息，提高应用性能</span><br>        <span class="hljs-comment">// 构造器之间的调用必须在第一行</span><br>        <span class="hljs-built_in">super</span>(errorCodeEnum.getMessage(), <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">this</span>.errorCodeEnum = errorCodeEnum;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>@EqualsAndHashCode只继承属性，不继承方法。</p><p>这里异常分为三大类：数据校验异常、业务处理异常、处理系统异常</p><h3 id="常量类创建"><a href="#常量类创建" class="headerlink" title="常量类创建"></a>常量类创建</h3><p>基本常量如是、否、性别常量等。</p><p>API路径常量。</p><p>业务相关常量包含了：通用常量类、 API 路由常量类、缓存常量类等等。</p><h3 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h3><p>跨域是指浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问问题。</p><p>跨域是出于浏览器的同源策略限制，同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。</p><p>我们可以通过前端配置、后端配置或 nginx 配置来解决跨域问题。</p><p>如果选择前端配置，我们可以使用 node 中间件 proxy 配置跨域，前端通过 node proxy 来转发我们的接口请求，和浏览器直接打交道的是 node proxy，这样可以避免浏览器的同源策略。配置示例如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx">proxy: &#123;<br>  &#x27;/api&#x27;: &#123;<br>    target: &#x27;http://localhost:8888&#x27;,<br>    // 请求改变源，此时 <span class="hljs-attribute">nginx</span> 可以获取到真实的请求 ip<br>    changeOrigin: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果通过 nginx 配置来解决跨域问题，我们在配置 location 路径转发时需要加上如下的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 允许的请求头</span><br><span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET,OPTIONS,POST,PUT,DELETE&#x27;</span> always;<br><span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span> always;<br><span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;<span class="hljs-variable">$http_origin</span>&#x27;</span> always;<br><span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-variable">$http_access_control_request_headers</span>;<br><span class="hljs-attribute">add_header</span> Access-Control-Max-Age <span class="hljs-number">3600</span>;<br><span class="hljs-comment"># 头转发</span><br><span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br><span class="hljs-attribute">proxy_set_header</span> X-Real-Ip <span class="hljs-variable">$remote_addr</span>;<br><span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br><span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">1000</span>;<br><span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">1000</span>;<br><span class="hljs-comment"># 跨域配置</span><br><span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = OPTIONS ) &#123; <span class="hljs-attribute">return</span> <span class="hljs-number">200</span>; &#125;<br></code></pre></td></tr></table></figure><p>因为我们项目的侧重点在后端，而且 Spring MVC 提供了跨域解决方案（<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS (opens new window)</a>）的支持。所以我们这里通过后端配置来解决跨域问题。</p><p>首先我们需要在 application.yml 配置文件中添加跨域相关的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 项目配置</span><br><span class="hljs-attr">novel:</span><br>  <span class="hljs-comment"># 跨域配置</span><br>  <span class="hljs-attr">cors:</span><br>    <span class="hljs-comment"># 允许跨域的域名</span><br>    <span class="hljs-attr">allow-origins:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http://localhost:1024</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http://localhost:8080</span><br></code></pre></td></tr></table></figure><p>然后在<code>io.github.xxyopen.novel.core.config</code>包下创建 CorsProperties 类来绑定 CORS 配置属性:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跨域配置属性</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiongxiaoyang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/5/17</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;novel.cors&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsProperties</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 允许跨域的域名</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; allowOrigins;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在<code>io.github.xxyopen.novel.core.config</code>包下增加如下的 CORS 配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跨域配置</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiongxiaoyang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/5/13</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(CorsProperties.class)</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CorsProperties corsProperties;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>        <span class="hljs-comment">// 允许的域,不要写*，否则cookie就无法使用了</span><br>        <span class="hljs-keyword">for</span> (String allowOrigin : corsProperties.getAllowOrigins()) &#123;<br>            config.addAllowedOrigin(allowOrigin);<br>        &#125;<br>        <span class="hljs-comment">// 允许的头信息</span><br>        config.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 允许的请求方式</span><br>        config.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 是否允许携带Cookie信息</span><br>        config.setAllowCredentials(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">configurationSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>        <span class="hljs-comment">// 添加映射路径，拦截一切请求</span><br>        configurationSource.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>,config);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsFilter</span>(configurationSource);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-Project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaGuide</title>
    <link href="/2022/10/15/JavaGuide/"/>
    <url>/2022/10/15/JavaGuide/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h3><p><strong>JIT的诞生 ？</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/java-code-to-machine-code.png" alt="Java程序转变为机器代码的过程"></p><p>在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)。热点代码使用JIT（just-in-time compilation）编译成机器码保存下来，这样可以高度的重复利用。</p><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p><p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？但AOT的出现AOT(Ahead of Time Compilation)让语言提前编译好了就不动态了，不能是改变了哪里就再更新哪里了。单纯的全部编译就和c++一样了。</p><p><strong>为什么说-java-语言-编译与解释并存为什么说 Java 语言“编译与解释并存”？</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/compiled-and-interpreted-languages.png" alt="编译型语言和解释型语言"></p><p>常见的编译性语言有 C、C++、Go、Rust 等等。</p><p>常见的解释性语言有 Python、JavaScript、PHP 等等。</p><p><strong>Java和C++的区别？</strong></p><p>虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><p>而对象存在于堆内存，局部变量则存在于栈内存。</p><p>(<strong>注意： <code>char</code> 在 Java 中占两个字节</strong>)</p><p><strong>静态方法为什么不能调用非静态成员?</strong></p><p>这个需要结合 JVM 的相关知识，主要原因如下：</p><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><p><strong>重载和重写有什么区别？</strong></p><p>重载</p><p>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。兼容多种数据类型？盲猜重载就是范型的前身</p><p>重写（两同两小一大）</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超级英雄&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超人&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Hero <span class="hljs-title function_">hero</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperSuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperMan</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超级超级英雄&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SuperMan <span class="hljs-title function_">hero</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperMan</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p><p>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p><p>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 <code>class</code>文件就可以看出来了。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>Java 中的几种基本数据类型了解么？</strong></p><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型：</li></ul><ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul><ul><li><p>1 种字符类型：<code>char</code></p></li><li><p>1 种布尔型：<code>boolean</code>。</p></li></ul><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">基本类型</th><th style="text-align:left">位数</th><th style="text-align:left">字节</th><th style="text-align:left">默认值</th><th>取值范围</th></tr></thead><tbody><tr><td style="text-align:left"><code>byte</code></td><td style="text-align:left">8</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td>-128 ~ 127</td></tr><tr><td style="text-align:left"><code>short</code></td><td style="text-align:left">16</td><td style="text-align:left">2</td><td style="text-align:left">0</td><td>-32768 ~ 32767</td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left">32</td><td style="text-align:left">4</td><td style="text-align:left">0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td style="text-align:left"><code>long</code></td><td style="text-align:left">64</td><td style="text-align:left">8</td><td style="text-align:left">0L</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td style="text-align:left"><code>char</code></td><td style="text-align:left">16</td><td style="text-align:left">2</td><td style="text-align:left">‘u0000’</td><td>0 ~ 65535</td></tr><tr><td style="text-align:left"><code>float</code></td><td style="text-align:left">32</td><td style="text-align:left">4</td><td style="text-align:left">0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td style="text-align:left"><code>double</code></td><td style="text-align:left">64</td><td style="text-align:left">8</td><td style="text-align:left">0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left">1</td><td style="text-align:left"></td><td style="text-align:left">false</td><td>true、false</td></tr></tbody></table></div><p><strong>注意：</strong></p><ol><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li><li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li></ol><p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code>。</p><p><strong>基本类型和包装类型的区别？</strong></p><ul><li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p><p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p><p><strong>包装类的作用</strong></p><p>在 Java 中每个基本数据类型都对应了一个包装类，而 <strong>int 对应的包装类就是 Integer</strong>，<strong>包装类的存在解决了基本数据类型无法做到的事情泛型类型参数、序列化、类型转换、高频区间数据缓存等问题</strong>。主要是数据存储的不同，因为普通数据类型不能像对象一样操作。</p><p><strong>equals 和 == 的区别？</strong></p><p>关于== </p><p>主要是针对基本数据类型</p><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：<br>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；</p><p>关于equals<br>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。为对象的值比较提供了方法。</p><h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><p><strong>对象的相等和引用相等的区别？</strong></p><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><p><strong>如果一个类没有声明构造方法，该程序能正确执行吗?</strong></p><p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><p><strong>接口和抽象类有什么共同点和区别？</strong></p><p><strong>共同点</strong> ：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong> ：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><p><a href="https://clearlove.blog.csdn.net/article/details/83059774?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-83059774-blog-79704852.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-83059774-blog-79704852.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=1">https://clearlove.blog.csdn.net/article/details/83059774?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-83059774-blog-79704852.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-83059774-blog-79704852.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=1</a> 抽象类和接口的意义</p><p>接口的出现就是为了让不同的人可以做相同事情，从而让设计与实现分离。是设计层面上的事情。</p><p><strong>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</strong></p><p>关于深拷贝和浅拷贝区别 <a href="https://developer.aliyun.com/article/924307?spm=a2c6h.12873639.article-detail.23.37bf3ddcLOR6aE&amp;scm=20140722.ID_community@@article@@924307._.ID_community@@article@@924307-OR_rec-V_1">https://developer.aliyun.com/article/924307?spm=a2c6h.12873639.article-detail.23.37bf3ddcLOR6aE&amp;scm=20140722.ID_community@@article@@924307._.ID_community@@article@@924307-OR_rec-V_1</a></p><p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。（和浅拷贝和深拷贝都不同，因为堆空间不创建新的对象）</p><p>浅拷贝：基本数据类型是值赋值；非基本的就是引用赋值，所以说就是引用类型还是共享地址，基本数据类型就是单纯复制值，这样和原数据是隔离的。</p><p>深拷贝：全部数据都是隔离的。相当于全新的clone体。</p><p><strong>String、StringBuffer、StringBuilder 的区别？</strong></p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><p>比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p><p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化</p><p>常量才会在编译期间放在虚拟机中。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图"></p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><strong>try-catch-finally 如何使用？</strong></p><ul><li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code>块。</li><li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li><li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Try to do something&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;RuntimeException&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">Try to do something<br>Catch Exception -&gt; RuntimeException<br>Finally<br></code></pre></td></tr></table></figure><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p><ol><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><p><strong>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</strong></p><ol><li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li><li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读取文本文件的内容</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D://read.txt&quot;</span>));<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (scanner != <span class="hljs-literal">null</span>) &#123;<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改造后，有点类似于defer，等程序运行完了或者中断了等等，再catch or finally    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))) &#123;<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException fnfe) &#123;<br>    fnfe.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><strong>泛型的使用方式有哪几种？</strong></p><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><p><strong>1.泛型类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="hljs-comment">//在实例化泛型类时，必须指定T的具体类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> T key;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;Integer&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure><p><strong>2.泛型接口</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现泛型接口，不指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.泛型方法</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; E &gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">( E[] inputArray )</span><br>&#123;<br>      <span class="hljs-keyword">for</span> ( E element : inputArray )&#123;<br>         System.out.printf( <span class="hljs-string">&quot;%s &quot;</span>, element );<br>      &#125;<br>      System.out.println();<br> &#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建不同类型数组： Integer, Double 和 Character</span><br>Integer[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>String[] stringArray = &#123; <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span> &#125;;<br>printArray( intArray  );<br>printArray( stringArray  );<br></code></pre></td></tr></table></figure><blockquote><p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以<strong>静态泛型方法是没有办法使用类上声明的泛型的</strong>。只能使用自己声明的 <code>&lt;E&gt;</code></p></blockquote><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><strong>何谓反射？</strong></p><p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><p><strong>反射的应用场景？</strong></p><p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p><p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p><p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p><p>相当于我先获取到标签，或者说是注释然后再进行对应的分析。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><strong>何谓注解？</strong></p><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Override</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p><p><strong>注解的解析方法有哪几种？</strong></p><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p><p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p><p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p><p><strong>那 SPI 和 API 有啥区别？</strong></p><p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png" alt="img"></p><p>一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p><p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p><p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根绝这个规则对这个接口进行实现，从而提供服务。</p><p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p><p>API决定权在实现方，SPI的决定权在调用方。</p><p><strong>SPI 的优缺点？</strong></p><p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p><ul><li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li><li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li></ul><h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/a478c74d-2c48-40ae-9374-87aacf05188c.png" alt="img"></p><p><strong>如果有些字段不想进行序列化怎么办？</strong></p><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><p> <strong>Java IO 流了解吗？</strong></p><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h3 id="Java-IO-中的设计模式有哪些？"><a href="#Java-IO-中的设计模式有哪些？" class="headerlink" title="Java IO 中的设计模式有哪些？"></a>Java IO 中的设计模式有哪些？</h3><p><a href="https://javaguide.cn/java/io/io-design-patterns.html">Java IO 设计模式总结 </a> 后面IO里面有讲</p><h3 id="BIO、NIO-和-AIO-的区别？"><a href="#BIO、NIO-和-AIO-的区别？" class="headerlink" title="BIO、NIO 和 AIO 的区别？"></a>BIO、NIO 和 AIO 的区别？</h3><p><a href="https://javaguide.cn/java/io/io-model.html">Java IO 模型详解</a> 后面IO里面有讲</p><h3 id="Java-中有哪些常见的语法糖？"><a href="#Java-中有哪些常见的语法糖？" class="headerlink" title="Java 中有哪些常见的语法糖？"></a>Java 中有哪些常见的语法糖？</h3><p>Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。</p><p>关于这些语法糖的详细解读，请看这篇文章 <a href="https://javaguide.cn/java/basis/syntactic-sugar.html">Java 语法糖详解</a> 。</p><h3 id="🌟重要知识点"><a href="#🌟重要知识点" class="headerlink" title="🌟重要知识点"></a>🌟重要知识点</h3><h4 id="Java怎么就全都是值传递了？"><a href="#Java怎么就全都是值传递了？" class="headerlink" title="Java怎么就全都是值传递了？"></a>Java怎么就全都是值传递了？</h4><p><strong>值传递&amp;引用传递</strong></p><p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p><ul><li><strong>值传递</strong> ：方法接收的是实参值的拷贝，会创建副本。</li><li><strong>引用传递</strong> ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li></ul><p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</p><p>看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。</p><p>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！</p><p>也就是说 <code>change</code> 方法的参数拷贝的是 <code>arr</code> （实参）的地址，因此，它和 <code>arr</code> 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p><p>为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！</p><p><strong>Java只有值传递</strong></p><p>要么他直接传输基本数据类型，要么就是引用类型，引用类型怎么办呢？那就是传递它的地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">xiaoZhang</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小张&quot;</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">xiaoLi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小李&quot;</span>);<br>    swap(xiaoZhang, xiaoLi);<br>    System.out.println(<span class="hljs-string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());<br>    System.out.println(<span class="hljs-string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(Person person1, Person person2)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> person1;<br>    person1 = person2;<br>    person2 = temp;<br>    System.out.println(<span class="hljs-string">&quot;person1:&quot;</span> + person1.getName());<br>    System.out.println(<span class="hljs-string">&quot;person2:&quot;</span> + person2.getName());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">person1:小李<br>person2:小张<br>xiaoZhang:小张<br>xiaoLi:小李<br></code></pre></td></tr></table></figure><p>都互换对象了，你本身的对象里的值还是没变说明啥，说明<code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此， <code>person1</code>和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p><h4 id="Java序列化详解"><a href="#Java序列化详解" class="headerlink" title="Java序列化详解"></a>Java序列化详解</h4><p><strong>实际开发中有哪些用到序列化和反序列化的场景？</strong></p><ol><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。</li><li>将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。</li></ol><p><strong>常见序列化协议对比</strong></p><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有 hessian、kryo、protostuff。</p><p>下面提到的都是基于二进制的序列化协议，像 JSON 和 XML 这种属于文本类序列化方式。虽然 JSON 和 XML 可读性比较好，但是性能较差，一般不会选择。</p><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1905122041950251207L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-keyword">private</span> Object[] parameters;<br>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] paramTypes;<br>    <span class="hljs-keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>序列化号 serialVersionUID 属于版本控制的作用。序列化的时候 serialVersionUID 也会被写入二进制序列，当反序列化时会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的序列化号</p></blockquote><p>我们很少或者说几乎不会直接使用这个序列化方式，主要原因有两个：</p><ol><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li></ol><p><strong>Kryo</strong></p><p>Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。</p><p><strong>Protobuf</strong></p><p>Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</p><blockquote><p>Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言</p></blockquote><p>一个简单的 proto 文件如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// protobuf的版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-comment">// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-comment">//string类型字段</span><br>  <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// int 类型字段</span><br>  <span class="hljs-type">int32</span> age = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ProtoStuff</strong></p><p>由于 Protobuf 的易用性，它的哥哥 Protostuff 诞生了。</p><p>protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p><p><strong>hessian</strong></p><p>hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。</p><p>dubbo RPC 默认启用的序列化方式是 hessian2 ,但是，Dubbo 对 hessian2 进行了修改，不过大体结构还是差不多。</p><p><strong>总结</strong></p><p>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：<a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/">https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/open in new window</a>)</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/569e541a-22b2-4846-aa07-0ad479f07440.png" alt="img"></p><p>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p><p>除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。</p><h4 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h4><p><strong>反射实战</strong></p><p><strong>获取 Class 对象的四种方式</strong></p><p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p><p><strong>1. 知道具体类的情况下可以使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass</span> <span class="hljs-operator">=</span> TargetObject.class;<br></code></pre></td></tr></table></figure><p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p><p><strong>2. 通过 <code>Class.forName()</code>传入类的全路径获取：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>3. 通过对象实例<code>instance.getClass()</code>获取：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TargetObject</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetObject</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass2</span> <span class="hljs-operator">=</span> o.getClass();<br></code></pre></td></tr></table></figure><p><strong>4. 通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行</p><p><strong>反射的一些基本操作</strong></p><ol><li>创建一个我们要使用反射操作的类 <code>TargetObject</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.javaguide;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetObject</span> &#123;<br>    <span class="hljs-keyword">private</span> String value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TargetObject</span><span class="hljs-params">()</span> &#123;<br>        value = <span class="hljs-string">&quot;JavaGuide&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publicMethod</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love &quot;</span> + s);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">privateMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;value is &quot;</span> + value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>使用反射操作这个类的方法以及参数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.javaguide;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例</span><br><span class="hljs-comment">         */</span><br>        Class&lt;?&gt; targetClass = Class.forName(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br>        <span class="hljs-type">TargetObject</span> <span class="hljs-variable">targetObject</span> <span class="hljs-operator">=</span> (TargetObject) targetClass.newInstance();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取 TargetObject 类中定义的所有方法</span><br><span class="hljs-comment">         */</span><br>        Method[] methods = targetClass.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(method.getName());<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取指定方法并调用</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">publicMethod</span> <span class="hljs-operator">=</span> targetClass.getDeclaredMethod(<span class="hljs-string">&quot;publicMethod&quot;</span>,<br>                String.class);<br><br>        publicMethod.invoke(targetObject, <span class="hljs-string">&quot;JavaGuide&quot;</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取指定参数并对参数进行修改</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> targetClass.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>        <span class="hljs-comment">//为了对类中的参数进行修改我们取消安全检查</span><br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(targetObject, <span class="hljs-string">&quot;JavaGuide&quot;</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 调用 private 方法</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">privateMethod</span> <span class="hljs-operator">=</span> targetClass.getDeclaredMethod(<span class="hljs-string">&quot;privateMethod&quot;</span>);<br>        <span class="hljs-comment">//为了调用private方法我们取消安全检查</span><br>        privateMethod.setAccessible(<span class="hljs-literal">true</span>);<br>        privateMethod.invoke(targetObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">publicMethod<br>privateMethod<br>I love JavaGuide<br>value is JavaGuide<br></code></pre></td></tr></table></figure><p><strong>注意</strong> : 有读者提到上面代码运行会抛出 <code>ClassNotFoundException</code> 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 <code>TargetObject</code> 所在的包 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; targetClass = Class.forName(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h4><p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p><p>举个例子：新娘找来了自己的姨妈来代替自己处理新郎的提问，新娘收到的提问都是经过姨妈处理过滤之后的。姨妈在这里就可以看作是代理你的代理对象，代理的行为（方法）是接收和回复新郎的提问。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/1*DjWCgTFm-xqbhbNQVsaWQw.png" alt="Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium"></p><p><strong>1. 静态代理</strong></p><p>从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p><p>静态代理实现步骤:</p><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li></ol><p>静态代理非常像内嵌了一个代理的方法。是一个包含的关系。</p><p><strong>2. 动态代理</strong></p><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p><p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p><p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。</p><p><strong>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p><p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p><h4 id="BigDecimal详解"><a href="#BigDecimal详解" class="headerlink" title="BigDecimal详解"></a>BigDecimal详解</h4><p>《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 <code>BigDecimal</code> 来进行浮点数的运算”。</p><p>浮点数的运算竟然还会有精度丢失的风险吗？确实会！</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.9f</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.8f</span> - <span class="hljs-number">1.7f</span>;<br>System.out.println(a);<span class="hljs-comment">// 0.100000024</span><br>System.out.println(b);<span class="hljs-comment">// 0.099999905</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>为什么浮点数 <code>float</code> 或 <code>double</code> 运算的时候会有精度丢失的风险呢？</strong></p><p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p><p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span><br><span class="hljs-comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span><br><span class="hljs-number">0.2</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.4</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">0.4</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.8</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">0.8</span> * <span class="hljs-number">2</span> = <span class="hljs-number">1.6</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-number">0.6</span> * <span class="hljs-number">2</span> = <span class="hljs-number">1.2</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-number">0.2</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.4</span> -&gt; <span class="hljs-number">0</span>（发生循环）<br></code></pre></td></tr></table></figure><p>浮点数没有办法用二进制精确表示，因此存在精度丢失的风险。</p><p>不过，Java 提供了<code>BigDecimal</code> 来操作浮点数。<code>BigDecimal</code> 的实现利用到了 <code>BigInteger</code> （用来操作大整数）, 所不同的是 <code>BigDecimal</code> 加入了小数位的概念。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p><a href="https://www.51cto.com/article/620174.html">https://www.51cto.com/article/620174.html</a> 集合概述</p><p><strong>Java集合预览</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java-collection-hierarchy.png" alt="img"></p><p><strong>说说List，Set，Queue，Map四者区别？</strong></p><ul><li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li><li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><p><strong>集合框架底层数据结构总结</strong></p><p><strong>List</strong></p><ul><li><code>ArrayList</code>： <code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><p><strong>Set</strong></p><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><p><strong>Queue</strong></p><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p>再来看看 <code>Map</code> 接口下面的集合。</p><p><strong>Map</strong></p><ul><li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a></li><li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li></ul><h3 id="Collection-子接口之-list"><a href="#Collection-子接口之-list" class="headerlink" title="Collection 子接口之 list"></a>Collection 子接口之 list</h3><p><strong>ArrayList 和 Vector 的区别?</strong></p><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</li></ul><h3 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h3><p><strong>comparable 和 Comparator 的区别</strong></p><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定制排序的用法</span><br>Collections.sort(arrayList, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o2.compareTo(o1);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Person&gt; &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * T重写compareTo方法实现按年龄来排序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Person o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.age &gt; o.getAge()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.age &lt; o.getAge()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前者在Comparator内重写，后者引用接口后，实现重写的接口compareTo(T)</p><p><strong>无序性和不可重复性的含义是什么</strong></p><ul><li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h3 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a><strong>Collection 子接口之 Queue</strong></h3><p><strong>Queue 与 Deque 的区别</strong></p><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><div class="table-container"><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table></div><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><div class="table-container"><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table></div><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="Java-IO-基础"><a href="#Java-IO-基础" class="headerlink" title="Java IO 基础"></a>Java IO 基础</h3><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h3 id="Java-IO-设计模式"><a href="#Java-IO-设计模式" class="headerlink" title="Java IO 设计模式"></a>Java IO 设计模式</h3><p><strong>装饰器模式</strong></p><p><strong>装饰器（Decorator）模式</strong> 可以在不改变原有对象的情况下拓展其功能。</p><p>装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</p><p>对于字节流来说， <code>FilterInputStream</code> （对应输入流）和<code>FilterOutputStream</code>（对应输出流）是装饰器模式的核心，分别用于增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p><strong>适配器模式</strong></p><p><strong>适配器（Adapter Pattern）模式</strong> 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。</p><p>适配器模式中存在被适配的对象或者类称为 <strong>适配者(Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器(Adapter)</strong>。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。</p><p><strong>适配器模式和装饰器模式有什么区别呢？</strong></p><p><strong>装饰器模式</strong> 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</p><p><strong>适配器模式</strong> 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 <code>StreamDecoder</code> （流解码器）和<code>StreamEncoder</code>（流编码器）就是分别基于 <code>InputStream</code> 和 <code>OutputStream</code> 来获取 <code>FileChannel</code>对象并调用对应的 <code>read</code> 方法和 <code>write</code> 方法进行字节数据的读取和写入。</p><p><strong>工厂模式</strong></p><p>工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 <code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（静态工厂）、 <code>Paths</code> 类的 <code>get</code> 方法创建 <code>Path</code> 对象（静态工厂）、<code>ZipFileSystem</code>类（<code>sun.nio</code>包下的类，属于 <code>java.nio</code> 相关的一些内部实现）的 <code>getPath</code> 的方法创建 <code>Path</code> 对象（简单工厂）。</p><p><strong>观察者模式</strong></p><p>NIO 中的文件目录监听服务使用到了观察者模式。</p><p>NIO 中的文件目录监听服务基于 <code>WatchService</code> 接口和 <code>Watchable</code> 接口。<code>WatchService</code> 属于观察者，<code>Watchable</code> 属于被观察者。</p><h3 id="Java-IO-模型"><a href="#Java-IO-模型" class="headerlink" title="Java IO 模型"></a>Java IO 模型</h3><p><img src="https://img-blog.csdnimg.cn/20190624122126398.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="冯诺依曼体系结构"></p><p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p><p><strong>我们再先从应用程序的角度来解读一下 I/O。</strong></p><p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p><p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p><p>并且，用户空间的程序不能直接访问内核空间。</p><p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p><p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p><p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol><p><strong>有哪些常见的 IO 模型?</strong></p><p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p><p>这也是我们经常提到的 5 种 IO 模型。</p><h4 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a><strong>Java 中 3 种常见 IO 模型</strong></h4><p><strong>BIO (Blocking I/O)</strong></p><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。(发出IO请求后知道你给我我要的才释放阻塞)</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。（BIO面对高并发无力）</p><p><strong>NIO (Non-blocking/New I/O)</strong></p><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>跟着我的思路往下看看，相信你会得到答案！</p><p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。（同步非阻塞IO就是允许你疯狂的发io请求，但我不执行，也是等到拷贝到数据后再继续）</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。（select像是一个调度员，分配好资源了，你再read）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p><strong>AIO (Asynchronous I/O)</strong></p><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。（AIO就是你请求你的，我处理好数据拷贝好了再给你回调回去）</p><p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p><p><img src="https://images.xiaozhuanlan.com/photo/2020/33b193457c928ae02217480f994814b6.png" alt="img"></p><p><strong>IO多路复用，select、poll、epoll区别</strong>  <a href="https://juejin.cn/post/6931543528971436046">https://juejin.cn/post/6931543528971436046</a></p><p>select就是找了一个线程，盲猜是内核线程来进行调度，他来接受所有的请求，fd请求，可以直接看作socket。接受请求以后我们再继续探索该谁了。文件描述符就是文件的序号FD，linux一切皆文件用fd来表示，这样方便统一查询。</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p><strong>什么是线程和进程?</strong></p><p><strong>何为进程?</strong></p><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p><strong>何为线程?</strong></p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>进程的切换需要切换堆和方法区的资源，而线程的资源都是都是堆和方法区的资源内存块的内部，所以切换起来不需要更换内存区。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)\</strong>资源，但是每个线程有自己的*<em>程序计数器<strong>、</strong>虚拟机栈<strong> 和 </strong>本地方法栈*</em>。</p><p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p><p><strong>程序计数器为什么是私有的?</strong></p><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。（用来记录指令执行的位置）</p><p><strong>虚拟机栈和本地方法栈为什么是私有的?</strong></p><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于<strong>【存储局部变量表、操作数栈、常量池引用】</strong>等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。(执行的时候需要自己的空间，就局部变量那些东西，所以说我们需要一个虚拟机栈和本地方法栈私有，<strong>其中Native方法是什么？</strong>简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。程序计数器就像是指针标记我们现在代码执行的位置)</p><p><strong>一句话简单了解堆和方法区</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2ff6db0fde4416ba3b06992002b179c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。（方法区存我们定义的对象的类型，java堆生成的对象包含两个方面一个是标记对象类型的指针，一个是对象已经定义好的初始化好的数据。而且方法区的东西的特征就是已经加载好的不会变的！！！这很重要）</p><p><strong>并发与并行的区别</strong></p><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行。</p><p><strong>同步和异步的区别</strong></p><ul><li><strong>同步</strong> ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong> ：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><p><strong>为什么要使用多线程呢?</strong></p><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li><li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</li></ul><p>单核的多线程是一cpu核心对多线程</p><p>多核的多线程是多cpu核心对多线程</p><p><strong>使用多线程可能带来什么问题?</strong></p><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p><p>（内存泄漏：同时占用太多的资源，内存直接爆了；死锁：同时竞争共享资源；线程不安全：出现脏读，幻读）</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/640.png" alt="Java 线程状态变迁图"></p><p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJavaopen in new window</a>：<a href="https://howtodoinjava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread Statesopen in new window</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p><p><strong>为什么 JVM 没有区分这两种状态呢？</strong> （摘自：<a href="https://www.zhihu.com/question/56494969/answer/154053599">Java 线程运行怎么有第六种状态？ - Dawell 的回答open in new window</a> ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p><p><strong>什么是上下文切换?</strong></p><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><p><strong>死锁的必要条件？</strong></p><p>上面的例子符合产生死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p><strong>如何预防和避免线程死锁?</strong></p><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p><ol><li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p><strong>如何避免死锁？</strong></p><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><blockquote><p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p></blockquote><p><strong>JMM（java内存模型）</strong></p><p><strong>volatile 关键字</strong></p><p>如何保证变量的可见性？</p><p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/jmm.png" alt="img"></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/jmm2.png" alt="JMM(Java 内存模型)强制在主存中进行读取"></p><p><code>volatile</code> 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。（相当于直接all in主内存中的内容）</p><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><p><strong>双重校验锁实现对象单例（线程安全）</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p>（volatile可以禁止指令重排，从而保证执行的顺序）</p><p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p><p><strong>volatile的作用</strong></p><p>volatile的作用就是当一个线程更新某个volatile声明的变量时，会通知其他的cpu使缓存失效，从而其他cpu想要做更新操作时，需要从内存重新读取数据。具体的通知方式，一种是通过某种协议，比如MESI；再就是对总线加锁，控制变量的读取。</p><p><strong>说一说自己对于 synchronized 关键字的了解</strong></p><p><code>synchronized</code> 翻译成中文是同步的的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。 因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>不过，在 Java 6 之后，Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 <code>synchronized</code> 关键字。</p><p><strong>如何使用 synchronized 关键字？</strong></p><p>synchronized 关键字最主要的三种使用方式：</p><ol><li>修饰实例方法</li><li>修饰静态方法</li><li>修饰代码块</li></ol><p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p><p><strong>总结：</strong></p><ul><li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li><li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li><li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能。</li></ul><p><strong>总结</strong></p><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><p><strong>synchronized 和 volatile 的区别？</strong></p><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li><li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li><li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li></ul><p><strong>ThreadLocal 有什么用？</strong></p><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p><p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p><strong>为什么要用线程池？</strong></p><blockquote><p><strong>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p></blockquote><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><p><img src="https://javaguide.cn/assets/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.2b9eb21a.png" alt="图解线程池实现原理"></p><p><strong>基本类型</strong></p><p>使用原子的方式更新基本类型</p><ul><li><code>AtomicInteger</code>：整型原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code>：布尔型原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li><code>AtomicIntegerArray</code>：整型数组原子类</li><li><code>AtomicLongArray</code>：长整型数组原子类</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类</li></ul><p><strong>引用类型</strong></p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li></ul><p><strong>AQS（抽象队列同步器） 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/AQS%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="AQS原理图"></p><h3 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h3><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/cpu-cache.png" alt="CPU 缓存模型示意图"></p><p><strong>CPU Cache 的工作方式：</strong> 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 <strong>内存缓存不一致性的问题</strong> ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。</p><p><strong>CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 <a href="https://zh.wikipedia.org/wiki/MESI协议">MESI 协议open in new window</a>）或者其他手段来解决。</strong> 这个缓存一致性协议指的是在 CPU 高速缓存与主内存交互的时候需要遵守的原则和规范。不同的 CPU 中，使用的缓存一致性协议通常也会有所不同。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/cpu-cache-protocol.png" alt="缓存一致性协议"></p><ul><li><strong>主内存</strong> ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li><li><strong>本地内存</strong> ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</li></ul><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/jmm.png" alt="JMM(Java 内存模型)"></p><p>从上图来看，线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：</p><ol><li>线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。</li><li>线程 2 到主存中读取对应的共享变量的值。</li></ol><p>也就是说，JMM 为共享变量提供了可见性的保障</p><p><strong>并发编程三个重要特性</strong></p><p><strong>原子性</strong></p><p>一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p><p>在 Java 中，可以借助<code>synchronized</code> 、各种 <code>Lock</code> 以及各种原子类实现原子性。</p><p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p><p><strong>可见性</strong></p><p>当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p><p>在 Java 中，可以借助<code>synchronized</code> 、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p><p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><strong>有序性</strong></p><p>由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p><p>我们上面讲重排序的时候也提到过：</p><blockquote><p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p></blockquote><p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>jdk1.8之前：</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.8 之前）"></p><p>jdk1.8之后：</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2ff6db0fde4416ba3b06992002b179c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><p>方法区记录对象类型；Java堆存储实例化后的对象；</p><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>tcp和udp</p><div class="table-container"><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否面向连接</td><td>是</td><td>否</td></tr><tr><td>是否可靠</td><td>是</td><td>否</td></tr><tr><td>是否有状态</td><td>是</td><td>否</td></tr><tr><td>传输效率</td><td>较慢</td><td>较快</td></tr><tr><td>传输形式</td><td>字节流</td><td>数据报文段</td></tr><tr><td>首部开销</td><td>20 ～ 60 bytes</td><td>8 bytes</td></tr><tr><td>是否提供广播或多播服务</td><td>否</td><td>是</td></tr></tbody></table></div><p><strong>使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</strong></p><p><strong>运行于 TCP 协议之上的协议</strong> ：</p><ol><li><strong>HTTP 协议</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li><strong>HTTPS 协议</strong> ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li><li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，<strong>基于 TCP</strong> 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</li><li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，<strong>基于 TCP 协议</strong>，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。</li><li><strong>POP3/IMAP 协议</strong>： POP3 和 IMAP 两者都是负责邮件接收的协议。</li><li><strong>Telent 协议</strong>：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。</li><li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li><li>……</li></ol><p><strong>运行于 UDP 协议之上的协议</strong> ：</p><ol><li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li><li><strong>DNS</strong> ： <strong>域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。</strong> 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li></ol><p><strong>TCP 三次握手和四次挥手（非常重要）</strong></p><p><strong>相关面试题</strong> ：</p><ul><li>为什么要三次握手?</li><li>第 2 次握手传回了ACK，为什么还要传回SYN？</li><li>为什么要四次挥手？</li><li>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</li><li>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</li><li>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</li></ul><p><strong>参考答案</strong> ：<a href="https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html">TCP 三次握手和四次挥手（传输层）</a> 。</p><p><strong>TCP 如何保证传输的可靠性？（重要）</strong></p><p><a href="https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html">TCP 传输可靠性保障（传输层）</a></p><p><strong>HTTP</strong></p><p><strong>从输入URL 到页面展示到底发生了什么？（非常重要）</strong></p><blockquote><p>类似的问题：打开一个网页，整个过程会使用哪些协议？</p></blockquote><p>图解（图片来源：《图解 HTTP》）：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="img"></p><blockquote><p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p></blockquote><p>总体来说分为以下几个过程:</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>具体可以参考下面这两篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000006879700">从输入URL到页面加载发生了什么？open in new window</a></li><li><a href="https://cloud.tencent.com/developer/article/1879758">浏览器从输入网址到页面展示的过程open in new window</a></li></ul><p><strong>OSI七层体系结构</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png" alt="osi七层模型2"></p><p>应用层：计算机网络应用</p><p>表示层：数据处理（编解码）</p><p>会话层：管理（建立、维护、重连）应用程序之间的会话</p><p>传输层：TCP、UDP等用来建立连接的的传输服务</p><p>网络层：IP、ARP用来找地址用的</p><p>数据链路层：帧编码和误差纠正控制，用来保证链路传输的可靠性</p><p>物理层：透明的传输比特流</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/network-protocol-overview.png" alt="TCP/IP 各层协议概览"></p><p><strong>HTTP和HTTPS</strong></p><p><strong>SSL/TLS 的工作原理</strong></p><p>SSL使用的是非对称加密，但是SSL的使用者传递的信息使用的是对称加密（因为资源消耗的问题）</p><p><img src="https://pic4.zhimg.com/80/v2-a994fbf3094d737814fe01c2b919477b_1440w.webp" alt="img"></p><p>服务端的公钥给客户端让他把对称的密钥，用公钥加密后还给服务端，这样服务端就可以用公钥包裹的对称加密来进行通信。</p><p>总结</p><ul><li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li><li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li></ul><p>三次握手？</p><p>第一次握手：客户端向服务端提出连接请求，确认服务端状态</p><p>第二次握手：服务端回应客户端的请求，回应客户端服务端状态ok和提出客户端仍提出连接请求的状态，发送ACK</p><p>第三次握手：客户端再次发送确认连接的请求，最终从而双向确认。    </p><p>四次挥手？</p><p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p><p>客户端和服务端双向确认断开连接。</p><p><strong>TCP 如何保证传输的可靠性？</strong></p><ol><li><strong>基于数据快传输</strong> ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li><li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li><li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<a href="https://zh.wikipedia.org/wiki/丢包">已丢失open in new window</a>并进行重传。</li><li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li><li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li></ol><p><strong>TCP发送窗口结构图示</strong> ：</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-send-window.png" alt="TCP发送窗口结构"></p><ul><li><strong>SND.WND</strong> ：发送窗口。</li><li><strong>SND.UNA</strong>：Send Unacknowledged 指针，指向发送窗口的第一个字节。</li><li><strong>SND.NXT</strong>：Send Next 指针，指向可用窗口的第一个字节。</li></ul><p><strong>可用窗口大小</strong> = <code>SND.UNA + SND.WND - SND.NXT</code> 。</p><p><strong>TCP 接收窗口可以划分成三个部分</strong> ：</p><ol><li>已经接收并且已经确认的 TCP 段（已经接收并确认）；</li><li>等待接收且允许发送方发送 TCP 段（可以接收未确认）；</li><li>不可接收且不允许发送方发送TCP段（不可接收）。</li></ol><p>两个状态一个已经发送（未发送）</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-congestion-control.png" alt="TCP的拥塞控制"></p><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li><li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><p><strong>ARP协议是什么？</strong></p><ol><li><strong>ARP 协议在协议栈中的位置？</strong> ARP 协议在协议栈中的位置非常重要，在理解了它的工作原理之后，也很难说它到底是网络层协议，还是链路层协议，因为它恰恰串联起了网络层和链路层。国外的大部分教程通常将 ARP 协议放在网络层。</li><li><strong>ARP 协议解决了什么问题，地位如何？</strong> ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li><li><strong>ARP 工作原理？</strong> 只希望大家记住几个关键词：<strong>ARP 表、广播问询、单播响应</strong>。</li></ol><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p><strong>什么是操作系统？</strong></p><p>os是管理计算机硬件与软件资源的程序，是计算机的基石。</p><p>本质是运行在计算机上的软件程序，用于管理计算机硬件和软件资源。</p><p><strong>什么是系统调用？</strong></p><p>凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p><p><strong>进程间通信？</strong></p><p><a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a> 文章总结</p><p><strong>线程间通信？</strong></p><p>1、互斥量，比如互斥锁。</p><p>2、信号量，控制同一时刻访问此资源的最大线程数量。</p><p>3、事件，通过Wait和Notify来主动控制线程的启停。</p><p><strong>进程的调度算法？</strong></p><p>1、先来先服务（FCFS）调度算法：先进来的先运行</p><p>2、短时间优先调度算法：从就绪队列中选出一个估计运行时间最短的进程为之分配资源</p><p>3、时间片轮转调度算法：时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</p><p>4、多级反馈队列调度算法：多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</p><p>详细说一下，首先来说他的多级体现在我们有多个优先级的队列，随着优先级的队列越高所分得得时间片越短。反馈指的是对于其他队列，遵循的是先来先服务算法，每一进程分配一定的时间片，若时间片运行完时进程未结束，则进入下一优先级队列的末尾。</p><p>5、优先级调度算法：为每个流程进行分级，分配其优先级，然后同一个级别用FCFS来进行调度。</p><p><strong>什么是死锁？</strong></p><p>死锁就是多个线程/进程同时抢占对方手上公共资源，且都不释放手中的资源，从而进程或者线程进入阻塞状态，导致了僵持形成了死锁。</p><p><strong>死锁的四个条件？</strong></p><p>互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</p><p>请求并保持：请求不到资源进入阻塞态，但不放弃自己占用的资源。</p><p>不可剥夺：不可以强行抢占别的线程已占用的资源</p><p>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。</p><p><strong>解决死锁的方法？</strong></p><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p><ul><li><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li><li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li><li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li><li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li></ul><p>预防就是破坏四大条件。</p><p>避免就是提前分配好资源可以进行预测，没有问题就可以执行（银行家算法）。</p><p><strong>常见的几种内存管理机制</strong></p><ol><li><strong>块式管理</strong> ： 远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。（👴想要多大的就开多大的）</li><li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。（官方有规矩的开多大，有定长）</li><li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。（我们直接在选择一段一段的内存来放比如main函数或者什么的）</li></ol><p>简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。</p><p><strong>页面淘汰算法</strong></p><ul><li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li><li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li><li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li><li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li></ul><h3 id="Linux基础知识总结"><a href="#Linux基础知识总结" class="headerlink" title="Linux基础知识总结"></a>Linux基础知识总结</h3><p>基本指令</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>红黑树？</strong></p><p>为了解决BST（二叉搜索树插入一个比一个小的数的时候树深度一直在增加的问题）</p><p><strong>布隆过滤器？</strong></p><p>布隆过滤器使用场景</p><ol><li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。</li><li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</li></ol><p>如果你想要手动实现一个的话，你需要：</p><ol><li>一个合适大小的位数组保存数据</li><li>几个不同的哈希函数</li><li>添加元素到位数组（布隆过滤器）的方法实现</li><li>判断给定元素是否存在于位数组（布隆过滤器）的方法实现。</li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p>字符集</p><p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p><ul><li><strong><code>utf8</code></strong> ： <code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li><li><strong><code>utf8mb4</code></strong> ： UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p><strong>mysql的架构</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png" alt="img"></p><p>从上图可以看出， MySQL 主要由下面几部分构成：</p><p>（分幼稚）分析语法，优化执行顺序，操作引擎执行sql语句</p><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（<strong>MySQL 8.0 版本后移除，因为这个功能不太实用</strong>）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><p><strong>MySQL 存储引擎架构了解吗？</strong></p><p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><p>并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。</p><p><strong>MyISAM 和 InnoDB 的区别是什么？</strong></p><p><img src="https://img-blog.csdnimg.cn/20210327145248960.png" alt="img"></p><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。<strong>（垃圾咯就因为没有事务保证它的可靠性）</strong></p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>言归正传！咱们下面还是来简单对比一下两者：</p><p><strong>1.是否支持行级锁</strong></p><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p>也就说，<strong>MyISAM 一锁就是锁住了整张表</strong>，这在并发写的情况下是多么滴憨憨啊！（你这么锁的话那和java里面直接的锁有啥区别，就是我一个请求，你其他请求啥也别干了，直接单线程）这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 <strong>REPEATABLE-READ（可重读）</strong>隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p><p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解open in new window</a>。</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p><p><strong>6.索引实现不一样。</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><p>详细区别，推荐你看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解open in new window</a>。</p><p>mysql的查询缓存没有用的必要，因为我们如果需要缓存的话直接用redis就好了</p><p><strong>MySql事务</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="事务示意图"></p><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p><ol><li>将小明的余额减少 1000 元</li><li>将小红的余额增加 1000 元。</li></ol><p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="数据库事务示意图"></p><p>要么都成功，要么都失败回滚到最初的状态。</p><p><strong>事务的四大特性：</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/ACID.png" alt="ACID"></p><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，最终呈现出来的效果是串行的，换句话说，既是不同事务，按照提交的先后顺序执行，再换句话说，对于事务本身来说，它所感知的数据库，应该只有它自己在操作。</li><li><strong>持久性</strong>（<code>Durabilily</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/AID-%3EC.png" alt="AID-&gt;C"></p><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p><p><strong>并发事务带来了哪些问题?</strong></p><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。（读到了未提交的数据）</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。（事务2无视了事务1的修改。）</li><li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。（事务1多次读取某一条数据，但在此期间事务2进行了修改导致事务1读到的数据变了，这个可以通过行级锁（默认可重复读权限）来解决，但不可重复读是可以接受的。）</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p>不可重复读读的是针对的行说的，幻读指的是针对表而言的，也是可以接受的。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><p>间隙锁（Gap Lock）：<strong>锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间</strong>。</p><p><strong>SQL 标准定义了哪些事务隔离级别?</strong></p><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。（比重复读多了个不能插入数据的限制）</li></ul><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都是基于 MVCC 实现。</p><p>不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><p><strong>表级锁和行级锁了解吗？有什么区别？</strong></p><p>InnoDB两个都支持，而MyISAM只支持表级锁。表级锁就是给整个表加锁，锁中粒度最大的，是针对非索引字段加的锁，资源消耗少，加锁快，不会死锁。行级锁，锁中粒度最小的，针对索引字段加的锁，资源消耗大，但并发度高，会出现死锁。</p><p><img src="https://static001.geekbang.org/resource/image/51/10/51f501f718e420244b0a2ec2ce858710.jpg" alt="img"></p><p><strong>共享锁和排他锁呢？</strong></p><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。（大家一起读）</li><li><strong>排他锁（X 锁）</strong> ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。（不允许大家一起写入，要排队）</li></ul><p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 共享锁<br><span class="hljs-keyword">SELECT</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br># 排他锁<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>InnoDB 支持<code>多粒度锁（multiple granularity locking）</code>，它允许<code>行级锁</code>与<code>表级锁</code>共存，而<strong>意向锁</strong>就是其中的一种<code>表锁</code>。</p><p><a href="https://juejin.cn/post/6844903666332368909">https://juejin.cn/post/6844903666332368909</a></p><p>需要强调一下，意向锁是一种<code>不与行级锁冲突表级锁</code>，这一点非常重要。意向锁分为两种：</p><ul><li><p>意向共享锁</p><p>（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<br>复制代码<br></code></pre></td></tr></table></figure></li><li><p>意向排他锁</p><p>（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br>复制代码<br></code></pre></td></tr></table></figure></li></ul><p>即：<code>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁</code>，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p><p>虽然意向锁和自家兄弟互相兼容，但是它会与普通的<strong>排他 / 共享锁</strong>互斥：</p><div class="table-container"><table><thead><tr><th></th><th>意向共享锁（IS）</th><th>意向排他锁（IX）</th></tr></thead><tbody><tr><td><strong>共享锁（S）</strong></td><td>兼容</td><td>互斥</td></tr><tr><td><strong>排他锁（X）</strong></td><td>互斥</td><td>互斥</td></tr></tbody></table></div><p><strong>注意：这里的排他 / 共享锁指的都是表锁！！！意向锁不会与行级的共享 / 排他锁互斥！！！</strong></p><p>现在我们回到刚才 <code>users</code> 表的例子：</p><p><code>事务 A</code> 获取了某一行的排他锁，并未提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">6</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br>复制代码<br></code></pre></td></tr></table></figure><p>此时 <code>users</code> 表存在两把锁：<code>users</code> 表上的<strong>意向排他锁</strong>与 id 为 6 的数据行上的<strong>排他锁</strong>。</p><p>就是说如果你给一个数据上了排他锁，那么他会自动上意向排他锁，表示这个表已经有数据有排他锁了，那么别的事务访问这个表的时候就知道我不能再给他上表级排他锁了（避免了一个个去排查最后发现哦，我不能，浪费性能）</p><p><strong>InnoDB 有哪几类行锁？</strong></p><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。（锁已经存在的）</li><li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。<a href="https://www.jianshu.com/p/32904ee07e56">https://www.jianshu.com/p/32904ee07e56</a></li><li><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong>（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。（读一个公认的历史版本）</li><li><strong>当前读</strong> （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。（读一个加锁就是别人不能修改的表）</li></ul><p><strong>mvcc</strong>:主要是给保存每行数据的多个版本，每个版本多了2个字段，一个为最后更新事务的id,一个是删除事务的id。在可重复读隔离级别下，每个事务都只能查询出小于等于自己事务id的版本记录。但这只针对于普通的，不加锁的select语句。对于update,delete语句如果想避免幻读，则需要间歇锁。</p><p><strong>索引的底层数据结构</strong></p><p>我们有两种选择B+树（多路平衡二叉树）和hash表，hash表虽然快但是有个问题，<strong>1.Hash 冲突问题</strong> 和<strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点</strong>。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p><p> <strong>聚集索引的缺点</strong></p><ol><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><p>（总结起来就是，乱序插入 自平衡难，复杂；增删更新的时候，自平衡复杂；触发自平衡就复杂）</p><p><strong>非聚集索引的缺点</strong></p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ol><p><img src="https://img-blog.csdnimg.cn/20210420165326946.png" alt="img"></p><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><h3 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a><strong>MySQL日志</strong></h3><p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01.png" alt="img"></p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。（防止炸了）</p><p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的<strong>持久性</strong>与完整性。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/02.png" alt="img"></p><p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p><p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p><p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p><p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/03.png" alt="img"></p><p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p><blockquote><p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p></blockquote><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04.png" alt="img"></p><p>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p><p><strong>为什么呢？</strong></p><p>因为在事务执行过程 <code>redo log</code> 记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/05.png" alt="img"></p><p>（两种刷新方法，一种事务提交的时候主动刷新，另外一种后台每隔1s有个线程专门执行redo log buffer中的数据刷新。</p><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p><p>（刷盘指的是清空redo log buffer记录到redo log 中，我们都是讨论成功执行<strong>事务提交之后</strong>的逻辑）</p><ul><li><strong>0</strong> ：设置为 0 的时候，表示每次事务<strong>提交时不进行</strong>刷盘操作</li></ul><p>​                为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。（提交了但是没记录上刷盘）</p><p>​                （依靠后台线程刷盘）</p><ul><li><strong>1</strong> ：设置为 1 的时候，表示每次事务<strong>提交时都将进行</strong>刷盘操作（<strong>默认值</strong>）</li></ul><p>​                为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p><p>​                如果事务执行期间<code>MySQL</code>挂了或宕机，这部分<strong>日志丢了，但是事务并没有提交</strong>，所以日志丢了也不会有损失。</p><p>​                （事务执行就直接刷盘，没执行完成就不刷盘）</p><ul><li><strong>2</strong> ：设置为 2 的时候，表示每次事务<strong>提交时都只把 redo log buffer 内容写入 page cache</strong></li></ul><p>​                为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p><p>​                如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p><p>​                （不主动刷盘，只记录在了文件系统缓冲中，所以不宕机就还能继续又后台线程刷盘写入）</p><p><strong>日志文件组</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/10.png" alt="img"></p><p>日志文件组中两个重要属性</p><p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。（应该是先写再更新）</p><p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p><p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/11.png" alt="img"></p><p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/12.png" alt="img"></p><p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p><blockquote><p>其实内存的数据页在一定时机也会刷盘，我们把这称为页合并，讲 <code>Buffer Pool</code>的时候会对这块细说</p></blockquote><p>checkpoint就是尾指针</p><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。（redo log 是存储引擎，binlog在server层中）</p><p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p><p>不管用什么存储引擎，<strong>只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</strong></p><p>那 <code>binlog</code> 到底是用来干嘛的？</p><p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01-20220305234724956.png" alt="img"></p><p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p><p><strong>记录格式</strong></p><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><strong>statement</strong></li></ul><p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/02-20220305234738688.png" alt="img"></p><ul><li><strong>row</strong></li></ul><p>当有及时性的数据的时候，比如当前之间这种操作<code>update_time=now()</code>，就需要用到row记录获取的值经过binlog工具解析后一同传入</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/03-20220305234742460.png" alt="img"></p><ul><li><strong>mixed</strong></li></ul><p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p><p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p><p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p><p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p><p><strong>写入机制</strong></p><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04-20220305234747840.png" alt="img"></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/06-20220305234801592.png" alt="img"></p><p>跟上面一样page cache是系统磁盘的缓存他是fsync的最后一道关卡。redo log 存的是修改的数据，而binlog存的是sql语句，这也是他们所处不同的地方根本区别。</p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了<strong>崩溃恢复</strong>能力。</p><p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据<strong>一致性</strong>。</p><p>虽然它们都属于持久化的保证，但是侧重点不同。</p><p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以<strong>基本的事务为单位</strong>，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01-20220305234816065.png" alt="img"></p><p>问题，解决我刚刚说的你redo log记载了，但是binlog还没有记录呢，结果不一致。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/03-20220305235104445.png" alt="img"></p><p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p><p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p><p>（相当于设置了一个信号量让这两个日志同步，不让redo log自行偷摸备份。同步他俩的方法也是通过事务id表示他们说的是同一个事情。）redo log是数据层面的，binlog是操作语句层面的。</p><p>binlog应该是写入一条语句就记录一条。</p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><blockquote><p>这部分内容为 JavaGuide 的补充：</p></blockquote><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p><blockquote><p>redo log 和 undo log 区别在哪？</p></blockquote><p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p><ul><li>redo log 记录了此次事务<strong>「完成后」</strong>的数据状态，记录的是更新之<strong>「后」</strong>的值；</li><li>undo log 记录了此次事务<strong>「开始前」</strong>的数据状态，记录的是更新之<strong>「前」</strong>的值；</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="事务恢复"></p><p><strong>总结：</strong></p><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p><p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p><ul><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li></ul><p><a href="https://www.cnblogs.com/xiaolincoding/p/16396502.html详细讲解。">https://www.cnblogs.com/xiaolincoding/p/16396502.html详细讲解。</a></p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p><strong>锁定读</strong></p><p>如果执行的是下列语句，就是 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html"><strong>锁定读（Locking Reads）</strong>open in new window</a></p><ul><li><code>select ... lock in share mode</code></li><li><code>select ... for update</code></li><li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li></ul><p>在锁定读下，读取的是数据的最新版本，这种读也被称为 <code>当前读（current read）</code>。锁定读会对读取到的记录加锁：</p><ul><li><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</li><li><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</li></ul><p>在一致性非锁定读下，即使读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 <code>Repeatable Read</code> 下 <code>MVCC</code> 防止了部分幻读，这边的 “部分” 是指在 <code>一致性非锁定读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong><code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</strong></p><p><strong>InnoDB对MVCC的实现</strong></p><p><strong>快照读：</strong></p><p>SQL读取的数据是快照版本【可见版本】，也就是历史版本，不用加锁，<strong>普通的SELECT就是快照读。</strong></p><p><strong>当前读：</strong></p><p>SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE都是当前读。</p><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code>和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p><p><strong>隐藏字段</strong></p><p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">隐藏字段open in new window</a>：</p><ul><li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为<strong>更新</strong>，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li><li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li><li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li></ul><p><strong>ReadView</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadView</span> &#123;</span><br>  <span class="hljs-comment">/* ... */</span><br>private:<br>  <span class="hljs-type">trx_id_t</span> m_low_limit_id;      <span class="hljs-comment">/* 大于等于这个 ID 的事务均不可见 */</span><br><br>  <span class="hljs-type">trx_id_t</span> m_up_limit_id;       <span class="hljs-comment">/* 小于这个 ID 的事务均可见 */</span><br><br>  <span class="hljs-type">trx_id_t</span> m_creator_trx_id;    <span class="hljs-comment">/* 创建该 Read View 的事务ID */</span><br><br>  <span class="hljs-type">trx_id_t</span> m_low_limit_no;      <span class="hljs-comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span><br><br>  <span class="hljs-type">ids_t</span> m_ids;                  <span class="hljs-comment">/* 创建 Read View 时的活跃事务列表 */</span><br><br>  m_closed;                     <span class="hljs-comment">/* 标记 Read View 是否 close */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://javaguide.cn/assets/trans_visible.048192c5.png" alt="trans_visible"></p><p><strong>undo-log</strong></p><p>我们执行一个insert语句，在undo log中就记录一个delete语句，用于删除掉刚插入的数据，以此来达到回滚到插入之前的状态；（记录相反的语句）</p><p><code>undo log</code> 主要有两个作用：</p><ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li></ul><p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种： <code>insert undo log</code> 和 <code>update undo log</code>：</strong></p><ol><li><strong><code>insert undo log</code></strong> ：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。因为 <code>insert</code> 操作的记录只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后直接删除。不需要进行 <code>purge</code> 操作。</li><li><strong><code>update undo log</code></strong> ：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供 <code>MVCC</code>机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除</li></ol><p>第一次修改</p><p><img src="https://javaguide.cn/assets/c52ff79f-10e6-46cb-b5d4-3c9cbcc1934a.b60a6e78.png" alt="img"></p><p>第二次修改</p><p><img src="https://javaguide.cn/assets/6a276e7a-b0da-4c7b-bdf7-c0c7b7b3b31c.2e496ea1.png" alt="img"></p><p>总结一下MVCC：如果当前事务想访问的数据被别的事务占用（上写锁）的话，那么我就通过undo log来找当前事务的可见版本，通过版本号来获取当前事务可以访问的最新的版本号。</p><p><strong>数据可见性算法</strong></p><p>在 <code>InnoDB</code> 存储引擎中，创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些<strong>变量</strong>及<strong>当前事务 ID</strong> 进行比较，判断是否满足可见性条件。</p><p><em>db_trx_id</em>，产生当前记录项的事务id;</p><p><strong>RC 和 RR 隔离级别下 MVCC 的差异</strong></p><p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p><ul><li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li><li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li></ul><p>RC—-读已提交</p><p>RR—-可重复读</p><p>（RC中因为每一次的读都是已提交的，所以查询前都要生成一个Read View来查找最新提交的事务id）</p><p>（RR中因为是可以重复读那么就是自从开始读以后，我们要读的数据就固定了，所以一次Read View就够了）</p><p><strong>MVCC➕Next-key-Lock 防止幻读</strong></p><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update/lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks">Next-key Lockopen in new window</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>MVCC可以解决脏读、不可重复读，并且实现了非阻塞读的功能。</strong></p><p><strong>读已提交隔离级别：每次读操作都会设置和读取自己的新快照（ReadView）。</strong></p><p><strong>可重复读隔离级别：同一个事务共用第一次查询时建立的快照（ReadView）。</strong></p><p><strong>当前读与快照读</strong> </p><p>最后扩展一个延伸的知识点，其实Mysql中的读操作可以分为两大类：<strong>快照读</strong>与<strong>当前读</strong>。</p><p><strong>快照读是指通过MVCC实现的非阻塞读</strong>，常见的快照读操作如下：</p><ul><li>select xxx from xxx</li></ul><p><strong>当前读也叫加锁读，每次读取数据都是读取数据的最新版本，并且会对其进行加锁</strong>。常见的当前读操作如下</p><ul><li>select xxx from xxx lock in share mode (共享锁/读锁)</li><li>select xxx from xxx for update （排它锁/写锁）</li><li>update 、delete、insert</li></ul><p>为什么要区分这两种读操作呢？因为<strong>MVCC并不能解决幻读的问题</strong>。即使是在可重复读级别，通过当前读依然会出现幻读问题。此问题最终是通过间隙锁来解决的。</p><p>mysql分为几大部分：</p><p>（外部看）mysql的结构</p><p>（内部看）主要是innoDB引擎和MyISAM的特性：事务特性、隔离级别、索引以及底层实现、各种锁（用来实现隔离级别）、MVCC</p><p>（日志）redo log、binlog、 undo log</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>快表就是一种缓存，特殊的一种高速缓存冲存储器（Cache）</p><p>缓存的内容一般在内存中，所以比较快，为了防止丢失经常用磁盘来做暂时的持久化，你想想所有的log buffer也都是这个原理先放到page buffer里面。缓存用来缓解数据库压力，提高并发量。</p><h2 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h2><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/738439/1663402422259-e78c83f1-331c-43e6-bf79-adc043e09a76.png" alt="local-cache.png"></p><p>本地缓存在应用内部（服务器的内部），应用存在于同一个进程内部。</p><p><strong>本地缓存的方案有哪些？</strong></p><p>1、JDK自带的<code>HashMap</code>和<code>ConcurrentHashMap</code></p><p>大部分场景不能用这个作为缓存，因为没有过期时间。这就是我当时抖音做的时候为啥不能用map存的原因。一个稍微完善一点的缓存框架至少提供：<strong>过期时间</strong>、<strong>淘汰机制</strong>、<strong>命中率统计</strong> 这三点</p><p>2、<code>Ehcache</code>、<code>Guava Cache</code>、<code>Spring Cache</code>这三者是使用的比较多的本地缓存框架。</p><p>3、后起之秀<code>Caffeine</code></p><p>Caffeine 和 Guava 使用很像。</p><p><strong>本地缓存的痛点？</strong></p><p>本地缓存的优势非常明显：<strong>低依赖、轻量、简单、成本低</strong>。</p><p>缺点：应用耦合，对分布式架构支持不好，相同服务部署在不同的机器上时，各缓存之间存在一致性的问题。</p><p>缓存受服务器部署所在的机器性能限制明显。</p><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p><strong>什么是分布式缓存？</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/738439/1663402443312-97aba9f8-ceec-408b-9b6a-6202843a9069.png" alt="distributed-cache.png"></p><p>两个服务使用同一个数据库和缓存，中间加一个缓存。</p><p>引入缓存后带来的问题：</p><ul><li><strong>系统复杂性增加：</strong>引入缓存之后，你要维护缓存和数据库的数据一致性、维护热点缓存、保证缓存服务的高可用等等。</li><li><strong>系统开发成本往往会增加：</strong>引入缓存意味着系统需要一个单独的缓存服务，这是需要花费相应的成本的，并且这个成本很贵，毕竟耗费的是宝贵的内存。</li></ul><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>本地缓存+分布式缓存的结合。为什么要这样呢？因为分布式缓存永远都会存在网络的开销，访问速度肯定比不上本地缓存，一般不建议用多级缓存，还是一致性的问题。</p><p><strong>使用场景</strong></p><ul><li>访问的数据不会频繁被修改，比较稳定</li><li>数据访问量特别大比如秒杀场景。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/738439/1666689226778-fb790f43-dcd3-485b-97fc-73edcc061895.png" alt="multilevel-cache.png"></p><p>一级缓存使用本地缓存（比如Caffeine），二级缓存使用分布式缓存。</p><p>先从L1读，读不到再去L2读，L2没有的话才去数据库里面找。</p><h2 id="缓存的更新策略"><a href="#缓存的更新策略" class="headerlink" title="缓存的更新策略"></a>缓存的更新策略</h2><h3 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h3><p>是我们常用的缓存读写模式，比较适合读请求比较多的场景。（因为一写操作就要更新）</p><p>要同时维系db和cache，以db为标准。</p><p>写：</p><p>1、先更新db；</p><p>2、直接删除cache；</p><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fcache-aside-write.png&amp;sign=a931e8844264af244d6341e9f56c6b48fc67f25f2dd48a12b29d98da08b30845" alt="img"></p><p>读：</p><p>1、从cache中读取数据，读取到就直接返回；</p><p>2、cache中读取不到的话，就从db中读取数据返回；</p><p>3、再把db中读取到的数据放到cache中；</p><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fcache-aside-read.png&amp;sign=7099a3ed9d84d82fc122292d1c7b1da70508b787567288aab2803032d30cbdb5" alt="img"></p><p><strong>Q1: 关键来了，为什么要删除cache，而不是更新cache呢？</strong></p><p>主要原因有两个：</p><p><strong>1、对服务端资源造成浪费：</strong>删除cache更直接，第一，相比更新cache存放的一些数据需要服务端通过计算得出，会消耗服务端的资源（更新就会消耗计算资源，比如hash存储，你得计算他在哪个位置吧？）；第二呢，因为你这么更新同步的话很可能cache中的数据进入cache后还没有被访问的就已经被删除了，妥妥的浪费。</p><p><strong>2、产生数据不一致的问题：</strong>并发场景下，更新cache产生数据不一致性问题的概率更大。</p><p><strong>Q2: 在写数据的过程中，可以先删除cache后更新db吗？</strong></p><p>不行的，因为数据的持久化是在db中做的，你要以db为标准，所以只有先更新了db以后，确认了某些数据更新了你才能删除之前的cache，这些cache才算是过去式了。</p><p>举个例子，请求1先写数据A，请求2随后读数据A的话，就会产生不一致的问题。</p><p>1、请求1先将cache中的A数据删除；</p><p>2、请求2从db中读取数据；</p><p>3、请求1再把db中的A数据更新；</p><p>这会导致请求2读取到的是旧值。</p><p><strong>Q3: 在写数据的过程中，先更新db，后删除cache就没有问题了吗？</strong></p><p>理论上是会出现数据不一致，概率小，因为缓存的写入速度是比数据库的写入速度快很多。所以你先删了缓存没有用，你还是会刷新到旧值。</p><p><strong>Q4: Cache Aside Pattern的缺陷</strong></p><p><strong>缺陷1: 首次请求数据一定不在cache的问题</strong></p><p>解决办法：将热点数据提前放入cache中（提前准备热点数据）</p><p><strong>缺陷2: 写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率</strong></p><p>解决办法：</p><ul><li>数据库和缓存数据强一致场景：更新db的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li><li>可以短暂地允许数据库和缓存数据不一致的场景：更新db的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话保证即使数据不一致的话影响也比较小。（通过淘汰来保留热点数据！！设定一个时间这样只有常被用到的会一直存在）</li></ul><h3 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read/Write Through Pattern（读写穿透）"></a>Read/Write Through Pattern（读写穿透）</h3><p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache服务负责将此数据读取和写入db，从而减轻了应用程序的职责。</p><p>这种比较少见，因为我们经常使用的风俗hi缓存redis并没有提供cache将数据写入db的功能。</p><p>写（Write Through）和旁路缓存模式不一样的是他是先找cache，而非直接更新db</p><ul><li>先查cache，cache中不存在，直接更新db。</li><li>cache中存在，则先更新cache，然后cache服务自己更新db（同步更新cache和db）</li></ul><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fwrite-through.png&amp;sign=ecf4f28f9487892a0b8e1f7c4206c55f4054ea3f4ca076648cf40773400e034b" alt="img"></p><p>读（Read Through）</p><ul><li>从cache中读取数据，读取到直接返回。</li><li>读取不到先从db加载，写入到cache后返回响应。</li></ul><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fread-through.png&amp;sign=308702058146b4c5b3ac047f8b42e2b0dec45a5ca229b132dd9452225ca42005" alt="img"></p><p>读写穿透模式实际上是旁路缓存模型的封装。在旁路缓存模型下，发生读请求的时候，如果cache中不存在对应的数据，是由客户端自己负责把数据写入cache，而读写穿透模式下则是cache服务自己来写入缓存的，这是对客户端是透明的。</p><p>一样都有热点数据的问题。</p><h3 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h3><p>Write Behind Pattern 和 Read/Write Through Pattern很相似，两者都是由cache服务来负责cache和db的读写。</p><p>但是两个又有很大的不同：读写穿透是同步更新cache和db，只不过是由cache驱动的两者更新。而异步缓存写入是只更新缓存，不直接更新db，而是改为异步批量的方式来更新db。</p><p>很明显这种方式对于数据一致性带来了更大的挑战，比如cache数据可能还没一部更新db，cache服务就挂掉了。</p><p>这种在开发中很少见，但应用场景不少，比如消息队列中消息的异步写入磁盘、MySQL的Innodb Buffer Pool机制都用到了这种策略。</p><p>异步缓存写入下的db的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p><h2 id="Redis-Sentinel-哨兵"><a href="#Redis-Sentinel-哨兵" class="headerlink" title="Redis Sentinel 哨兵"></a>Redis Sentinel 哨兵</h2><p>背景：在普通的主从复制方案下，一旦master宕机了，我们就要从slave中手动选择一个新的master，同时需要修改应用方的主节点地址，还需要其他的节点复制新的主节点，进行同步。</p><p>Redis官方提供了哨兵方案来进行解决。</p><p>Redis要到2.8以后发布的稳定版本，默认运行在26379端口上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-sentinel /path/to/sentinel.conf<br>or<br>redis-server /path/to/sentinel.conf --sentinel<br></code></pre></td></tr></table></figure><p>Redis有专门的哨兵模式。<code>sentinel.conf</code>就是用来配置Sentinel的。</p><p><a href="http://redisdoc.com/topic/sentinel.html">http://redisdoc.com/topic/sentinel.html</a> 详细见这个链接。</p><p>当master节点出现故障的时候，Sentinel会帮助我们实现故障转移，自动根据一定的规则选出一个slave升级为master，确保整个Redis系统的可用性。整个过程完全自动，不需要人工介入。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979593266-3d66a28e-c0db-4a96-8400-d7c6ffae0a9f.png" alt="redis-master-slave-sentinel.png"></p><p><strong>Sentinel有什么作用？</strong></p><ul><li>监控：监控所有redis的（包括自己）状态是否正常。</li><li>故障转移：如果一个master出现故障，Sentinel会帮助我们实现故障转移，自动将某一台slave升级为master，确保整个Redis系统的可用性。</li><li>通知：通知slave新的master连接信息，让他们执行replicaof成为新的matser的slave。</li><li>配置提供：客户端链接sentinel请求master的地址，如果发生故障转移，sentinel会通知新的master连接信息给客户端。</li></ul><p>Redis Sentinel  本身设计的就是一个分布式系统，建议多个sentinel节点协作运行。这样做的好处是：</p><ul><li>多个sentinel节点通过投票的方式来确定sentinel节点是否真的不可用，避免误判（比如网络问题可能会导致误判）</li><li>Sentinel自身就是高可用</li></ul><p>如果想要实现高可用，建议将哨兵 Sentinel 配置成单数且大于等于 3 台。高可用是系统不间断的运行的能力。</p><p><strong>Sentinel如何检测节点是否下线？</strong></p><ul><li>主观下线：哨兵节点认为某个Redis节点已经下线了，但还不是很确定，<strong>需要其他sentinel节点的投票</strong>。</li><li>客观下线：法定数量过半认为某个redis节点下线了，那就是真的下线了，<strong>被动下线</strong>。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979614062-f3219a07-0815-4b0d-9b63-750219d9e59c.png" alt="redis-master-slave-sentinel-ping.png"></p><p>有效回复不一定是PONG，可以是-LOADING或者-MASTERDOWN。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979628031-1ccb8eb9-5da0-46d5-a16a-01f6724c2ee1.png" alt="redis-master-slave-sentinel-ping-sdown.png"></p><p>slave下线对redis集群影响不大，但是master认定主观下线就不一样了，sentinel整体还要对其进行进一步核实，确保master是真的下线了。</p><p>master 才被判定客观下线。当法定数量（通常为过半）的sentinel节点认定master已经下线，裁判定下线。这样做的目的是为了<strong>防止误判</strong>，毕竟故障转移的开销比较大，这也是为什么Redis官方推荐部署多个sentinel节点。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/738439/1663979639394-8eb65a8f-5905-473d-90d8-47cba7c58ae5.png" alt="redis-master-slave-sentinel-ping-odown.png"></p><p>哨兵中会有一个Leader的角色来负责故障转移，自动从slave中选出一个新的master并执行完相关的一些工作（比如通知slave新的master连接信息，让它们执行replicaof成为新的master的slave）。</p><p>如果没有足够数量的sentinel节点认定master已经下线的话，当master能对sentinel的PING命令进行有效回复之后，master也就不再被认定为主观下线，回归正常。</p><p><strong>如何从 Sentinel 集群中选择出 Leader？</strong></p><p>共识算法。<a href="https://javaguide.cn/distributed-system/theorem&amp;algorithm&amp;protocol/raft-algorithm.html#_1-">https://javaguide.cn/distributed-system/theorem&amp;algorithm&amp;protocol/raft-algorithm.html#_1-</a></p><p><strong>Sentinel 可以防止脑裂吗？</strong></p><p>脑裂就是发生网络隔离。</p><p>通过Redis主从复制进行配置就可以。</p><h2 id="Redis-Cluster-集群"><a href="#Redis-Cluster-集群" class="headerlink" title="Redis Cluster 集群"></a>Redis Cluster 集群</h2><p><strong>为什么需要redis集群？</strong></p><p><a href="https://blog.csdn.net/m0_67266585/article/details/126489775?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-126489775-blog-124017233.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-126489775-blog-124017233.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=2">https://blog.csdn.net/m0_67266585/article/details/126489775?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-126489775-blog-124017233.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-126489775-blog-124017233.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=2</a> 最大存储量。</p><p>1、缓存的数据量太大，不够放的。</p><p>2、并发量要求太大。</p><p>核心思想就是分摊压力，同样的效能给两个能干活的人一定是压力减半的。</p><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fredis-cluster%2Fredis-cluster-shard.png&amp;sign=33a67ec08ad62aa857bafa46a651b091322094cb5ebd49722d3e45d87d76a619" alt="img"></p><p>Redis切片集群对于横向扩展非常友好，只需要增加Redis节点到集群中即可。我们集群了master，这样如果想增加负载能力就直接扩展redis实例就行了。</p><p>Redis Cluster 通过分片来进行数据管理，提供主从复制（Master-Slave Replication）、故障转移（Failover）等开箱即用的功能。</p><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fredis-cluster%2Fredis-scale-out.png&amp;sign=4f407532c59d139da1d21835bbbc395a8bc2950c9de766b034b9f01d74872300" alt="img"></p><p>官方的Redis Cluster支持扩展到1000个节点。可以说Redis Cluster的动态扩容和缩容是其最大的优势。这是因为Redis Cluster中的各个节点基于Gossip协议（传染病算法，一个传播几个设定一个大小。）来共享信息。节点过多，通信成本剧增。</p><p><strong>集群模式</strong></p><p>Redis主从架构模式下，所有数据都写入一个主库，存在着单机容量上限、高并发写性能的一些问题。Redis 集群则有多个主库，数据是根据一定规则分散到各个主库上的，主库的数量就取决于数据量的大小，可以根据数据量动态增删主库节点。</p><p>Redis 集群至少需要 3 个主节点才可以正常运转（两个人谁也不服谁），每个主节点建议再配置至少一个从节点，用于做主备切换，在主库不可用时，从库可以顶上去。生产环境中，建议使用 6 台服务器，分别部署 3 个主库和 3 个从库，这样更能保证集群的高可用。</p><p>切片集群<a href="https://juejin.cn/post/7084163543108927502">https://juejin.cn/post/7084163543108927502</a></p><p>集群里面的节点数量<a href="https://blog.csdn.net/xisheng_lx/article/details/120988277">https://blog.csdn.net/xisheng_lx/article/details/120988277</a></p><p>集群部署</p><div class="table-container"><table><thead><tr><th>服务器</th><th>Redis实例</th></tr></thead><tbody><tr><td>172.17.0.2</td><td>7001、7002</td></tr><tr><td>172.17.0.3</td><td>7003、7004</td></tr><tr><td>172.17.0.4</td><td>7005、7006</td></tr></tbody></table></div><p>总结Redis Cluster的主要优势：</p><ul><li>可以横向扩展缓解写压力和存储压力，支持动态扩容和缩容；</li><li>具备主从复制、故障转移（内置了Sentinel机制）</li></ul><p><strong>基本的Redis Cluster架构的是怎么样的？</strong></p><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fredis-cluster%2Fredis-cluster-3-node.png&amp;sign=3747718cea8e943896849aa789e756fdf5b491cbd3746363cda320aac457a38c" alt="img"></p><p>Redis Cluster是去中心化的（各个节点基于Gossip进行通信），任何一个master出现故障都不影响其他节点。key找的是hash槽而不是Redis节点。不过，Redis Cluster至少要保证宕机的master有一个slave可用。 </p><p>如果宕机的master无slave的话，为了保障集群的完整性，保证所有的哈希槽都指派给了可以用的master，整个集群将不可用。这种情况下如果要保持可用的话，可以将<code>cluster-require-full-coverage</code>这个参数设置成no，<code>cluster-require-full-coverage</code>表示需要16384（2^14)个slot都正常被分配的时候才可以对外提供服务。</p><p>为什么是16384<a href="https://www.fushengwushi.com/archives/1616">https://www.fushengwushi.com/archives/1616</a></p><p>如果我们想要添加新的节点比如master4、master5进入Redis Cluster也非常方便，分配哈希slot就行。如果要移除某个master就把该节点slot分配给其他节点再删除。</p><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fredis-cluster%2Fredis-cluster-5-node-slots.png&amp;sign=ac8dc5564f99ce175e49e001f607e4f3c75514e9c764c309012408c5f9509af0" alt="img"></p><p><strong>Redis Cluster是如何分片的？</strong></p><p><strong>一致性哈希</strong> 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p><p>Redis Cluster使用的是哈希槽分区，每一个kv都属于一个hash slot。</p><p>我们要想知道放入哪个槽中，我们需要进行CRC-16校验码，在让校验码对16384取模，得到的就是对应的hash槽。</p><p><strong>这里就要说说hash槽和一致性hash的区别了</strong></p><p>当发生扩容时候，哈希槽采用灵活的可配置映射表，可以随意组织映射到新增server上面的slot数，比一致性hash的算法更灵活方便；同时也给开发人员手工配置更大的简洁性。</p><p>其次，在数据迁移时，一致性hash 需要算哪些key是落在新增服务节点的数据，然后迁移这部分数据，哈希槽则直接将一个slot对应的数据全部迁移，算法明确以及实现更简单。</p><p>也就是说槽的可插拔效果更好因为我只需要替换坏掉的or不要的节点。而一致性hash的数据迁移还需要重新计算之前的点都应该流向哪里浪费计算资源。</p><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fredis-cluster%2Fredis-cluster-3-node-slots.png&amp;sign=ce064d9535d014f8702627ccf5f1419a2abdade1d52d71faf5e3703ab523e165" alt="img"></p><p>客户端连接Redis Cluster中任意一个master节点即可访问Redis Cluster的数据，当客户端发送命令请求的时候，需要先根据key通过上面的计算公式找到对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标节点。</p><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fredis-cluster%2Fredis-cluster-3-find-hash-slot.png&amp;sign=6675c92a2d86c45afe0b353db2d17e748116230600e1db866680fa55b8ded4a1" alt="img"></p><p>如果哈希槽确实是当前节点负责的，那么直接相应请求，如果没找到就返回<code>-MOVED</code>重定向错误，在重新告知哪个才是新的负责的节点（找ip）。</p><p>为什么还会找错呢？因为内部重新分配哈希槽比如扩容和缩容的时候，会导致客户端缓存的哈希槽分配信息有误。</p><p><strong>优点：解耦了数据和节点之间的关系，提升了集群的横向扩展性和容错性。</strong></p><p><strong>为什么 哈希槽 是16384个？</strong></p><p>正常的心跳包会携带一个节点的完整配置，以幂等（所谓幂等性通俗的将就是一次请求和多次请求同一个资源产生相同的副作用。用数学语言表达就是<code>f(x)=f(f(x))</code>。）这意味着心跳包会附带当前节点的负责的哈希槽的信息。假设用16384/8占2k，65536/8占8k。而且也不建议扩展到超过1000个主节点。</p><p>总结一下：</p><ul><li>哈希槽大，心跳包大，消耗太多带宽；</li><li>哈希槽总数越少，对存储哈希槽信息的bitmap压缩效果越好；</li><li>Redis Cluster 的主节点通常不会扩展太多，16384 个哈希槽已经足够用了（上限2k）。</li></ul><p><strong>Redis Cluster 扩容和缩容本质是进行重新分片，动态迁移哈希槽</strong></p><p>提供了重定向机制，两种不同的类型：</p><ul><li>ASK 重定向</li><li>MOVED 重定向</li></ul><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fguide-blog-images.oss-cn-shenzhen.aliyuncs.com%2Fgithub%2Fjavaguide%2Fdatabase%2Fredis%2Fredis-cluster%2Fredis-cluster-ask.png&amp;sign=1aebb4e38d69b82124445ef986bc0ba4ed67138c1eb32a51ed81a1cb88454549" alt="img"></p><p>ask是种中间状态，还没有更新，他仍然会一直请求旧的地址。迁移完成以后才会发送moved重定向</p><p><strong>Redis Cluster 中的节点是怎么进行通信的？</strong></p><p>Redis Cluster是一个典型的分布式系统，分布式系统中的各个节点需要互相通信。既然要互相通信就要遵守一致的通信协议，Redis Cluster中的各个节点给予 <strong>Gossip 协议</strong> 来进行通信共享信息，每个 Redis 节点都维护了一份集群的状态信息。</p><p>总结一下：</p><p>1、redis单机解决了mysql直接的读写压力。</p><p>2、redis哨兵解决了读写分离使得更多的读操作的压力降低。</p><p>3、redis集群解决了哨兵单机master性能上线的问题。</p><h2 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h2><p>高并发的效果：MySql的单机（4 核 8g）QPS大概在1w左右，但是使用Redis缓存之后很容易达到10w+，甚至最高能达到30w+（单机Redis的情况，Redis集群的话会更高）</p><blockquote><p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p></blockquote><p><strong>Redis 除了做缓存，还能做什么？</strong></p><ul><li><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。相关阅读：<a href="https://mp.weixin.qq.com/s/CbnPRfvq4m1sqo2uKI6qQw">《分布式锁中的王者方案 - Redisson》open in new window</a>。</li><li><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window</a>。</li><li><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li><li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li><li>……</li></ul><h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>Redis 常用的数据结构有哪些？</p><ul><li><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124403897.png" alt="img"></p><p><strong>常用命令</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SET key value</td><td>设置指定 key 的值</td></tr><tr><td>SETNX key value</td><td>只有在 key 不存在时设置 key 的值</td></tr><tr><td>GET key</td><td>获取指定 key 的值</td></tr><tr><td>MSET key1 value1 key2 value2 …</td><td>设置一个或多个指定 key 的值</td></tr><tr><td>MGET key1 key2 …</td><td>获取一个或多个指定 key 的值</td></tr><tr><td>STRLEN key</td><td>返回 key 所储存的字符串值的长度</td></tr><tr><td>INCR key</td><td>将 key 中储存的数字值增一</td></tr><tr><td>DECR key</td><td>将 key 中储存的数字值减一</td></tr><tr><td>EXISTS key</td><td>判断指定 key 是否存在</td></tr><tr><td>DEL key（通用）</td><td>删除指定的 key</td></tr><tr><td>EXPIRE key seconds（通用）</td><td>给指定 key 设置过期时间</td></tr></tbody></table></div><p><strong>应用场景</strong></p><p><strong>需要存储常规数据的场景</strong></p><ul><li>举例 ：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li><li>相关命令 ： <code>SET</code>、<code>GET</code>。</li></ul><p><strong>需要计数的场景</strong></p><ul><li>举例 ：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li><li>相关命令 ：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h4><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124413287.png" alt="img"></p><p><strong>常用命令</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>RPUSH key value1 value2 …</td><td>在指定列表的尾部（右边）添加一个或多个元素</td></tr><tr><td>LPUSH key value1 value2 …</td><td>在指定列表的头部（左边）添加一个或多个元素</td></tr><tr><td>LSET key index value</td><td>将指定列表索引 index 位置的值设置为 value</td></tr><tr><td>LPOP key</td><td>移除并获取指定列表的第一个元素(最左边)</td></tr><tr><td>RPOP key</td><td>移除并获取指定列表的最后一个元素(最右边)</td></tr><tr><td>LLEN key</td><td>获取列表元素数量</td></tr><tr><td>LRANGE key start end</td><td>获取列表 start 和 end 之间 的元素</td></tr></tbody></table></div><p><strong>应用场景</strong></p><p><strong>信息流展示</strong></p><ul><li>举例 ：最新文章、最新动态。</li><li>相关命令 ： <code>LPUSH</code>、<code>LRANGE</code>。</li></ul><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124421703.png" alt="img"></p><p><strong>常用命令</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>HSET key field value</td><td>设置指定哈希表中指定字段的值</td></tr><tr><td>HSETNX key field value</td><td>只有指定字段不存在时设置指定字段的值</td></tr><tr><td>HMSET key field1 value1 field2 value2 …</td><td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td></tr><tr><td>HGET key field</td><td>获取指定哈希表中指定字段的值</td></tr><tr><td>HMGET key field1 field2 …</td><td>获取指定哈希表中一个或者多个指定字段的值</td></tr><tr><td>HGETALL key</td><td>获取指定哈希表中所有的键值对</td></tr><tr><td>HEXISTS key field</td><td>查看指定哈希表中指定的字段是否存在</td></tr><tr><td>HDEL key field1 field2 …</td><td>删除一个或多个哈希表字段</td></tr><tr><td>HLEN key</td><td>获取指定哈希表中字段的数量</td></tr><tr><td>HINCRBY key field increment</td><td>对指定哈希中的指定字段做运算操作（正数为加，负数为减）</td></tr></tbody></table></div><p><strong>应用场景</strong></p><p><strong>对象数据存储场景</strong></p><ul><li>举例 ：用户信息、商品信息、文章信息、购物车信息。</li><li>相关命令 ：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124430264.png" alt="img"></p><p><strong>常用命令</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SADD key member1 member2 …</td><td>向指定集合添加一个或多个元素</td></tr><tr><td>SMEMBERS key</td><td>获取指定集合中的所有元素</td></tr><tr><td>SCARD key</td><td>获取指定集合的元素数量</td></tr><tr><td>SISMEMBER key member</td><td>判断指定元素是否在指定集合中</td></tr><tr><td>SINTER key1 key2 …</td><td>获取给定所有集合的交集</td></tr><tr><td>SINTERSTORE destination key1 key2 …</td><td>将给定所有集合的交集存储在 destination 中</td></tr><tr><td>SUNION key1 key2 …</td><td>获取给定所有集合的并集</td></tr><tr><td>SUNIONSTORE destination key1 key2 …</td><td>将给定所有集合的并集存储在 destination 中</td></tr><tr><td>SDIFF key1 key2 …</td><td>获取给定所有集合的差集</td></tr><tr><td>SDIFFSTORE destination key1 key2 …</td><td>将给定所有集合的差集存储在 destination 中</td></tr><tr><td>SPOP key count</td><td>随机移除并获取指定集合中一个或多个元素</td></tr><tr><td>SRANDMEMBER key count</td><td>随机获取指定集合中指定数量的元素</td></tr></tbody></table></div><p><strong>应用场景</strong></p><p><strong>需要存放的数据不能重复的场景</strong></p><ul><li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li><li>相关命令：<code>SCARD</code>（获取集合数量） 。</li></ul><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719073733851.png" alt="img"></p><p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p><ul><li>举例 ：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景。</li><li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）</li></ul><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719074543513.png" alt="img"></p><p><strong>需要随机获取数据源中的元素的场景</strong></p><ul><li>举例 ：抽奖系统、随机。</li><li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li></ul><h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124437791.png" alt="img"></p><p><strong>常用命令</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>ZADD key score1 member1 score2 member2 …</td><td>向指定有序集合添加一个或多个元素</td></tr><tr><td>ZCARD KEY</td><td>获取指定有序集合的元素数量</td></tr><tr><td>ZSCORE key member</td><td>获取指定有序集合中指定元素的 score 值</td></tr><tr><td>ZINTERSTORE destination numkeys key1 key2 …</td><td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td></tr><tr><td>ZUNIONSTORE destination numkeys key1 key2 …</td><td>求并集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZDIFF destination numkeys key1 key2 …</td><td>求差集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td></tr><tr><td>ZREVRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td></tr><tr><td>ZREVRANK key member</td><td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td></tr></tbody></table></div><p><strong>应用场景</strong></p><p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p><ul><li>举例 ：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li><li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul><p>key就是一个set</p><ul><li><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li></ul><h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720194154133.png" alt="img"></p><p><strong>常用命令</strong></p><div class="table-container"><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SETBIT key offset value</td><td>设置指定 offset 位置的值</td></tr><tr><td>GETBIT key offset</td><td>获取指定 offset 位置的值</td></tr><tr><td>BITCOUNT key start end</td><td>获取 start 和 end 之前值为 1 的元素个数</td></tr><tr><td>BITOP operation destkey key1 key2 …</td><td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td></tr></tbody></table></div><p><strong>应用场景</strong></p><p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p><ul><li>举例 ：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li><li>相关命令 ：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li></ul><p><strong>String 还是 Hash 存储对象数据更好呢？</strong></p><ul><li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要<strong>经常变动</strong>或者经常需要单独查询对象中的个别字段信息，<strong>Hash 就非常适合</strong>。</li><li><strong>String 存储相对来说更加节省内存</strong>，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对<strong>性能和资源消耗非常敏感的话</strong>，String 就非常适合。</li></ul><p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p><p><strong>使用 Redis 实现一个排行榜怎么做？</strong></p><p>Redis 中有一个叫做 <code>sorted set</code> 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p><p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)</p><p><strong>使用 Set 实现抽奖系统需要用到什么命令？</strong></p><ul><li><code>SPOP key count</code> ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li><li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li></ul><p><strong>使用 Bitmap 统计活跃用户怎么做？</strong></p><p>bitmap 使用场景 <a href="https://www.cnblogs.com/54chensongxia/p/13794391.html">https://www.cnblogs.com/54chensongxia/p/13794391.html</a></p><p>使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p><p>初始化数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; SETBIT 20210308 1 1<br>(<span class="hljs-built_in">integer</span>) 0<br>&gt; SETBIT 20210308 2 1<br>(<span class="hljs-built_in">integer</span>) 0<br>&gt; SETBIT 20210309 1 1<br>(<span class="hljs-built_in">integer</span>) 0<br></code></pre></td></tr></table></figure><p>统计 20210308~20210309 总活跃用户数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; BITOP and desk1 20210308 20210309<br>(<span class="hljs-built_in">integer</span>) 1<br>&gt; BITCOUNT desk1<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><p>统计 20210308~20210309 在线活跃用户数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; BITOP or desk2 20210308 20210309<br>(<span class="hljs-built_in">integer</span>) 1<br>&gt; BITCOUNT desk2<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><h3 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h3><p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p><p>《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。</p><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p><ul><li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-event-handler.png" alt="文件事件处理器"></p><p><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：</p><ul><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ul><p><strong>那为何又引入了呢？</strong></p><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p><p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p><p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">io-threads-do-reads <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 <code>redis.conf</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">io-threads 4 <span class="hljs-comment">#官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span><br></code></pre></td></tr></table></figure><h3 id="Redis-内存管理"><a href="#Redis-内存管理" class="headerlink" title="Redis 内存管理"></a>Redis 内存管理</h3><p>内存有限，淘汰掉没用的数据。</p><p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p><p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-expired-dictionary.png" alt="redis过期字典"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br>    ...<br><br>    dict *dict;     <span class="hljs-comment">//数据库键空间,保存着数据库中所有键值对</span><br>    dict *expires   <span class="hljs-comment">// 过期字典,保存着键的过期时间</span><br>    ...<br>&#125; redisDb;<br></code></pre></td></tr></table></figure><p><strong>过期策略</strong></p><p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p><ol><li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p><p><strong>内存淘汰机制了解吗？</strong></p><blockquote><p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p><p>通过内存淘汰机制</p></blockquote><p>Redis 提供 6 种数据淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol><h3 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a><strong>Redis 持久化机制</strong></h3><p><strong>怎么保证Redis挂掉之后再重启数据可以进行恢复？</strong></p><p>Redis的一种持久化方式叫<strong>快照（snapshotting，RDB）</strong>，另一种方式是<strong>只追加文件（append-only file，AOF）</strong>。</p><p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clojure">save <span class="hljs-number">900</span> <span class="hljs-number">1</span>           #在<span class="hljs-number">900</span>秒(<span class="hljs-number">15</span>分钟)之后，如果至少有<span class="hljs-number">1</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。<br><br>save <span class="hljs-number">300</span> <span class="hljs-number">10</span>          #在<span class="hljs-number">300</span>秒(<span class="hljs-number">5</span>分钟)之后，如果至少有<span class="hljs-number">10</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。<br><br>save <span class="hljs-number">60</span> <span class="hljs-number">10000</span>        #在<span class="hljs-number">60</span>秒(<span class="hljs-number">1</span>分钟)之后，如果至少有<span class="hljs-number">10000</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。<br></code></pre></td></tr></table></figure><p><strong>RDB 创建快照时会阻塞主线程吗？</strong></p><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li><code>save</code> : 主线程执行，会阻塞主线程；</li><li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li></ul><p><strong>什么是 AOF 持久化？</strong></p><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendonly <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。（AOF很像是binlog）</p><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendfsync always    <span class="hljs-comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br>appendfsync everysec  <span class="hljs-comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘</span><br>appendfsync no        <span class="hljs-comment">#让操作系统决定何时进行同步</span><br></code></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p><strong>AOF日志如何实现？</strong></p><p>关系型数据库（如MySQL）通常都是<strong>执行命令之前</strong>记录日志（方便故障恢复），而 Redis AOF 持久化机制是在<strong>执行完命令之后</strong>再记录日志。（对比binlog和undo log 说的）</p><p><img src="https://javaguide.cn/assets/redis-aof-write-log-disc.ca22bd65.png" alt="AOF 记录日志过程"></p><p><strong>为什么是在执行完命令之后记录日志呢？</strong></p><ul><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul><p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p><ul><li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li><li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li></ul><p><strong>AOF日志因为是傻瓜记录所以需要有AOF重写？</strong></p><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p><p>那具体咋重写呢，执行BGREWRITEAOF命令，Redis服务器会维护一个AOF重写缓冲区，然后这个缓冲区会在子进程创建新AOF期间，记录服务器所有的写入指令，知道后台维护好了AOF文件后，自动追加到末尾。</p><p><strong>如何选择 RDB 和 AOF？</strong></p><p>关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明<a href="https://redis.io/docs/manual/persistence/">Redis persistenceopen in new window</a>，这里结合自己的理解简单总结一下。</p><p><strong>RDB 比 AOF 优秀的地方</strong> ：</p><ul><li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复（RDB更像是redo log）。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li><li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li></ul><p>（1、RDB是经过二进制压缩的，只保存时间戳+数据集，文件小，适合做备份和灾难恢复；2、直接还原数据就行，而AOF需要逐条指令写入）</p><p><strong>AOF 比 RDB 优秀的地方</strong> ：</p><ul><li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li><li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li><li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li></ul><p>（1、RDB记录的是数据，虽然恢复容易，但是记录的时候很占用cpu和内存的资源，比如AOF的秒级持久化安全；2、RDB是特定的二进制格式保存的，所以序列化的方式可能不同，有多个版本的RDB，存在老版本的Redis服务不兼容新版本的RDB格式的问题；3、AOF的分析很直观，都是语句）</p><h3 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">MULTI</span><br>OK<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span></span><br>QUEUED<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">GET PROJECT</span><br>QUEUED<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">EXEC</span><br>1) OK<br>2) &quot;JavaGuide&quot;<br></code></pre></td></tr></table></figure><p><code>MULTI</code>命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <code>EXEC</code>命令后，再执行所有的命令。</p><p>这个过程是这样的：</p><ol><li>开始事务（<code>MULTI</code>）；</li><li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li><li>执行事务(<code>EXEC</code>)。</li></ol><p>你也可以通过 <code>DISCARD</code> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p><p>可以用<code>WATCH</code>看住一个key，这样其他的事务不能修改这个key。但在本事务内<code>WATCH</code>的其他的事务不能操作，但他自己可以。</p><p><strong>Redis的事务支持原子性吗？</strong></p><p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）。</p><p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p><p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><p>除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p><p>因此，Redis 事务是<strong>不建议在日常开发中使用</strong>的。</p><p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p><p>Redis7.0新增了Redis functions 你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p><h3 id="Redis-性能优化"><a href="#Redis-性能优化" class="headerlink" title="Redis 性能优化"></a>Redis 性能优化</h3><p><strong>bigkey</strong></p><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p><h3 id="Redis-生产问题"><a href="#Redis-生产问题" class="headerlink" title="Redis 生产问题"></a>Redis 生产问题</h3><p><strong>缓存击穿</strong>：redis中都没有缓存的key，突然请求直接大面积打到mysql，让mysql崩溃 </p><p>解决方案：用布隆过滤器解决。</p><p><strong>缓存雪崩</strong>：redis中热点key突然大面积失效，突然请求直接大面积打到mysql，让mysql崩溃。比如秒杀商品都设置固定12h，结果都失效了，还在被请求。</p><p>解决方案：随机设置热点key的过期时间，让它们不一致；设置永久不过期，比如双11期间这些热点商品keyID都不过期。</p><h3 id="Redis-内存碎片"><a href="#Redis-内存碎片" class="headerlink" title="Redis 内存碎片"></a>Redis 内存碎片</h3><p><strong>什么是内存碎片？</strong></p><p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/memory-fragmentation.png" alt="内存碎片"></p><p>Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。</p><p><strong>为什么有Redis内存碎片？</strong></p><p>Redis 内存碎片产生比较常见的 2 个原因：</p><p><strong>1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</strong>（申请的多，贪婪）</p><p><strong>2、频繁修改 Redis 中的数据也会产生内存碎片。</strong></p><p>当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。</p><p>使用 <code>info memory</code> 命令即可查看 Redis 内存相关的信息。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/redis-info-memory.png" alt="img"></p><p><strong>如何清理 Redis 内存碎片？</strong></p><p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p><p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">config <span class="hljs-built_in">set</span> activedefrag <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>具体什么时候清理需要通过下面两个参数控制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 内存碎片占用空间达到 500mb 的时候开始清理</span><br>config <span class="hljs-built_in">set</span> active-defrag-ignore-bytes 500mb<br><span class="hljs-comment"># 内存碎片率大于 1.5 的时候开始清理</span><br>config <span class="hljs-built_in">set</span> active-defrag-threshold-lower 50<br></code></pre></td></tr></table></figure><p>通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span><br>config <span class="hljs-built_in">set</span> active-defrag-cycle-min 20<br><span class="hljs-comment"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span><br>config <span class="hljs-built_in">set</span> active-defrag-cycle-max 50<br></code></pre></td></tr></table></figure><p>另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！</p><h2 id="Spring基础"><a href="#Spring基础" class="headerlink" title="Spring基础"></a>Spring基础</h2><p><strong>Spring 包含的模块有哪些？</strong></p><p><strong>spring4.x 版本</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/framework/spring/jvme0c60b4606711fc4a0b6faf03230247a.png" alt="Spring4.x主要模块"></p><p><strong>Spring5.x 版本</strong> </p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/framework/spring/20200831175708.png" alt="Spring5.x主要模块"></p><p>Spring5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p><p>Spring 各个模块的依赖关系如下：</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/framework/spring/20200902100038.png" alt="Spring 各个模块的依赖关系"></p><p><strong>Core Container</strong></p><p>Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。</p><ul><li><strong>spring-core</strong> ：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong> ：提供对 bean 的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong> ：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong> ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用</li></ul><p><strong>Spring, Spring MVC, Spring Boot 之间什么关系?</strong></p><p>很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。</p><p>Spring 包含了多个功能模块（上面刚刚提到过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p><p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/jvme0c60b4606711fc4a0b6faf03230247a.png" alt="Spring主要模块"></p><h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h2><p><strong>谈谈自己对于 Spring IoC 的了解</strong></p><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png" alt="img"></p><p>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p><strong>什么是 Spring Bean？</strong></p><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p><p><img src="https://img-blog.csdnimg.cn/062b422bd7ac4d53afd28fb74b2bc94d.png" alt="img"></p><p><strong>将一个类声明为 Bean 的注解有哪些?</strong></p><ul><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><p>（三层结构）</p><p><strong>@Component 和 @Bean 的区别是什么？</strong></p><ul><li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ul><p><code>@Bean</code>注解使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransferService <span class="hljs-title function_">transferService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码相当于下面的 xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transferService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> OneService <span class="hljs-title function_">getService</span><span class="hljs-params">(status)</span> &#123;<br>    <span class="hljs-keyword">case</span> (status)  &#123;<br>        when <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl1</span>();<br>        when <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl2</span>();<br>        when <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl3</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@Autowired 和 @Resource 的区别是什么？</strong></p><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 <code>smsService</code> 就是我这里所说的名称，这样应该比较好理解了吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// smsService 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><p>举个例子，<code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><span class="hljs-comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-comment">// smsServiceImpl1 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>（名称）、<code>type</code>（类型）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Resource &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    Class&lt;?&gt; type() <span class="hljs-keyword">default</span> Object.class;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果仅指定 <code>name</code> 属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code> 和<code>type</code>属性（不建议这么做）则注入方式为<code>byType</code>+<code>byName</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span><br><span class="hljs-meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><p><strong>简单总结一下：</strong></p><ul><li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li><li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code>可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</li></ul><p><strong>Bean 的作用域有哪些?</strong></p><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application/global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>xml 方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">personPrototype</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>单例 Bean 的线程安全问题了解吗？</strong></p><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><p>常见的有两种解决办法：</p><ol><li>在 Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><p>不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p><p><strong>Bean 的生命周期了解么?</strong></p><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li><li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><p><img src="https://s2.51cto.com/images/blog/202203/16022710_6230da7ec16409844.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/resize,m_fixed,w_1184" alt="Spring Bean生命周期"></p><p><img src="https://s2.51cto.com/images/blog/202203/16022711_6230da7f02f3016309.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/resize,m_fixed,w_1184" alt="Spring Bean生命周期，好像人的一生。。_生命周期_09"></p><p>1、实例化 2、属性赋值 3、初始化 4、使用中 5、销毁</p><h2 id="Spring-AoP"><a href="#Spring-AoP" class="headerlink" title="Spring AoP"></a>Spring AoP</h2><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess"></p><p>AOP 切面编程设计到的一些专业术语：</p><div class="table-container"><table><thead><tr><th style="text-align:left">术语</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:left">目标(Target)</td><td style="text-align:center">被通知的对象</td></tr><tr><td style="text-align:left">代理(Proxy)</td><td style="text-align:center">向目标对象应用通知之后创建的代理对象</td></tr><tr><td style="text-align:left">连接点(JoinPoint)</td><td style="text-align:center">目标对象的所属类中，定义的所有方法均为连接点</td></tr><tr><td style="text-align:left">切入点(Pointcut)</td><td style="text-align:center">被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td></tr><tr><td style="text-align:left">通知(Advice)</td><td style="text-align:center">增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情</td></tr><tr><td style="text-align:left">切面(Aspect)</td><td style="text-align:center">切入点(Pointcut)+通知(Advice)</td></tr><tr><td style="text-align:left">Weaving(织入)</td><td style="text-align:center">将通知应用到目标对象，进而生成代理对象的过程动作</td></tr></tbody></table></div><p><strong>Spring AOP 和 AspectJ AOP 有什么区别？</strong></p><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><p><strong>多个切面的执行顺序如何控制？</strong></p><p><strong>1、通常使用<code>@Order</code> 注解直接定义切面顺序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 值越小优先级越高</span><br><span class="hljs-meta">@Order(3)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br></code></pre></td></tr></table></figure><p><strong>2、实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br><br>    <span class="hljs-comment">// ....</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回值越小优先级越高</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>Spring MVC 的核心组件有哪些？</p><p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p><ul><li><strong><code>DispatcherServlet</code></strong> ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code></strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code></strong> ：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code></strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code></strong> ：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><p>原理图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/de6d2b213f112297298f3e223bf08f28.png" alt="img"></p><p><strong>Spring 框架中用到了哪些设计模式？</strong></p><blockquote><p>关于下面这些设计模式的详细介绍，可以看我写的 <a href="https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html">Spring 中的设计模式详解open in new window</a> 这篇文章。</p></blockquote><ul><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h2 id="Spring-DATA-JPA"><a href="#Spring-DATA-JPA" class="headerlink" title="Spring DATA JPA"></a>Spring DATA JPA</h2><p>JPA非持久化数据到数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String transient1; <span class="hljs-comment">// not persistent because of static</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">transient2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Satish&quot;</span>; <span class="hljs-comment">// not persistent because of final</span><br><span class="hljs-keyword">transient</span> String transient3; <span class="hljs-comment">// not persistent because of transient</span><br><span class="hljs-meta">@Transient</span><br>String transient4; <span class="hljs-comment">// not persistent because of @Transient</span><br></code></pre></td></tr></table></figure><p>一般用注解比较多。</p><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p><strong>有哪些控制请求访问权限的方法？</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/framework/spring/image-20220728201854641.png" alt="img"></p><ul><li><code>permitAll()</code> ：无条件允许任何形式访问，不管你登录还是没有登录。</li><li><code>anonymous()</code> ：允许匿名访问，也就是没有登录才可以访问。</li><li><code>denyAll()</code> ：无条件决绝任何形式的访问。</li><li><code>authenticated()</code>：只允许已认证的用户访问。</li><li><code>fullyAuthenticated()</code> ：只允许已经登录或者通过 remember-me 登录的用户访问。</li><li><code>hasRole(String)</code> : 只允许指定的角色访问。</li><li><code>hasAnyRole(String)</code>: 指定一个或者多个角色，满足其一的用户即可访问。</li><li><code>hasAuthority(String)</code> ：只允许具有指定权限的用户访问</li><li><code>hasAnyAuthority(String)</code> ：指定一个或者多个权限，满足其一的用户即可访问。</li><li><code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问。</li></ul><p><strong>如何对密码进行加密？</strong></p><p>如果我们需要保存密码这类敏感数据到数据库的话，需要先加密再保存。</p><p>Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 <code>PasswordEncoder</code> ，如果你想要自己实现一个加密算法的话，也需要继承 <code>PasswordEncoder</code>。</p><p><code>PasswordEncoder</code> 接口一共也就 3 个必须实现的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PasswordEncoder</span> &#123;<br>    <span class="hljs-comment">// 加密也就是对原始密码进行编码</span><br>    String <span class="hljs-title function_">encode</span><span class="hljs-params">(CharSequence var1)</span>;<br>    <span class="hljs-comment">// 比对原始密码和数据库中保存的密码</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(CharSequence var1, String var2)</span>;<br>    <span class="hljs-comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">upgradeEncoding</span><span class="hljs-params">(String encodedPassword)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1>]]></content>
    
    
    <categories>
      
      <category>Back-End Engineer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript</title>
    <link href="/2022/10/08/JavaScript/"/>
    <url>/2022/10/08/JavaScript/</url>
    
    <content type="html"><![CDATA[<h1 id="Js基础"><a href="#Js基础" class="headerlink" title="Js基础"></a>Js基础</h1><h2 id="变量定义-var-let-const"><a href="#变量定义-var-let-const" class="headerlink" title="变量定义 var, let, const"></a>变量定义 var, let, const</h2><p>const声明的不能变</p><p>let声明的变量会变</p><p><strong>let声明的变量可以改变，值和类型都可以改变；const声明的常量不可以改变</strong>，这意味着，const一旦声明，就必须立即初始化，不能以后再赋值数组和对象等复合类型的变量，变量名不指向数据，而是指向数据所在的地址。</p><p><a href="https://www.jianshu.com/p/4e9cd99ecbf5">https://www.jianshu.com/p/4e9cd99ecbf5</a></p><p>var在ES6之前一直在用 跟let一样。var是函数范围，let是块作用域</p><p>不写let就是全局变量。</p><p>ES6 模版字符串 ${abc} 还有 对于不规则的字符串使用``来标记</p><p>NaN 是number但是是无效number</p><p>只有加号可以做字符串拼接</p><p>===是严格的相等运算符号，==是松散的相等运算符号，‘18’ == 18 是true 而 ===不行</p><p>!== 对应 ===， != 对应 ==</p><p>三元表达式可以有返回值</p><h2 id="ES5-ES6-and-ESNext"><a href="#ES5-ES6-and-ESNext" class="headerlink" title="ES5, ES6+ and ESNext"></a>ES5, ES6+ and ESNext</h2><p>“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。</p><p>它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。</p><p>“use strict” 的目的是指定代码在严格条件下执行。</p><p>严格模式下你不能使用未声明的变量。</p><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>1、普通函数</p><p>2、匿名函数</p><p>3、箭头函数</p><p>写单行函数用的 =&gt; 表达式，表达式也可以是代码块。</p><p>（输入值，可以是多个）=&gt; {代码块}</p><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>push 添加到队尾</p><p>unshift 添加到队头</p><p>pop 弹出最后一个元素</p><p>shift 弹出第一个元素</p><p>indexOf找具体下标</p><p>includes包含元素判断</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>在JavaScript中， prompt() 方法被<strong>用于展示一个提示框去提示用户进行输入</strong>。</p><p>this指针用来防止和属性域中相同的命名。</p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>Math.trunc() 会剔除整数部分</p><p>Math.random() 会随机 0 &lt;= x &lt; 1 的数</p><h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><p>console.table()</p><p>console.log()</p><p>log里面要${data}的话需要用``括住</p><h2 id="✨DOM-amp-DOM-操作"><a href="#✨DOM-amp-DOM-操作" class="headerlink" title="✨DOM &amp; DOM 操作"></a>✨DOM &amp; DOM 操作</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAADhCAMAAADmr0l2AAAAk1BMVEX///9EcsQ3asE9bsNEdMUwZ8Dl6/aistW2xeWCntVBcMM6bMJ4ltJ9mtNOecdlic2itt+ardTt8fmtvuKvvtxwkdDq7vhVfsnE0etoi84pY7+csd1Zgcr5+vy7yujL1+6MpdiqutrZ4vPU3vHJ1e2VrNuIo9geXb2pu+KHn8zN1efd4+8VWry+yuJ4k8a8zOpsicFQZXTyAAAPi0lEQVR4nO2dDWOrKNbHR8AsgqJTx4JKxRUxPtO7437/T7eQNG3eG5ukvebxf2+aFyOcX0CQc1D++GPWrFmzZs2aNWvWrFm/q1o8Tu1PGzxWmQ/GyA9/2uCxCqE3RjD6aYPHagacAX9zzYCPAkggeWhAknUxOANGyMQB/UVQYUA9QKhHCSGUAAIotOVKCaSUdgGcOGADigbhStFS4MAAwbRoh4Z0WKCharhqMjJxQOi3oViaWhegLoFi4tdr0WeNEUaRoOw6OvUSLOirFMuyawrYJb7iVdEUSaa5pIpEZV2DaQMCLVQGqkGAvsWkqQTDhfLLrBMVH0hYyqlXUc+OFIhtYmwj4/655sWjtu2E0DU0Vm+9yHQBL9QM+NtpBpwBf3PNgFMHfHivmjjh/0wfxS96Sv/6aQPurT9/2oB7awacumbAqWsGnLoeHvCvnzbgVkqi4Ki64x9HyU8bPFYhgGMEJneyHVIAPkZMqxCEc7CxI6EYt3F6w6VQahU416CLL5EMEQ9gIZiC3uoj5z70IHQORIJy+256gGH/a1HkfQx5EsJFygjQRQFaypKMZnWUlxDUBuRZQssmY2x6gFmDe65kwxrZZm2EPKCH1G+BYoo9h03fm6Tu0hTXOGtZF0zvGAxxWdamSLuqiMqK2yqqAQStt+gHqZYDz5I2TU0as0pin4LplWCYLhex4tqWoMhxZ0uwyTKigOYx1IWQWd93jKc5H5hmWTa9EuQhjVjYxzTuQ8DtMUjCsmQB5L2BAYgYz6jpZcZRBEyU5dMDdI2li+h6m8eq7XQvbUPqNhEPupive7bfm14VfXS34Qw4A/7mOgDcmRBEDrZOHhB23J1Tv/Hxbn/zxAEJtScsAMqSutk/kMYV2i3EiQOCUHXpoLJ+ESRYJa2ROFYGkEcBBG3q+zhjguPlEAdVoTn2/W5ByIMAEokrhmMkJF5WPOh9xTFMRPYwJegREHdVzBR97ixg6mteZZG/3axOHND1C/a8080HAq6LcNOCdn0Xkwf8TNMDzAr/qMDxj4vspw0eq+fFcYkTnz//tMG30v/9tAH31gw4df3mgIs//3Wl/nttAn829wT8+/WeqV+kp+qeqf8GgM//uWfqM+D99XzXKrp4umfqF+nlJr8xpmiU/MUtct3Rwh9nAsWjAAEZpbsAbmfgfWoCGAn4MValUMojgeed4dBdALdMoCg/Eft+19gS3KSRL4QxBlI3UAWrwAmA9hWkBm75xe4LuBgwb4HNfpUxdcSetQiGEn54W78KmPVL3xiQViw0IhMdCKqAmKqUL4NnyHcAEk/98rko6ipkRkQ4BTFOgOkxbXTcvc9q+DLgQuSm7iMpyj5e+A1UheYLX8MWkRJ+CyB5Hmou4srXsimekJCK9FEj+6CMgLkesC980w1pHyURqwolX5OEtYVArUfeK9G9S3AJ+BCppIxxoQqcN0nPdWFMGUH/+iralJExtl5mfWDrSeM3kWGqUEgkXvVNJbgwhgukoy52Fx9WeWUMavzSBIKl/MoS9Lwsk4zTOGKceZLEBEUxkUR6KCT5txyDHomz3JOQRXJlgEQwzOwzYzBkMbqyBD1vqxta1ZfVu9Wz99FK3xVwkyVZV1jieZv3ZKuj+DLgRbov4EWaAWfAxwbcvSPFQQT6OwC3g21HTkyvAiQgZevGa/3gCd3N4hsAaRC5n9XlS0tJ9k61rwIklMcaMUjcgyMCkRxith2fvT8gJJmpGbWm2DN+hGPbQcgc3GA04fhQak//Bp3lGEdBr1nXtlUs+q1u8O6A0KigbioMVKqKFi8yUQhZDdvDuK8DguduWWiU9RVOW7/WWQvl4C/rxdZ37gwIKmHPiOulNmY5RMMvzDXSfiFf2C06ekJSJVeAMbAn232oUD7EqoffWIKgVp1JCt0lyzZvfwlZK+MNA79JCdomBsUY5SVvh6gWIs81TnKPfu8xCLJAqNoXbeJjISR9IVLe6BhcFaIbTduBtB1S21cA7Eegv6EVdVlDb/0AJG7BXlcxcafTvji/0ulEvaNC6Pjn33gm82bCQVc/rgRP6fXlFqlcpae7Otf/+vlQ+utdYxPVDHh3zYBX6XsA/zkfwz638Z8rW8HvAbziMti/rozvzYA30Q8CXrv/ZfoGwJcTU+b064kNXzq2T6S1aD+fsPd04ivqVJp7WafL47MeT+nXl85F4cgpl/xj13Lcrv6vvZI9cN1/oq+dbLPtTLxPZ9CS+GPX5GM0cJmBJwHtuJJl2TE33fUD3ndAwqQk5kgmO/7J44DWQH7cwIsASfaaBsZQO8aEFNh/HqXUjXhBSraSuBLQb9IUaegC5atbWLkxtcsPygR8eEaOApJssTKQ7hpo32NKtgw8DZgWwNTeIPIa67JNiwT3RAyVfMIevjI+uAVYAKD8GmNfDCLVnA9Clljn/SIIgg3hccDQGegcNHldrQ2srIGi4k8V3QpgngZc4NjU2ESqNEz/apjOG9kslScI+agY1wJq3PuKNLnKm6XIo1IEXZVGfODY/5jicaoEnYGpCXVpUPNLcx03Ui8V1HTbwNOAbhJCNwQ5SwIXwuYqjlchbOWRj5bo6hJcFkAhHedEFxUPE5XlDOe8kpUP30vhVAlaA2vc5TwJkChU3FoDRSE8Db0tA08C5g2uTR23LuTPLWDR9r1NR6B08NR7Hb8SECiMWevjNPXUCjAUfZZaQLqI6npDeBzQGVivDXSALRB9ap8HlAqgP6+itoFjyMVTnQtyFVelfPWeQE7Qraoosbmskmbr6DGCyKbuXiL24QU60Yq6r6CVgeTNsGMGnusHP/56Htl+eW0Ie7cf3ISmvZ38ttr/0/3g7hePGnga8CJdC3iRTgBeZuAM+Mn+M+AUACHZmRvz+wGuWhd49KT9M0ACiQR1hpivgbe6+8TdAFe3Fz+YBHABIPFb2y3AzsAjg4vzgASgJH61w4oEe40PI+mVaDdIfzNACEspA89drj0OkIAoVDIDWT/4QbQfejoPSFAisuw166NesKaoglaGIkE3HC59ZFWrGpZd63eiPiiGc4AkEz1QqQiAFAD1Yn/8dBYQBg0viCr6MCiLpliUQ1jI1+gegPwpK6jpG7/IFgfzqM8BwsYUvqJZD2IBYGGave3nqyhEWNCm6KOgt4CND4jAt5izfaQEQaJyVbx6OjmoZeerqB/oUHth78uhiHS0H3v7pJEhFMGkD2MiwhLEw8C8vexvdgy6q5fTtPTIkVbyfCMDASq9OMpbYRuIgwP4027CDt9d80Zt80bs4PngGL5lN0GPNDCfA678Gy7SC47NgzoE/I4QNhuXyS7guF2LfUB35Qu795UvzDue2omMdwDhSAOPOIRf7nol4jn9feH3rjTw6cduBXqh6/5aA2fAu2kGXGsGvPP+X9cMuNYMeOf9v65vBnw5tYrJKemPNE4tjHJK1VcAX0Zmgpvd/Z+Wo5anAUX5YYMct7QN8L4C+DzWwH4P8OAKDQjPrVxKt256Hn9EL7fvMeadcPoR9iXAkQaC9DwgiROTvPk8jvnojgKSPLejyZU3jhADNuPNvf1vA0ii0iT8tIGfAspoEUhI7TCfdubwtzoKCJT2Y1wkIQQeyYDyqbu/ODAddIufblx0NwLMuyZyMXpKQHDEwM8APVLooq6UrHDWNlm678A6Bkg4FihdBI2S9r8qFlUDNayN0nGCFRBvv/etqigSRZq2vJHVcMTATwE9oIvXsiqH0g9qcDCL+xgg7TuTSluCtvAKqgq9NLWy5V8HYGF0SG5agjYZQRamkeWTLcFDH/1FgNoeSn6Ng/IyQNAkif09iz4ELYDarXMaKVAaUwNNCdk4Z24H6CL0fqVjZ+C+hRcADiAUQ4yHkOnLqqhM/QJz3eVaYghXcylA1w6B1Hk9DGRgt62iLPXNUMUpwtbAfnwVte38apFSuHKzXdLIrNYmcEspw7dXto2C7t4N9G2505uWoMtunSw8ZuAFgGd1vB+8SLcCPK/pAP7nOsCXf/76t5MeGQy9BpA3LscLATcG/j3SwA3gHy9rfW8J2gwvnhD7ZuDYy5nfATc1Yf9EYf/l/sW0ZwB3I8TO5bwP6DRyxu+qin5MczmnVYbnAYlkiAK6jsOuT0A43+lpTgMSztDWd6HknN8IEHEJ3a181vOV3mD2mJ3BzK3scRYQqCQQWiU9yhHU7l62SAw7a/GcBrT7ZoK5SxFdM05iFe5exPl1QBImKmibNhQ+BJXrHDyK0WohCCntW9c7QZb7IurpJ4A0rfOi4n6EmoopP7b9fL8b7T0NCNMuruoEZoHxTQmEknu7fh0w7lJgT5GRKCMQ0ChlBEYkT2MCB5WjNCC13yVNluQGfnYMukHAEPvKqyK3wAls9ockZ45BSIAorQRPgqg3Pdk71f96FXXTFoD20XPcwAZoxAnQoLFP0CRQsSpXZZlVCH5+DK4QLGBL0pjasUGP0d6BfbYVBQPL0zIqVJrWdbk/WLuikXFpa58NRcV0YZQkQMFIZwTWNVj0OI7/8PN03Z9cAChcCaalZ38kFl40HnwHFDxPk8DvjZTm1oCNz9piYA3JbNJAkygcAAwqT8e5pwMs9fqA/xyQhIyECPUshDw9mA1xFtDux/NYeqDupTzcehUgiQgKYYgiWNojjUSwTmwTCsuYJCXP/I6a8ELAzcTMtyVqxgCubylkP7Uj+cP5OtcBeuQt+XWr4J5WU5/IejUduJm+dABYjFqHDvrbgOPWsKPoS4BjDdwHDI8vGXhK0db9Mc24XYPuK4CjDRTj0r+9Hn4ZzRlw6poBp64ZcOqaAaeu/zeAY0PT7Y9aPUIbwJHxb38y64huAPfHUwR8LD99xD84naWNTgAS3g6iBGvHID8knDygRwqF/DyjMGCRlgfj5ekDekChOu1NVYd1kx34rB4CkKg+TYM23rl6+ZEAvSqjiDHNFJXx4wFCgzxcZWYIKa7DgDwc4GpRaeCWTfDA4UV0jwB4VjPgb6N//lxJ7Uc9HgZwo4ctwY3eAN/i3ps3q787d0h4ezNVQBJKN1dpHS8nqwtPEUPvs7+g3b5eF2KqgKAK07CnsIeUAtC4RW0CvMAxcHf8oTIoRJDAKQPCTgYOMAFJigtdYORBqoqsSlDvJ3gR1nE06RK0vTuNekqbYkEGqXAIPYJUodGQVSLM0vcuf7KA7sjrfTeHs0hjpaS7zYwCC2NY9ALC/n2e06QBmzRvisat2AMWjBCki7ZMuI4VX7zPlpwwoOdJyTiRhCP7cLcN4gRkMWJQwpg/BCAh733h2+I63sfiOpMFfFiv2kYP6xedNWvWrFmzZs2aNetx9T8nv4qUhI6gRgAAAABJRU5ErkJggg==" alt="JavaScript HTML DOM - DEV Community 👩‍💻👨‍💻"></p><p>DOM TREE 对应 html 结构。</p><p>dom并不是js</p><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p>选择器选择出类，执行监听事件，传入事件类型，告诉时间需要做什么传入一个函数值。</p><p>classList就是某个标签的class name的所有。</p><h4 id="监听动作"><a href="#监听动作" class="headerlink" title="监听动作"></a>监听动作</h4><p>click，keydown，keyup，keypress</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>1、高级语言</p><p>2、垃圾回收机制</p><p>3、实时编译系统</p><p>4、多范式语言</p><p>​    程序化编程</p><p>​    OOP</p><p>​    函数编程FP</p><p>5、原型链编程</p><p>6、动态类型</p><p>​    不需要手动定义变量类型，强类型语言，定义完成后，不再变化类型（如果不转换的话）</p><p>7、单线程</p><p>8、非阻塞事件循环并发模型</p><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>js引擎。v8和nodeJS。</p><p>引擎里面包含调用栈（上下文）和堆。</p><p>js直接通过解释器运行程序，不用通过编译器编程机器编码再运行。（类似python，之前的js）</p><p>现代js是即时编译just in time（JIT）定期提前编译再运行。</p><p><img src="https://pic1.zhimg.com/80/v2-e510730cbb214ebae66eed01b61396c0_720w.jpg" alt="img"></p><p>解释型语言逐行解析代码，逐行执行，即开即用，无需准备时间，但是运行速度较慢</p><p>编译型语言将代码一次性编译成机器码，直接被机器直接执行，运行速度快，但运行前的准备时间较长</p><p>RUNTIME IN THE BROWSER（引擎 + WEB APIs + CALLBACK QUEUE回调函数）</p><p>WEB APIs中有DOM、Timers、Fetch API等等</p><p>EVENT LOOP 事件循环：当调用栈为空的时候从回调函数队列中找到事件函数，放进调用栈</p><p>nodejs没有WEB APIs他代替的是浏览器。但nodejs里面有c++绑定和线程池。</p><p>执行上下文CONTEXT中包含三样，变量环境，Scope chain作用域链， this keyword</p><p>其中箭头函数没有this关键字和参数对象，return会把执行上下文弹出调用栈放到内存中运行。</p><p>全局作用域（整体），函数作用域（函数块）和块作用域（if、for）</p><p>只有let和const会在块作用域中，var的话不会收到块作用域的控制，还是可以被访问，var是函数作用域，ES5之前只有函数作用域和全局作用域。</p><p>子作用域可以访问父作用域中的所有变量，但父作用域不能访问子作用域的变量。（变量查找）重点在于声明的位置。同级之间不能互相访问。（作用域只与定义变量当时的位置有关）</p><p>hoisting吊装，在一个作用域内，变量的定义会被移到代码顶部，而变量的赋值则保持原来的位置。</p><p>箭头函数可以帮忙继承this关键字进入下一层域</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>const共享内存，let不共享内存设置新的值会开新的空间。调用栈里面存放变量，堆HEAP里面存储对象，对象名字指向调用栈中的地址，但地址是个hash值，hash值对应一个Heap中的空间。对象默认共享内存的，你新引用一个变量指向对象，修改属性是会修改被引用的对象内部的值的。</p><p>浅拷贝只拷贝数值，深拷贝拷贝所有内容。</p><p>解构数组（用[ ]）解构对象（用{ }）</p><p>还有…语法糖 ??检测 null 和 undefined</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>for of 可以用 continue 和 break 中断</p><p>ES6支持内嵌对象，之前需要起名字。</p><p>ES2020用一个？来判断当前的属性是不是空的 ？？合并运算符（如果前者ok那么就可以run，要不就用后面的提示）</p><p>Object.values 对象里面的值</p><p>Object.keys 对象包含的key</p><p>Object.entires 整个对象，包含kv</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>Set</strong></p><p>没有重复元素</p><p>const set = new Set()</p><p>通过add添加</p><p><a href="https://www.w3school.com.cn/js/js_object_sets.asp">https://www.w3school.com.cn/js/js_object_sets.asp</a></p><p><strong>Map</strong></p><p><a href="https://www.w3school.com.cn/js/js_object_maps.asp">https://www.w3school.com.cn/js/js_object_maps.asp</a></p><p>const rest = new Map()</p><p>放入是set 拿出来是get</p><p>对象可以转换为map </p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(&#123;object&#125;))<br></code></pre></td></tr></table></figure><p>遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> &#123;map&#125;) &#123;<br>  ...<br>&#125;;<br><br>[...&#123;map&#125;]<br></code></pre></td></tr></table></figure><p><strong>String</strong></p><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_string.asp">https://www.w3school.com.cn/jsref/jsref_obj_string.asp</a></p><p>可以在入参的时候直接初始化</p><p>js没有引用传递，仅仅按照值传递</p><p>原始数据类型在调用栈中会生成副本，此时副本的改动与原数据无关；引用类型在堆中直接被改变。</p><p>以下为原始数据类型。</p><ul><li>string</li><li>number</li><li>bigint</li><li>boolean</li><li>null</li><li>undefined</li><li>symbol</li></ul><p>函数是一个对象。 </p><p>高阶函数，可以接受别的函数作为输入（回调函数）。一个函数他可以return一个函数，所有的函数都是值。</p><p>函数可以当作参数</p><p>forEach给每个对象增加回调函数。自动调用。</p><p><strong>函数式编程</strong></p><p>对象里面里面直接写 函数名（变量）{} </p><p>我们可以直接提取出来函数的名字return一个函数变量，第二步然后我们可以直接用那个函数对象名.call（指定对象，变量1，变量2）</p><p><a href="https://segmentfault.com/a/1190000018270750">https://segmentfault.com/a/1190000018270750</a> 上下文绑定相关。</p><p>call会立即调用而bind只是绑定，bind可以绑定很多对象，函数也是对象。可以让一个函数bind函数a后拥有有另外一个函数a先调用新绑定的。。</p><p>但是bind和call会更新上下文，需要用_this, that, self等来记录上下文。</p><p>也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。</p>]]></content>
    
    
    <categories>
      
      <category>Front-End Engineer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Front-End Engineer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html+css+js</title>
    <link href="/2022/09/14/html-css-js/"/>
    <url>/2022/09/14/html-css-js/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p>文件类型</p><p>​    html（指定语言）</p><p>​        head（制定字符集）</p><p>​        body</p><p>​    /html</p><p>元数据<code>&lt;meta&gt;</code>描述数据的数据</p><h2 id="常用结构"><a href="#常用结构" class="headerlink" title="常用结构"></a>常用结构</h2><h3 id="1-lt-p-gt-段落"><a href="#1-lt-p-gt-段落" class="headerlink" title="1. &lt;p&gt;段落"></a>1. <code>&lt;p&gt;</code>段落</h3><h3 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h3><p>​    有序列表<code>&lt;ol&gt;</code></p><p>​    无序列表<code>&lt;ul&gt;</code></p><p>​        列表<code>&lt;li&gt;</code></p><h3 id="3-图片-lt-img-attribute-gt"><a href="#3-图片-lt-img-attribute-gt" class="headerlink" title="3. 图片&lt;img {$attribute} /&gt;"></a>3. 图片<code>&lt;img &#123;$attribute&#125; /&gt;</code></h3><p>他不包含任何结构，所以没有对应的结束标签符号</p><p>src 来源</p><p>alt 表述图片</p><p>width 宽度</p><p>height 高度</p><p>transform: scale({倍数});</p><p>filter: brightness(0); 属性滤镜</p><p>opacity: 100%; 透明度</p><h3 id="4-锚元素-lt-a-gt"><a href="#4-锚元素-lt-a-gt" class="headerlink" title="4. 锚元素&lt;a&gt;"></a>4. 锚元素<code>&lt;a&gt;</code></h3><p>可以插入在p中的元素，比如超链接</p><p>通常<strong>a元素</strong>不添加target属性时是在当前页面加载链接。当我们需要每次都在新选项卡加载链接时，则会在<strong>元素</strong>上添加<strong>target=”_blank”</strong> 关键字写法，也是大家经常使用的方法。</p><h3 id="5-段落格式"><a href="#5-段落格式" class="headerlink" title="5. 段落格式"></a>5. 段落格式</h3><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>文章头<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>导航<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span>文章正文<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure><p>统一用<code>&lt;div&gt;&lt;/div&gt;</code>来表示，不代表意义，单纯的是一个盒子，比如上面这仨就是语义html</p><p><code>&lt;asides&gt;&lt;/asides&gt;</code>标签常用来写补充信息</p><p><code>&lt;figure&gt;</code>里面才可以用 <code>&lt;figurecation&gt;</code></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>INLINE内联CSS, INTERNAL内部CSS, EXTERNAL外部CSS</p><p>在html的head中，通过link来连接css文件</p><p><code>&lt;span&gt;</code>一个普通的内联文字标签</p><p>rel属性，<strong>描述的是当前页面与href所指定文档的关系</strong></p><h2 id="CSS的用法"><a href="#CSS的用法" class="headerlink" title="CSS的用法"></a>CSS的用法</h2><h3 id="1-内联CSS"><a href="#1-内联CSS" class="headerlink" title="1. 内联CSS"></a>1. 内联CSS</h3><p>就是直接写在html内部</p><h3 id="2-内部CSS"><a href="#2-内部CSS" class="headerlink" title="2. 内部CSS"></a>2. 内部CSS</h3><h3 id="3-外部CSS"><a href="#3-外部CSS" class="headerlink" title="3. 外部CSS"></a>3. 外部CSS</h3><p>li默认字体是16</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="列表选择器"><a href="#列表选择器" class="headerlink" title="列表选择器"></a>列表选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>,<br><span class="hljs-selector-tag">h2</span>,<br><span class="hljs-selector-tag">h3</span>,<br><span class="hljs-selector-tag">h4</span>,<br><span class="hljs-selector-tag">p</span>,<br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单一选择器"><a href="#单一选择器" class="headerlink" title="单一选择器"></a>单一选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">footer</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="id和class"><a href="#id和class" class="headerlink" title="id和class"></a>id和class</h2><p>id不可以重复命名，但class可以重复命名。</p><p>我们一般只用class很少用id，要为未来着想。</p><h2 id="颜色模式"><a href="#颜色模式" class="headerlink" title="颜色模式"></a>颜色模式</h2><h3 id="RGB-RGBA-NOTATION"><a href="#RGB-RGBA-NOTATION" class="headerlink" title="RGB/RGBA NOTATION"></a>RGB/RGBA NOTATION</h3><p>rbga就是带有透明度，多了一个纬度</p><h3 id="HEXADECIMAL-NOTATION"><a href="#HEXADECIMAL-NOTATION" class="headerlink" title="HEXADECIMAL NOTATION"></a>HEXADECIMAL NOTATION</h3><p>0 to ff 的（即0 to 255）的数值标准色</p><h1 id="00-ff-ff-三位表示的也是rgb的三色的0-255"><a href="#00-ff-ff-三位表示的也是rgb的三色的0-255" class="headerlink" title="00 ff ff 三位表示的也是rgb的三色的0-255"></a>00 ff ff 三位表示的也是rgb的三色的0-255</h1><p>border: 5px solid #1098ad; 【粗细、样式、颜色】也分为top，bottom等等</p><p>伪类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125; <br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">是从1开始计数，也可以用odd这样的关键字</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123; <br>  <span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">input</span><br>                    id=&quot;full-name&quot;<br>                    type=&quot;text&quot;<br>                    placeholder=&quot;John Smith&quot;<br>                    required<br>                  /&gt;<br></code></pre></td></tr></table></figure><p>这是input标签的几个属性</p><p>for 属性规定 label 与哪个表单元素绑定。</p><p>label和input都是内联元素</p><p>require必须填写，要不不能提交表单。    </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">*<span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-comment">/* outline: 4px dotted #e67e22; */</span><br>  <span class="hljs-comment">/* outline-offset: 8px; */</span><br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0.8rem</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">230</span>, <span class="hljs-number">125</span>, <span class="hljs-number">34</span>, <span class="hljs-number">0.5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>focus就是点击表格后的状态。</p><h2 id="针对-lt-a-gt-锚元素的一些css"><a href="#针对-lt-a-gt-锚元素的一些css" class="headerlink" title="针对&lt;a&gt;锚元素的一些css"></a>针对<code>&lt;a&gt;</code>锚元素的一些css</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 超链接静态颜色 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#1098ad</span>;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br><br><span class="hljs-comment">/* 点击之后的颜色 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#1098ad</span>;<br>&#125;<br><br><span class="hljs-comment">/* 鼠标悬停的颜色 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">color</span>: orangered;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">text-decoration</span>: underline orangered;<br>&#125;<br><br><span class="hljs-comment">/* 激活后的颜色（鼠标点击但不确定的时候） */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: black;<br>  <span class="hljs-attribute">font-style</span>: italic;<br>&#125;<br></code></pre></td></tr></table></figure><p>口诀LVHA</p><h2 id="CSS选择器的优先级"><a href="#CSS选择器的优先级" class="headerlink" title="CSS选择器的优先级"></a>CSS选择器的优先级</h2><p>同级别下，最后一个选择器作为code applies</p><h3 id="最最高级-！important-关键字"><a href="#最最高级-！important-关键字" class="headerlink" title="最最高级 - ！important 关键字"></a>最最高级 - ！important 关键字</h3><h3 id="最高级-内敛样式"><a href="#最高级-内敛样式" class="headerlink" title="最高级 - 内敛样式"></a>最高级 - 内敛样式</h3><h3 id="高级-ID-选择器"><a href="#高级-ID-选择器" class="headerlink" title="高级 - ID 选择器"></a>高级 - ID 选择器</h3><h3 id="中级-继承-选择器-or-伪继承-选择器"><a href="#中级-继承-选择器-or-伪继承-选择器" class="headerlink" title="中级 - 继承 选择器 or 伪继承 选择器"></a>中级 - 继承 选择器 or 伪继承 选择器</h3><h3 id="低级-元素-选择器"><a href="#低级-元素-选择器" class="headerlink" title="低级 - 元素 选择器"></a>低级 - 元素 选择器</h3><h3 id="最低级-通用-选择器"><a href="#最低级-通用-选择器" class="headerlink" title="最低级 - 通用 选择器"></a>最低级 - 通用 选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>selector specificity显示优先级</p><h2 id="CSS-BOX-MODEL"><a href="#CSS-BOX-MODEL" class="headerlink" title="CSS BOX MODEL"></a>CSS BOX MODEL</h2><p><a href="https://www.w3schools.com/css/css_boxmodel.asp">https://www.w3schools.com/css/css_boxmodel.asp</a></p><h3 id="Margins-amp-paddings"><a href="#Margins-amp-paddings" class="headerlink" title="Margins &amp; paddings"></a>Margins &amp; paddings</h3><p>这俩不是文本属性，所以不能够进行继承。想要全局的话就要用通用选择器。</p><p>当有两个相叠加的时候，比如上和下，他们会取大的那个作为间距。（折叠边距，边距塌陷）</p><p><strong>块级元素会占据父元素宽度的100%</strong></p><h3 id="块级元素-可以创造垂直空间-BLOCK-LEVEL-BOXES"><a href="#块级元素-可以创造垂直空间-BLOCK-LEVEL-BOXES" class="headerlink" title="块级元素(可以创造垂直空间) BLOCK-LEVEL BOXES"></a>块级元素(可以创造垂直空间) BLOCK-LEVEL BOXES</h3><p><strong>display:block</strong></p><p>body, main, header, footer, section, nav, aside, div, h1-h6, p, ul, ol, li, etc.</p><h3 id="内联块元素-INLINE-BLOCK-BOXES"><a href="#内联块元素-INLINE-BLOCK-BOXES" class="headerlink" title="内联块元素 INLINE-BLOCK BOXES"></a>内联块元素 INLINE-BLOCK BOXES</h3><p><strong>display: inline-block</strong></p><p>Img</p><p>只占用自己应该占用的空间，而不有任何的换行符。我们就是没有换行符，但是可以用margin来增加垂直空间。</p><h3 id="内联元素-不创造任何垂直空间-INLINE-LEVEL-BOXES"><a href="#内联元素-不创造任何垂直空间-INLINE-LEVEL-BOXES" class="headerlink" title="内联元素(不创造任何垂直空间) INLINE-LEVEL BOXES"></a>内联元素(不创造任何垂直空间) INLINE-LEVEL BOXES</h3><p><strong>display:inline</strong></p><p>a, img,  strong, em, button, etc.</p><h2 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h2><h3 id="常规布局-NORMAL-FLOW"><a href="#常规布局-NORMAL-FLOW" class="headerlink" title="常规布局 NORMAL FLOW"></a>常规布局 NORMAL FLOW</h3><p>default positioning</p><p>position：relative</p><h3 id="绝对位置-ABSOLUTE-POSITIONING"><a href="#绝对位置-ABSOLUTE-POSITIONING" class="headerlink" title="绝对位置 ABSOLUTE POSITIONING"></a>绝对位置 ABSOLUTE POSITIONING</h3><p>他是在对应的布局块里面的绝对位置。</p><h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><p>伪类 :</p><p>伪元素 ::</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span> + <span class="hljs-selector-tag">p</span> :: first-line &#123;<br>  <span class="hljs-comment">/* 仅仅是h3的p的第一行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>:after 伪元素在元素之后添加内容。</p><p>这个伪元素允许创作人员在元素内容的最后面插入生成内容。默认地，这个伪元素是行内元素，不过可以使用属性 display 改变这一点。</p><p>.page-link.page-link—current 联合and选择器，在有前者的情况下还有后者。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="FLOAT-LAYOUTS"><a href="#FLOAT-LAYOUTS" class="headerlink" title="FLOAT LAYOUTS"></a>FLOAT LAYOUTS</h3><p>lorem输入可以产生盲文，随机文字。</p><p>就是让其在对应的父类里面飘来飘去。</p><p>clearfix hack</p><p>解决float造成的css塌陷的方法：增加一个clearfix（就这么叫）在类的名字中</p><p><strong>一个标签内可以携带多个类名</strong></p><p>类名指的是 class 的属性值。</p><p>一个标签内可以携带多个类名，指的是 class 的属性值可以有多个，每一个属性值之间使用空格分隔。</p><p>例子：</p><p>&lt;标签名 class = ”值1 值2 值3”&gt;&lt;/标签名&gt;</p><p>多个类名的优点：</p><p>1.减少 css 的代码量</p><p>2.多个类名的样式会叠加到当前元素上面</p><p>在clearfix::after加入一个空元素，但是本身他是inline的，所以我们要把升级成block级别。这样就赋予他内容。本身float已经漂浮起来了。</p><p><strong>float都是在padding里面float！</strong></p><p>其float的元素上下左右都会被float所影响如果是在同一个父布局里面的话</p><h3 id="FLEXBOX"><a href="#FLEXBOX" class="headerlink" title="FLEXBOX"></a>FLEXBOX</h3><p><strong>🌟box-sizing</strong>：border-box设定为直接就是盒子的大小，不再是height+padding的大小。变成了纯height的大小。此模式下我们的padding就不是填充的概念了，而是挤压消去多少盒子的空间。</p><p>就是box里面的元素，通过flex来操作。解决垂直居中，还有并排同高。</p><p>又一个main axis 和一个 cross axis（对齐用的）</p><h4 id="FLEX-CONTAINER"><a href="#FLEX-CONTAINER" class="headerlink" title="FLEX CONTAINER"></a>FLEX CONTAINER</h4><ul><li>gap: 0 | { length }</li><li>justify-content: flex-start | flex-end | center | space-between | space around | space-evenly  <strong>通过横轴排列元素</strong></li><li>align-items: stretch | flex-start | flex-end | center | baseline <strong>通过纵轴排列元素</strong></li><li>flex-direction: row | row-reverse | column | column-reverse</li><li>flex-wrap: nowrap | wrap | wrap-reverse</li><li>align-content: stretch | flex-start | flex-end | center | space-between | space-around</li><li>flex-direction: col是横着的一排排，row是纵向一列列，控制的是主轴的方向。横轴cross axis也变了，导致justify也变了方向，因为justify是根据主轴走的。</li></ul><p>flexbox某种程度上也是inline-block元素</p><h4 id="FLEX-ITEMS"><a href="#FLEX-ITEMS" class="headerlink" title="FLEX ITEMS"></a>FLEX ITEMS</h4><ul><li>align-self: auto | stretch | flex-start | flex-end | center | baseline</li><li>flex-grow: 0 | { integer } <strong>1为开启，自动填充剩余空间，如果有的话</strong>(常用于按比例填充)</li><li>flex-shrink: 1 | { integer } <strong>1为开启， flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据flex-shrink 的值</strong></li><li>flex-basis: auto | { length } <strong>并非严格宽度，在不超过的情况下是设置的大小</strong></li><li>flex: 0 1 auto | { int } { int } { len } <strong>第一个是flex-grow 第二个是flex-shrink 第三个是flex-basis</strong></li><li>order: 0 | { integer } <strong>默认初始都为0</strong></li></ul><h3 id="CSS-GRID-css网格"><a href="#CSS-GRID-css网格" class="headerlink" title="CSS GRID(css网格)"></a>CSS GRID(css网格)</h3><h4 id="制表"><a href="#制表" class="headerlink" title="制表"></a>制表</h4><p>适合大布局的</p><p>1D布局用flex box</p><p>2D布局用GRID </p><p>fr单位不是px</p><p>如果有一个显式的固定值，那么fr就是以这个为单位1fr</p><p><img src="https://www.w3schools.com/css/grid_gaps.png" alt="img"></p><p>有隐式行和显式行 </p><p>grid线是从1开始的 最后是-1</p><p>自动排版生成新的行</p><p>Display:gird</p><p>Grid-template-columns(or rows)</p><p>grid-template-columns: 1fr 300px; 这样fr就会填充剩余空间而且fr变成单位。</p><p>应该是block的都是可以当作独立的一个ceil</p><h4 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h4><p><strong>整体元素</strong></p><p>水平justify-content：center</p><p>纵向align-content：center</p><p><strong>批量管理个体元素</strong></p><p>水平justify-items：center</p><p>纵向align-items：center</p><p><strong>独自管理个体元素</strong></p><p>水平justify-self：center</p><p>纵向align-self：center</p><p>.grid:not(:last-child) {</p><p>  margin-bottom: 9.6rem;</p><p>}</p><p>not除了某某</p><h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">table</span>&gt;表<br>      &lt;<span class="hljs-selector-tag">thead</span>&gt; 表头<br>&lt;<span class="hljs-selector-tag">tbody</span>&gt; 表主体<br>        &lt;<span class="hljs-selector-tag">tr</span>&gt;表行<br>&lt;<span class="hljs-selector-tag">th</span>&gt;  表列名不过会加粗 weight = bold<br>          &lt;<span class="hljs-selector-tag">td</span>&gt;表列名<br></code></pre></td></tr></table></figure><p>默认每个ceil自己管理好自己，所以如果需要融合需要边界塌陷。</p><h1 id="设计习惯"><a href="#设计习惯" class="headerlink" title="设计习惯"></a>设计习惯</h1><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>用16px到32px的大小 正文</p><p>长文本尝试用20px或者更大</p><p>weight不低于400</p><p>将谷歌字体放在css文件的前面选 400、500、700</p><h2 id="子行数"><a href="#子行数" class="headerlink" title="子行数"></a>子行数</h2><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p>stroke：图标的边</p><p>fill：填充色</p><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>Box-shadow: <code>offset-x | offset-y | blur-radius | spread-radius | color</code></p><p>元素 —&gt; 组件 —&gt; 布局 —&gt; 网页</p><h2 id="打开组件"><a href="#打开组件" class="headerlink" title="打开组件"></a>打开组件</h2><p>我们先写好所有人打开的，然后关闭它，然后再加上一个open名，写好open的样式，以后谁要open就命名谁。</p><p>top指的是整个父容器的对应元素的起点。</p><p>transform搞的是元素的的高度</p><p>所以想让一个元素在其父元素的位置居中就要 top：50% 搭配 transform：translate（0，-50%）</p><p><code>&amp;nbsp;</code>none breaking space</p><p>Viewport height 视口高度 就是你已打开可以直接看到的所有地方</p><p>Viewport width</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">width</span>: <span class="hljs-number">1200px</span>;<br><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br><span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br><br>// 在某段画板上的居中操作<br></code></pre></td></tr></table></figure><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>cover 的特性是讓背景圖整個「不變形」、「寬高等比例」、「在必要時局部裁切」的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-size</span>: cover;<br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<br>            <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.6</span>),<br>            <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.6</span>)<br>          ),<br>          <span class="hljs-built_in">url</span>(<span class="hljs-string">hero.jpg</span>);<br></code></pre></td></tr></table></figure><p>套滤镜</p><p>类选择器的优先级一定高于普通元素选择器。</p><p>Margin-left 顶到最右边。</p><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><p>处理不适合的元素</p><p>overflow: scroll;</p><p>如果是flex box的话 我们需要flex-shrink: 0; 因为这个磨人flex-shrink: 1；他会压缩flex box 里面的元素。</p><h2 id="响应式设计理论"><a href="#响应式设计理论" class="headerlink" title="响应式设计理论"></a>响应式设计理论</h2><h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><p>适应视口</p><p>可以设置通用助手类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.margin-right-sm</span> &#123;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">1.6rem</span> <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>!important 有最高优先级</p><p>可重用组件。</p><h3 id="响应单元"><a href="#响应单元" class="headerlink" title="响应单元"></a>响应单元</h3><p>用rem单位，rem只是代名词而已，会在使用的时候自动转换。如果更改html中的font-size，那么他的rem就会变化。</p><p>transition: background-color 1s; 可以让按钮有动画。</p><p>文件夹路径，注意默认没有..是当前路径，直接写是当前路径，加上..是总工程路径。</p><h3 id="灵活图片"><a href="#灵活图片" class="headerlink" title="灵活图片"></a>灵活图片</h3><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>我们隔离不同的media是隔离的设备，给不同的设备一个区间。设置断点。</p><p><strong>rem</strong> 单位翻译为像素值是由html 元素的字体大小决定的。 此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位。 <strong>em</strong> 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位。</p><p>一般是200px为跨度</p><p>display无法用transaction做动画因为直接不显示了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1) Hide it visually */</span><br><span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 2) Make it unaccessible to mouse and keyboard */</span><br><span class="hljs-attribute">pointer-events</span>: none;<br><br><span class="hljs-comment">/* 3) Hide it from screen readers */</span><br><span class="hljs-attribute">visibility</span>: hidden;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器类别<br><br><span class="hljs-selector-id">#header</span>&#123;&#125;<br>&lt;!--匹配ID=&quot;<span class="hljs-selector-tag">header</span>&quot;的元素--&gt;<br><span class="hljs-selector-class">.header</span>&#123;&#125;<br>&lt;!--匹配class=&quot;<span class="hljs-selector-tag">header</span>&quot;的元素--&gt;<br><span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.logo</span>&#123;&#125;<br>&lt;!--匹配class=&quot;<span class="hljs-selector-tag">header</span>&quot;下，class=&quot;logo&quot;的元素，--&gt;<br><span class="hljs-selector-class">.header</span><span class="hljs-selector-class">.mobile</span>&#123;&#125;<br>&lt;!--匹配class=&quot;<span class="hljs-selector-tag">header</span> mobile&quot;的元素--&gt;<br><span class="hljs-selector-class">.header</span> <span class="hljs-selector-tag">p</span>, <span class="hljs-selector-class">.header</span> <span class="hljs-selector-tag">h3</span>&#123;&#125;<br>&lt;!--匹配class=&quot;<span class="hljs-selector-tag">header</span>&quot;下的<span class="hljs-selector-tag">P</span>元素和<span class="hljs-selector-tag">h3</span>元素。--&gt;<br><span class="hljs-selector-id">#header</span> <span class="hljs-selector-class">.nav</span>&gt;<span class="hljs-selector-tag">li</span>&#123;&#125;<br>&lt;!--匹配ID＝&quot;<span class="hljs-selector-tag">header</span>&quot;元素下，class=&quot;<span class="hljs-selector-tag">nav</span>&quot;元素的直接子元素<span class="hljs-selector-tag">li</span>。--&gt;<br><span class="hljs-selector-id">#header</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;&#125;<br>&lt;!--匹配ID=&quot;<span class="hljs-selector-tag">header</span>&quot;元素下，<span class="hljs-selector-tag">a</span>元素的伪类--&gt;````<br></code></pre></td></tr></table></figure><p>.nav-open .main-nav 等于是.nav-open 存在包裹的时候 .main-nav 才存在</p><p>通过 href 中的 </p>]]></content>
    
    
    <categories>
      
      <category>Front-End Engineer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Front-End Engineer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeTop</title>
    <link href="/2022/09/05/CodeTop/"/>
    <url>/2022/09/05/CodeTop/</url>
    
    <content type="html"><![CDATA[<h1 id="EASY"><a href="#EASY" class="headerlink" title="EASY"></a>EASY</h1><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> help(<span class="hljs-literal">nil</span>, head)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">help</span><span class="hljs-params">(pre, cur *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> cur == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> pre<br>    &#125;<br>    next := cur.Next<br>    cur.Next = pre<br>    <span class="hljs-keyword">return</span> help(cur, next)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="207-最大子序和"><a href="#207-最大子序和" class="headerlink" title="207. 最大子序和"></a>207. 最大子序和</h2><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p><p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    mx := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        dp[i] = max(dp[i<span class="hljs-number">-1</span>]+nums[i], nums[i])<br>        <span class="hljs-keyword">if</span> dp[i] &gt; mx &#123;<br>            mx = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mx<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>dp[i]只有两个方向可以推出来：</p><ul><li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li><li>nums[i]，即：从头开始计算当前连续子序列和</li></ul><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong><em>exactly\</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用map方式解题，降低时间复杂度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> index, val := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> preIndex, exist := m[target-val]; exist &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;preIndex, index&#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            m[val] = index<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h2><p>Given two non-negative integers, <code>num1</code> and <code>num2</code> represented as string, return <em>the sum of</em> <code>num1</code> <em>and</em> <code>num2</code> <em>as a string</em>.</p><p>You must solve the problem without using any built-in library for handling large integers (such as <code>BigInteger</code>). You must also not convert the inputs to integers directly.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addStrings</span><span class="hljs-params">(String num1, String num2)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(); <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> num1.length() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记遍历到 num1 的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> num2.length() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记遍历到 num2 的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span><br>        <span class="hljs-keyword">while</span> (p1 &gt;= <span class="hljs-number">0</span> || p2 &gt;= <span class="hljs-number">0</span> || carry != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// num1 没遍历完，或 num2 没遍历完，或进位不为 0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">digit1</span> <span class="hljs-operator">=</span> p1 &gt;= <span class="hljs-number">0</span> ? num1.charAt(p1) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前 num1 的取值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">digit2</span> <span class="hljs-operator">=</span> p2 &gt;= <span class="hljs-number">0</span> ? num2.charAt(p2) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前 num2 的取值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> digit1 + digit2 + carry; <span class="hljs-comment">// 当前位置相加的结果</span><br>            carry = add &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">// 是否有进位</span><br>            add = add &gt;= <span class="hljs-number">10</span> ? add - <span class="hljs-number">10</span> : add; <span class="hljs-comment">// 去除进位后留下的数字</span><br>            res.append(add); <span class="hljs-comment">// 把去除进位后留下的数字拼接到结果中</span><br>            p1 --; <span class="hljs-comment">// 遍历到 num1 的位置向左移动</span><br>            p2 --; <span class="hljs-comment">// 遍历到 num2 的位置向左移动</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res.reverse().toString(); <span class="hljs-comment">// 把结果反转并返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>「<strong>求加法</strong>」系列题目都不难，其实就是 <strong>「列竖式」</strong> 计算。</li><li>需要注意的是：<ol><li>while循环结束条件；</li><li>遍历两个「加数」不要越界；</li><li>进位。</li><li>最后的结果需要翻转</li></ol></li></ol><h2 id="121-最佳时间买卖股票"><a href="#121-最佳时间买卖股票" class="headerlink" title="121. 最佳时间买卖股票"></a>121. 最佳时间买卖股票</h2><p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p><p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 贪心</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    low := math.MaxInt32<br>    rlt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> prices&#123;<br>        low = min(low, prices[i])<br>        rlt = max(rlt, prices[i]-low)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> rlt<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>length:=<span class="hljs-built_in">len</span>(prices)<br><span class="hljs-keyword">if</span> length==<span class="hljs-number">0</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>dp:=<span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,length)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;length;i++&#123;<br>dp[i]=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">2</span>)<br>&#125;<br><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=-prices[<span class="hljs-number">0</span>]<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;length;i++&#123;<br>dp[i][<span class="hljs-number">0</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],-prices[i])<br>dp[i][<span class="hljs-number">1</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+prices[i])<br>&#125;<br><span class="hljs-keyword">return</span> dp[length<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a&gt;b&#123;<br>        <span class="hljs-keyword">return</span> a <br>    &#125;<br>    <span class="hljs-keyword">return</span> b <br>&#125;<br></code></pre></td></tr></table></figure><p>贪心就是找最小的做差</p><p>dp的方法就是用两个状态，买和卖，分别做推导，因为卖出状态有两个状态（前一天卖出和一直没买过）</p><p>如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</li><li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</li></ul><p>那么dp[i] [0]应该选所得现金最大的，所以dp[i] [0] = max(dp[i - 1] [0], -prices[i]);</p><p>如果第i天不持有股票即dp[i] [1]， 也可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</li><li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1] [0]</li></ul><p>细节：注意最后是用卖出的最后一天作为结果，因为卖出一定有更多的钱。</p><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code>exists, then return its index. Otherwise, return <code>-1</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l, r := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        mid := l + (r-l)&gt;&gt;<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>            r = mid<span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l = mid+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么l可以等于r呢？因为l=r可以满足一个当他为首位或者末尾的时候的结果，如果l &lt; r 就一个数字，那么l = 0， r = 0，你需要在里面再判断一下。</p><h2 id="94-二叉树中序遍历"><a href="#94-二叉树中序遍历" class="headerlink" title="94. 二叉树中序遍历"></a>94. 二叉树中序遍历</h2><p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// LNR</span><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    scan(root, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scan</span><span class="hljs-params">(root *TreeNode, res *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    <br>    scan(root.Left, res)<br>    *res = <span class="hljs-built_in">append</span>(*res, root.Val)<br>    scan(root.Right, res)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p><p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    max := <span class="hljs-number">0</span><br>    depth := <span class="hljs-number">1</span><br>    dfs(root, depth, &amp;max)<br>    <span class="hljs-keyword">return</span> max<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, depth <span class="hljs-type">int</span>, max *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> depth &gt; *max &#123;<br>            *max = depth<br>        &#125;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        depth += <span class="hljs-number">1</span><br>        dfs(root.Left, depth, max)<br>        depth -= <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        depth += <span class="hljs-number">1</span><br>        dfs(root.Right, depth, max)<br>        depth -= <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们需要知道所有分支末端的结果，所以采用dfs+回溯的手法获取所有末枝的结果。</p><h2 id="509-斐波那契数列"><a href="#509-斐波那契数列" class="headerlink" title="509. 斐波那契数列"></a>509. 斐波那契数列</h2><p>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">F(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>, F(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br>F(n) = F(n - <span class="hljs-number">1</span>) + F(n - <span class="hljs-number">2</span>), <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">1.</span><br></code></pre></td></tr></table></figure><p>Given <code>n</code>, calculate <code>F(n)</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// dp</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n+<span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]<br>    &#125;<br>    <span class="hljs-comment">// fmt.Println(dp)</span><br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br><br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;<br>    <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>最基本的dp和递归的展现</p><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> dfs(root)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    tmp := root.Right<br>    root.Right = dfs(root.Left)<br>    root.Left = dfs(tmp)<br>    <br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>重点在于用tmp暂时存储，要不会出现内存重叠导致的分支重复。</p><p>我们不需要考虑叶子结点，只要是nil返回就ok</p><h2 id="144-二叉树前序遍历"><a href="#144-二叉树前序遍历" class="headerlink" title="144. 二叉树前序遍历"></a>144. 二叉树前序遍历</h2><p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(root, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, arr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    *arr = <span class="hljs-built_in">append</span>(*arr, root.Val)<br>    dfs(root.Left, arr)<br>    dfs(root.Right, arr)<br>    <br>    <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="283-移动0"><a href="#283-移动0" class="headerlink" title="283. 移动0"></a>283. 移动0</h2><p>Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p><p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    slow := <span class="hljs-number">0</span><br>    fast := <span class="hljs-number">0</span><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">0</span> &#123;<br>            fast++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums[slow], nums[fast] = nums[fast], nums[slow]<br>            slow++<br>            fast++<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 简单版本</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    slow := <span class="hljs-number">0</span><br>    fast := <span class="hljs-number">0</span><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] != <span class="hljs-number">0</span> &#123;<br>            nums[slow], nums[fast] = nums[fast], nums[slow]<br>            slow++     <br>        &#125;<br>        fast++<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 究极简单版本</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    slow := <span class="hljs-number">0</span><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> fast := <span class="hljs-number">0</span>; fast &lt; n; fast++ &#123;<br>        <span class="hljs-keyword">if</span> nums[fast] != <span class="hljs-number">0</span> &#123;<br>            nums[slow], nums[fast] = nums[fast], nums[slow]<br>            slow++     <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>else里面都++是因为要保持slow和fast之间的差距，要让fast指向最新，slow指向第一个0的位置。</p><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p><p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" alt="img"></p><p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p><p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p><p><strong>Custom Judge:</strong></p><p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p><ul><li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li><li><code>listA</code> - The first linked list.</li><li><code>listB</code> - The second linked list.</li><li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li><li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li></ul><p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">//boundary check</span><br><span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> || headB == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>    <br>    curA := headA<br>curB := headB<br>    <br>    <span class="hljs-comment">//if a &amp; b have different len, then we will stop the loop after second iteration</span><br><span class="hljs-keyword">for</span> curA != curB &#123;<br><span class="hljs-comment">//for the end of first iteration, we just reset the pointer to the head of another linkedlist</span><br><span class="hljs-keyword">if</span> curA == <span class="hljs-literal">nil</span> &#123;<br>curA = headB<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>curA = curA.Next<br>&#125;<br><br><span class="hljs-keyword">if</span> curB == <span class="hljs-literal">nil</span> &#123;<br>curB = headA<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>curB = curB.Next<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> curA<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题的思路其实类似链表找环。</p><p>给定的 2 个链表的长度如果一样长，都从头往后扫即可。如果不一样长，需要先“拼成”一样长。把 B 拼接到 A 后面，把 A 拼接到 B 后面。这样 2 个链表的长度都是 A + B。再依次扫描比较 2 个链表的结点是否相同。</p><p>第二次迭代，重复了845，说白了就是如果不齐，就将头对齐变成尾部对齐。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] <span class="hljs-string">&quot; &quot;</span> [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] <span class="hljs-string">&quot; &quot;</span> [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>这种解法投机取巧，默认有一样的后面都相同。单纯的尾部对齐。</p><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>prefix := strs[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(strs); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(prefix); j++ &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(strs[i]) &lt;= j || strs[i][j] != prefix[j] &#123;<br>prefix = prefix[<span class="hljs-number">0</span>:j]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> prefix<br>&#125;<br></code></pre></td></tr></table></figure><p>默认第一个为前缀。如果第一个是长度最小的串，那么其他的串不影响只会从j被截断。如果是长度最长的，他会因为<code>len(strs[i]) &lt;= j</code>而截断。剩下截断prefix的方式，就是如果有串内的元素对应位置是不同于prefix的话，那么就踢出当前重复串中。</p><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> isMirror(root.Left, root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isMirror</span><span class="hljs-params">(left, right *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> (left.Val == right.Val) &amp;&amp; (isMirror(left.Left, right.Right)) &amp;&amp; (isMirror(left.Right, right.Left))<br>&#125;<br></code></pre></td></tr></table></figure><p>dfs的时候，先处理左右节点为空，或者有空的情况，再考虑左右节点的情况。说白了，confirm一下当前节点不为空，那么才可以深入，要不会出现空指针的情况。</p><h1 id="MIDDLE"><a href="#MIDDLE" class="headerlink" title="MIDDLE"></a>MIDDLE</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">var</span> freq [<span class="hljs-number">127</span>]<span class="hljs-type">int</span><br>result, left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span><br><br><span class="hljs-keyword">for</span> left &lt; <span class="hljs-built_in">len</span>(s) &#123;<br><span class="hljs-keyword">if</span> right+<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(s) &amp;&amp; freq[s[right+<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span> &#123;<br>freq[s[right+<span class="hljs-number">1</span>]]++<br>right++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>freq[s[left]]--<br>left++<br>&#125;<br>result = max(result, right-left+<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>滑动窗口的右边界不断的右移，只要没有重复的字符，就持续向右扩大窗口边界。一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界，然后继续移动滑动窗口的右边界。以此类推，每次移动需要计算当前长度，并判断是否需要更新最大长度，最终最大的值就是题目中的所求。</p><h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a>146. LRU缓存机制</h2><p>Design a data structure that follows the constraints of a <strong><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">Least Recently Used (LRU) cache</a></strong>.</p><p>Implement the <code>LRUCache</code> class:</p><ul><li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li><li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li><li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li></ul><p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>    Head, Tail *Node<br>    Keys       <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Node<br>    Cap        <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    Key, Val    <span class="hljs-type">int</span><br>    Prev, Next  *Node<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>    <span class="hljs-keyword">return</span> LRUCache&#123;Keys: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Node), Cap: capacity&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cache *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> node, ok := cache.Keys[key]; ok &#123;<br>        cache.Remove(node) <span class="hljs-comment">// 从队伍里面剔除</span><br>        cache.Add(node) <span class="hljs-comment">// 放到队尾，重新插入更新一下</span><br>        <span class="hljs-keyword">return</span> node.Val<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cache *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-keyword">if</span> node, ok := cache.Keys[key]; ok &#123;<br>node.Val = value <span class="hljs-comment">// 找到，更新key对应的value</span><br>cache.Remove(node)<br>cache.Add(node)<br><span class="hljs-keyword">return</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>node = &amp;Node&#123;Key: key, Val: value&#125; <span class="hljs-comment">// 创建一个新的节点</span><br>cache.Keys[key] = node <span class="hljs-comment">// 更新map</span><br>cache.Add(node) <span class="hljs-comment">// 插入队尾</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cache.Keys) &gt; cache.Cap &#123; <span class="hljs-comment">// 如果超过容量了</span><br><span class="hljs-built_in">delete</span>(cache.Keys, cache.Tail.Key) <span class="hljs-comment">// 删除map中对应的k-v</span><br>cache.Remove(cache.Tail) <span class="hljs-comment">// 删除队头的node</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cache *LRUCache)</span></span> Add(node *Node) &#123;<br>    node.Prev = <span class="hljs-literal">nil</span><br>    node.Next = cache.Head <span class="hljs-comment">// 左边是队尾，右边是队头</span><br>    <span class="hljs-keyword">if</span> cache.Head != <span class="hljs-literal">nil</span> &#123;<br>        cache.Head.Prev = node <span class="hljs-comment">// Prev在右边，Next在左边</span><br>    &#125;<br>    cache.Head = node <span class="hljs-comment">// 更新head</span><br>    <br>    <span class="hljs-keyword">if</span> cache.Tail == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 当存储为空的时候，才如此更新，保证Tail有值，后续才好插入。</span><br>        cache.Tail = node<br>        cache.Tail.Next = <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cache *LRUCache)</span></span> Remove(node *Node) &#123;<br>    <span class="hljs-keyword">if</span> node == cache.Head &#123; <span class="hljs-comment">// 如果要移除的节点在Head（右边）</span><br>        cache.Head = node.Next <br>        node.Next = <span class="hljs-literal">nil</span> <br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> node == cache.Tail &#123; <span class="hljs-comment">// 如果要移除的节点在Tail（左边）</span><br>        cache.Tail = node.Prev<br>        node.Prev.Next = <span class="hljs-literal">nil</span><br>        node.Prev = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    node.Prev.Next = node.Next<br>    node.Next.Prev = node.Prev<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(capacity);</span><br><span class="hljs-comment"> * param_1 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>主体结构就是map来做查询，双向链表来存储。</p><p>GET PUT方法中包含，add和remove，add都是对尾部的增加，remove都是对头部的剔除</p><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>largest element in the array</em>.</p><p>Note that it is the <code>kth</code> largest element in the sorted order, not the <code>kth</code> distinct element.</p><p>You must solve it in <code>O(n)</code> time complexity.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sort.Ints(nums)<br>  <span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">len</span>(nums)-k]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p><p>Notice that the solution set must not contain duplicate triplets.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>[][]<span class="hljs-type">int</span>&#123;<br>sort.Ints(nums)<br>res:=[][]<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>;i++&#123;<br>n1:=nums[i]<br><span class="hljs-keyword">if</span> n1&gt;<span class="hljs-number">0</span>&#123; <span class="hljs-comment">// 排序后如果第一个元素已经大于0后面都没有意义了</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span>&amp;&amp;n1==nums[i<span class="hljs-number">-1</span>]&#123; <span class="hljs-comment">// 如果当前位和前一位是一样的，代表重复，如果和后面的一样的话等于是a不给b选择的机会了</span><br><span class="hljs-keyword">continue</span><br>&#125;<br>l,r:=i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> l&lt;r&#123;<br>n2,n3:=nums[l],nums[r]<br><span class="hljs-keyword">if</span> n1+n2+n3==<span class="hljs-number">0</span>&#123;<br>res=<span class="hljs-built_in">append</span>(res,[]<span class="hljs-type">int</span>&#123;n1,n2,n3&#125;)<br><span class="hljs-keyword">for</span> l&lt;r&amp;&amp;nums[l]==n2&#123; <span class="hljs-comment">// 一直往后找找到不一样为止</span><br>l++<br>&#125;<br><span class="hljs-keyword">for</span> l&lt;r&amp;&amp;nums[r]==n3&#123; <span class="hljs-comment">// 一直往前找找到不一样为止</span><br>r--<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n1+n2+n3&lt;<span class="hljs-number">0</span>&#123;<br>l++<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>r--<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>去重逻辑的思考</strong></p><p><strong>a的去重</strong></p><p>说道去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]</p><p>a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。</p><p>但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。</p><p>有同学可能想，这不都一样吗。</p><p>其实不一样！</p><p>都是和 nums[i]进行比较，是比较它的前一个，还是比较他的后一个。</p><p>如果我们的写法是 这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重操作</span><br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那就我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p><p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p><p>所以这里是有两个重复的维度。</p><p>那么应该这么写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。</p><p>这是一个非常细节的思考过程。</p><h2 id="912-快速排序"><a href="#912-快速排序" class="headerlink" title="912. 快速排序"></a>912. 快速排序</h2><p>Given an array of integers <code>nums</code>, sort the array in ascending order.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quick</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, start, end <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> start &lt; end &#123; <br>        pivot := nums[start]<br>        i, j := start + <span class="hljs-number">1</span>, end<br>        <br>        <span class="hljs-keyword">for</span> i &lt;= j &#123;<br>            <span class="hljs-keyword">if</span> nums[i] &lt;= pivot &#123; <span class="hljs-comment">// left smaller then the pivot, continue</span><br>                i++<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[j] &gt;= pivot &#123; <span class="hljs-comment">// right bigger than the pivot, continue</span><br>                j--<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums[j], nums[i] = nums[i], nums[j]<br>                j--<br>                i++<br>            &#125;<br>        &#125;<br>        <br>        nums[j], nums[start] = nums[start], nums[j] <span class="hljs-comment">// i meet j, then exchange</span><br>        <br>        quick(nums, start, j - <span class="hljs-number">1</span>)<br>        quick(nums, j + <span class="hljs-number">1</span>, end)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    quick(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> nums<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 交换的新写法</span><br>a := <span class="hljs-number">0</span><br>b := <span class="hljs-number">1</span><br>a, b = b, a<br></code></pre></td></tr></table></figure><ol><li>找到标兵</li><li>排序，要求左边都比标兵小，右边都比标兵大，交换</li><li>递归下一层，直到start和end相遇</li></ol><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 解法一 BFS</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br>queue := []*TreeNode&#123;root&#125;<br>res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>l := <span class="hljs-built_in">len</span>(queue)<br>tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, l)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l; i++ &#123;<br>            node := queue[i]<br><span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>&#125;<br><span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>&#125;<br>tmp = <span class="hljs-built_in">append</span>(tmp, queue[i].Val)<br>&#125;<br>queue = queue[l:]<br>res = <span class="hljs-built_in">append</span>(res, tmp)<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>队列不为空</li><li>用一个循环清空队列弄好新的队列</li><li>直到所有的队列清空，结束</li></ol><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h2><p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong>values).</p><p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p><p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>low, high := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> low &lt;= high &#123;<br>mid := low + (high-low)&gt;&gt;<span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> nums[mid] == target &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; nums[low] &#123; <span class="hljs-comment">// 在数值大的一部分区间里</span><br><span class="hljs-keyword">if</span> nums[low] &lt;= target &amp;&amp; target &lt; nums[mid] &#123;<br>high = mid - <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>low = mid + <span class="hljs-number">1</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; nums[high] &#123; <span class="hljs-comment">// 在数值小的一部分区间里</span><br><span class="hljs-keyword">if</span> nums[mid] &lt; target &amp;&amp; target &lt;= nums[high] &#123;<br>low = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>high = mid - <span class="hljs-number">1</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果落在了low或者high上，low右移，high左移</span><br><span class="hljs-keyword">if</span> nums[low] == nums[mid] &#123;<br>low++<br>&#125;<br><span class="hljs-keyword">if</span> nums[high] == nums[mid] &#123;<br>high--<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个和普通的二分查找有什么不一样呢？</p><p>因为二分的前提是本身有序，所以这个相当于用一个断点打乱了你的排序。你需要做的就是识别这个断点，由于要求O(logN)所以说不能先找到，而是要在查找的过程中识别断点。</p><p>左边一定比右边的大，然后low代表的大区域，high代表小区域</p><h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a>165. 比较版本号</h2><p>Given two version numbers, <code>version1</code> and <code>version2</code>, compare them.</p><p>Version numbers consist of <strong>one or more revisions</strong> joined by a dot <code>&#39;.&#39;</code>. Each revision consists of <strong>digits</strong> and may contain leading <strong>zeros</strong>. Every revision contains <strong>at least one character</strong>. Revisions are <strong>0-indexed from left to right</strong>, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example <code>2.5.33</code> and <code>0.1</code> are valid version numbers.</p><p>To compare version numbers, compare their revisions in <strong>left-to-right order</strong>. Revisions are compared using their <strong>integer value ignoring any leading zeros</strong>. This means that revisions <code>1</code> and <code>001</code> are considered <strong>equal</strong>. If a version number does not specify a revision at an index, then <strong>treat the revision as <code>0</code></strong>. For example, version <code>1.0</code> is less than version <code>1.1</code> because their revision 0s are the same, but their revision 1s are <code>0</code> and <code>1</code> respectively, and <code>0 &lt; 1</code>.</p><p><em>Return the following:</em></p><ul><li>If <code>version1 &lt; version2</code>, return <code>-1</code>.</li><li>If <code>version1 &gt; version2</code>, return <code>1</code>.</li><li>Otherwise, return <code>0</code>.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>x, y, i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span><br><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(version1) || j &lt; <span class="hljs-built_in">len</span>(version2) &#123;<br>x, i = readInt(version1, i+<span class="hljs-number">1</span>)<br>y, j = readInt(version2, j+<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> x &lt; y:<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br><span class="hljs-keyword">case</span> y &lt; x:<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readInt</span><span class="hljs-params">(s <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>result := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; index &lt; <span class="hljs-built_in">len</span>(s) &amp;&amp; s[index] != <span class="hljs-string">&#x27;.&#x27;</span>; index++ &#123;<br>result = result*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(s[index]-<span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">return</span> result, index<br>&#125;<br></code></pre></td></tr></table></figure><p>我们要分区的思考这个问题，先找到对应的区域。<code>int(s[index]-&#39;0&#39;)</code>来转换成int，如果是英文字母的话就用<code>-&#39;a&#39;</code>来转换。这样我们对于数据的处理就是，比如12.04就是1*10 + 2，如果1的位置是0的话，则不会成为整数。</p><p>我们readInt函数有两个作用，一个是找到对应区间的数的整数，第二个作用是找到对应的下一个出发的index。我们不用对应位去比较，而是全部提出来然后直接比整数的大小。</p><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    used := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>    dfs(used, c, nums, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(used <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, c, nums []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> ok, _ := used[nums[i]]; ok &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            used[nums[i]] = <span class="hljs-literal">true</span><br>            c = <span class="hljs-built_in">append</span>(c, nums[i])<br>            dfs(used, c, nums, res)<br>            used[nums[i]] = <span class="hljs-literal">false</span><br>            c = c[:<span class="hljs-built_in">len</span>(c)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先把所有的情况都写出来，再慢慢减枝</p><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.</p><p>A string is called a palindrome string if the reverse of that string is the same as the original string.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    max := <span class="hljs-number">0</span><br>    left := <span class="hljs-number">0</span><br>    length := <span class="hljs-number">0</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(s))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(s))<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; <span class="hljs-built_in">len</span>(s); j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                <span class="hljs-keyword">if</span> j-i &lt;= <span class="hljs-number">1</span> &#123;<br>                    length = j-i<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] &#123;<br>                    length = j-i<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> length &gt; max &#123;<br>                max = length<br>                left = i<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s[left:left+max+<span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>返回主要靠记录起点和长度的结合。</p><p>不想等的情况肯定是不能匹配，想等的时候分三种情况，如果相差相遇等于1直接就是ok的，如果是大于的话就由他前一个状态推导出来。</p><h2 id="129-求根到叶子结点数字之和"><a href="#129-求根到叶子结点数字之和" class="headerlink" title="129. 求根到叶子结点数字之和"></a>129. 求根到叶子结点数字之和</h2><p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p><p>Each root-to-leaf path in the tree represents a number.</p><ul><li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li></ul><p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p><p>A <strong>leaf</strong> node is a node with no children.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// solution1</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    dfs(root, root.Val, &amp;sum)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, tmp <span class="hljs-type">int</span>, sum *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        *sum += tmp<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        tmp = tmp*<span class="hljs-number">10</span> + root.Left.Val<br>        dfs(root.Left, tmp, sum)<br>        tmp = (tmp-root.Left.Val)/<span class="hljs-number">10</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        tmp = tmp*<span class="hljs-number">10</span> + root.Right.Val<br>        dfs(root.Right, tmp, sum)<br>        tmp = (tmp-root.Right.Val)/<span class="hljs-number">10</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// solution2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    dfs(root, root.Val, &amp;sum)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, tmpSum <span class="hljs-type">int</span>, sum *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        *sum += tmpSum<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>            dfs(root.Left, tmpSum*<span class="hljs-number">10</span> + root.Left.Val, sum)<br>        &#125;<br>        <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>            dfs(root.Right, tmpSum*<span class="hljs-number">10</span> + root.Right.Val, sum)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我这里是写成了回溯，其实是写麻烦了，并不需要回溯，我只需要知道顺着下来以后的分支总和是多少就ok。</p><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p><p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    result := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> grid &#123;<br>        <span class="hljs-keyword">for</span> j, value := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> value == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                visit(&amp;grid, i, j)<br>                result += <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">visit</span><span class="hljs-params">(grid *[][]<span class="hljs-type">byte</span>, i <span class="hljs-type">int</span>, j <span class="hljs-type">int</span>)</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(*grid), <span class="hljs-built_in">len</span>((*grid)[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) || (i &gt;= m) || (j &lt; <span class="hljs-number">0</span>) || (j &gt;= n) || ((*grid)[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    (*grid)[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>    <br>    visit(grid, i<span class="hljs-number">-1</span>, j)<br>    visit(grid, i+<span class="hljs-number">1</span>, j)<br>    visit(grid, i, j<span class="hljs-number">-1</span>)<br>    visit(grid, i, j+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>要求找出地图中的孤岛。孤岛的含义是四周被海水包围的岛。</li><li>这一题可以按照第 79 题的思路进行搜索，只要找到为 “1” 的岛以后，从这里开始搜索这周连通的陆地，也都标识上访问过。每次遇到新的 “1” 且没有访问过，就相当于遇到了新的岛屿了。</li></ul><p>DFS的题</p><p>两种思路，上述思路是直接将海岛变成海水，还有一个思路就是标记浏览过哪个。</p><p>相当于我进入一个岛屿，只要他是岛屿我就感染他变成，海水。这样剩下的大循环去找也不能发现多余的岛屿了。一种类似于感染的思想。</p><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h2><p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spiralOrder</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(matrix)<br>    n := <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    idx, sum := <span class="hljs-number">0</span>, m*n<br>    arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m*n)<br>    <br>    top := <span class="hljs-number">0</span><br>    bottom := m<span class="hljs-number">-1</span><br>    left := <span class="hljs-number">0</span><br>    right := n<span class="hljs-number">-1</span><br>    <br>    <span class="hljs-keyword">for</span> idx &lt; sum &#123;<br>        <span class="hljs-keyword">for</span> i := left; i &lt;= right &amp;&amp; idx &lt; sum; i++ &#123;<br>            arr[idx] = matrix[top][i]<br>            idx++<br>        &#125;<br>        top++<br><br>        <span class="hljs-keyword">for</span> i := top; i &lt;= bottom &amp;&amp; idx &lt; sum; i++ &#123;<br>            arr[idx] = matrix[i][right]<br>            idx++<br>        &#125;<br>        right--<br><br>        <span class="hljs-keyword">for</span> i := right; i &gt;= left &amp;&amp; idx &lt; sum; i-- &#123;<br>            arr[idx] = matrix[bottom][i]<br>            idx++<br>        &#125;<br>        bottom--<br><br>        <span class="hljs-keyword">for</span> i := bottom; i &gt;= top &amp;&amp; idx &lt; sum; i-- &#123;<br>            arr[idx] = matrix[i][left]<br>            idx++<br>        &#125;<br>        left++<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><p>注意循环的区间一定要：有idx&lt;sum防止，加完idx还往后继续走。所以外层一个判断，内层一个判断。</p><h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h2><p>Given an integer array <code>nums</code>, return the length of the longest strictly increasing subsequence.</p><p>A <strong>subsequence</strong> is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, <code>[3,6,2,7]</code> is a subsequence of the array <code>[0,3,1,6,2,2,7]</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划求解</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// dp数组的定义 dp[i]表示取第i个元素的时候，表示子序列的长度，其中包括 nums[i] 这个元素</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br><br>    <span class="hljs-comment">// 初始化，所有的元素都应该初始化为1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-number">1</span><br>    &#125;<br><br>    ans := dp[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[j] &#123;<br>                dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> dp[i] &gt; ans &#123;<br>            ans = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>    &#125;<br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br>    dfs(n, n, <span class="hljs-string">&quot;&quot;</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(lindex, rindex <span class="hljs-type">int</span>, str <span class="hljs-type">string</span>, res *[]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> lindex == <span class="hljs-number">0</span> &amp;&amp; rindex == <span class="hljs-number">0</span> &#123;<br>        *res = <span class="hljs-built_in">append</span>(*res, str)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> lindex &gt; <span class="hljs-number">0</span> &#123;<br>        dfs(lindex<span class="hljs-number">-1</span>, rindex, str+<span class="hljs-string">&quot;(&quot;</span>, res)<br>    &#125;<br>    <span class="hljs-keyword">if</span> rindex &gt; <span class="hljs-number">0</span> &amp;&amp; lindex &lt; rindex &#123;<br>        dfs(lindex, rindex<span class="hljs-number">-1</span>, str+<span class="hljs-string">&quot;)&quot;</span>, res)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的思路是dfs，因为是个组合问题，现在着眼于这么实现呢？我们设定lindex和rindex作为左右括号的储备库，然后进行匹配，只要库里面还有储备就排列进去，然后注意右括号一定是在左括号小于左括号数量的时候进行匹配，要不然会出现左括号不匹配右括号的。</p><h2 id="19-删除倒数第k个节点"><a href="#19-删除倒数第k个节点" class="headerlink" title="19. 删除倒数第k个节点"></a>19. 删除倒数第k个节点</h2><p>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>fakeHead := &amp;ListNode&#123;Next: head&#125;<br>preSlow, slow, fast := fakeHead, head, head<br><span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> &#123;<br>preSlow = slow<br>slow = slow.Next<br>&#125;<br>n--<br>fast = fast.Next<br>&#125;<br>preSlow.Next = slow.Next<br><span class="hljs-keyword">return</span> fakeHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题比较简单，先循环一次拿到链表的总长度，然后循环到要删除的结点的前一个结点开始删除操作。需要注意的一个特例是，有可能要删除头结点，要单独处理。</p><p>这道题有一种特别简单的解法。设置 2 个指针，一个指针距离前一个指针 n 个距离。同时移动 2 个指针，2 个指针都移动相同的距离。当一个指针移动到了终点，那么前一个指针就是倒数第 n 个节点了。</p><h2 id="322-零钱交换"><a href="#322-零钱交换" class="headerlink" title="322. 零钱交换"></a>322. 零钱交换</h2><p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p><p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p><p>You may assume that you have an infinite number of each kind of coin.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 初始化dp[0]</span><br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-comment">// 遍历背包,从1开始</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= amount; j++ &#123;<br><span class="hljs-comment">// 初始化为math.MaxInt32</span><br>dp[j] = math.MaxInt32<br><span class="hljs-comment">// 遍历物品</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(coins); i++ &#123;<br><span class="hljs-keyword">if</span> j &gt;= coins[i]&#123;<br><span class="hljs-comment">// 推导公式</span><br>dp[j] = min(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 没找到能装满背包的, 就返回-1</span><br><span class="hljs-keyword">if</span> dp[amount] == math.MaxInt32 &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化为amount+1是因为是从0开始算的，但是最终背包的容量是amount</p><p>遍历物品放入背包中，只要是当前的币值没有大于最终amount就可以有资格放入（因为我们追求更大的币值，更少的币数）。这时进行递推两种状态，状态一：不放入币；状态二：放入币（找前一个状态），我们尽可能放入更少的硬币满足当前的币值。最终迭代到最后，发现只要dp[amount]==math.MaxInt32的话，那么代表他没有被更新，代表容量并没有被装满肯定是错误的返回-1。</p><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p>Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//先从小到大排序</span><br>    sort.Slice(intervals,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>]&lt;intervals[j][<span class="hljs-number">0</span>]<br>    &#125;)<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-comment">//再弄重复的</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(intervals)<span class="hljs-number">-1</span>;i++&#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">1</span>]&gt;=intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&#123;<br>            intervals[i][<span class="hljs-number">1</span>]=max(intervals[i][<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<span class="hljs-comment">//赋值最大值</span><br>            intervals=<span class="hljs-built_in">append</span>(intervals[:i+<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">2</span>:]...)<br>            i--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> intervals<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a&gt;b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>1、先将区间按照左起点的顺序排序。</p><p>2、从第一个区间开始遍历，如果前者的右边界大于等于了后者的左边界，那就可以进行合并。将前者的右边界更新为（前者右边界或后者后边界的最大值）。</p><p>3、剔除后者区间（让前者append上后者的后者），再i—归档</p><h2 id="695-最大岛屿数量"><a href="#695-最大岛屿数量" class="headerlink" title="695. 最大岛屿数量"></a>695. 最大岛屿数量</h2><p>You are given an <code>m x n</code> binary matrix <code>grid</code>. An island is a group of <code>1</code>‘s (representing land) connected <strong>4-directionally</strong> (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p><p>The <strong>area</strong> of an island is the number of cells with a value <code>1</code> in the island.</p><p>Return <em>the maximum <strong>area</strong> of an island in</em> <code>grid</code>. If there is no island, return <code>0</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> grid &#123;<br>        <span class="hljs-keyword">for</span> j, value := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> value == <span class="hljs-number">1</span> &#123;<br>                count := <span class="hljs-number">0</span><br>                dfs(&amp;grid, &amp;count, &amp;res, i, j)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid *[][]<span class="hljs-type">int</span>, count, res *<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(*grid), <span class="hljs-built_in">len</span>((*grid)[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) || (i &gt;= m) || (j &lt; <span class="hljs-number">0</span>) || (j &gt;= n) || ((*grid)[i][j] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    (*grid)[i][j] = <span class="hljs-number">0</span><br>    *count++<br>    <span class="hljs-keyword">if</span> *count &gt; *res &#123;*res = *count&#125;<br>    <br>    dfs(grid, count, res, i+<span class="hljs-number">1</span>, j)<br>    dfs(grid, count, res, i<span class="hljs-number">-1</span>, j)<br>    dfs(grid, count, res, i, j+<span class="hljs-number">1</span>)<br>    dfs(grid, count, res, i, j<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这一题和第 200 题，第 1254 题解题思路是一致的。DPS 深搜。这不过这一题需要多处理 2 件事情，一个是注意靠边缘的岛屿不能计算在内，二是动态维护岛屿的最大面积。</li><li>注意count一定要是指针，要不然当他有两个分支的时候count不是累加而是单纯的增加一</li></ul><h2 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a>103. 二叉树的锯齿形层次遍历</h2><p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes’ values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;&#125;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    queue := []*TreeNode&#123;root&#125;<br>    flag := <span class="hljs-literal">true</span> <span class="hljs-comment">// flag true = l to r, flag false = r to l</span><br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        l := <span class="hljs-built_in">len</span>(queue)<br>tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, l)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l; i++ &#123;<br>            node := queue[i]<br><span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>&#125;<br><span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>&#125;<br>            <span class="hljs-keyword">if</span> flag &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, queue[i].Val)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, queue[l-i<span class="hljs-number">-1</span>].Val)<br>            &#125;<br>&#125;<br>queue = queue[l:]<br>    flag =!flag<br>res = <span class="hljs-built_in">append</span>(res, tmp)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>之前顺序弄的不好，想的是反向放入，其实反向提取更好理解。</p><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h2><p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(target <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>left, sum, res := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> right, v := <span class="hljs-keyword">range</span> nums &#123;<br>sum += v<br><span class="hljs-keyword">for</span> sum &gt;= target &#123;<br>res = min(res, right-left+<span class="hljs-number">1</span>)<br>sum -= nums[left]<br>left++<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> res == <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><p>滑动窗口思想，排好序列的，还有连续子序列的都考虑滑动窗口。</p><h2 id="718-最长重复子序列"><a href="#718-最长重复子序列" class="headerlink" title="718. 最长重复子序列"></a>718. 最长重复子序列</h2><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>the maximum length of a subarray that appears in <strong>both</strong> arrays</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLength</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(nums1)<br>    n := <span class="hljs-built_in">len</span>(nums2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> dp[i][j] &gt; res &#123;<br>                res = dp[i][j]<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//fmt.Println(dp[i][1:])</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>根据dp[i] [j]的定义，dp[i] [j]的状态只能由dp[i - 1] [j - 1]推导出来。</p><p>即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] = dp[i - 1] [j - 1] + 1;</p><p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p><h2 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384. 打乱数组"></a>384. 打乱数组</h2><p>Given an integer array <code>nums</code>, design an algorithm to randomly shuffle the array. All permutations of the array should be <strong>equally likely</strong> as a result of the shuffling.</p><p>Implement the <code>Solution</code> class:</p><ul><li><code>Solution(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li><li><code>int[] reset()</code> Resets the array to its original configuration and returns it.</li><li><code>int[] shuffle()</code> Returns a random shuffling of the array.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Solution <span class="hljs-keyword">struct</span> &#123;<br>    nums []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> Solution &#123;<br>    <span class="hljs-keyword">return</span> Solution&#123;<br>nums: nums,<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Solution)</span></span> Reset() []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.nums<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Solution)</span></span> Shuffle() []<span class="hljs-type">int</span> &#123;<br>  arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(this.nums))<br><span class="hljs-built_in">copy</span>(arr, this.nums)<br>rand.Shuffle(<span class="hljs-built_in">len</span>(arr), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>arr[i], arr[j] = arr[j], arr[i]<br>&#125;)<br><span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><p>利用rand.Shuffle()函数。</p><p>用copy复制新空间的数组，不会破坏本身对象自己的数组。</p><h2 id="62-独一无二的路径"><a href="#62-独一无二的路径" class="headerlink" title="62. 独一无二的路径"></a>62. 独一无二的路径</h2><p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>&#125;<br>    <br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>只能向下后或者向右，所以初始化希望是纵列和横列全都初始化为1</p><p>当前位置就是由上一个状态推出来的，并且上一个状态都来自于上边或者左边。</p><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a>93. 复原IP地址</h2><p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p><ul><li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li></ul><p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into</em> <code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>&#125;<br>res, ip := []<span class="hljs-type">string</span>&#123;&#125;, []<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ip, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s <span class="hljs-type">string</span>, start, cut <span class="hljs-type">int</span>, ip []<span class="hljs-type">int</span>, res *[]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> cut == <span class="hljs-number">4</span> &amp;&amp; start == <span class="hljs-built_in">len</span>(s) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ip))<br>        <span class="hljs-built_in">copy</span>(tmp, ip)<br>        resIp := getIp(tmp)<br>        *res = <span class="hljs-built_in">append</span>(*res, resIp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> cut &gt; <span class="hljs-number">4</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        sub := s[start : i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> isValid(sub) &#123;<br>            tmp, _ := strconv.Atoi(sub)<br>            ip = <span class="hljs-built_in">append</span>(ip, tmp)<br>            cut++<br>            dfs(s, i + <span class="hljs-number">1</span>, cut, ip, res)<br>            ip = ip[:<span class="hljs-built_in">len</span>(ip) - <span class="hljs-number">1</span>]<br>            cut--<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; <span class="hljs-built_in">len</span>(s) != <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 0开头的不可以</span><br>    tmp, _ := strconv.Atoi(s)<br>    <span class="hljs-keyword">if</span> (tmp &gt; <span class="hljs-number">255</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIp</span><span class="hljs-params">(ip []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    resIp := strconv.Itoa(ip[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(ip); i++ &#123;<br>resIp += <span class="hljs-string">&quot;.&quot;</span> + strconv.Itoa(ip[i])<br>&#125;<br><span class="hljs-keyword">return</span> resIp<br>&#125;<br></code></pre></td></tr></table></figure><p>getIp函数用来组装ip</p><p>isValid用来校验是否合法（开头不能是0，并且不能大于255）</p><p>合法并且总共遍历完成了就算是一个结果，每次存的都是一个数。</p><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><p>Implement the <code>MinStack</code> class:</p><ul><li><code>MinStack()</code> initializes the stack object.</li><li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li><li><code>void pop()</code> removes the element on the top of the stack.</li><li><code>int top()</code> gets the top element of the stack.</li><li><code>int getMin()</code> retrieves the minimum element in the stack.</li></ul><p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MinStack define</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>elements, min []<span class="hljs-type">int</span><br>l             <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">/** initialize your data structure here. */</span><br><br><span class="hljs-comment">// Constructor define</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br><span class="hljs-keyword">return</span> MinStack&#123;<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// Push define</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>this.elements = <span class="hljs-built_in">append</span>(this.elements, x)<br><span class="hljs-keyword">if</span> this.l == <span class="hljs-number">0</span> &#123;<br>this.min = <span class="hljs-built_in">append</span>(this.min, x)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>min := this.GetMin()<br><span class="hljs-keyword">if</span> x &lt; min &#123;<br>this.min = <span class="hljs-built_in">append</span>(this.min, x)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>this.min = <span class="hljs-built_in">append</span>(this.min, min)<br>&#125;<br>&#125;<br>this.l++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop() &#123;<br>this.l--<br>this.min = this.min[:this.l]<br>this.elements = this.elements[:this.l]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> this.elements[this.l<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> this.min[this.l<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>只是加入了最小值属性的栈。</p><p>为什么一定要用min的数组呢，是为了pop函数而考虑的，因为你pop以后如果min是当前弹出的数值，那么你的min就错误了，所以保证min弹出以后还是有替补的，就需要有个min数组保证替补。min记录的是当前数值进入时候的最小值状态，所以可以实现。</p><h2 id="105-从前序与中序遍历序列构建二叉树"><a href="#105-从前序与中序遍历序列构建二叉树" class="headerlink" title="105. 从前序与中序遍历序列构建二叉树"></a>105. 从前序与中序遍历序列构建二叉树</h2><p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// preorder N L R</span><br><span class="hljs-comment">// inorder  L N R</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    root := &amp;TreeNode&#123;Val: preorder[<span class="hljs-number">0</span>]&#125;<br>    <span class="hljs-keyword">for</span> pos, node := <span class="hljs-keyword">range</span> inorder &#123;<br><span class="hljs-keyword">if</span> node == root.Val &#123; <span class="hljs-comment">// 找到inorder中的 L N R 中的N，从他的左右分开，进行递归进入深一层。</span><br>root.Left = buildTree(preorder[<span class="hljs-number">1</span>:pos+<span class="hljs-number">1</span>], inorder[:pos])<br>root.Right = buildTree(preorder[pos+<span class="hljs-number">1</span>:], inorder[pos+<span class="hljs-number">1</span>:])<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>preorder要从1开始因为N已经被我提取出来了。</p><p>核心就是N就是同一个N</p><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;<br>fakehead := &amp;ListNode&#123;Val: <span class="hljs-number">0</span>&#125;<br>n1, n2, carry, current := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, fakehead<br><span class="hljs-keyword">for</span> l1 != <span class="hljs-literal">nil</span> || l2 != <span class="hljs-literal">nil</span> || carry != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> l1 == <span class="hljs-literal">nil</span> &#123;<br>n1 = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>n1 = l1.Val<br>l1 = l1.Next<br>&#125;<br><span class="hljs-keyword">if</span> l2 == <span class="hljs-literal">nil</span> &#123;<br>n2 = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>n2 = l2.Val<br>l2 = l2.Next<br>&#125;<br>current.Next = &amp;ListNode&#123;Val: (n1 + n2 + carry) % <span class="hljs-number">10</span>&#125; <span class="hljs-comment">// 获取个位</span><br>current = current.Next<br>carry = (n1 + n2 + carry) / <span class="hljs-number">10</span> <span class="hljs-comment">// 获取进位</span><br>&#125;<br><span class="hljs-keyword">return</span> fakehead.Next<br>&#125;<br></code></pre></td></tr></table></figure><p>为了处理方法统一，可以先建立一个虚拟头结点，这个虚拟头结点的 Next 指向真正的 head，这样 head 不需要单独处理，直接 while 循环即可。另外判断循环终止的条件不用是 p.Next ！= nil，这样最后一位还需要额外计算，循环终止条件应该是 p != nil。</p><p>负负得正，只是加法方向从左往右走了。</p><h2 id="64-最短路径和"><a href="#64-最短路径和" class="headerlink" title="64. 最短路径和"></a>64. 最短路径和</h2><p>Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p><p><strong>Note:</strong> You can only move either down or right at any point in time.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 解法一 原地 DP，无辅助空间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>grid[i][<span class="hljs-number">0</span>] += grid[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]<br>&#125;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>grid[<span class="hljs-number">0</span>][j] += grid[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>]<br>&#125;<br>  <br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>grid[i][j] += min(grid[i<span class="hljs-number">-1</span>][j], grid[i][j<span class="hljs-number">-1</span>])<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>不能用dfs的枚举法要不然会报错，超时。只能用dp来减少重复路径的计算。</p><h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h2><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p><p><strong>Note:</strong> You must not use any built-in BigInteger library or convert the inputs to integer directly.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiply</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span><br>&#125;<br>b1, b2, tmp := []<span class="hljs-type">byte</span>(num1), []<span class="hljs-type">byte</span>(num2), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(num1)+<span class="hljs-built_in">len</span>(num2))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(b1); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(b2); j++ &#123;<br>tmp[i+j+<span class="hljs-number">1</span>] += <span class="hljs-type">int</span>(b1[i]-<span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-type">int</span>(b2[j]-<span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-comment">//fmt.Println(tmp)</span><br>&#125;<br>&#125;<br>    <span class="hljs-comment">//fmt.Println()</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(tmp) - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>tmp[i<span class="hljs-number">-1</span>] += tmp[i] / <span class="hljs-number">10</span><br>tmp[i] = tmp[i] % <span class="hljs-number">10</span><br>        <span class="hljs-comment">//fmt.Println(tmp)</span><br>&#125;<br>  <span class="hljs-comment">// 消除最高位没有进位的情况。</span><br><span class="hljs-keyword">if</span> tmp[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &#123;<br>tmp = tmp[<span class="hljs-number">1</span>:]<br>&#125;<br>  <span class="hljs-comment">// int 转 byte</span><br>res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(tmp))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmp); i++ &#123;<br>res[i] = <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-type">byte</span>(tmp[i])<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(res)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用数组模拟乘法。创建一个数组长度为 <code>len(num1) + len(num2)</code> 的数组用于存储乘积。对于任意 <code>0 ≤ i &lt; len(num1)</code>，<code>0 ≤ j &lt; len(num2)</code>，<code>num1[i] * num2[j]</code> 的结果位于 <code>tmp[i+j+1]</code>，如果 <code>tmp[i+j+1]≥10</code>，则将进位部分加到 <code>tmp[i+j]</code>。最后，将数组 <code>tmp</code> 转成字符串，如果最高位是 0 则舍弃最高位。</li></ul><p>首先经过测试</p><p>[0 81 162 243 170 1]<br>[0 81 162 260 0 1]<br>[0 81 188 0 0 1]<br>[0 99 8 0 0 1]<br>[9 9 8 0 0 1]</p><p>999 <em> 999 最高只是998001，所以说不会出现最高位超过10的情况。长度定为 len(num1) + len(num2) 也是经过测试的最高长度。如果是100 </em> 100 最低位也得有 len(num1) + len(num2) - 1个有效位。</p><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h2><p>You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p><p>You have to rotate the image <strong>in-place</strong>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span>  &#123;<br>    length := <span class="hljs-built_in">len</span>(matrix)<br>    <span class="hljs-comment">// rotate by diagonal 对角线变换</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; length; j++ &#123;<br>matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// rotate by vertical centerline 竖直轴对称翻转</span><br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; (length/<span class="hljs-number">2</span>); col++ &#123;<br>        <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; length; row++ &#123;<br>            matrix[row][col], matrix[row][length-col<span class="hljs-number">-1</span>] = matrix[row][length-col<span class="hljs-number">-1</span>], matrix[row][col]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>[1,2,3]<br>[4,5,6]<br>[7,8,9]</p><p>[1,4,7]<br>[2,5,8]<br>[3,6,9]</p><p>[7,4,1]<br>[8,5,2]<br>[9,6,3]</p><p>先对角线翻转，再左右翻转</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; length; j++ &#123;<br>matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经典对角线互换。</p><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h2><p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rightSideView</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br>queue := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        length := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> i == length<span class="hljs-number">-1</span> &#123;<br>                res = <span class="hljs-built_in">append</span>(res, node.Val)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>&#125;<br><span class="hljs-comment">// dp[i] 代表抢 nums[0...i] 房子的最大价值</span><br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>], max(nums[<span class="hljs-number">1</span>], nums[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>dp[i] = max(dp[i<span class="hljs-number">-1</span>], nums[i]+dp[i<span class="hljs-number">-2</span>])<br>&#125;<br><span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>非常牛！潘潘，你识别出来了dp，并且有个很牛的一点，你递推公式差点成功了，这次是欠考虑要找0 to i区间的最大值，而写的是前两个，他其实找的是当前前面所有中最大的。总之是很不错的。</p><h2 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h2><p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes’ values.</p><p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Children []*Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *Node)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    queue := []*Node&#123;root&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        length := <span class="hljs-built_in">len</span>(queue) <br>        tmp := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            tmp = <span class="hljs-built_in">append</span>(tmp, node.Val) <br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <br>            m := <span class="hljs-built_in">len</span>(node.Children)<br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Children[i])<br>            &#125;<br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, tmp)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>跟二叉树的层序遍历差不多。</p><h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h2><p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p><p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code>will be separated by at least one space.</p><p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p><p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 调用外部工具版本</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords151</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>ss := strings.Fields(s)<br>reverse151(&amp;ss, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(ss)<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">return</span> strings.Join(ss, <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse151</span><span class="hljs-params">(m *[]<span class="hljs-type">string</span>, i <span class="hljs-type">int</span>, j <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i &lt;= j &#123;<br>(*m)[i], (*m)[j] = (*m)[j], (*m)[i]<br>i++<br>j--<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 自己写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    b := []<span class="hljs-type">byte</span>(s)<br>    b = trim(b)<br>    b = reverse(b)<br>    b = findWordAndReverse(b)<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(b)<br>&#125;<br><br><span class="hljs-keyword">const</span> SPACE = <span class="hljs-type">byte</span>(<span class="hljs-type">rune</span>(<span class="hljs-string">&#x27; &#x27;</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trim</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    <span class="hljs-comment">//trim start space</span><br>    <span class="hljs-keyword">for</span> s[<span class="hljs-number">0</span>] == SPACE &#123;<br>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i&lt;<span class="hljs-built_in">len</span>(s);i++ &#123;<br>            s[i<span class="hljs-number">-1</span>] = s[i]<br>        &#125;<br>        s = s[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]<br>    &#125;<br>    <br>    <span class="hljs-comment">//trim mid space</span><br>    <br>    l := <span class="hljs-number">1</span><br>    swap :=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;        <br>        <span class="hljs-keyword">if</span> s[i] == SPACE &amp;&amp; s[i<span class="hljs-number">-1</span>] == SPACE &#123;<br>            swap++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> i!=l &#123;<br>                s[l] = s[i]<br>            &#125;<br>            l++  <br>        &#125;<br>    &#125;<br>    s = s[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(s)-swap]<br>    <br>    <br>    <span class="hljs-comment">//trim end space</span><br>    l = <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> ; l &gt; <span class="hljs-number">0</span>; l-- &#123;<br>        <span class="hljs-keyword">if</span> s[l] != SPACE &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125; <br><br>    <span class="hljs-keyword">return</span> s[<span class="hljs-number">0</span>:l+<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s)-i; i++ &#123;<br>        s[i], s[<span class="hljs-built_in">len</span>(s)-i<span class="hljs-number">-1</span>] = s[<span class="hljs-built_in">len</span>(s)-i<span class="hljs-number">-1</span>], s[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findWordAndReverse</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    prev := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span>  i == <span class="hljs-built_in">len</span>(s) || s[i] == SPACE &#123;<br>            reverse(s[prev:i])<br>            prev = i+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;  <br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>先剪枝，两次反转，反转全部+反转每个单词。</p><h2 id="19-删除链表倒数第N个节点"><a href="#19-删除链表倒数第N个节点" class="headerlink" title="19. 删除链表倒数第N个节点"></a>19. 删除链表倒数第N个节点</h2><p>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    fakeHead := &amp;ListNode&#123;Next: head&#125;<br>    slow := fakeHead<br>    fast := head<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        fast = fast.Next<br>    &#125;<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next<br>    &#125;<br>    slow.Next = slow.Next.Next<br>    <span class="hljs-keyword">return</span> fakeHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h2><p>A <strong>permutation</strong> of an array of integers is an arrangement of its members into a sequence or linear order.</p><ul><li>For example, for <code>arr = [1,2,3]</code>, the following are all the permutations of <code>arr</code>: <code>[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]</code>.</li></ul><p>The <strong>next permutation</strong> of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the <strong>next permutation</strong> of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).</p><ul><li>For example, the next permutation of <code>arr = [1,2,3]</code> is <code>[1,3,2]</code>.</li><li>Similarly, the next permutation of <code>arr = [2,3,1]</code> is <code>[3,1,2]</code>.</li><li>While the next permutation of <code>arr = [3,2,1]</code> is <code>[1,2,3]</code> because <code>[3,2,1]</code> does not have a lexicographical larger rearrangement.</li></ul><p>Given an array of integers <code>nums</code>, <em>find the next permutation of</em> <code>nums</code>.</p><p>The replacement must be in place and use only constant extra memory.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> nums[i] &lt; nums[i+<span class="hljs-number">1</span>] &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> j = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; j &gt; i; j-- &#123;<br><span class="hljs-keyword">if</span> nums[j] &gt; nums[i] &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>swap(&amp;nums, i, j)<br>&#125;<br>    <br>    <span class="hljs-comment">// 如果没有找到，跳过前两步，只需要反转全部即可。如果找到了后面（i+1）的区间一定是降序的</span><br>    reverse(&amp;nums, i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(nums *[]<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i &lt; j &#123;<br>swap(nums, i, j)<br>i++<br>j--<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(nums *[]<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>(*nums)[i], (*nums)[j] = (*nums)[j], (*nums)[i]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>题目有 3 个问题需要解决。如何找到下一个排列。不存在下一个排列的时候如何生成最小的排列。如何原地修改。先解决第一个问题，如何找到下一个排列。下一个排列是找到一个大于当前排序的字典序，且变大的幅度最小。那么只能将较小的数与较大数做一次原地交换。并且较小数的下标要尽量靠右，较大数也要尽可能小。原地交换以后，还需要将较大数右边的数按照升序重新排列。这样交换以后，才能生成下一个排列。以排列 [8,9,6,10,7,2] 为例：能找到的符合条件的一对「较小数」与「较大数」的组合为 6 与 7，满足「较小数」尽量靠右，而「较大数」尽可能小。当完成交换后排列变为 [8,9,7,10,6,2]，此时我们可以重排「较小数」右边的序列，序列变为 [8,9,7,2,6,10]。</li><li>第一步：在 <code>nums[i]</code> 中找到 <code>i</code> 使得 <code>nums[i] &lt; nums[i+1]</code>，此时较小数为 <code>nums[i]</code>，并且 <code>[i+1, n)</code> 一定为下降区间。第二步：如果找到了这样的 <code>i</code> ，则在下降区间 <code>[i+1, n)</code> 中从后往前找到第一个 <code>j</code> ，使得 <code>nums[i] &lt; nums[j]</code> ，此时较大数为 <code>nums[j]</code>。第三步，交换 <code>nums[i]</code> 和 <code>nums[j]</code>，此时区间 <code>[i+1, n)</code> 一定为降序区间。最后原地交换 <code>[i+1, n)</code> 区间内的元素，使其变为升序，无需对该区间进行排序。（n为数组的长度）</li><li>如果第一步找不到符合条件的下标 <code>i</code>，说明当前序列已经是一个最大的排列。那么应该直接执行第三步，生成最小的排列。</li></ul><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// stop</span><br>    <span class="hljs-keyword">if</span> root == p || root == q || root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <br>    <span class="hljs-comment">// left</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br>    <span class="hljs-comment">// right</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br>    <br>    <span class="hljs-comment">// root</span><br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们从下往上找，如果说此节点的左子树和右子树中同时都找到了p和q那么就返回此节点（为什么一定是呢？因为是二叉树，所以左右都有就可以。）如果增加这个题的难度，那么就是多叉树怎么做呢，一样的只要判断能同时找到多个节点的节点，就是公共祖先。</p><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h2><p>Given an encoded string, return its decoded string.</p><p>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code>inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there will not be input like <code>3a</code> or <code>2[4]</code>.</p><p>The test cases are generated so that the length of the output will never exceed <code>105</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">用栈处理，遇到 “[&quot;，就要开始重复字符串了，另外重复的数字是可能存在多位的，所以需要往前找到不为数字的那一位，把数字转换出来。最后用把 stack 里面的字符串都串联起来即可。</span><br><span class="hljs-string"></span><br><span class="hljs-string"># HARD</span><br><span class="hljs-string"></span><br><span class="hljs-string">## 25. K个一组翻转链表</span><br><span class="hljs-string"></span><br><span class="hljs-string">Given the `</span>head<span class="hljs-string">` of a linked list, reverse the nodes of the list `</span>k<span class="hljs-string">` at a time, and return *the modified list*.</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span>k<span class="hljs-string">` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `</span>k<span class="hljs-string">` then left-out nodes, in the end, should remain as it is.</span><br><span class="hljs-string"></span><br><span class="hljs-string">You may not alter the values in the list&#x27;s nodes, only nodes themselves may be changed.</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><span class="hljs-keyword">go</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>curr := head<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br><span class="hljs-keyword">if</span> curr == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> head<br>&#125;<br>curr = curr.Next<br>&#125;<br>newHead := reverse(head, curr) <span class="hljs-comment">// curr此时是下一个的开头</span><br>head.Next = reverseKGroup(curr, k)<br><span class="hljs-keyword">return</span> newHead<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(first *ListNode, last *ListNode)</span></span> *ListNode &#123;<br>    curr := first<br>prev := last<br><span class="hljs-keyword">for</span> curr != last &#123;<br>tmp := curr.Next<br>curr.Next = prev<br>prev = curr<br>curr = tmp<br>&#125;<br><span class="hljs-keyword">return</span> prev<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum:=<span class="hljs-number">0</span><br>    n:=<span class="hljs-built_in">len</span>(height)<br>    lh:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)<br>    rh:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)<br>    lh[<span class="hljs-number">0</span>]=height[<span class="hljs-number">0</span>]<br>    rh[n<span class="hljs-number">-1</span>]=height[n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;<br>        lh[i]=max(lh[i<span class="hljs-number">-1</span>],height[i])<br>    &#125;<br>    <span class="hljs-keyword">for</span> i:=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;<br>        rh[i]=max(rh[i+<span class="hljs-number">1</span>],height[i])<br>    &#125;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++&#123;<br>        h:=min(rh[i],lh[i])-height[i]<br>        <span class="hljs-keyword">if</span> h&gt;<span class="hljs-number">0</span>&#123;<br>            sum+=h<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a&gt;b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a&lt;b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>在上一节的双指针解法中，我们可以看到只要记录左边柱子的最高高度 和 右边柱子的最高高度，就可以计算当前位置的雨水面积，这就是通过列来计算。</p><p>当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。</p><p>为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight）。这样就避免了重复计算，这就用到了动态规划。</p><p>当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。</p><p>即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);</p><p>从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);</p><p>总体思路就是拆开看：</p><p>1、我们需要知道每个位置其左边和右边最高的高度是多少，所以先init两个数组。dp的思想，分别记录左右位置的其左边最高的高度和其右边最高的高度。细节就是我们要注意左边是从下标1开始，右边要从下标n-2开始都要留出一个空间，因为</p><p>2、这时候准备工作做好了我们就要用dp的思想将所有的雨水记录出来，用 <strong>min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度</strong> 来进行计算。</p><h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><p>Given an unsorted integer array <code>nums</code>, return the smallest missing positive integer.</p><p>You must implement an algorithm that runs in <code>O(n)</code> time and uses constant extra space.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        m[v] = v<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>; i++ &#123; <span class="hljs-comment">// 比如 7,8,9,11,12 最后输出1</span><br>        <span class="hljs-keyword">if</span> _, exist := m[i]; !exist &#123;<br>            <span class="hljs-keyword">return</span> i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span> <span class="hljs-comment">// 比如 0,1,2 最后是 3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了减少时间复杂度，可以把 input 数组都装到 map 中，然后 i 循环从 1 开始，依次比对 map 中是否存在 i，只要不存在 i 就立即返回结果，即所求。</p><h2 id="124-二叉树的最大路径和"><a href="#124-二叉树的最大路径和" class="headerlink" title="124. 二叉树的最大路径和"></a>124. 二叉树的最大路径和</h2><p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p><p>The <strong>path sum</strong> of a path is the sum of the node’s values in the path.</p><p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>max := math.MinInt32<br>getPathSum(root, &amp;max)<br><span class="hljs-keyword">return</span> max<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getPathSum</span><span class="hljs-params">(root *TreeNode, maxSum *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> math.MinInt32<br>&#125;<br>left := getPathSum(root.Left, maxSum)<br>right := getPathSum(root.Right, maxSum)<br><br>currMax := max(max(left+root.Val, right+root.Val), root.Val)<br>*maxSum = max(*maxSum, max(currMax, left+right+root.Val))<br><span class="hljs-keyword">return</span> currMax<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>因为有负数，所有用math.MinInt32</p><p>对于当前节点，每次比较走左边，还是走右边，还是走在当前节点不走了。再让这个和（左+根+右重新开一条路）还有最大值进行比较。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis-study</title>
    <link href="/2022/07/26/redis-study/"/>
    <url>/2022/07/26/redis-study/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用Homebrew安装Redis</p><p><code>brew install redis</code></p><p>启动redis</p><p><code>Brew services start redis</code></p><p>查看redis是否运行</p><p><code>ps axu|grep redis</code></p><p>查看列表</p><p><code>brew services list</code></p><p>关闭redis</p><p><code>brew services stop redis</code></p><p>docker中运行redis</p><p><code>docker exec -it &quot;container_name&quot; bash</code></p><h1 id="指南传送门"><a href="#指南传送门" class="headerlink" title="指南传送门"></a>指南传送门</h1><p>golang-redis <a href="https://www.bilibili.com/read/cv15392487?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv15392487?spm_id_from=333.999.0.0</a></p><p>redis入门 <a href="https://www.bilibili.com/read/cv15157176?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv15157176?spm_id_from=333.999.0.0</a></p><h1 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h1><p>数据结构：字符串、链表、哈希表、集合、有序集合</p><p>持久化：RDB、AOF</p><p>写操作慢于读操作  </p><p><strong>缓存淘汰：</strong></p><p>FIFO先入先出</p><p>LRU最近最少使用：通过hash表来定位具体的位置，然后把他放在队尾</p><p>LFU最不经常使用：记录访问次数，按照访问次数少放队尾</p><p><strong>缓存一致：</strong></p><p>延迟双删，还有一个忘记了</p><p><strong>缓存击穿：</strong>缓存中没有数据，然后再次访问直接打到数据库</p><p>redis的性能是普通关系型数据库的10-100倍，如果redis勉强完成的任务，直接打到数据库上，mysql肯定直接宕机了</p><p>mysql角度出发：减少击穿后的直接流量</p><p>从Redis角度出发：</p><p>设置热点数据永不过期</p><p>热点数据后台启动一个异步线程，重新把数据回填缓存层</p><p><strong>缓存穿透：</strong>查询一个数据库也不存在的数据，即缓存查不到，数据库也查不到，所以透了</p><p>一般解决办法：</p><ol><li>拦截非法查询请求</li><li>缓存空对象 value为空，防止直接打到数据库</li><li>布隆过滤器<a href="https://zhuanlan.zhihu.com/p/43263751">https://zhuanlan.zhihu.com/p/43263751</a></li></ol><p>​        设计思路：设计k个hash映射函数，这k个映射函数各不相同，把在数据库中的有效数据通过这个映射函数得到数组指定位置，并置为1</p><p>​        查询思路：输入查询数据，通过这一系列hash函数，判断对应位置是否全为1。如果是，则很大概率就是我们的有效请求了，如果有一位为0，则查询一定是无效查询</p><p>过滤器加在请求redis前面这样可以先查一下有没有过这个数据，如果没有的话就不用请求了，因为肯定不存在。注意返回的结果是概率性的，而且hash值可能覆盖，所以不一定每一个数据都可以在存储中有k个结果</p><p><strong>缓存雪崩：</strong>一大批被缓存的数据，同时失效，此时对于这一批的数据请求就全打到数据库上，导致数据库宕机</p><p>缓存击穿：单点；缓存雪崩：多点</p><p>从MySQL的角度：减少并发量</p><p>从Redis的角度：</p><p>设置热点数据永不过期</p><p>分析失效时间，尽量让失效时间点分散</p><p>缓存预热，即在上线前，根据当天的情况分析，将热数据直接加载到缓存系统</p><h1 id="多机"><a href="#多机" class="headerlink" title="多机"></a>多机</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Mysql的主从复制<a href="https://www.cnblogs.com/rickiyang/p/13856388.html">https://www.cnblogs.com/rickiyang/p/13856388.html</a></p><p><strong>一主一从/一主多从</strong></p><p>写命令直接打到主库上，从库滞后一点（时延）从主库同步数据，然后读请求尽量从从库里面搞</p><ol><li><p>当主库从库上线后，他们不急着直接进行复制过程，首先需要进行握手，进行信息验证。</p></li><li><p>当握手完成后，从库需要向主库发送PSYN命令，即同步命令，开启数据同步过程，并发送主库ID（防止断网后换了主库，用来判断的是进行全量复制/断线后重复制），复制的进度偏移量offset</p></li><li>主库会根据从库发送的信息，进行逻辑判断，并告诉从库，是进行全量复制/断线后重复制</li></ol><p><strong>全量复制</strong>：初次复制后的同步</p><p>​    主库执行BGSAVE，生成对应的RDB文件，同时开辟缓冲区，记录在RDB文件实行过程中，收到的新数据命令</p><p>​    RDB文件产生后，主库发送给从库，从库通过RDB恢复数据（持久化<a href="https://www.51cto.com/article/634555.html）">https://www.51cto.com/article/634555.html）</a></p><p><strong>命令传播阶段</strong>：</p><p>​    主库状态被修改了（如增加了新数据，修改了原始数据）为了使得从库和主库数据状态一致，主库将会把数据变更命令发给从库，从库收到后执行命令。</p><p><strong>断线后重复制</strong>：从库与主库断线重连后复制，此过程依赖服务器运行ID，复制偏移量，复制积压缓冲区</p><p>​    服务器运行ID：唯一确定主库身份，如果不是一个的话就执行全量复制。</p><p>​    复制偏移量：代表主节点传输了的字节数</p><p>​    复制积压缓冲区：复制积压缓冲区是一个先进先出队列，存储了最近主节点的数据修改命令</p><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>哨兵机制：即新建哨兵组，对主库从库统一进行监控，如果主库坏了，哨兵组进行投票，从从库中重新选出主库</p><p>本质上，从代码层面上讲，哨兵是一个不提供数据服务的redis服务器</p><p>例子参考《Redis设计与实现》</p><p>一台主库，三台从库，哨兵系统监控着这四台机器。</p><p>每个机器都会向哨兵一定时间（10秒）发送信息（也称为心跳）。</p><p>哨兵系统如果一定时间收不到这个信息，就默认这个机器断联了。</p><p>具体判断<strong>下线的逻辑</strong>是：</p><p>当某个哨兵发现主库连接不上，会将其标注为主观下线，并通知其他哨兵连接一下主库试试。</p><p>超过半数哨兵确认链接不上后，就会标记该主库为客观下线，并执行故障转移（从从库中挑个当主库）</p><p>在故障转移过程中，会通过选举协议，从所有哨兵中选择一个节点，作为老大，主持负责新主库的选举工作</p><p>选取完成后，哨兵会对这个从库发送slave of no one，此时该从库就变成主库了，同时向其他slave发送新主库的IP端口</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Cluster：Redis提供的分布式数据库解决方案</p><p>自动将你的数据切分给多个节点存储</p><p>即使这些节点中一部分宕机，也可以继续执行数据操作</p><p>分区策略：采用虚拟槽，所有key通过CRC16校验函数，对16384取模，决定数据分配到哪个槽位。</p><p>每个redis的cluster节点负责一部分槽数据的存储，并且该节点可以结合之前讲到的主从复制模式，将分配给他的数据进行复制。</p><p>查询策略：每隔节点都会存储整个集群节点信息，这些信息也被称为元信息。</p><p>这个节点存储的元数据包括在该节点视角下：</p><div class="code-wrapper"><pre><code class="hljs">1. 各节点存储的槽数据1. 各节点的master和slave状态1. 各节点是否存活</code></pre></div><p>  ……</p><p>元数据信息的传播：gossip协议，每个节点都把自己的数据信息通过这个协议散歩出去</p><p>具体过程：</p><ol><li>Gossip协议是周期性的，每隔一定时间，执行一次</li><li>所有被感染节点选择k个邻接节点散步信息</li></ol><p>关于cluster的扩容和缩容：由于集群数据可能出现服务器扩容（数据太多了加节点），服务器缩容（数据太少减少节点避免浪费）在该过程中，数据产生迁移</p><p>所以会出现这种情况：某个槽一部分数据在原来节点上，因此一般cluster的查询逻辑如下：</p><ol><li><p>客户端给指定节点发送查询命令</p></li><li><p>节点判断数据是否还存在本节点上</p></li></ol><p>​    3.1（yes）返回预期数据</p><p>​    3.2（no）判断数据所在槽是否迁移</p><p>​       4.1（yes）发送ASK错误，告诉客户端新节点位置</p><p>​       4.2（no）key不存在</p><h1 id="青训营项目的应用"><a href="#青训营项目的应用" class="headerlink" title="青训营项目的应用"></a>青训营项目的应用</h1><p>那么在用户注册需求之下，redis中的哈希类型来存储用户的基本信息是非常适合的，从存储优势上面来讲，使用哈希类型的存储能够让每个用户的非必填字段不占用多余的内存。那么每次创建用户的时候，只需要在业务层保证用户必填的字段都存在，然后插入新用户的信息即可。</p><p><strong>Redis 存储一条用户信息</strong></p><p><strong>一、方式1</strong></p><p>如果用普通的key/value结构来存储，主要有以下2种存储方式： </p><p>第一种方式将用户ID作为查找key,把其他信息封装成一个对象以<a href="https://so.csdn.net/so/search?q=序列化&amp;spm=1001.2101.3001.7020">序列化</a>的方式存储， </p><p> 如：set u001 “李三,18,20010101” </p><p> 这种方式的缺点是，增加了序列化/<a href="https://so.csdn.net/so/search?q=反序列化&amp;spm=1001.2101.3001.7020">反序列化</a>的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。 </p><p><strong>二、方式2</strong></p><p>第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值， </p><p> 如：mset user:001:name “李三 “user:001:age18 user:001:birthday “20010101” </p><p> 虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。 </p><p><strong>三、最好的办法</strong></p><p>那么Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap， </p><p> 并提供了直接存取这个Map成员的接口， </p><p> 如：hmset user:001 name “李三” age 18 birthday “20010101” </p><p> 也就是说，Key仍然是用户ID,value是一个Map，这个Map的key是成员的属性名，value是属性值， 这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 </p><p> key(用户ID) + field(属性标签) 操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。</p><p>我们现在的情况是，用户密码的作用是在验证登录上面，账号的信息是用来做业务的。暂时想分库存储。</p><p>【摘要】 Gorm 读写分离 写在前面在gorm v2版本中，我们可以看到已经支持读写分离，那读写分离是基于主从复制的，所以我们要先配置mysql的主从复制 1. 为什么需要主从复制？在业务复杂的系统中，有这么一个情景：如果有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务。使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正…<a href="https://bbs.huaweicloud.com/blogs/314327">https://bbs.huaweicloud.com/blogs/314327</a></p><p>公司专门管db的人会帮你把数据表建立好，所以不用在意是否有这个表，肯定有所以直接迁移就可以了。    </p><h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a><strong>什么是跨域？</strong></h3><p>这篇博文解释的挺清楚，我直接引用 <a href="https://blog.csdn.net/lambert310/article/details/51683775">https://blog.csdn.net/lambert310/article/details/51683775</a></p><p><strong>跨域</strong>，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。</p><p>所谓同源是指，<strong>域名，协议，端口</strong>均相同，只要有一个不同，就是跨域。不明白没关系，举个栗子：</p><p><a href="http://www.123.com/index.html">http://www.123.com/index.html</a> 调用 <a href="http://www.123.com/server.php">http://www.123.com/server.php</a> （非跨域）</p><p><a href="http://www.123.com/index.html">http://www.123.com/index.html</a> 调用 <a href="http://www.456.com/server.php">http://www.456.com/server.php</a> （主域名不同:123/456，跨域）</p><p><a href="http://abc.123.com/index.html">http://abc.123.com/index.html</a> 调用 <a href="http://def.123.com/server.php">http://def.123.com/server.php</a> （子域名不同:abc/def，跨域）</p><p><a href="http://www.123.com:8080/index.html">http://www.123.com:8080/index.html</a> 调用 <a href="http://www.123.com:8081/server.php">http://www.123.com:8081/server.php</a> （端口不同:8080/8081，跨域）</p><p><a href="http://www.123.com/index.html">http://www.123.com/index.html</a> 调用 <a href="https://www.123.com/server.php">https://www.123.com/server.php</a> （协议不同:http/https，跨域）</p><p>请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。</p><p>浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。</p><h3 id="跨域会阻止什么操作？"><a href="#跨域会阻止什么操作？" class="headerlink" title="跨域会阻止什么操作？"></a><strong>跨域会阻止什么操作？</strong></h3><p>浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询</p><p>跨域问题的解决<a href="https://juejin.cn/post/7114216333700677640">https://juejin.cn/post/7114216333700677640</a></p><p>shouldbind讲解<a href="https://blog.51cto.com/dongweizhen/3606784">https://blog.51cto.com/dongweizhen/3606784</a></p><p>项目结构命名<a href="https://zhuanlan.zhihu.com/p/346573562">https://zhuanlan.zhihu.com/p/346573562</a></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs go">err := dao.DB.Model(&amp;model.User&#123;&#125;).Where(<span class="hljs-string">&quot;user_name = ?&quot;</span>, username).Find(&amp;user).Error<br></code></pre></td></tr></table></figure><p>以谁为模型成为表然后去找对应的名字，用find将输出的数据对象装入user结构</p><p>作用域<a href="https://studygolang.com/articles/13239">https://studygolang.com/articles/13239</a></p><p>Abort终止请求<a href="https://blog.csdn.net/cyberspecter/article/details/100602552">https://blog.csdn.net/cyberspecter/article/details/100602552</a></p><p>日志框架 “github.com/sirupsen/logrus”</p><p>redis + token的用处<a href="https://juejin.cn/post/7022579299349692452">https://juejin.cn/post/7022579299349692452</a></p>]]></content>
    
    
    <categories>
      
      <category>Nosql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java web</title>
    <link href="/2022/07/23/java-web/"/>
    <url>/2022/07/23/java-web/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JDBC"><a href="#一、JDBC" class="headerlink" title="一、JDBC"></a>一、JDBC</h1><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 注册驱动</span><br><span class="hljs-comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><br><span class="hljs-comment">//2. 获取连接</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/db1&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;woaini123&quot;</span>;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br><span class="hljs-comment">//3. 定义sql</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = 2000 where id = 1&quot;</span>;<br><br><span class="hljs-comment">//4. 获取执行sql的对象 Statement</span><br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br><br><span class="hljs-comment">//5. 执行sql</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql); <span class="hljs-comment">// 受影响的行数</span><br><br><span class="hljs-comment">//6. 处理结果</span><br>System.out.println(count);<br><br><span class="hljs-comment">//7. 释放资源</span><br>stmt.close();<br>conn.close();<br></code></pre></td></tr></table></figure><h2 id="1-DriverManager"><a href="#1-DriverManager" class="headerlink" title="1. DriverManager"></a>1. DriverManager</h2><p>registerDriver()</p><h2 id="2-Connection"><a href="#2-Connection" class="headerlink" title="2. Connection"></a>2. Connection</h2><h3 id="2-1-获取执行SQL的对象"><a href="#2-1-获取执行SQL的对象" class="headerlink" title="2.1 获取执行SQL的对象"></a>2.1 获取执行SQL的对象</h3><h3 id="2-2-管理事务"><a href="#2-2-管理事务" class="headerlink" title="2.2 管理事务"></a>2.2 管理事务</h3><ul><li>MySQL事务管理</li></ul><p>开启事务：BEGIN；/START TRANSACTION；</p><p>提交事务：COMMIT；</p><p>回滚事务：ROLLBACK；</p><p>MySQL默认自动提交事务</p><ul><li>JDBC事务管理：Connection接口定义了3个对应的方法</li></ul><p>开启事务：setAutoCommit(boolean autoCommit)：true为自动提交事务；false为手动提交事务，即为开启事务</p><p>提交事务：commit()</p><p>回滚事务：rollback()</p><h2 id="3-Statement"><a href="#3-Statement" class="headerlink" title="3. Statement"></a>3. Statement</h2><p>作用：执行sql语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>  <span class="hljs-title function_">executeUpdate</span><span class="hljs-params">(sql)</span>: 执行DML、DDL语句<br>  -&gt; 返回值：(<span class="hljs-number">1</span>)DML语句影响的行数 (<span class="hljs-number">2</span>)DDL语句执行后，执行成功也可能返回<span class="hljs-number">0</span><br>  <br>ResultSet  <span class="hljs-title function_">executeQuery</span><span class="hljs-params">(sql)</span>: 执行DQL语句<br>  -&gt; 返回值：ResultSet 结果集对象<br></code></pre></td></tr></table></figure><p>执行DDL（对数据的库操作）以后不报错就算是ok的</p><h2 id="4-ResultSet"><a href="#4-ResultSet" class="headerlink" title="4. ResultSet"></a>4. ResultSet</h2><ul><li><p>封装了DQL查询语句的结果</p><p>ResultSet stmt.executeQuery(sql)：执行DQL语句，返回 ResultSet对象</p></li><li><p>获取查询结果</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span>: (<span class="hljs-number">1</span>)将光标从当前位置向前移动一行 （<span class="hljs-number">2</span>）判断当前行是否为有效行<br>  -&gt; 返回值：<br>  <span class="hljs-literal">true</span>：有效行，当前行有数据<br>  <span class="hljs-literal">false</span>：无效行，当前行没有数据<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">xxx <span class="hljs-title function_">getXxx</span><span class="hljs-params">(参数)</span>: 获取数据<br>  -&gt; xxx：数据类型；如：<span class="hljs-type">int</span> <span class="hljs-title function_">getInt</span><span class="hljs-params">(参数)</span>；String <span class="hljs-title function_">getString</span><span class="hljs-params">(参数)</span><br>  -&gt; 参数：<br>  <span class="hljs-type">int</span>：列的编号，从<span class="hljs-number">1</span>开始<br>  String：列的名称<br></code></pre></td></tr></table></figure><p>列的编号是从1开始的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(re.next())&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> getInt(<span class="hljs-number">1</span>)<br>  <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-number">2</span>)<br>  <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> rs.getDouble(<span class="hljs-number">3</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>定义实体类Account</p></li><li><p>查询数据，封装到Account对象中</p></li><li>将Account对象存入ArrayList集合中</li></ol><h2 id="5-PreparedStatement"><a href="#5-PreparedStatement" class="headerlink" title="5. PreparedStatement"></a>5. PreparedStatement</h2><p>预编译SQL语句并执行：预防SQL注入问题</p><p>SQL注入演示</p><p><code>String sql = &quot;select * from tb_user where username = &#39;&quot;+name+&#39;&#39; and password = &#39;&quot;+pwd+&#39;&quot;&#39;&quot;;</code></p><p>pwd = “ ‘ or ‘1’ = ‘1 ”</p><p>1⃣️获取PreparedStatement对象</p><p>​     用？当占位符</p><p>2⃣️设置参数值</p><p>​     设置参数</p><p>​     Xxx：数据类型；如 setInt（参数1，参数2）</p><p>3⃣️执行SQL</p>]]></content>
    
    
    
    <tags>
      
      <tag>java web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>simple distributed</title>
    <link href="/2022/07/23/simple-distributed/"/>
    <url>/2022/07/23/simple-distributed/</url>
    
    <content type="html"><![CDATA[<h1 id="一、服务注册"><a href="#一、服务注册" class="headerlink" title="一、服务注册"></a>一、服务注册</h1><h2 id="1-自定义日志的逻辑"><a href="#1-自定义日志的逻辑" class="headerlink" title="1. 自定义日志的逻辑"></a>1. 自定义日志的逻辑</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    O_RDONLY <span class="hljs-type">int</span> = syscall.O_RDONLY <span class="hljs-comment">// 只读模式打开文件</span><br>    O_WRONLY <span class="hljs-type">int</span> = syscall.O_WRONLY <span class="hljs-comment">// 只写模式打开文件</span><br>    O_RDWR   <span class="hljs-type">int</span> = syscall.O_RDWR   <span class="hljs-comment">// 读写模式打开文件</span><br>    O_APPEND <span class="hljs-type">int</span> = syscall.O_APPEND <span class="hljs-comment">// 写操作时将数据附加到文件尾部</span><br>    O_CREATE <span class="hljs-type">int</span> = syscall.O_CREAT  <span class="hljs-comment">// 如果不存在将创建一个新文件</span><br>    O_EXCL   <span class="hljs-type">int</span> = syscall.O_EXCL   <span class="hljs-comment">// 和O_CREATE配合使用，文件必须不存在</span><br>    O_SYNC   <span class="hljs-type">int</span> = syscall.O_SYNC   <span class="hljs-comment">// 打开文件用于同步I/O</span><br>    O_TRUNC  <span class="hljs-type">int</span> = syscall.O_TRUNC  <span class="hljs-comment">// 如果可能，打开时清空文件</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">f, err := os.OpenFile(<span class="hljs-type">string</span>(fl), os.O_CREATE | os.O_WRONLY | os.O_APPEND, <span class="hljs-number">0600</span>)<br></code></pre></td></tr></table></figure><p>相当于是打开一个文件，如果fl这个名字不存在就创建一个fl，只写入，并且写操作时将数据附加在文件尾部。</p><p>系统自带的log函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(out io.Writer, prefix <span class="hljs-type">string</span>, flag <span class="hljs-type">int</span>)</span></span> *Logger &#123;<br><span class="hljs-keyword">return</span> &amp;Logger&#123;out: out, prefix: prefix, flag: flag&#125;<br>&#125;<br>LstdFlags     = Ldate | Ltime <span class="hljs-comment">// initial values for the standard logger</span><br></code></pre></td></tr></table></figure><h2 id="2-可运行的日志服务"><a href="#2-可运行的日志服务" class="headerlink" title="2. 可运行的日志服务"></a>2. 可运行的日志服务</h2><pre><code class=" mermaid">graph TD;log --&gt; logserviceservice --&gt; logservicesubgraph cmdlogserviceend</code></pre><p>log包提供log逻辑</p><p>service包start()提供服务</p><p>cmd包提供启动服务</p><h2 id="3-注册服务的逻辑"><a href="#3-注册服务的逻辑" class="headerlink" title="3. 注册服务的逻辑"></a>3. 注册服务的逻辑</h2><p><strong>golang中处理http响应数据解码，一般有两种方式</strong></p><ul><li>json.Unmarshal进行解码</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleUse</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> u Use<br>    data, err := ioutil.ReadAll(r.Body)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        w.WriteHeader(http.StatusBadRequest)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> err := json.Unmarshal(data, &amp;u); err != <span class="hljs-literal">nil</span> &#123;<br>        w.WriteHeader(http.StatusInternalServerError)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    w.WriteHeader(http.StatusOK)<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;姓名：%s，年龄：%d&quot;</span>, u.Name, u.Age)<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>json.NewDecoder解码</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleUse</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> u Use<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;u); err != <span class="hljs-literal">nil</span> &#123;<br>        w.WriteHeader(http.StatusInternalServerError)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    w.WriteHeader(http.StatusOK)<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;姓名：%s，年龄：%d&quot;</span>, u.Name, u.Age)<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>区别</strong></p><p>1、json.NewDecoder是从一个流里面直接进行解码，代码精干<br>2、json.Unmarshal是从已存在于内存中的json进行解码<br>3、相对于解码，json.NewEncoder进行大JSON的编码比json.marshal性能高，因为内部使用pool</p><p><strong>场景应用</strong></p><p>1、json.NewDecoder用于http连接与socket连接的读取与写入，或者文件读取<br>2、json.Unmarshal用于直接是byte的输入</p><pre><code class=" mermaid">graph TD;log --&gt; logserviceservice --&gt; logserviceregistrysubgraph cmdlogserviceend</code></pre><h2 id="4-可运行的服务注册的-Web-Service"><a href="#4-可运行的服务注册的-Web-Service" class="headerlink" title="4. 可运行的服务注册的 Web - Service"></a>4. 可运行的服务注册的 Web - Service</h2><pre><code class=" mermaid">graph TD;log --&gt; logserviceservice --&gt; logserviceregistry --&gt; registryservicesubgraph cmdlogserviceregistryserviceend</code></pre><h2 id="5-注册一个服务"><a href="#5-注册一个服务" class="headerlink" title="5. 注册一个服务"></a>5. 注册一个服务</h2><pre><code class=" mermaid">graph TD;log --&gt; logserviceservice --&gt; logserviceregistry --&gt; registryserviceregistry --&gt; servicesubgraph cmdlogserviceregistryserviceend</code></pre><p>注意网址一定表明http，因为默认似乎是https，这样就404了，权限不够。</p><h2 id="6-取消注册的服务"><a href="#6-取消注册的服务" class="headerlink" title="6. 取消注册的服务"></a>6. 取消注册的服务</h2><p>写了两种对一个slice中删除特定元素的方法，并做了性能对比，在这里记录一下。</p><p>假设我们的切片有0和1，我们要删除所有的0，此处有三种方法：</p><p>第一种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeleteSlice</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span>&#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a); i++ &#123;<br><span class="hljs-keyword">if</span> a[i] == <span class="hljs-number">0</span> &#123;<br>a = <span class="hljs-built_in">append</span>(a[:i], a[i+<span class="hljs-number">1</span>:]...)<br>i--<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：这里利用常见的方法对slice中的元素进行删除，注意删除时，后面的元素前移，i应该后移一位。</p><p>第二种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeleteSlice1</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>ret := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a))<br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-keyword">if</span> val == <span class="hljs-number">1</span> &#123;<br>ret = <span class="hljs-built_in">append</span>(ret, val)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：这种方法最容易理解，重新使用一个slice，将不合理的过滤掉。缺点是需要开辟另一个slice的空间，优点是容易理解，而且不对原来的slice进行操作。</p><p>第三种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeleteSlice2</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span>&#123;<br>j := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-keyword">if</span> val == <span class="hljs-number">1</span> &#123;<br>a[j] = val<br>j++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> a[:j]<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：这里利用一个index，记录应该下一个有效元素应该在的位置，遍历所有元素，当遇到有效元素，index加一，否则不加，最终index的位置就是所有有效元素的下一个位置。最后做一个截取就行了。这种方法会对原来的slice进行修改。</p><p>第一种方法在slice大小比较小时，比第2、3种方法慢一倍左右。但是slice大小变大时，性能显著下降。</p><p>第2种方法和第3种方法差距基本处于同一量级，但是第3种方法稍快一些。但是当slice大小增加到10^6级别时，第三种方法的优势就显现出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">r.registrations = <span class="hljs-built_in">append</span>(r.registrations[:i], r.registrations[i+<span class="hljs-number">1</span>:]...)<br></code></pre></td></tr></table></figure><p>slice2被打散然后一个个的放入slice1中。</p><h1 id="二、服务发现"><a href="#二、服务发现" class="headerlink" title="二、服务发现"></a>二、服务发现</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// 声明一个结构体</span><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;<br>name   <span class="hljs-type">string</span><br>color  <span class="hljs-type">string</span><br>sex    <span class="hljs-type">bool</span><br>couple Mouse <span class="hljs-comment">// 这里赋值为 另一个结构体, 如果和结构体名一样 可以省略一个</span><br>&#125;<br><br><span class="hljs-comment">// 结构体挂载方法 使用指针 避免内存拷贝</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span></span> CaptureMouse(name <span class="hljs-type">string</span>) (res <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">if</span> c.name == name &#123;<br>fmt.Println(<span class="hljs-string">&quot;名字为Tom，能捉到老鼠&quot;</span>)<br><span class="hljs-comment">// 由于使用了指针， 可以改变结构体的值</span><br>c.name = <span class="hljs-string">&quot;old tom &quot;</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;名字不为Tom， 捉不到老鼠&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 在定义一个结构体</span><br><span class="hljs-keyword">type</span> Mouse <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>color <span class="hljs-type">string</span><br>sex <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-comment">// 结构体挂载方法 不使用指针 实例的成员会进行值复制</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m Mouse)</span></span> Eat(stuff <span class="hljs-type">string</span>) (res <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">if</span> stuff == <span class="hljs-string">&quot;奶酪&quot;</span> &#123;<br>fmt.Println(m.name, <span class="hljs-string">&quot;喜欢吃&quot;</span>, stuff)<br><span class="hljs-comment">// 不能改变外部结构体的值</span><br>m.name = <span class="hljs-string">&quot;old jerry&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;Mouse.Eat(): &quot;</span> + m.name) <span class="hljs-comment">// 形式参数改变</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(m.name, <span class="hljs-string">&quot;不喜欢吃&quot;</span>, stuff)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 实例化结构体</span><br>Tom := Cat&#123;<br>name:  <span class="hljs-string">&quot;Tom&quot;</span>,<br>color: <span class="hljs-string">&quot;white&quot;</span>,<br>sex:   <span class="hljs-literal">true</span>,<br>couple: Mouse&#123;<br>name: <span class="hljs-string">&quot;Jerry&quot;</span>,<br>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 调用方法</span><br>res := Tom.CaptureMouse(<span class="hljs-string">&quot;Tom&quot;</span>)<br>fmt.Println(res)<br>fmt.Println(Tom)<br><span class="hljs-comment">// 通过子类属性调用子类的方法(我自己取的名字)</span><br>Tom.couple.Eat(<span class="hljs-string">&quot;糖&quot;</span>)<br>Tom.couple.Eat(<span class="hljs-string">&quot;奶酪&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;main: &quot;</span> + Tom.couple.name) <span class="hljs-comment">// 形式参数改变，实例化的内容不改变</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结构体挂载方法有两种， 一种是不使用指针，这种会对实例的成员会进行值的复制， 第二种是指针，可以避免内存拷贝(所以更推荐指针方式)。</p><p>不加指针，输出的结果是一样的里面的形式参数都是正常的修改和使用输出结果，但是具体本身这个实例化的对象的内容是不改变的</p><p>读写锁</p><p>读写锁是分别针对读操作和写操作进行锁定和解锁操作的互斥锁。在 Go 语言中，读写锁由结构体类型 sync.RWMutex 代表。</p><p>基本遵循原则：</p><p>写锁定情况下，对读写锁进行读锁定或者写锁定，都将阻塞；而且读锁与写锁之间是互斥的；</p><p>读锁定情况下，对读写锁进行写锁定，将阻塞；加读锁时不会阻塞；</p><p>对未被写锁定的读写锁进行写解锁，会引发 Panic；</p><p>对未被读锁定的读写锁进行读解锁的时候也会引发 Panic；</p><p>写解锁在进行的同时会试图唤醒所有因进行读锁定而被阻塞的 goroutine；</p><p>读解锁在进行的时候则会试图唤醒一个因进行写锁定而被阻塞的 goroutine。</p><p>与互斥锁类似，sync.RWMutex 类型的零值就已经是立即可用的读写锁了。在此类型的方法集合中包含了两对方法，即：</p><p>RWMutex 提供四个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">func (*RWMutex) Lock // 写锁定</span><br><span class="hljs-comment">func (*RWMutex) Unlock // 写解锁</span><br><span class="hljs-comment">func (*RWMutex) RLock // 读锁定</span><br><span class="hljs-comment">func (*RWMutex) RUnlock // 读解锁</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><span class="hljs-keyword">var</span> m *sync.RWMutex<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    wg := sync.WaitGroup&#123;&#125;<br>    wg.Add(<span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">var</span> rwMutex sync.RWMutex<br>    Data := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t <span class="hljs-type">int</span>)</span></span> &#123;<br>            rwMutex.RLock()<br>            <span class="hljs-keyword">defer</span> rwMutex.RUnlock()<br>            fmt.Printf(<span class="hljs-string">&quot;Read data: %v\n&quot;</span>, Data)<br>            wg.Done()<br>            time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>            <span class="hljs-comment">// 这句代码第一次运行后，读解锁。</span><br>            <span class="hljs-comment">// 循环到第二个时，读锁定后，这个goroutine就没有阻塞，同时读成功。</span><br>        &#125;(i)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t <span class="hljs-type">int</span>)</span></span> &#123;<br>            rwMutex.Lock()<br>            <span class="hljs-keyword">defer</span> rwMutex.Unlock()<br>            Data += t<br>            fmt.Printf(<span class="hljs-string">&quot;Write Data: %v %d \n&quot;</span>, Data, t)<br>            wg.Done() <br>            <span class="hljs-comment">// 这句代码让写锁的效果显示出来，写锁定下是需要解锁后才能写的。</span><br>            time.Sleep(<span class="hljs-number">2</span> * time.Second)        <br>        &#125;(i)<br>    &#125;<br>    time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">handler := <span class="hljs-built_in">new</span>(logHandler)<br>handler := &amp;logHandler&#123;&#125;<br><span class="hljs-comment">// 这两个是一样的都是返回一个指针</span><br></code></pre></td></tr></table></figure><h1 id="三、服务状态监控"><a href="#三、服务状态监控" class="headerlink" title="三、服务状态监控"></a>三、服务状态监控</h1><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><pre><code class=" mermaid">graph LR;客户端 --&gt; portalportal --&gt; 注册服务注册服务 --&gt; portalportal --&gt; 客户端portal --&gt; Log服务portal --&gt; Grading服务注册服务 --&gt; Log服务Log服务 --&gt; 注册服务注册服务 --&gt; Grading服务Grading服务 --&gt; 注册服务Grading服务 --&gt; Log服务</code></pre><p>由于有注册中心所以是个SOA架构的分布式。</p><p>所有的小服务都分成一个client一个server。</p><p><strong>客户端（Client）：</strong>调用远程服务的服务消费方。客户端调用远程服务就像调用本地函数一样，客户端负责序列化、反序列化、连接池管理、负载均衡、故障转移、超时管理、异步管理等。</p><p><strong>服务器端（Server）：</strong>暴露服务的服务提供方。服务器端如同实现一个本地函数一样来实现远程服务提供，服务器端需要做收发包队列、I/O线程、工作线程、序列化及反序列化等工作。</p><p><strong>注册中心：</strong>服务注册与发现的注册中心。</p><p>分布式的前世今生<a href="https://juejin.cn/post/6844903862327836685">https://juejin.cn/post/6844903862327836685</a></p><p>注册这个概念其实是将自己的handler绑定在路由上，并且启动该路由的监听从而提供服务。</p>]]></content>
    
    
    <categories>
      
      <category>Backend development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>distributed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gee系列实现</title>
    <link href="/2022/06/29/Gee%E7%B3%BB%E5%88%97%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/06/29/Gee%E7%B3%BB%E5%88%97%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Web框架-Gee"><a href="#Web框架-Gee" class="headerlink" title="Web框架 - Gee"></a>Web框架 - Gee</h1><h2 id="0-1-基本的net包"><a href="#0-1-基本的net包" class="headerlink" title="0.1 基本的net包"></a>0.1 基本的net包</h2><p>建立tcp连接的步骤(server端)</p><ol><li>设置tcp地址</li><li>设立监听对象</li><li>建立连接</li></ol><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs go">tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>listener, _ := net.ListenTCP(<span class="hljs-string">&quot;tcp&quot;</span>, tcpAddr)<br>conn, err := listener.AcceptTCP()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 创建好一个tcp的服务端</span><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优化，循环链接，要处理很多tcp请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>    listener, _ := net.ListenTCP(<span class="hljs-string">&quot;tcp&quot;</span>, tcpAddr)<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.AcceptTCP()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>          fmt.Println(err)<br>          <span class="hljs-keyword">return</span><br>          <span class="hljs-comment">// handle error</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> handleConnection(conn)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn *net.TCPConn)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>n, err := conn.Read(buf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>        <span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(conn.RemoteAddr().String() + <span class="hljs-type">string</span>(buf[<span class="hljs-number">0</span> : n])) <span class="hljs-comment">// 获取连接进来的地址 + 字符串</span><br>str := <span class="hljs-string">&quot;received success! message: &quot;</span> + <span class="hljs-type">string</span>(buf[<span class="hljs-number">0</span> : n])<br>conn.Write([]<span class="hljs-type">byte</span>(str))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(dial端)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    tcpAddr, _ := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br>    conn, _ := net.DialTCP(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-literal">nil</span>, tcpAddr)<br>    reader := bufio.NewReader(os.Stdin)<br>    <span class="hljs-keyword">for</span> &#123;<br>        bytes, _, _ := reader.ReadLine()<br>        conn.Write(bytes)<br>        rb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>        rn, _ := conn.Read(rb)<br>        fmt.Println(<span class="hljs-type">string</span>(rb[<span class="hljs-number">0</span> : rn])) <span class="hljs-comment">// string处理要不就是ASCII码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0-2-Http包"><a href="#0-2-Http包" class="headerlink" title="0.2 Http包"></a>0.2 Http包</h2><p><strong>Get请求的实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;<br>res.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;我收到了给你返回&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/test&quot;</span>, handler)<br>    server := http.Server&#123;<br>      Addr: <span class="hljs-string">&quot;:8080&quot;</span>,<br>      Handler: <span class="hljs-literal">nil</span>,<br>    &#125;<br>    server.ListenAndServe()<br>    <span class="hljs-comment">// http.ListenAndServe(&quot;:8080&quot;, nil)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么不用判断req的方法就可以实现呢get呢？因为默认是get请求？</p><p>其中为什么前者response不是指针，而后者request是指针呢？因为request是外部传来的（这个有待以后check源码）</p><p><strong>server</strong> 服务，包含地址、端口、处理器等等</p><p><strong>conn</strong> 链接，用户请求来的</p><p><strong>response</strong> 返回信息</p><p><strong>request</strong> 用户的请求信息</p><p><strong>Handle</strong> 对于接收的信息进行处理并且返回的一个处理器</p><p>Step：</p><p>1、通过 Header() 来设置头map</p><p>2、通过 WriteHeader(code) 来设置状态码</p><p>3、通过 Write 写入这个io.writer 来控制返回值</p><p>4、通过 req.Body 以请求过来的body内容</p><p>5、剩下的就是组装，e.g. 一个内置的方法，把路径当静态显示</p><p>http.Handle(“/“, http.FileServer(http.dir(“/“)))</p><p>res是我们要返回的值，req是前端传给我们的值。</p><pre><code class=" mermaid">graph LR;http请求 --&gt; DefaultServeMux;DefaultServeMux --&gt; Handler1;DefaultServeMux --&gt; Handler2;DefaultServeMux --&gt; ......;DefaultServeMux --&gt; Handler3;</code></pre><p>有自定义的handler的话就是这个样子。</p><pre><code class=" mermaid">graph LR;http请求 --&gt; myHandler;</code></pre><p>Multiplexer（多路复用器）</p><p>他也是一个handler</p><p><strong>url通用格式</strong></p><p>Scheme : // [ userinfo@ ] host / path [ ?query ] [ #fragment ]</p><p>如果从浏览器发出的请求，那么你无法提取处 Fragment 字段的值（浏览器在发送请求时会把 fragment 部分去掉）</p><h3 id="FORM-表单"><a href="#FORM-表单" class="headerlink" title="FORM 表单"></a>FORM 表单</h3><h4 id="表单的-enctype-属性"><a href="#表单的-enctype-属性" class="headerlink" title="表单的 enctype 属性"></a>表单的 enctype 属性</h4><ul><li>如果 enctype 是 application/x-www-form-urlencoded，那么浏览器会将表单数据编码到查询字符串里面。例如：</li></ul><p>​            frist_name=peter&amp;last_name=pan</p><ul><li><p>如果 enctype 是 multipart/form-data，那么</p><p>​     每一个 name-value 对都会被转换为一个MIME消息部分</p><p>​     每一个部分都有自己的 Content Type 和 Content Dispostion</p></li></ul><p><strong>如何选择呢？</strong></p><p>简单文本：表单URL编码</p><p>大量数据，例如上传文件：multipart-MIME</p><p>​        甚至可以把二进制数据通过base64编码，来当作文本进行发送</p><h4 id="FORM-字段"><a href="#FORM-字段" class="headerlink" title="FORM 字段"></a>FORM 字段</h4><p>提取Request上的字段有三个，Form，PostForm，MultipartForm</p><p>通常做法调用 ParseForm 或 ParseMultipartForm 来解析 Request，然后相应的访问 Form、PostForm 或 MultipartForm 字段</p><h4 id="PostForm-字段"><a href="#PostForm-字段" class="headerlink" title="PostForm 字段"></a>PostForm 字段</h4><p>由于表单和 URL 里有同样的 Key，那么他们都会放在一个 slice 里面，（表单在前面，url的在后面）。如果只想要表单的 key - value 对，不要 URL 的，可以使用PostForm 字段</p><p>PostForm 和 Form 只支持 application/x-www-form-urlencoded</p><p>MultipartForm 字段支持 multipart key-value 对，返回类型是个 struct 不是 map。1⃣️ key—-string，value—-[]string 2⃣️ 空的（key—-string，value—-文件）所以这个是用来传输文件的</p><p>FormValue 方法会返回 Form 字段中指定 key 对应的第一个 value，无需调用ParseForm（无需解析）</p><p>PostFromValue 相同，但如果 enctype 设为 multipart/form-data</p><h4 id="FromFile方法"><a href="#FromFile方法" class="headerlink" title="FromFile方法"></a>FromFile方法</h4><p>上传文件还有一个简便方法：FormFile（例子）</p><p>​        无需调用 ParseMultipartForm 方法</p><p>​        返回指定 key 对应的第一个 value</p><p>​        同时返回 File 和FileHeader，以及错误信息</p><p>​        如果只上传一个文件，那么这种方式会快一些        </p><h3 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a>ResponseWriter</h3><p>从服务器向客户端返回响应需要使用 ResponseWriter</p><p>ResponseWriter 是一个接口，handler 用它来返回响应</p><p>真正支撑 ResponseWriter 的幕后 struct 是非导出的 http.response</p><p><strong>Q：为什么 Handler 的 ServeHTTP(w ResponseWriter, r *Request)，只有一个是指针类型？而 w 是按值传递的吗？</strong></p><p><strong>A：</strong>ResponseWriter是一个接口它代表了一个指针，w 和 r 都是按照引用传递的</p><h4 id="Header-方法"><a href="#Header-方法" class="headerlink" title="Header 方法"></a>Header 方法</h4><p>Header 方法返回 headers 的 map，可以进行修改</p><p>修改后的 headers 将会体现在返回给客户端的 HTTP 响应里</p><h4 id="Write-方法"><a href="#Write-方法" class="headerlink" title="Write 方法"></a>Write 方法</h4><p>写入body</p><h4 id="WriteHeader-方法"><a href="#WriteHeader-方法" class="headerlink" title="WriteHeader 方法"></a>WriteHeader 方法</h4><p>WriteHeader 方法接受一个整数类型（HTTP 状态码）作为参数，并把它作为 HTTP 响应的状态码返回</p><p>如果该方法没有显式调用，那么在第一次调用 Write 方法前，会隐式的调用 WriteHeader（http.StatusOK）</p><p>​        所以 WriteHeader 主要用来发送错误类的 HTTP 状态码</p><p>调用完 WriteHeader 方法之后，仍然可以写入到 ResponseWriter，但无法再修改 header 了</p><h4 id="内置的-Response"><a href="#内置的-Response" class="headerlink" title="内置的 Response"></a>内置的 Response</h4><p>NotFound 函数，404 + 额外的信息</p><p>ServeFile 函数，从文件系统提供文件，返回给请求者</p><p>ServeContent 函数，可以请求range内的内容</p><p>Redirect 函数，重定向</p><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><pre><code class=" mermaid">graph LR;模版 --&gt; 模版引擎;数据 --&gt; 模版引擎;模版引擎 --&gt; HTML</code></pre><p>两种理想的模版引擎：1、无逻辑模版引擎 2、逻辑嵌入模版引擎</p><p>go使用的是text/template，HTML相关部分用的是html/template，是混合体</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="controller的角色"><a href="#controller的角色" class="headerlink" title="controller的角色"></a>controller的角色</h4><p>main()：设置类工作</p><p>controller：</p><p>​        静态资源</p><p>​        把不同的请求送到不同的controller进行处理</p><pre><code class=" mermaid">graph LR;前置controller --&gt; home_handler;前置controller --&gt; page1_handler;前置controller --&gt; page2_handler;</code></pre><h4 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h4><p>静态路由：一个路径对应一个页面</p><p>/home</p><p>/about</p><p>带参数的路由：根据路由参数，创建出一族不同的页面</p><p>/companies/123</p><p>/companies/Microsoft</p><h4 id="第三方路由器"><a href="#第三方路由器" class="headerlink" title="第三方路由器"></a>第三方路由器</h4><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><p>Marshal和Unmarshal</p><p>Marshal（编码）：把 go struct 转化为 json 格式</p><p>​        MarshalIndent，（内容，换行，缩进）</p><p>Unmarshal（解码）：把 json 转化为 go struct</p><p><strong>针对 string 或 bytes：</strong></p><p>​        Marshal =&gt; String</p><p>​        Unmarshal &lt;= String</p><p><strong>针对stream：</strong></p><p>​        Encode =&gt; Stream，把数据写入到 io.Writer</p><p>​        Decode &lt;= Stream，从 io.Reader 读取数据</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>创建中间件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyMiddleware <span class="hljs-keyword">struct</span> &#123;<br>  Next http.Handler<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyMiddleware)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>  <span class="hljs-comment">// 在 next handler之前做一些事情</span><br>  m.Next.ServeHTTP(w,r)<br>  <span class="hljs-comment">// 在 next handler之后做一些事情（处理一些响应里面的内容）</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中间件的用途"><a href="#中间件的用途" class="headerlink" title="中间件的用途"></a>中间件的用途</h4><ul><li><p>Logging 日志</p></li><li><p>安全</p></li><li><p>请求超时</p></li><li><p>响应压缩</p></li><li><p>拦截器</p></li></ul><h3 id="使用请求上下文"><a href="#使用请求上下文" class="headerlink" title="使用请求上下文"></a>使用请求上下文</h3><h4 id="Request-Context"><a href="#Request-Context" class="headerlink" title="Request Context"></a>Request Context</h4><p>func(*Request) Context() context.Context</p><p>​        返回当前请求的上下文</p><p>func(*Request) WithContext(ctx context.Context) context.Context</p><p>​        基于 Context 进行 ”修改“，（实际上）创建一个新的 Context</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br><br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br>    Err() <span class="hljs-type">error</span><br><br>    Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些方法都是用于读的，要更新的话得创建新的context</p><h4 id="Context-API-可以返回新-Context"><a href="#Context-API-可以返回新-Context" class="headerlink" title="Context API - 可以返回新 Context"></a>Context API - 可以返回新 Context</h4><p>WithCancel()，它有一个 CancelFunc</p><p>WithDeadline()，带有一个时间戳（time.Time）</p><p>WithTimeout()，带有一个具体的时间段（time.Duration)</p><p>WithValue()，在里面添加一些值</p><p>PS：new创建结构体返回的是一个对应类型的指针，而普通结构体的创建需要加&amp;才能是指针要不就是个普通的结构体无人指向它</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>TLS —— 传输层安全</p><h4 id="HTTP-Listener"><a href="#HTTP-Listener" class="headerlink" title="HTTP Listener"></a>HTTP Listener</h4><p>http.ListenAndServe 函数</p><p>http.ListenAndServeTLS 函数</p><p>用 https 会让http协议从1.1升级到2</p><p>他建立长连接，所以分成各种frame，可以数据类型来进行优化从而提高处理效率。</p><p>Server Push可以提前预加载好要加载的文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> pusher, ok := w.(http.Pusher); ok &#123;<br>    pusher.Push(<span class="hljs-string">&quot;/css/app.css&quot;</span>, &amp;http.PushOptions&#123;<br>      Header: http.Header&#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;text/css&quot;</span>&#125;&#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试model层</p><p>user<strong>_test</strong>.go</p><ul><li><p>测试代码所在文件的名称以 _test 结尾</p></li><li><p>对于生产编译，不会包含以 _test 结尾的文件</p></li><li><p>对于测试编译，会包含以 _test 结尾的文件</p></li></ul><p>func <strong>Test</strong>UpdatesModifiedTime( <strong>t *testing.T</strong> )</p><ul><li>测试函数名应以 Test 开头（需要导出）</li><li>函数名需要表达出被验证的特征</li><li>测试函数的参数类型是 *testing.T，它会提供测试相关的一些工具</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>Import _ “net/http/pprof”</p><ul><li>设置一些监听的 URL，它们会提供各类诊断信息</li></ul><p>go tool pprof <a href="http://localhost:8080/debug/pprof/heap">http://localhost:8080/debug/pprof/heap</a> // 内存</p><ul><li>从应用获取内存dump：应用在使用哪些内存，他们会去哪</li></ul><p>go tool pprof <a href="http://localhost:8080/debug/pprof/profile">http://localhost:8080/debug/pprof/profile</a> // CPU</p><ul><li>CPU的快照，可以看到谁在用 CPU</li></ul><p>go tool pprof <a href="http://localhost:8080/debug/pprof/block">http://localhost:8080/debug/pprof/block</a> // goroutine</p><ul><li>看到阻塞的 goroutine</li></ul><p>go tool pprof <a href="http://localhost:8080/debug/pprof/trace?second=5">http://localhost:8080/debug/pprof/trace?second=5</a> // trace</p><ul><li>监控这段时间内，什么在执行，什么在调用什么</li></ul><p><a href="http://localhost:8080/debug/pprof">http://localhost:8080/debug/pprof</a> // 网址</p><h2 id="Day-1-HTTP基础"><a href="#Day-1-HTTP基础" class="headerlink" title="Day 1 HTTP基础"></a>Day 1 HTTP基础</h2><p>在实现<code>Engine</code>之前，我们调用 <em>http.HandleFunc</em> 实现了路由和Handler的映射，也就是只能针对具体的路由写处理逻辑。比如<code>/hello</code>。但是在实现<code>Engine</code>之后，我们拦截了所有的HTTP请求，拥有了统一的控制入口。在这里我们可以自由定义路由映射的规则，也可以统一添加一些处理逻辑，例如日志、异常处理等</p><p><code>gee.go</code>内容</p><ul><li>首先定义了类型<code>HandlerFunc</code>，这是提供给框架用户的，用来定义路由映射的处理方法。我们在<code>Engine</code>中，添加了一张路由映射表<code>router</code>，key 由请求方法和静态路由地址构成，例如<code>GET-/</code>、<code>GET-/hello</code>、<code>POST-/hello</code>，这样针对相同的路由，如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法。</li><li>当用户调用<code>(*Engine).GET()</code>方法时，会将路由和处理方法注册到映射表 <em>router</em>中，<code>(*Engine).Run()</code>方法，是 <em>ListenAndServe</em> 的包装。</li><li><code>Engine</code>实现的 <em>ServeHTTP</em> 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 <em>404 NOT FOUND</em> 。</li></ul><p>第二个参数类型是接口类型 <code>http.Handler</code>，<code>Handler</code> 的定义博文中已经贴了，是从 <code>http</code> 的源码中找到的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>    ServeHTTP(w ResponseWriter, r *Request)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(address <span class="hljs-type">string</span>, h Handler)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><p>在 Go 语言中，实现了接口方法的 struct 都可以强制转换为接口类型。你可以这么写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">handler := (http.Handler)(engine) <span class="hljs-comment">// 手动转换为借口类型</span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:9999&quot;</span>, handler))<br></code></pre></td></tr></table></figure><p>然后，<code>ListenAndServe</code> 方法里面会去调用 <code>handler.ServeHTTP()</code> 方法，你感兴趣，可以在 http 的源码中找到调用的地方。但是这么写是多余的，传参时，会自动进行参数转换的。所以直接传入engine 即可。</p><p>在没有 engine 的情况下我们默认的是一个 DefaultServeMux 他负责识别所有的 handler，但他不能给 handler 分类，所以我们要引入 engine。</p><p><a href="https://blog.csdn.net/liuqun0319/article/details/106136338">https://blog.csdn.net/liuqun0319/article/details/106136338</a> 详解 type func() 用法分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>one(<span class="hljs-number">2</span>, callback)<br>&#125;<br><br><span class="hljs-comment">//需要传递函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">callback</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;i am callBack&quot;</span>)<br>fmt.Println(i)<br>&#125;<br><br><span class="hljs-comment">//main 中调用的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">one</span><span class="hljs-params">(i <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span>) &#123;<br>two(i,fun(f))<br>&#125;<br><br><span class="hljs-comment">//one() 中调用的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">two</span><span class="hljs-params">(i <span class="hljs-type">int</span>, c Call)</span></span> &#123;<br>c.call(i)<br>&#125;<br><br><span class="hljs-comment">//定义的type函数</span><br><span class="hljs-keyword">type</span> fun <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><br><span class="hljs-comment">//fun实现的Call接口的call()函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f fun)</span></span> call(i <span class="hljs-type">int</span>) &#123;<br>f(i)<br>&#125;<br><br><span class="hljs-comment">//call接口</span><br><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">interface</span> &#123;<br>call(<span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里解释清楚了上述的调用关系。首先 one() 参数中的函数调用 two() 参数中的接口，并且通过该接口为这个函数赋值，但最终真正运行的还是 one() 中的函数 callback，只不过 callback 代表着一个 fun 函数实现了一个接口，接口的功能是用来给 fun 函数赋值。如下转换</p><p><strong>流程图：</strong></p><pre><code class=" mermaid">graph LR;http请求 --&gt; engine;engine --&gt; GET请求;engine --&gt; POST请求;</code></pre><p>其中 engine 是用来鉴别请求的（有两部分），它里面有一个路由map，用来存放我们设定好的路由。第二部分就是一个ServeHTTP方法（这个是在 GET 和 POST 方法中转换的，因为go中结构体放入函数中的参数接口可以自动转换为别的类型）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 所有的handler都要有SeverHTTP这样一个函数，还要有ResponseWriter, *Request这两个参数）</span><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>   ServeHTTP(ResponseWriter, *Request)<br>&#125;<br></code></pre></td></tr></table></figure><p>engine 中的 ServeHTTP 目的是为了实现转换成 handler 的 engine 该有的接口。第一步通过 listenAndServer 将 engine 变成 handler 接口。因为变成了handler接口（如上），所以第二步 engine 也要实现 ServeHTTP 函数。第三步里面实现的内容就是 1.查找是否有对应的路由注册 2. 若查找到就直接为这个 handlerFunc 赋入参 3. 没找到就404</p><p>其中为什么可以直接写成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> handler, ok := e.Router[key]; ok &#123;<br>handler(w, r) <span class="hljs-comment">// 调用存储在 map 中的函数，执行并赋值。</span><br></code></pre></td></tr></table></figure><p>handler 本身就是个 func 类型，所以这一步就是赋值并运行。</p><h2 id="Day-2-上下文"><a href="#Day-2-上下文" class="headerlink" title="Day 2 上下文"></a>Day 2 上下文</h2><p><strong>设计Context必要性</strong></p><ol><li>对Web服务来说，无非是根据请求<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写大量重复，繁杂的代码，而且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。</li></ol><p>用返回 JSON 数据作比较，感受下封装前后的差距。</p><p>封装前</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">obj = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;geektutu&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1234&quot;</span>,<br>&#125;<br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>w.WriteHeader(http.StatusOK)<br>encoder := json.NewEncoder(w)<br><span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>    http.Error(w, err.Error(), <span class="hljs-number">500</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>VS 封装后：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">c.JSON(http.StatusOK, gee.H&#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: c.PostForm(<span class="hljs-string">&quot;username&quot;</span>),<br>    <span class="hljs-string">&quot;password&quot;</span>: c.PostForm(<span class="hljs-string">&quot;password&quot;</span>),<br>&#125;)<br></code></pre></td></tr></table></figure><p>流程图</p><pre><code class=" mermaid">graph LR;http请求 --&gt; engine;engine --&gt; router-get\post;router-get\post --&gt; PostForm;router-get\post --&gt; Query;router-get\post --&gt; Status;router-get\post --&gt; SetHeader;router-get\post --&gt; String;router-get\post --&gt; JSON;router-get\post --&gt; Data;router-get\post --&gt; HTML;</code></pre><p>最重要的还是通过实现了 ServeHTTP 接口，接管了所有的 HTTP 请求。</p><p>后面集成了常用的方法，比如JSON，HTML等等，为的就是前文提到的，这样再处理JSON请求的时候不用重复的写一遍怎么将数据转成JSON，统一转换成JSON然后响应JSON请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// origin objects</span><br>Writer http.ResponseWriter<br>Req    *http.Request<br><span class="hljs-comment">// request info</span><br>Path   <span class="hljs-type">string</span><br>Method <span class="hljs-type">string</span><br><span class="hljs-comment">// response info</span><br>StatusCode <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>本质上没有变就是在 w 和 r 的上面又封装了一层 context，这个 context 包含了一些属性比如请求中的路径和方法，响应的状态码。</p><p>把状态码的设置，响应头的内容的设置封装在 context 的方法中，Context 就像一次会话的百宝箱，可以找到任何东西。</p><ul><li>给<code>map[string]interface&#123;&#125;</code>起了一个别名<code>gee.H</code>，构建JSON数据时，显得更简洁。</li><li><code>Context</code>目前只包含了<code>http.ResponseWriter</code>和<code>*http.Request</code>，另外提供了对 Method 和 Path 这两个常用属性的直接访问。</li><li>提供了访问Query和PostForm参数的方法。</li><li>提供了快速构造String/Data/JSON/HTML响应的方法。</li></ul><p>二、区别：</p><p>1、json.NewDecoder是从一个<code>流</code>里面直接进行解码，代码精干；<br>2、json.Unmarshal是从已存在与内存中的json进行解码；<br>3、相对于解码，json.NewEncoder进行大JSON的编码比json.marshal性能高，因为内部使用pool。</p><p>三、场景应用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">encoder := json.NewEncoder(c.Writer)<br><span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>1、json.NewDecoder用于http连接与socket连接的读取与写入，或者文件读取；<br>2、json.Unmarshal用于直接是byte的输入。</p><h2 id="Day-3-前缀树路由"><a href="#Day-3-前缀树路由" class="headerlink" title="Day 3 前缀树路由"></a>Day 3 前缀树路由</h2><p>所有的路由地址其实是虚拟的地址，就是map存储，相当于一个标识。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">parts := strings.Split(url, <span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样之后 parts[0] = “”，是一个nil</p><p>我们对于路由的修改变成了，添加路由和查找路由，查找路由比较复杂一点，因为要考虑到通配符的问题。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h3><p>addRouter -&gt; getRouter -&gt; handle 在看一遍代码 走一遍流程就明了多了, 说白了就是 用前缀树结构存 前缀树结构取, 用GET /a/asd/c || GET a/s/c 匹配到路由(GET-/a/:param/c)对应的HandlerFunc 并把asd || s 存在context的Params里。</p><h3 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a><strong>BUG</strong></h3><p><strong>Q：</strong></p><p><strong>第一个 bug</strong></p><p>在 <code>trie.go</code> 里的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> insert(pattern <span class="hljs-type">string</span>, parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height &#123;<br>n.pattern = pattern<br><span class="hljs-keyword">return</span><br>&#125;<br>part := parts[height]<br>child := n.matchChild(part)<br><span class="hljs-keyword">if</span> child == <span class="hljs-literal">nil</span> &#123;<br>child = &amp;node&#123;part: part, isWild: part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> || part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span>&#125;<br>n.children = <span class="hljs-built_in">append</span>(n.children, child)<br>&#125;<br>child.insert(pattern, parts, height+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果第一次插入的<code>pattern</code>为<code>/:age</code>，<code>method</code> 为 <code>GET</code>，<code>handlefunc</code> 为 <code>handleAge()</code></p><p>那么会生成一个这样的 <code>node</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;:age&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br></code></pre></td></tr></table></figure><p>第二次插入的 <code>pattern</code> 为 <code>/18</code> ,<code>method</code> 与第一次相同，仍然为 <code>GET</code>，<code>handlefunc</code>为 <code>handle18()</code>，此时并不会修改之前的 <code>node</code>，而是修改了之前 <code>nodeAge</code> 的 <code>pattern</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;18&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br>handlers[<span class="hljs-string">&quot;GET-18&quot;</span>] =  handle18<br></code></pre></td></tr></table></figure><p>接下来看看<code>handle()</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;<br>n, params := r.getRoute(c.Method, c.Path)<br><span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>c.Params = params<br>key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + n.pattern<br>r.handlers[key](c)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.String(http.StatusNotFound, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当有一个 <code>/19</code> 的请求到来时，将会匹配到 <code>nodeAge</code>，但是由于 <code>nodeAge</code> 的 <code>pattern</code>变成了 <code>18</code>，因此将会被 <code>handle18()</code> 处理，这不太合适。</p><p><strong><code>GIN</code>的做法是将冲突的路由直接<code>panic</code>了。</strong></p><p><strong>第二个bug</strong></p><p><code>router</code>的 <code>handle</code> 方法貌似不是协程安全的</p><p>假设此时只有一个<code>/:age</code>的<code>router</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">nodeAge = node&#123;<br>    pattern:  <span class="hljs-string">&quot;:age&quot;</span>,<br>    part:     <span class="hljs-string">&quot;:age&quot;</span>,<br>    children: <span class="hljs-literal">nil</span>,<br>    isWild:   <span class="hljs-literal">true</span>,<br>&#125;<br>handlers[<span class="hljs-string">&quot;GET-:age&quot;</span>] = handleAge<br></code></pre></td></tr></table></figure><p>此时有两个请求地址分别为 <code>/18</code> 和 <code>/19</code>的请求到达。</p><p><code>handle()</code> 内的 <code>getRoute()</code> 函数得到的 <code>params</code> 分别为 <code>key:age value:18</code> 和 <code>key:age value:19</code>，它们会对<strong>同一个</strong> <code>context</code> 进行写入，因此不太安全。</p><p>在 <code>http</code> 包内的 <code>server.go</code> 文件中的 <code>Serve</code> 函数内，有这样一段注释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Serve accepts incoming connections on the Listener l, creating a</span><br><span class="hljs-comment">// new service goroutine for each. The service goroutines read requests and</span><br><span class="hljs-comment">// then call srv.Handler to reply to them.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// HTTP/2 support is only enabled if the Listener returns *tls.Conn</span><br><span class="hljs-comment">// connections and they were configured with &quot;h2&quot; in the TLS</span><br><span class="hljs-comment">// Config.NextProtos.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Serve always returns a non-nil error and closes l.</span><br><span class="hljs-comment">// After Shutdown or Close, the returned error is ErrServerClosed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><p>可见，<code>http.ListenAndServe()</code> 是有可能开启多个协程的。</p><p><strong>A：</strong></p><p>第一个bug，存在覆盖的问题，gin 的做法才是对的，应该把问题暴露给用户。<br>第二个问题，http 请求是并发的，但每一个请求都会调用 <code>ServeHTTP</code> ，这个方法中，context 每次都创建新的，不会对同一个context进行写入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>c := newContext(w, req)<br>engine.router.handle(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点：比较 parts 的长度有没有相匹配的深度就可以知道是否匹配上了，因为通配符也占位</p><h2 id="Day-4-分组控制"><a href="#Day-4-分组控制" class="headerlink" title="Day 4 分组控制"></a>Day 4 分组控制</h2><h3 id="分组的意义"><a href="#分组的意义" class="headerlink" title="分组的意义"></a>分组的意义</h3><p>分组控制(Group Control)是 Web 框架应提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如：</p><ul><li>以<code>/post</code>开头的路由匿名可访问。</li><li>以<code>/admin</code>开头的路由需要鉴权。</li><li>以<code>/api</code>开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</li></ul><p>ps：RESTful风格是 —— <strong>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</strong></p><p>parent 之前设计是用来拼接 prefix 的，每个 group 只记录自己的部分，最后通过 parent 层层回溯拼接。不过后来改用 <code>group.prefix + prefix</code> 的方式 group 初始化时已经拼接了完整的 prefix，所以不需要 <code>parent</code> 了，可以删除。</p><h2 id="Day-5-中间件"><a href="#Day-5-中间件" class="headerlink" title="Day 5 中间件"></a>Day 5 中间件</h2><p>Gee 的中间件的定义与路由映射的 Handler 一致，处理的输入是<code>Context</code>对象。插入点是框架接收到请求初始化<code>Context</code>对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对<code>Context</code>进行二次加工。c.Next()<code>表示等待执行其他的中间件或用户的</code>Handler</p><p>假设我们应用了中间件 A 和 B，和路由映射的 Handler。<code>c.handlers</code>是这样的[A, B, Handler]，<code>c.index</code>初始化为-1。调用<code>c.Next()</code>，接下来的流程是这样的：</p><ul><li>c.index++，c.index 变为 0</li><li>0 &lt; 3，调用 c.handlers[0]，即 A</li><li>执行 part1，调用 c.Next()</li><li>c.index++，c.index 变为 1</li><li>1 &lt; 3，调用 c.handlers[1]，即 B</li><li>执行 part3，调用 c.Next()</li><li>c.index++，c.index 变为 2</li><li>2 &lt; 3，调用 c.handlers[2]，即Handler</li><li>Handler 调用完毕，返回到 B 中的 part4，执行 part4</li><li>part4 执行完毕，返回到 A 中的 part2，执行 part2</li><li>part2 执行完毕，结束。</li></ul><p>一句话说清楚重点，最终的顺序是<code>part1 -&gt; part3 -&gt; Handler -&gt; part 4 -&gt; part2</code>。恰恰满足了我们对中间件的要求，接下来看调用部分的代码，就能全部串起来了。</p><p>目前的结构：</p><pre><code class=" mermaid">graph LR;http请求 --&gt; RouterGroup;RouterGroup --&gt; Engine;Engine --&gt; Context-get\post;Context-get\post --&gt; Next;Context-get\post --&gt; Param;Context-get\post --&gt; PostForm;Context-get\post --&gt; Query;Context-get\post --&gt; Status;Context-get\post --&gt; SetHeader;Context-get\post --&gt; String;Context-get\post --&gt; JSON;Context-get\post --&gt; Data;Context-get\post --&gt; HTML;</code></pre><p>每一个use都会append一个中间件，并且存储在router group中，在实现serveHTTP的时候将这些中间件函数递给context</p><p>最后在next()中启动第一个handler</p><h2 id="Day-6-模版-Template"><a href="#Day-6-模版-Template" class="headerlink" title="Day 6 模版 Template"></a>Day 6 模版 Template</h2><p>那如果我么将所有的静态文件放在<code>/usr/web</code>目录下，那么<code>filepath</code>的值即是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。</p><p>找到文件后，如何返回这一步，<code>net/http</code>库已经实现了。因此，gee 框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给<code>http.FileServer</code>处理就好了</p><p>Golang 內建提供 <a href="https://golang.org/pkg/net/http/#FileServer">http.FileServer</a> ，可以方便地透過 HTTP 存取檔案系統(file system)，例如以下程式碼執行之後，就可以透過瀏覽器打開網址 <code>http://localhost:8080</code> 瀏覽 <code>/usr/share/doc</code> 資料夾內的檔案。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, http.FileServer(http.Dir(<span class="hljs-string">&quot;/usr/share/doc&quot;</span>)))<br>&#125;<br></code></pre></td></tr></table></figure><p>可以挂载一个文件路径通过ip来访问规定的地址。</p><p>如果是一个普通的结构体是需要加指针的</p><p>如果是一个map类型他自己就是个对象不用加指针</p><p>首先为 Engine 示例添加了 <code>*template.Template</code> 和 <code>template.FuncMap</code>对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。</p><p>另外，给用户分别提供了设置自定义渲染函数<code>funcMap</code>和加载模板的方法。</p><p>接下来，对原来的 <code>(*Context).HTML()</code>方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p><p>这一块设计比较简单，RouterGroup 只做路由的事情，Engine 做全局的事情。<code>LoadHTMLGlob</code> 设计成全局的了，你可以尝试下，实现 RouterGroup 级别的模板。</p><p><code>e.HtmlTemplates = template.Must(template.New(&quot;&quot;).Funcs(e.FuncMap).ParseGlob(pattern))</code></p><p><a href="https://www.cnblogs.com/f-ck-need-u/p/10035768.html">https://www.cnblogs.com/f-ck-need-u/p/10035768.html</a></p><p><strong>使用template.New()函数可以创建一个空的、无解析数据的模板，同时还会创建一个common，也就是模板组</strong>。</p><p>也就是说，<strong>template.New()函数不仅创建了一个模板，还创建了一个空的common结构(模板组)。需要注意，新创建的common是空的，只有进行模板解析(Parse()，ParseFiles()等操作)之后，才会将模板添加到common的tmpl字段(map结构)中</strong>。</p><p>Parse()只能解析字符串，要解析文件中的内容，需要使用ParseFiles()或ParseGlob()。</p><p>template内置了一系列函数，但这些函数毕竟有限，可能无法满足特殊的需求。template允许我们定义自己的函数，添加到common中，然后就可以在待解析的内容中像使用内置函数一样使用自定义的函数。</p><p>自定义函数的优先级高于内置的函数优先级，即先检索自定义函数，再检索内置函数。也就是说，如果自定义函数的函数名和内置函数名相同，则内置函数将失效。</p><p>本文只对此稍作解释，本文的重点不是template的具体语法和用法。</p><p><strong>Golang Template</strong></p><p><a href="https://blog.csdn.net/lengyuezuixue/article/details/79367825?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;utm_relevant_index=1">https://blog.csdn.net/lengyuezuixue/article/details/79367825?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79367825-blog-79899340.pc_relevant_aa&amp;utm_relevant_index=1</a></p><h2 id="Day-7-错误恢复"><a href="#Day-7-错误恢复" class="headerlink" title="Day 7 错误恢复"></a>Day 7 错误恢复</h2><p>Gee 的错误处理机制</p><p>对一个 Web 框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。</p><p>我们在第六天实现的框架并没有加入异常处理机制，如果代码中存在会触发 panic 的 BUG，很容易宕掉。</p><h1 id="分布式缓存-GeeCache"><a href="#分布式缓存-GeeCache" class="headerlink" title="分布式缓存 - GeeCache"></a>分布式缓存 - GeeCache</h1><h2 id="Day-1-LRU缓存机制"><a href="#Day-1-LRU缓存机制" class="headerlink" title="Day 1 LRU缓存机制"></a>Day 1 LRU缓存机制</h2><h3 id="1-核心数据结构"><a href="#1-核心数据结构" class="headerlink" title="1. 核心数据结构"></a>1. 核心数据结构</h3><p><img src="https://geektutu.com/post/geecache-day1/lru.jpg" alt="implement lru algorithm with golang"></p><p>这张图很好地表示了 LRU 算法最核心的 2 个数据结构</p><ul><li>绿色的是字典(map)，存储键和值的映射关系。这样根据某个键(key)查找对应的值(value)的复杂是<code>O(1)</code>，在字典中插入一条记录的复杂度也是<code>O(1)</code>。</li><li>红色的是双向链表(double linked list)实现的队列。将所有的值放到双向链表中，这样，当访问到某个值时，将其移动到队尾的复杂度是<code>O(1)</code>，在队尾新增一条记录以及删除一条记录的复杂度均为<code>O(1)</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Cache is a LRU cache. It is not safe for concurrent access.</span><br><span class="hljs-keyword">type</span> Cache <span class="hljs-keyword">struct</span> &#123;<br>maxBytes <span class="hljs-type">int64</span><br>nbytes   <span class="hljs-type">int64</span><br>ll       *list.List<br>cache    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element<br><span class="hljs-comment">// optional and executed when an entry is purged.</span><br>OnEvicted <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>, value Value)</span></span> <span class="hljs-comment">// 驱逐</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这里我们直接使用 Go 语言标准库实现的双向链表<code>list.List</code>。</li><li>字典的定义是 <code>map[string]*list.Element</code>，键是字符串，值是双向链表中对应节点的指针。</li><li><code>maxBytes</code> 是允许使用的最大内存，<code>nbytes</code> 是当前已使用的内存，<code>OnEvicted</code> 是某条记录被移除时的回调函数，可以为 nil。</li><li>键值对 <code>entry</code> 是双向链表节点的数据类型，在链表中仍保存每个值对应的 key 的好处在于，淘汰队首节点时，需要用 key 从字典中删除对应的映射。</li><li>为了通用性，我们允许值是实现了 <code>Value</code> 接口的任意类型，该接口只包含了一个方法 <code>Len() int</code>，用于返回值所占用的内存大小。</li></ul><h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h3><p>查找主要有 2 个步骤，第一步是从字典中找到对应的双向链表的节点，第二步，将该节点移动到队尾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get look ups a key&#x27;s value</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Get(key <span class="hljs-type">string</span>) (value Value, ok <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;<br>c.ll.MoveToFront(ele)<br>kv := ele.Value.(*entry)<br><span class="hljs-keyword">return</span> kv.value, <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果键对应的链表节点存在，则将对应节点移动到队尾，并返回查找到的值。</li><li><code>c.ll.MoveToFront(ele)</code>，即将链表中的节点 <code>ele</code> 移动到队尾（双向链表作为队列，队首队尾是相对的，在这里约定 front 为队尾）</li></ul><p>其中<code>kv := ele.Value.(*entry)</code></p><p>一个简单的断言表达式：</p><p>var s = x.(T)</p><p>如果 x 不是 nil，且 x 可以转换成 T 类型，就会断言成功，返回 T 类型的变量 s。如果 T 不是接口类型，则要求 x 的类型就是 T（或者包含x），如果 T 是一个接口，要求 x 实现了 T 接口。</p><p>如果断言类型成立，则表达式返回值就是 T 类型的 x，如果断言失败就会触发 panic。</p><p>上述表所示再断言失败就会 panic，go 提供了另外一种带返回是否成立的断言语法：</p><p>s, ok := x.(T)</p><p>该方法和第一种差不多一样，但是 ok 会返回是否断言成功不会出现 panic，ok 就表示是否是成功了。</p><h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3. 删除"></a>3. 删除</h3><p>这里的删除，实际上是缓存淘汰。即移除最近最少访问的节点（队首）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RemoveOldest removes the oldest item</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> RemoveOldest() &#123;<br>ele := c.ll.Back()<br><span class="hljs-keyword">if</span> ele != <span class="hljs-literal">nil</span> &#123;<br>c.ll.Remove(ele)<br>kv := ele.Value.(*entry)<br><span class="hljs-built_in">delete</span>(c.cache, kv.key)<br>c.nbytes -= <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(kv.key)) + <span class="hljs-type">int64</span>(kv.value.Len())<br><span class="hljs-keyword">if</span> c.OnEvicted != <span class="hljs-literal">nil</span> &#123;<br>c.OnEvicted(kv.key, kv.value)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>c.ll.Back()</code> 取到队首节点，从链表中删除。</li><li><code>delete(c.cache, kv.key)</code>，从字典中 <code>c.cache</code> 删除该节点的映射关系。</li><li>更新当前所用的内存 <code>c.nbytes</code>。</li><li>如果回调函数 <code>OnEvicted</code> 不为 nil，则调用回调函数。</li></ul><h3 id="4-新增-修改"><a href="#4-新增-修改" class="headerlink" title="4. 新增/修改"></a>4. 新增/修改</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Add adds a value to the cache.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Add(key <span class="hljs-type">string</span>, value Value) &#123;<br><span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;<br>c.ll.MoveToFront(ele)<br>kv := ele.Value.(*entry)<br>c.nbytes += <span class="hljs-type">int64</span>(value.Len()) - <span class="hljs-type">int64</span>(kv.value.Len())<br>kv.value = value<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)<br>c.cache[key] = ele<br>c.nbytes += <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(key)) + <span class="hljs-type">int64</span>(value.Len())<br>&#125;<br><span class="hljs-keyword">for</span> c.maxBytes != <span class="hljs-number">0</span> &amp;&amp; c.maxBytes &lt; c.nbytes &#123;<br>c.RemoveOldest()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果键存在，则更新对应节点的值，并将该节点移到队尾。</li><li>不存在则是新增场景，首先队尾添加新节点 <code>&amp;entry&#123;key, value&#125;</code>, 并字典中添加 key 和节点的映射关系。</li><li>更新 <code>c.nbytes</code>，如果超过了设定的最大值 <code>c.maxBytes</code>，则移除最少访问的节点。</li></ul><p>最后，为了方便测试，我们实现 <code>Len()</code> 用来获取添加了多少条数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Len the number of cache entries</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> c.ll.Len()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Day-2-单机并发缓存"><a href="#Day-2-单机并发缓存" class="headerlink" title="Day 2 单机并发缓存"></a>Day 2 单机并发缓存</h2><h3 id="1-支持并发读写"><a href="#1-支持并发读写" class="headerlink" title="1. 支持并发读写"></a>1. 支持并发读写</h3><p>接下来我们使用 <code>sync.Mutex</code> 封装 LRU 的几个方法，使之支持并发的读写。在这之前，我们抽象了一个只读数据结构 <code>ByteView</code> 用来表示缓存值，是 GeeCache 主要的数据结构之一。</p><ul><li>ByteView 只有一个数据成员，<code>b []byte</code>，b 将会存储真实的缓存值。选择 byte 类型是为了能够支持任意的数据类型的存储，例如字符串、图片等。</li><li>实现 <code>Len() int</code> 方法，我们在 lru.Cache 的实现中，要求被缓存对象必须实现 Value 接口，即 <code>Len() int</code> 方法，返回其所占的内存大小。</li><li><code>b</code> 是只读的，使用 <code>ByteSlice()</code> 方法返回一个拷贝，防止缓存值被外部程序修改。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cache <span class="hljs-keyword">struct</span> &#123;<br>mu         sync.Mutex<br>lru        *lru.Cache<br>cacheBytes <span class="hljs-type">int64</span> <span class="hljs-comment">// cache的内容长度</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>主体结构Group</strong></p><p>Group 是 GeeCache 最核心的数据结构，负责与用户的交互，并且控制缓存值存储和获取的流程。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">                            <span class="hljs-comment">是</span><br><span class="hljs-comment">接收 key</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-comment">检查是否被缓存</span> <span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">返回缓存值 ⑴</span><br>                <span class="hljs-comment">|  否                         是</span><br>                <span class="hljs-comment">|</span><span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">是否应当从远程节点获取</span> <span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">与远程节点交互</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-comment">返回缓存值 ⑵</span><br>                            <span class="hljs-comment">|  否</span><br>                            <span class="hljs-comment">|</span><span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">调用`回调函数`，获取值并添加到缓存</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-comment">返回缓存值 ⑶</span><br></code></pre></td></tr></table></figure><p>我们将在 <code>geecache.go</code> 中实现主体结构 Group，那么 GeeCache 的代码结构的雏形已经形成了。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">geecache/<br>    |<span class="hljs-params">--lru/</span><br>        |<span class="hljs-params">--lru</span>.go  <span class="hljs-string">//</span> lru 缓存淘汰策略<br>    |<span class="hljs-params">--byteview</span>.go <span class="hljs-string">//</span> 缓存值的抽象与封装<br>    |<span class="hljs-params">--cache</span>.go    <span class="hljs-string">//</span> 并发控制<br>    |<span class="hljs-params">--geecache</span>.go <span class="hljs-string">//</span> 负责与外部交互，控制缓存存储和获取的主流程<br></code></pre></td></tr></table></figure><p>接下来我们将实现流程 ⑴ 和 ⑶，远程交互的部分后续再实现。</p><p>我们思考一下，如果缓存不存在，应从数据源（文件，数据库等）获取数据并添加到缓存中。GeeCache 是否应该支持多种数据源的配置呢？不应该，一是数据源的种类太多，没办法一一实现；二是扩展性不好。如何从源头获取数据，应该是用户决定的事情，我们就把这件事交给用户好了。因此，我们设计了一个回调函数(callback)，在缓存不存在时，调用这个函数，得到源数据。</p><p>GetGroup()</p><ul><li>一个 Group 可以认为是一个缓存的命名空间，每个 Group 拥有一个唯一的名称 <code>name</code>。比如可以创建三个 Group，缓存学生的成绩命名为 scores，缓存学生信息的命名为 info，缓存学生课程的命名为 courses。</li><li>第二个属性是 <code>getter Getter</code>，即缓存未命中时获取源数据的回调(callback)。</li><li>第三个属性是 <code>mainCache cache</code>，即一开始实现的并发缓存。</li><li>构建函数 <code>NewGroup</code> 用来实例化 Group，并且将 group 存储在全局变量 <code>groups</code> 中。</li><li><code>GetGroup</code> 用来特定名称的 Group，这里使用了只读锁 <code>RLock()</code>，因为不涉及任何冲突变量的写操作。</li></ul><h2 id="Day-3-HTTP-服务端"><a href="#Day-3-HTTP-服务端" class="headerlink" title="Day 3 HTTP 服务端"></a>Day 3 HTTP 服务端</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">url := <span class="hljs-string">&quot;/_geecache/scores/Tom&quot;</span><br>basePath := <span class="hljs-string">&quot;/_geecache/&quot;</span><br>fmt.Println(url[<span class="hljs-built_in">len</span>(basePath):])<br>parts := strings.SplitN(url[<span class="hljs-built_in">len</span>(basePath):],<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">2</span>)<br>fmt.Println(strings.SplitN(url[<span class="hljs-built_in">len</span>(basePath):],<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">2</span>))<br>fmt.Printf(<span class="hljs-string">&quot;parts[0]: %s\n&quot;</span>, parts[<span class="hljs-number">0</span>])<br>fmt.Printf(<span class="hljs-string">&quot;parts[1]: %s\n&quot;</span>, parts[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>注意这里的切片basePath是有两个/，所以后面不用+1</p><h2 id="Day-4-一致性Hash"><a href="#Day-4-一致性Hash" class="headerlink" title="Day 4 一致性Hash"></a>Day 4 一致性Hash</h2><h3 id="1-为什么使用一致性Hash"><a href="#1-为什么使用一致性Hash" class="headerlink" title="1.为什么使用一致性Hash"></a>1.为什么使用一致性Hash</h3><h4 id="1-1-我该访问谁？"><a href="#1-1-我该访问谁？" class="headerlink" title="1.1 我该访问谁？"></a>1.1 我该访问谁？</h4><p>对于分布式缓存来说，当一个节点接收到请求，如果该节点并没有存储缓存值，那么它面临的难题是，从谁那获取数据？自己，还是节点1, 2, 3, 4… 。假设包括自己在内一共有 10 个节点，当一个节点接收到请求时，随机选择一个节点，由该节点从数据源获取数据。</p><p>假设第一次随机选取了节点 1 ，节点 1 从数据源获取到数据的同时缓存该数据；那第二次，只有 1/10 的可能性再次选择节点 1, 有 9/10 的概率选择了其他节点，如果选择了其他节点，就意味着需要再一次从数据源获取数据，一般来说，这个操作是很耗时的。这样做，一是缓存效率低，二是各个节点上存储着相同的数据，浪费了大量的存储空间。</p><p>那有什么办法，对于给定的 key，每一次都选择同一个节点呢？使用 hash 算法也能够做到这一点。那把 key 的每一个字符的 ASCII 码加起来，再除以 10 取余数可以吗？当然可以，这可以认为是自定义的 hash 算法。</p><p><img src="https://geektutu.com/post/geecache-day4/hash_select.jpg" alt="hash select peer"></p><p>从上面的图可以看到，任意一个节点任意时刻请求查找键 <code>Tom</code> 对应的值，都会分配给节点 2，有效地解决了上述的问题。</p><h5 id="1-2-节点数量变化了怎么办？"><a href="#1-2-节点数量变化了怎么办？" class="headerlink" title="1.2 节点数量变化了怎么办？"></a>1.2 节点数量变化了怎么办？</h5><p>简单求取 Hash 值解决了缓存性能的问题，但是没有考虑节点数量变化的场景。假设，移除了其中一台节点，只剩下 9 个，那么之前 <code>hash(key) % 10</code> 变成了 <code>hash(key) % 9</code>，也就意味着几乎缓存值对应的节点都发生了改变。即几乎所有的缓存值都失效了。节点在接收到对应的请求时，均需要重新去数据源获取数据，容易引起 <code>缓存雪崩</code>。</p><blockquote><p>缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。常因为缓存服务器宕机，或缓存设置了相同的过期时间引起。</p></blockquote><p>那如何解决这个问题呢？一致性哈希算法可以。</p><p>一致性哈希算法将 key 映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ChecksumIEEE</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">uint32</span><br></code></pre></td></tr></table></figure><p> ChecksumIEEE 使用 IEEE 多项式返回数据的 CRC-32 校验和。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">uint32</span> <span class="hljs-type">uint32</span><br></code></pre></td></tr></table></figure><p>uint32 is the set of all unsigned 32-bit integers. Range: 0 through 4294967295</p><h3 id="Go标准库是如何实现二分查找的？"><a href="#Go标准库是如何实现二分查找的？" class="headerlink" title="Go标准库是如何实现二分查找的？"></a>Go标准库是如何实现二分查找的？</h3><p>我们先看一下标准库中的代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span><span class="hljs-params">(n <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// Define f(-1) == false and f(n) == true.</span><br>    <span class="hljs-comment">// Invariant: f(i-1) == false, f(j) == true.</span><br>    i, j := <span class="hljs-number">0</span>, n<br>    <span class="hljs-keyword">for</span> i &lt; j &#123;<br>        h := <span class="hljs-type">int</span>(<span class="hljs-type">uint</span>(i+j) &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// avoid overflow when computing h</span><br>        <span class="hljs-comment">// i ≤ h &lt; j</span><br>        <span class="hljs-keyword">if</span> !f(h) &#123;<br>            i = h + <span class="hljs-number">1</span> <span class="hljs-comment">// preserves f(i-1) == false</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = h <span class="hljs-comment">// preserves f(j) == true 因为是开区间所以，j = h</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.</span><br>    <span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure><p>🌟这个函数返回的是我们要找的index距离他最小的坐标（0开始）</p><p>初一看，与我们上面的实现一点也不同呢，我们来分析一下。</p><p>入参<code>n</code>就是代表要查找序列的长度，入参<code>f</code>就是我们自定义的条件。这段代码很短，大概思路就是：</p><ul><li>定义好这段序列的开始、结尾的位置</li><li>使用位移操作获取中位数，这样能更好的避免溢出</li><li>然后根据我们传入的条件判断是否符合条件，逐渐缩小范围</li></ul><p>这段代码与我实现的不同在于，它并不是在用户传入的比较函数<code>f</code>返回<code>true</code>就结束查找，而是继续在当前<code>[i, j)</code>区间的前半段查找，并且，当<code>f</code>为<code>false</code>时，也不比较当前元素与要查找的元素的大小关系，而是直接在后半段查找。所以<code>for</code>循环退出的唯一条件就是<code>i&gt;=j</code>，如果我们这样使用，就会出现问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nums := []<span class="hljs-type">int64</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br>    fmt.Println(sort.Search(<span class="hljs-built_in">len</span>(nums), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> nums[i] == <span class="hljs-number">1</span><br>    &#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果竟然是<code>7</code>，而不是<code>1</code>，如果我们把条件改成<code>return nums[i] &gt;=1</code>，运行结果就对了。这是因为我们传入的条件并不是让用户确认目标条件，这里的思想是让我们逐步缩小范围，通过这个条件，我们每次都可以缩小范围，说的有点饶，就上面的代码举个例子。现在是一个升序数组，我们要找的数值是<code>1</code>，我们传入的条件是<code>return nums[i]&gt;=1</code>，第一进入函数<code>Search</code>，我们获取中的中位数<code>h</code>是<code>3</code>，当前元素是大于目标数值的，所以我们只能在前半段查找，就是这样不断缩小范围，找到我们最终的那个数值，如果当前序列中没有我们要找的目标数值，那么就会返回我们可以插入的位置，也就是最后一位元素的坐标+1的位置。</p><p>这个逻辑说实话，我也是第一次接触，仔细思考了一下，这种实现还是有一些优点的：</p><ul><li>使用<strong>移位操作</strong>，避免因为<code>i+j</code>太大而造成的溢出</li><li>如果我们查找序列中有多个元素相等时，且我们要找的元素就是这个时，我们总会找到下标最小的那个元素</li><li>如果我们没找到要找的目标元素时，返回的下标是我们可插入的位置，我们在进行数据插入时，依然可以保证数据的有序</li></ul><p>🌟<strong>注意：使用<code>sort.Search</code>时，入参条件是根据要查找的序列是升序序列还是降序序列来决定的，如果是升序序列，则传入的条件应该是<code>&gt;=目标元素值</code>，如果是降序序列，则传入的条件应该是<code>&lt;=目标元素值</code></strong></p><p>解析<code>int(uint(i+j) &gt;&gt; 1)</code>这段代码</p><p>这里我想单独解析一下这段代码，因为很少见，所以可以当作一个知识点记一下。这里使用到的是移位操作，通过向右移动一位，正好可以得到<code>/2</code>的结果。具体什么原因呢，我画了一个图，手工画的，看完你就懂了：</p><p><img src="https://segmentfault.com/img/remote/1460000040178986" alt="img"></p><p>懂了吧，兄弟们！移位实现要比乘除发的效率高很多，我们在平常开发中可以使用这种方式来提升效率。</p><p>这里还有一个点就是使用<code>uint</code>数据类型，因为<code>uint</code>的数据范围是<code>2^32</code>即<code>0</code>到<code>4294967295</code>。使用<code>uint</code>可以避免因为<code>i+j</code>太大而造成的溢出。</p><div class="table-container"><table><thead><tr><th>运算符</th><th>说明</th><th>范例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td><td>A &amp; B</td></tr><tr><td>\</td><td></td><td>按位或</td><td>A \</td><td>B</td></tr><tr><td>^</td><td>按位异或</td><td>A ^ B</td></tr><tr><td>&lt;&lt;</td><td>左移运算符</td><td>A &lt;&lt; 2</td></tr><tr><td><code>&gt;&gt;</code></td><td>右移运算符</td><td>A &gt;&gt; 2</td></tr></tbody></table></div><p><strong>说明</strong></p><div class="table-container"><table><thead><tr><th>运算符</th><th>说明</th><th>功能</th><th>运算规则</th></tr></thead><tbody><tr><td>按位与</td><td>双目运算符</td><td>参与运算的两数各对应的二进制位相与</td><td>如果两数对应的二进制位都为 1，那么结果为 1， 否则结果为 0。</td></tr><tr><td>按位或</td><td>双目运算符</td><td>参与运算的两数各对应的二进制位相或</td><td>如果两数对应的二进制位有一个为 1，那么结果为 1， 否则结果为 0。</td></tr><tr><td>按位异或</td><td>双目运算符</td><td>参与运算的两数各对应的二进制位相异或</td><td>如果两数对应的二进制位不同，那么结果为 1， 否则结果为 0。</td></tr><tr><td>左移</td><td>双目运算符</td><td>把运算符 <code>&lt;&lt;</code> 左边的运算数的各二进制位全部左移若干位，高位丢弃，低位补 0。</td><td>左移 N 位，就是乘以 2 的 N 次方。</td></tr><tr><td>右移</td><td>双目运算符</td><td>把运算符 <code>&lt;&lt;</code> 左边的运算数的各二进制位全部右移若干位。</td><td>右移 N 位，就是除以 2 的 N 次方。</td></tr></tbody></table></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get gets the closest item in the hash to the provided key.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Get(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(m.keys) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br>hash := <span class="hljs-type">int</span>(m.hash([]<span class="hljs-type">byte</span>(key)))<br><span class="hljs-comment">// Binary search for appropriate replica.</span><br>idx := sort.Search(<span class="hljs-built_in">len</span>(m.keys), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> m.keys[i] &gt;= hash<br>&#125;)<br><br><span class="hljs-keyword">return</span> m.hashMap[m.keys[idx%<span class="hljs-built_in">len</span>(m.keys)]]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>选择节点就非常简单了，第一步，计算 key 的哈希值。</li><li>第二步，顺时针找到第一个匹配的虚拟节点的下标 <code>idx</code>，从 m.keys 中获取到对应的哈希值。如果 <code>idx == len(m.keys)</code>，说明应选择 <code>m.keys[0]</code>，因为 <code>m.keys</code> 是一个环状结构，所以用取余数的方式来处理这种情况。</li><li>第三步，通过 <code>hashMap</code> 映射得到真实的节点。</li></ul><p>至此，整个一致性哈希算法就实现完成了。</p><p>🌟流程是先有hash的key，通过key我们再进行查找对应的节点的hash，通过hash作为hashMap的key找到hashMap里面的存值（真实节点）这就是<code>return m.hashMap[m.keys[idx%len(m.keys)]]</code>的意义。</p><p>idx%len(m.keys)是成环形的关键，保证如果超过目前设立的所有节点（虚 + 实）就默认找一圈找到下标0的位置。</p><p>keys数组存的是下标连续的hash值，所以必定通过go的二分查找能找到一个已存在的节点，如果比已存在的A节点小的话就插在A的位置（下标相同）</p><h2 id="Day-5-分布式节点"><a href="#Day-5-分布式节点" class="headerlink" title="Day 5 分布式节点"></a>Day 5 分布式节点</h2><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">使用一致性哈希选择节点        是                                    是</span><br>    <span class="hljs-comment">|</span><span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">是否是远程节点</span> <span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">HTTP 客户端访问远程节点</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-comment">成功？</span><span class="hljs-literal">-----</span>&gt; <span class="hljs-comment">服务端返回返回值</span><br>                    <span class="hljs-comment">|  否                                    ↓  否</span><br>                    <span class="hljs-comment">|</span><span class="hljs-literal">----------------------------</span>&gt; <span class="hljs-comment">回退到本地节点处理。</span><br></code></pre></td></tr></table></figure><p>默认格式<code>%v</code>下，对于不同的数据类型，底层会去调用默认的格式化方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">bool</span>:                    %t <br><span class="hljs-type">int</span>, <span class="hljs-type">int8</span> etc.:          %d <br><span class="hljs-type">uint</span>, <span class="hljs-type">uint8</span> etc.:        %d, %x <span class="hljs-keyword">if</span> printed with %#v<br><span class="hljs-type">float32</span>, <span class="hljs-type">complex64</span>, etc: %g<br><span class="hljs-type">string</span>:                  %s<br><span class="hljs-keyword">chan</span>:                    %p <br>pointer:                 %p<br></code></pre></td></tr></table></figure><h3 id="func-QueryEscape"><a href="#func-QueryEscape" class="headerlink" title="func QueryEscape"></a>func QueryEscape</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QueryEscape</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>QueryEscape函数对s进行转码使之可以安全的用在URL查询里。</p><h3 id="func-QueryUnescape"><a href="#func-QueryUnescape" class="headerlink" title="func QueryUnescape"></a>func QueryUnescape</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QueryUnescape</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>QueryUnescape函数用于将QueryEscape转码的字符串还原。它会把%AB改为字节0xAB，将’+’改为’ ‘。如果有某个%后面未跟两个十六进制数字，本函数会返回错误。</p><p>http.Get()就是发送一个get请求</p><p>当Point.Distance被第一个包装方法调用时，它的接收器值是p.Point，而不是p，当然了，在Point类的方法里，你是访问不到ColoredPoint的任何字段的。</p><p>在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中(译注：访问需要通过该指针指向的对象去取)。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。下面这个ColoredPoint的声明内嵌了一个*Point的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> car <span class="hljs-keyword">struct</span> &#123;<br>e     engine<br>price <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> engine <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>size <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e engine)</span></span> start() &#123;<br>fmt.Println(<span class="hljs-string">&quot;engine start...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ChangeName</span><span class="hljs-params">(e engine, newName <span class="hljs-type">string</span>)</span></span> &#123;<br>e.name = newName<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>car := &amp;car&#123;<br>e: engine&#123;<br>name: <span class="hljs-string">&quot;HONDA&quot;</span>,<br>size: <span class="hljs-number">200</span>,<br>&#125;,<br>price: <span class="hljs-number">9999</span>,<br>&#125;<br>car.e.start()<br>ChangeName(car.e, <span class="hljs-string">&quot;KTM&quot;</span>)<br>fmt.Println(car.e.name)<br>&#125;<br><br>engine start...<br>HONDA<br></code></pre></td></tr></table></figure><p>这时如果结构体作为形参传入函数中，当时不是按照地址传递而是值传递是无法修改的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> car <span class="hljs-keyword">struct</span> &#123;<br>e     *engine<br>price <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> engine <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>size <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e engine)</span></span> start() &#123;<br>fmt.Println(<span class="hljs-string">&quot;engine start...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ChangeName</span><span class="hljs-params">(e *engine, newName <span class="hljs-type">string</span>)</span></span> &#123;<br>e.name = newName<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>car := &amp;car&#123;<br>e: &amp;engine&#123;<br>name: <span class="hljs-string">&quot;HONDA&quot;</span>,<br>size: <span class="hljs-number">200</span>,<br>&#125;,<br>price: <span class="hljs-number">9999</span>,<br>&#125;<br>car.e.start()<br>ChangeName(car.e, <span class="hljs-string">&quot;KTM&quot;</span>)<br>fmt.Println(car.e.name)<br>&#125;<br><br>engine start...<br>KTM<br></code></pre></td></tr></table></figure><p>这时是地址传递才能改变内部的值</p><ul><li><code>Set()</code> 方法实例化了一致性哈希算法，并且添加了传入的节点。</li><li>并为每一个节点创建了一个 HTTP 客户端 <code>httpGetter</code>。</li><li><code>PickerPeer()</code> 包装了一致性哈希算法的 <code>Get()</code> 方法，根据具体的 key，选择节点，返回节点对应的 HTTP 客户端。</li></ul><p>至此，HTTPPool 既具备了提供 HTTP 服务的能力，也具备了根据具体的 key，创建 HTTP 客户端从远程节点获取缓存值的能力。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>    <span class="hljs-comment">// 第一个参数是命令行key，第二个参数是默认是，第三个参数是 .exe -h 提示 </span><br>    <span class="hljs-keyword">var</span> user = flag.String(<span class="hljs-string">&quot;user&quot;</span>， <span class="hljs-string">&quot;root&quot;</span>， <span class="hljs-string">&quot;用户名&quot;</span>) <br>    <span class="hljs-keyword">var</span> port = flag.Int(<span class="hljs-string">&quot;port&quot;</span>， <span class="hljs-number">3306</span>， <span class="hljs-string">&quot;端口&quot;</span>) <br>    <span class="hljs-keyword">var</span> ip = flag.String(<span class="hljs-string">&quot;ip&quot;</span>， <span class="hljs-string">&quot;localhost&quot;</span>， <span class="hljs-string">&quot;mysql ip&quot;</span>) <br> <br>    <span class="hljs-comment">//必须使用flag.Parse()解析一下命令行参数 </span><br>    flag.Parse() <br>    <span class="hljs-comment">//flag.Type返回的是一个指针，必须通过 *变量取值 </span><br>    fmt.Println(*user，*port，*ip) <br>&#125; <br></code></pre></td></tr></table></figure><p><strong>使用情境</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">trap</span> <span class="hljs-string">&#x27;rm -f &quot;/var/tmp/CJK.text&quot;&#x27;</span> EXIT<br><span class="hljs-comment">#當腳本遇上 EXIT 就會執行 rm -f &quot;/var/tmp/CJK.txt&quot;。</span><br></code></pre></td></tr></table></figure><p>常用於退出腳本時清理檔案，或是執行錯誤時退出腳本。</p><p>如果當退出要執行多行指令可以使用呼叫函式的方式，使用舉例如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">Exit_safely</span></span> ()&#123;<br>  command1<br>  command2<br>  command3<br>&#125;<br><span class="hljs-built_in">trap</span> Exit_safely EXIT<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;rm server;kill 0&quot;</span> EXIT<br><br>go build -o server<br>./server -port=8001 &amp;<br>./server -port=8002 &amp;<br>./server -port=8003 -api=1 &amp;<br><br><span class="hljs-built_in">sleep</span> 2<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt; start test&quot;</span><br>curl <span class="hljs-string">&quot;http://localhost:9999/api?key=Tom&quot;</span><br>curl <span class="hljs-string">&quot;http://localhost:9999/api?key=Tom&quot;</span><br>curl <span class="hljs-string">&quot;http://localhost:9999/api?key=Tom&quot;</span><br><br><span class="hljs-built_in">wait</span><br></code></pre></td></tr></table></figure><p>wait(参数)  使用 wait 是在等待上一批或上一个脚本执行完（即上一个的进程终止），再执行wait之后的命令。</p><h2 id="Day-6-防止缓存击穿"><a href="#Day-6-防止缓存击穿" class="headerlink" title="Day 6 防止缓存击穿"></a>Day 6 防止缓存击穿</h2><blockquote><p><strong>缓存雪崩</strong>：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。</p><p><strong>缓存击穿</strong>：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。</p><p><strong>缓存穿透</strong>：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。</p></blockquote><h2 id="Day-7-使用-Protobuf-通信"><a href="#Day-7-使用-Protobuf-通信" class="headerlink" title="Day 7 使用 Protobuf 通信"></a>Day 7 使用 Protobuf 通信</h2><p>protobuf 广泛地应用于远程过程调用(RPC) 的二进制传输，使用 protobuf 的目的非常简单，为了获得更高的性能。传输前使用 protobuf 编码，接收方再进行解码，可以显著地降低二进制传输的大小。另外一方面，protobuf 可非常适合传输结构化数据，便于通信字段的扩展。</p><p>使用 protobuf 一般分为以下 2 步：</p><ul><li>按照 protobuf 的语法，在 <code>.proto</code> 文件中定义数据结构，并使用 <code>protoc</code> 生成 Go 代码（<code>.proto</code>文件是跨平台的，还可以生成 C、Java 等其他源码文件）。</li><li>在项目代码中引用生成的 Go 代码。</li></ul><p><code>option go_package = &quot;./&quot;; // 指定生成的go文件所在path</code></p><h1 id="ORM框架-GeeORM"><a href="#ORM框架-GeeORM" class="headerlink" title="ORM框架 - GeeORM"></a>ORM框架 - GeeORM</h1><h2 id="Day-0-序言"><a href="#Day-0-序言" class="headerlink" title="Day 0 序言"></a>Day 0 序言</h2><p>go的反射</p><ul><li><code>reflect.ValueOf()</code> 获取指针对应的反射值。</li><li><code>reflect.Indirect()</code> 获取指针指向的对象的反射值。</li><li><code>(reflect.Type).Name()</code> 返回类名(字符串)。</li><li><code>(reflect.Type).Field(i)</code> 获取第 i 个成员变量。</li></ul><p>并发协程之间不需要消息传递，非常适合 <code>sync.WaitGroup</code>。</p><ul><li>wg.Add(1) 锁加1。</li><li>wg.Wait() 阻塞，直到锁被释放。</li><li>wg.Done() 锁减1。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Backend development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP, UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang原理</title>
    <link href="/2022/06/18/golang%E5%8E%9F%E7%90%86/"/>
    <url>/2022/06/18/golang%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Slice"><a href="#1-Slice" class="headerlink" title="1. Slice"></a>1. Slice</h1><p>slice的扩容的内存分配，两大部分，先进行容量预估，再进行内存分配。</p><p>第一步查看是否是扩容后的cap是否大于原来cap的两倍，如果大于则更新为扩容后cap；如果小于的话则进行第二步。</p><p>第二步查看更新后的cap的大小，如果cap &lt; 1024 则 cap <em> 2，如果cap &gt; 1024 则 cap </em> 1.25。</p><p>第三步根据内存分配进行选择，内存占用为cap * 对应数据结构的字节数，向上取整</p><h1 id="2-结构体和内存对齐"><a href="#2-结构体和内存对齐" class="headerlink" title="2. 结构体和内存对齐"></a>2. 结构体和内存对齐</h1><p>8根地址总线，对应256个地址，可以操作256个地址，所以可以用的最高的内存数为256byte</p><p>32根地址总线，对应2^32 - 1个地址，可以操作4G个地址，所以可以用的最高的内存数为4G</p><p>（<strong>32位系统</strong> <strong>32位系统</strong>使用<strong>32位</strong>地址线的<strong>最大</strong>寻址空间为2的<strong>32</strong>次方bytes，计算后即4294967296 Bytes，也就是我们常说的4096MB，<strong>32位</strong>地址线的寻址空间封顶即为4GB）</p><p>64根地址总线，对应2^64 - 1个地址，可以操作128G个地址，所以可以用的最高的内存数为128G</p><p>（相对来说，<strong>64位</strong>操作<strong>系统</strong>支持的<strong>内存</strong>大小是2的<strong>64</strong>次方，相当于128GB<strong>内存</strong>，<strong>最大</strong>支持32<strong>位系统</strong>的32倍数，现在来说，128GB<strong>内存</strong>支持是理论值，但是在实际运用过程中很少需要这么大的，现阶段主流电脑一般都是8GB<strong>内存</strong>大一些16GB/32GB）</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>编程语言规定自己的数据类型的长度，比如int16长度为2字节（2*8byte）</p><p><strong>换算关系 </strong> 8bit(位)=1Byte(<strong>字节</strong>)； 1024Byte(<strong>字节</strong>)=1KB； 1024KB=1MB； 1024MB=1GB</p><p>1字节（byte）= 8位（bit）</p><p>RegSize是对齐边界</p><div class="table-container"><table><thead><tr><th></th><th>64位平台</th><th></th><th>32位平台</th><th></th></tr></thead><tbody><tr><td>类型</td><td>大小</td><td>RegSize</td><td>大小</td><td>RegSize</td></tr><tr><td>int8</td><td>1 byte ✅</td><td>8 byte</td><td>1 byte ✅</td><td>4 byte</td></tr><tr><td>int16</td><td>2 byte ✅</td><td>8 byte</td><td>2 byte ✅</td><td>4 byte</td></tr><tr><td>int32</td><td>4 byte ✅</td><td>8 byte</td><td>4 byte ✅</td><td>4 byte</td></tr><tr><td>int64</td><td>8 byte ✅</td><td>8 byte</td><td>8 byte</td><td>4 byte ✅</td></tr><tr><td>string</td><td>16 byte</td><td>8 byte ✅</td><td>8 byte</td><td>4 byte ✅</td></tr><tr><td>Slice</td><td>24 byte</td><td>8 byte ✅</td><td>12 byte</td><td>4 byte ✅</td></tr></tbody></table></div><p>这样的对齐方式不会浪费内存</p><h2 id="结构体的内存对齐"><a href="#结构体的内存对齐" class="headerlink" title="结构体的内存对齐"></a>结构体的内存对齐</h2><p><img src="https://cdn.jsdeliver.net/gh/PanyuHaa/PicGo/img/Screen%20Shot%202022-06-21%20at%2015.03.58.png" alt="Screen Shot 2022-06-21 at 15.03.58"></p><p>大于8byte的一定要内存对齐，要不后续查找的性能会降低，不是整数倍的话就会查询两次（甚至更多）再拼接。</p><p>结构体都是按顺序连续存储的。</p><h1 id="3-map"><a href="#3-map" class="headerlink" title="3. map"></a>3. map</h1><p><a href="https://www.cnblogs.com/qcrao-2018/p/10903807.html">https://www.cnblogs.com/qcrao-2018/p/10903807.html</a></p><p>哈希放入的方法：1、取模法 2、与运算</p><p>解决哈希冲突的方法：1、开放地址法 2、拉链法 </p><p>哈希冲突就算能解决但是他的存在就是会影响速度，通常把存储键值对的数目与桶的数目有比值，称为负载因子。</p><p>负载因子是用来判断是否扩容的标准。</p><p>渐进式扩容，可以避免一次性扩容带来的性能瞬时抖动。他的过程：先分配足够多的新桶，用一个字段记录旧桶的位置，还有当前迁移的进度，每次读写的时候都进行一部分迁移，等到全部迁移完成后就是扩容完毕。</p><p><img src="https://cdn.jsdeliver.net/gh/PanyuHaa/PicGo/img/hmap.png" alt="hmap"></p><p><strong>tophash是</strong>一个长度为8的数组，它不仅仅用来存放key的哈希高8位，在不同场景下它还可以标记迁移状态，bucket是否为空等。</p><p>取k1的高八位（bit）hash值放在tophash里面。</p><p><code>bmap</code> 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。</p><p><img src="https://user-images.githubusercontent.com/7698088/57576986-acd87600-749f-11e9-8710-75e423c7efdb.png" alt="hashmap bmap"></p><p><strong>扩容规则</strong></p><p><code>B</code> 是 buckets 数组的长度的对数，也就是说 buckets 数组的长度就是 2^B。</p><p>count/(2^B) &gt; 6.5 ———-&gt; 翻倍扩容hmap.B++</p><p>LoadFactor没超标 ————&gt; 等量扩容</p><p>noverflow 较多 B &lt;= 15 noverflow &gt;= 2^B; B &gt; 15 noverflow &gt;= 2^15</p><p>等量扩容的意义，因为不需要太多的溢出桶，所以新桶可以整合之前还存在的KV，可以删除之前残存的内部碎片</p><h1 id="4-函数调用栈"><a href="#4-函数调用栈" class="headerlink" title="4. 函数调用栈"></a>4. 函数调用栈</h1><p>call指令记录有函数调用存在，ret用来返回函数调用的位置。</p><p>函数执行时，局部变量，参数和返回值，都存在虚拟地址中的栈。上面是高地址</p><p><a href="https://static.cyub.vip/images/202105/go-stack-sum.png"><img src="https://static.cyub.vip/images/202105/go-stack-sum.png" alt="main函数调用栈"></a></p><p>栈底也称栈基bp，局部变量，返回值，参数，返回地址</p><p>栈指针sp，偏移 + sp</p><p>go中的函数栈的分配是一次性的，这样不会出现函数栈溢出的问题。</p><p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-06-21 at 16.51.03.png" alt="Screen Shot 2022-06-21 at 16.51.03"></p><p>先存储下一个要去的位置，然后开始跳转到调用处继续执行，不过在栈底的位置的高地址处，存入调用者的栈基和向下移动的移动位置（用于向上移动回去），然后执行ret返回之前存储的状态。本质上是实现了一个跳转的过程。</p><p>之所以值拷贝不能够改变具体的值的原因是，值拷贝的话他的参数是局部变量的值而不是指向他们的地址，所以举例swap函数，他的确交换了，但交换的只是参数里面的a和b，并没有对局部变量的a和b的值进行交换，所以没有变化。</p><p><strong>匿名返回值</strong>——返回值先赋值，再调用defer函数。</p><p><strong>命名返回值</strong>——如果返回的是一个具体的参数b且defer里面有对b的操作，那么defer里面的调用是会影响到返回值的。</p><p>如果A调用了函数B和C，那么函数栈帧的大小要依照最大的空间需求函数，并且栈顶指针的位置是统一的，这样会更方便后续的虚拟地址查询。（栈底在上，栈顶在下）</p><h1 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5. 闭包"></a>5. 闭包</h1><p>堆存储的是函数的地址</p><p>闭包函数里面的变量要和外部函数保持一致，他们使用同一片变量</p><h1 id="6-方法"><a href="#6-方法" class="headerlink" title="6. 方法"></a>6. 方法</h1><h1 id="7-defer"><a href="#7-defer" class="headerlink" title="7. defer"></a>7. defer</h1><p>defer是用头插法链表连接起来的。</p>]]></content>
    
    
    <categories>
      
      <category>Backend development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend development, Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言笔记</title>
    <link href="/2022/06/07/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/07/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、控制并发的两种方式"><a href="#一、控制并发的两种方式" class="headerlink" title="一、控制并发的两种方式"></a>一、控制并发的两种方式</h1><h2 id="1-使用WaitGroup"><a href="#1-使用WaitGroup" class="headerlink" title="1. 使用WaitGroup"></a>1. 使用WaitGroup</h2><p><strong>应用场景：多个Goroutine执行同一件事情</strong></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>   wg.Add(<span class="hljs-number">2</span>)<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>      fmt.Println(<span class="hljs-string">&quot;job 1 done.&quot;</span>)<br>      wg.Done()<br>   &#125;()<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>      fmt.Println(<span class="hljs-string">&quot;job 2 done.&quot;</span>)<br>      wg.Done()<br>   &#125;()<br>   wg.Wait()<br>   fmt.Println(<span class="hljs-string">&quot;All Done.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何主动停止呢？</strong><br>使用Channel，Channel + Select的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- stop:<br>fmt.Println(<span class="hljs-string">&quot;got the stop channel&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;still working&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;stop the goroutine&quot;</span>)<br>stop &lt;- <span class="hljs-literal">true</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>多个Goroutine或Goroutine内又有Goroutine</p><p><img src="/Users/peterpan/Library/Application Support/typora-user-images/Screen Shot 2022-06-07 at 22.49.10.png" alt="Screen Shot 2022-06-07 at 22.49.10"></p><p>这种方式很难用嵌套的。</p><h2 id="2-使用Context"><a href="#2-使用Context" class="headerlink" title="2. 使用Context"></a>2. 使用Context</h2><p>简单改写没有嵌套。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithCancel(context.Background()) <span class="hljs-comment">// context.Background() 是root节点，将root节点放在channel里</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;got the stop channel&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;still working&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;stop the goroutine&quot;</span>)<br>cancel()<br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>多个进程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithCancel(context.Background()) <span class="hljs-comment">// context.Background() 是root节点，将root节点放在channel里</span><br><br><span class="hljs-keyword">go</span> worker(ctx, <span class="hljs-string">&quot;node01&quot;</span>)<br><span class="hljs-keyword">go</span> worker(ctx, <span class="hljs-string">&quot;node02&quot;</span>)<br><span class="hljs-keyword">go</span> worker(ctx, <span class="hljs-string">&quot;node03&quot;</span>)<br><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;stop the goroutine&quot;</span>)<br>cancel()<br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br><br><span class="hljs-comment">// 参数为context和进程的name</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(ctx context.Context, name <span class="hljs-type">string</span>)</span></span>  &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;got the stop channel&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;still working&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、并发模型"><a href="#二、并发模型" class="headerlink" title="二、并发模型"></a>二、并发模型</h1><p>pool资源池</p><p>包含：资源resources (chan io.Closer)、工厂函数factory工厂模式产生pool通过new（）、closed判断pool的开关、和锁</p><p>信号量模式：就是给一个信号量的源头，然后传递下去直到还给main()，因为main()也可以看成协程，不过换成等待也可以。</p><h1 id="三、初识gRPC"><a href="#三、初识gRPC" class="headerlink" title="三、初识gRPC"></a>三、初识gRPC</h1><p>grpc理论基础</p><p><a href="https://www.cnblogs.com/songgj/p/13463717.html">https://www.cnblogs.com/songgj/p/13463717.html</a></p><p><img src="https://img2020.cnblogs.com/blog/824470/202010/824470-20201030135431451-1886001617.png" alt="img"></p><p><strong>RPC和HTTP区别</strong><br>RPC 和 HTTP都是微服务间通信较为常用的方案之一，其实RPC 和 HTTP 并不完全是同一个层次的概念，它们之间还是有所区别的。</p><p>RPC 是远程过程调用，其调用协议通常包括序列化协议和传输协议。序列化协议有基于纯文本的 XML 和 JSON、二进制编码的Protobuf和Hessian。传输协议是指其底层网络传输所使用的协议，比如 TCP、HTTP。<br>可以看出HTTP是RPC的传输协议的一个可选方案，比如说 gRPC 的网络传输协议就是 HTTP。HTTP 既可以和 RPC 一样作为服务间通信的解决方案，也可以作为 RPC 中通信层的传输协议（此时与之对比的是 TCP 协议）。</p><p><strong>任务背景：</strong></p><p>描述一个向导服务，服务名为RouteGuide</p><p>定义四种不同的信息类型分别为Point，Rectangle，Feature，RouteSummary以及Chat。</p><p>定义四个方法：</p><p><img src="https://cdn.jsdeliver.net/gh/PanyuHaa/PicGo/img/Screen%20Shot%202022-06-09%20at%2016.13.15.png" alt="Screen Shot 2022-06-09 at 16.13.15"></p><p>定义一个service</p><h2 id="1-gRPC四种服务类型"><a href="#1-gRPC四种服务类型" class="headerlink" title="1. gRPC四种服务类型"></a>1. gRPC四种服务类型</h2><p><a href="https://www.lixueduan.com/post/grpc/03-stream/">https://www.lixueduan.com/post/grpc/03-stream/</a></p><p>我们重点关注这四种服务类型，永远记住是客户端向服务端请求服务。</p><h3 id="1-1-Unary"><a href="#1-1-Unary" class="headerlink" title="1.1 Unary"></a>1.1 Unary</h3><p>即时通信</p><h3 id="1-2-Client-side-streaming"><a href="#1-2-Client-side-streaming" class="headerlink" title="1.2 Client-side streaming"></a>1.2 Client-side streaming</h3><p>客户端发送一个stream的请求，但是服务端发回来是个unary</p><h3 id="1-3-Server-side-streaming"><a href="#1-3-Server-side-streaming" class="headerlink" title="1.3 Server-side streaming"></a>1.3 Server-side streaming</h3><p>客户端发送一个unary的请求，但是服务器发回来是个stream</p><h3 id="1-4-Bidirectional-streaming"><a href="#1-4-Bidirectional-streaming" class="headerlink" title="1.4 Bidirectional streaming"></a>1.4 Bidirectional streaming</h3><p>双方通信的参数都是流</p><p>用forloop来一直接受对方的流</p><p>流数据就是需要一直传输的数据，比如实时发送自己的位置（每隔1s）</p><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><p><a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated">https://developers.google.com/protocol-buffers/docs/reference/go-generated</a></p><p>一、先写好proto文件</p><p>如果是http1.1用json来数据传输field直接是string当成key，value就是value。这里呢把数字作为key，这样压缩数据长度。注意序号是1开始。</p><p>message是变量</p><p>enum是枚举</p><p>service是方法</p><p>二、在terminal里面写</p><p>安装protoc</p><p><code>$ brew install protobuf</code><br><code>$ protoc --version</code> (最新版本)</p><p>.是当前文件的意思</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">protoc --go_out=. --go_opt=paths=source_relative --<span class="hljs-keyword">go</span>-grpc_out. --<span class="hljs-keyword">go</span>-grpc_opt=paths=source_relative route.proto<br></code></pre></td></tr></table></figure><p>前面的go_out输出的是message的代码文件</p><p>后面的go-rpc_out输出的是service的代码文件</p><p>可以写成shell，这样以后更新pb文件的时候就会方便</p><p>这个pb文件也就是stun代码桩</p><p>可能遇到的两个问题：<br>1、客户端拨通服务端失败：端口可能被占用，mac系统使用lsof -i tcp:port命令可查询端口占用情况（port替换为要查询的端口号），改用未被占用的端口号即可。<br>2、grpc.WithInsecure()：跳过证书验证，目前已被弃用，文档推荐使用grpc.WithTransportCredentials(insecure.NewCredentials())。</p><p><strong>服务端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> routeGuideServer <span class="hljs-keyword">struct</span> &#123;<br>features []*pb.Feature<br>pb.UnimplementedRouteGuideServer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newServer</span><span class="hljs-params">()</span></span> *routeGuideServer &#123;<br><span class="hljs-keyword">return</span> &amp;routeGuideServer&#123;<br>features: []*pb.Feature&#123;<br>&#123;Name: <span class="hljs-string">&quot;上海交通大学闵行校区 上海市闵行区东川路800号&quot;</span>, Location: &amp;pb.Point&#123;<br>Latitude:  <span class="hljs-number">310235000</span>,<br>Longitude: <span class="hljs-number">121437403</span>,<br>&#125;&#125;,<br>&#123;Name: <span class="hljs-string">&quot;复旦大学 上海市杨浦区五角场邯郸路220号&quot;</span>, Location: &amp;pb.Point&#123;<br>Latitude:  <span class="hljs-number">312978870</span>,<br>Longitude: <span class="hljs-number">121503457</span>,<br>&#125;&#125;,<br>&#123;Name: <span class="hljs-string">&quot;华东理工大学 上海市徐汇区梅陇路130号&quot;</span>, Location: &amp;pb.Point&#123;<br>Latitude:  <span class="hljs-number">311416130</span>,<br>Longitude: <span class="hljs-number">121424904</span>,<br>&#125;&#125;,<br>&#125;,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:5000&quot;</span>) <span class="hljs-comment">// 监听</span><br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatalln(<span class="hljs-string">&quot;cannot create a listener at the address&quot;</span>)<br>  &#125;<br>  grpcServer := grpc.NewServer() <span class="hljs-comment">// 创建新server</span><br>  pb.RegisterRouteGuideServer(grpcServer, newServer()) <span class="hljs-comment">// 将pb代码桩注册到grpc的server</span><br>  log.Fatalln(grpcServer.Serve(lis)) <span class="hljs-comment">// 启动grpc的server</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之所以需要内嵌一个UnimplementedXXX 是因为protoc在解析.proto文件，创建grpc.pb.go文件的时候用unplementedXXX完成向前兼容的实现。</p><p><strong>客户端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>conn, err := grpc.Dial(<span class="hljs-string">&quot;localhost:5000&quot;</span>, grpc.WithInsecure(), grpc.WithBlock()) <span class="hljs-comment">// 拨号请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(<span class="hljs-string">&quot;client cannot dial grpc server&quot;</span>)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>client := pb.NewRouteGuideClient(conn) <span class="hljs-comment">// 建立一个client</span><br><br>runForth(client)<br>&#125;<br></code></pre></td></tr></table></figure><p>grpc.WithInsecure() —- 设置不验证证书</p><p>grpc.WithBlock() —- 拨号成功才会往下走</p><p>服务端stream通过Send(T type)函数进行发送数据</p><p>客户端通过stream.Recv()来接收数据，通过 err == io.EOF 来进行处理</p><p>（Client-side streaming也是同理的，上述是Server-side streaming。client端需要主动进行关闭clientStream.CloseAndRecv()，server端也需要关闭stream.SendAndClose()）</p><p>为什么要用到流呢？比如当你数据量很大的时候，不需要一次性装填完才让前端显示，这样增加了运行的效率</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p><strong>Client发送完成后需要手动调用Close()或者CloseSend()方法关闭stream，Server端则<code>return nil</code>就会自动 Close</strong>。</p><p><strong>1）ServerStream</strong></p><ul><li>服务端处理完成后<code>return nil</code>代表响应完成</li><li>客户端通过 <code>err == io.EOF</code>判断服务端是否响应完成</li></ul><p><strong>2）ClientStream</strong></p><ul><li>客户端发送完毕通过<code>CloseAndRecv</code>关闭stream 并接收服务端响应</li><li>服务端通过 <code>err == io.EOF</code>判断客户端是否发送完毕，完毕后使用<code>SendAndClose</code>关闭 stream并返回响应。</li></ul><p><strong>3）BidirectionalStream</strong></p><ul><li>客户端服务端都通过stream向对方推送数据</li><li>客户端推送完成后通过<code>CloseSend</code>关闭流，通过<code>err == io.EOF</code>判断服务端是否响应完成</li><li>服务端通过<code>err == io.EOF</code>判断客户端是否响应完成,通过<code>return nil</code>表示已经完成响应</li></ul><p>通过<code>err == io.EOF</code>来判定是否把对方推送的数据全部获取到了。</p><p>客户端通过<code>CloseAndRecv</code>或者<code>CloseSend</code>关闭 Stream，服务端则通过<code>SendAndClose</code>或者直接 <code>return nil</code>来返回响应。</p><h1 id="四、go的反射"><a href="#四、go的反射" class="headerlink" title="四、go的反射"></a>四、go的反射</h1><p>可以反射的内容有四个：Type、Type.Name、Kind、Value</p><p>name是包内的定义</p><p>元数据：就是描述数据的数据</p><p>通过反射，将一个值进行转型：1、拿到值 2、调用Interface().(T type)</p><p>Reflect.Value to float</p><p>Reflect.Value to slice</p><p>通过反射改变对应的数值。用set，要先检测一下canset()</p><p>通过反射来调用该类型的方法，MethodByName(func name)返回一个func value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Student)</span></span> DoHomework(number <span class="hljs-type">int</span>) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s is doing homework %d\n&quot;</span>, s.name, number)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// use reflect to invoke the DoHomework of a student</span><br>s := Student&#123;name: <span class="hljs-string">&quot;heli&quot;</span>&#125;<br>v := reflect.ValueOf(s)  <span class="hljs-comment">// 如果函数是指针的函数就要加地址，要不不能加地址</span><br>methodV := v.MethodByName(<span class="hljs-string">&quot;DoHomework&quot;</span>)<br><span class="hljs-keyword">if</span> methodV.IsValid() &#123;<br>in := []reflect.Value&#123;reflect.ValueOf(<span class="hljs-number">55</span>)&#125;<br>methodV.Call(in)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用过反射也可以构建函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeTimeFunc</span><span class="hljs-params">(f <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>tf := reflect.TypeOf(f)<br>vf := reflect.ValueOf(f)<br><br><span class="hljs-keyword">if</span> tf.Kind() != reflect.Func &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;expect a function&quot;</span>)<br>&#125;<br>wrapper := reflect.MakeFunc(tf, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(args []reflect.Value)</span></span> (result []reflect.Value) &#123;<br>start := time.Now()<br>result = vf.Call(args)<br>end := time.Now()<br>fmt.Printf(<span class="hljs-string">&quot;The function takes %v\n&quot;</span>, end.Sub(start))<br><span class="hljs-keyword">return</span> result<br>&#125;)<br><span class="hljs-keyword">return</span> wrapper.Interface()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TimeMe</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>timedFunc := makeTimeFunc(TimeMe).(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>)<br>timedFunc()<br>&#125;<br></code></pre></td></tr></table></figure><p>用kind来判断类型，因为不同的类型可以调用的方法不完全一样。</p><p>通过反射我们可以知道一个结构体的field的数量和其值还有method的数量，还有名字等等。</p><p>对于一个函数我们可以知道函数的名字，函数的IN和OUT有几个。</p><p>反正反射可以帮助我们获得函数，基本数据类型等的信息。</p><h1 id="五、Gin和RESTful风格的API设计"><a href="#五、Gin和RESTful风格的API设计" class="headerlink" title="五、Gin和RESTful风格的API设计"></a>五、Gin和RESTful风格的API设计</h1><p><strong>举例不符合的</strong></p><p>/getAllEmployees</p><p>/createEmployee</p><p>/updateEmployee</p><p>URI里面是动词，这里显然没有把Employee当作资源来对待</p><p><strong>正确如下</strong></p><p>GET /employees （列出所有员工）</p><p>GET /employees？state=external（列出所有状态为external的员工）</p><p>POST /employees （创建一个新员工）</p><p>PUT /employees/56 （更新56号员工的信息）</p><p>遵守RESTful风格的优势</p><ol><li>对于URI的匹配比较简洁，只需要匹配 /employees 和 /employees/:id 即可</li><li>格式规范，使用时不容易出错</li></ol><p><strong>注意事项</strong></p><p>命名API接口 推荐用复数名词</p><p>GET /employees/56</p><p>非资源请求用动词</p><p>GET /translate？from=de_DE&amp;to=en_US&amp;text=Hello</p><p>shouldbind，是将传入进来的json绑定到你设定的结构体上，对应赋值。</p><p>bind方法 <a href="https://cloudfeng.github.io/2020/03/13/2020/03/20200311_go_gin_request_bind_type/">https://cloudfeng.github.io/2020/03/13/2020/03/20200311_go_gin_request_bind_type/</a></p><h1 id="六、Raft，分布式共识算法"><a href="#六、Raft，分布式共识算法" class="headerlink" title="六、Raft，分布式共识算法"></a>六、Raft，分布式共识算法</h1><h2 id="BG"><a href="#BG" class="headerlink" title="BG"></a>BG</h2><p>分布式系统的挑战</p><ol><li>时序性 Timing 运行在不同网络下的机器中的进程如何判断一些事件发生的顺序</li><li>并发性 Concurrency运行在不同网络下的机器中的进程如何共享资源，而互不干扰。比如访问共同的数据库</li><li>健壮性 Robustness 应对网络的不稳定性以及硬件的不稳定性</li><li>一致性 Consistency 如何保障无论访问哪个服务节点，都能获得相同的结果</li></ol><p>分布式共识 Consensus</p><p>分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程</p><p>分布式共识的应用 Application of Consensus</p><ol><li>逻辑时间的共识，来决定事件发生的<strong>顺序</strong></li><li>互斥性的共识，用于决定谁正拥有<strong>访问的资源</strong></li><li>协调者的共识，谁是当下的<strong>leader</strong></li></ol><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>raft动画演示<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><p><a href="https://zhuanlan.zhihu.com/p/32052223">https://zhuanlan.zhihu.com/p/32052223</a></p><p>每个节点都会有三个状态：<strong>追随者Follower</strong>、<strong>竞选者candidate</strong> 、<strong>领导者Leader</strong>（默认都是竞选者，需要分配）</p><p>竞选者拿到超过半数的票时才能称为领导者（超过半数保证了领导者的唯一性）</p><p>每一个请求都会成为log entry，然后都默认是uncommitted的状态，不会进行更新。要先进行广播（复制该请求），获得高投票的话，就commit。然后通知所有的follower然后各自根据日志commit了。（通过log来保证所有的节点都准备好更新了达成共识后再更新）</p><p>上述过程也叫<strong>日志复制</strong></p><h3 id="1-Leader选举"><a href="#1-Leader选举" class="headerlink" title="1. Leader选举"></a>1. Leader选举</h3><p>选举过期的时间一般在150ms-300ms</p><p>term来表示逻辑时间越大的term表示最新的任期，成为竞选者以后开始发票，每个term之内别人只能投票一次给他，这样避免了重复。</p><p>term代表任期的轮次，如果A是term=1，B和C都是0的时候，A优先发起投票，并且给到BC，查看自己的term在当前A给的term下有无投票，如果没有则投票，更新term和A相等（保证不会再投票）；如果本身和A的term相同则不投票。</p><p>投票给别人以后自己的Timer就会重置（timer为0的时候变成竞选者）</p><p>竞选者 ——&gt; 领导者 之后，会周期性发送 Append Entries 也就是那个 log entry，这样会一直重置其他节点的timer，防止无故变成竞选者</p><p>timeout有两个：1、election timeout 2、heartbeat timeout（远小于前者）</p><p>heartbeat timeout就是前面提到的<code>周期性发送 Append Entries</code> （raft中？leader发心跳吗）</p><p>平票的情况—-都会time out，重新评选，而且time out的时间都是随机数很小的概率会重复。</p><p>follower变成candidate的时候term要<strong>+1</strong></p><h3 id="2-Log-Replication"><a href="#2-Log-Replication" class="headerlink" title="2. Log Replication"></a>2. Log Replication</h3><p>客户先发送数据请求，leader先接收到请求。然后同步广播到其他节点上，当其他节点返回确认的消息，保证了一致性以后，leader再讲数据写进状态机。</p><p>为节点加入partition后（用来排除区域的网络故障），会在分开的区域各自选出leader，其余不变。但是这里会遇到一个问题，由于分开不代表挂掉所以导致有的leader无法再获得超过半数的投票（算上自己），所有的log entry不能够commit。</p><p>这里就遇到了一个换届的问题：换届的规则就是谁的term高听谁的。如果故障时，有一个term为2的leaderA和一个term为1的leaderB，那么我们就要在拆partition后，恢复的区域内的leader进行term比较（leader再融合前仍然向其他节点发送消息）。</p><h2 id="Raft论文节选"><a href="#Raft论文节选" class="headerlink" title="Raft论文节选"></a>Raft论文节选</h2><h3 id="参量定义"><a href="#参量定义" class="headerlink" title="参量定义"></a>参量定义</h3><p><strong>State</strong></p><p>Volatile state on leaders：</p><p>nextIndex[]和matchIndex[]是长度等于<strong>所有机器数量</strong>的两个数组，Leader对每个follower都记录它的nextIndex和matchIndex。用来管理follower</p><p>nextIndex[]：指的是下一次appendEntries从哪里开始尝试</p><p>matchIndex[]：已知的某follower的log与Leader的log最大匹配到第几个index </p><p>以上两个元素都是在follower内部</p><p><strong>AppendEntries RPC</strong>（Log Replication的过程）</p><p>prevLogIndex和prevLogTerm用来决定你append的位置，确认状态用的，保证你数据记录的一致性和连续性。他会一点一点按照nextIndex[]进行比对，如果不匹配就将nextIndex—，直到找到对应的位置再开始插入数据，如果此时遍历了全部都没有发现合适的话，那么我们就要将log entry从序号下标记0开始插入。</p><p>什么是 Commit Index</p><p>Leader的commit index指的是最后一个被大多数机器都复制的日志的index。</p><p>如果Follower收到从Leader发过来的commitIndex大于自己记录的commitIndex，就可以把自己的commitIndex更新，并开始把这些日志应用到状态机里。</p><p><strong>RequestVote RPC</strong></p><p>如果他的log和发起投票的candidate不匹配的话，是不可以投票的。</p><h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p><a href="https://etcd.io/">etcd</a>（读作 et-see-dee）是一种开源的分布式统一键值存储，用于分布式系统或计算机集群的共享配置、服务发现和的调度协调。etcd 有助于促进更加安全的自动更新，协调向主机调度的工作，并帮助设置容器的覆盖网络。</p><p>etcd 是许多其他项目的核心组件。最值得注意的是，它是Kubernetes的首要数据存储，也是容器编排的实际标准系统。使用 etcd， 云原生应用可以保持更为一致的运行时间，而且在个别服务器发生故障时也能正常工作。应用从 etcd 读取数据并写入到其中；通过分散配置数据，为节点配置提供冗余和弹性。</p><h1 id="七、dokcer容器化"><a href="#七、dokcer容器化" class="headerlink" title="七、dokcer容器化"></a>七、dokcer容器化</h1><p>docker容器轻量的原因是不需要装入操作系统</p><p>dockefile —&gt; Image —-&gt; Container</p><p>dockerfile构建image</p><p>image启动container</p><p><strong>镜像（image）</strong>是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（入匿名卷、环境变量、用户等）</p><p>镜像不包含任何动态数据，其内容在构建之后也不会被改变</p><p><strong>容器（container）</strong>docker容器是在运行的一个Docker镜像的instance。包括服务或应用的状态和其他动态数据。</p><p><strong>Docker Compose</strong>用于定义和运行多容器Docker应用程序的工具。通过Compose，您可以使用YML文件来配置应用程序需要的所有服务。</p><h3 id="Dockerfile关键字说明"><a href="#Dockerfile关键字说明" class="headerlink" title="Dockerfile关键字说明"></a>Dockerfile关键字说明</h3><p>1.本人在使用Dockerfile文件制作镜像过程中踩了不少坑，这里将我总结的一些注意点贴出来，供大家参考。</p><p>2.Dockerfile大致格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">MAINTAINER</span> chuan<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum install -y vim</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /bin/bash</span><br></code></pre></td></tr></table></figure><p>3.关键字说明：</p><ul><li>FROM：基于哪个基础镜像</li><li>WORKDIR：指定shell命令运行在哪个目录下。为后续的 RUN、CMD、COPY、ADD 等命令配置工作目录。接下来的 COPY 和 ADD 命令中的相对路径就是相对于 WORKDIR 指定的路径</li><li>COPY：将当前宿主机的文件拷贝到镜像中去（<strong>copy的文件必须在build命令最后指定的路径内</strong>）</li><li>ADD：和COPY一样，并且还可以解压缩，或者从 url 拷贝文件到镜像中。<strong>COPY 和 ADD 命令具有相同的特点：只复制目录中的内容而不包含目录自身</strong>。</li><li>RUN：构建镜像时运行的shell命令</li><li>CMD：容器运行时执行的shell命令（<strong>多个CMD只有最后一个生效，要想都执行可以使用&amp;&amp;连接多个命令</strong>）（<strong>如果容器run时，后面指定了shell版本，Dockerfile中的CMD也会被覆盖</strong>）</li><li>ENTRYPOINT：和CMD一样，但是可以追加（必须使用exec格式，即：ENTRYPOINT [./entrypoint.sh，参数1，参数2……]）</li></ul><hr><ul><li>EXPOSE：指定镜像暴露出来的端口</li><li>VOLUMU：数据容器卷，指定映射文件，用于数据持久化</li><li>ENV：指定环境变量</li><li>LABEL：指定容器运行时标示</li><li>SHELL：指定shell</li><li>MAINTAINER：镜像维护者的姓名和邮箱地址</li><li>ONBUILD：当构建一个父镜像时，父镜像被子镜像继承时，ONBUILD被触发</li></ul><p>4.最后生成镜像时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t 新镜像名 -f centos\_dockerfile .<br></code></pre></td></tr></table></figure><p>最后有个点表示当前目录的centos_dockerfile文件。（如果文件名就是Dockerfile，则直接：docker build -t 新镜像名 .）</p><ol><li><code>docker image ls</code>查看image有啥 </li><li><code>docker run -d [image_name]</code>运行起来image ；<code>docker run -d -p 8080:8080 [image_name]</code>指定端口的跑起来</li><li><code>docker container ls</code>查看跑起来的container</li><li><code>docker stop [contain_id]</code>停止某个container</li><li><code>docker container ls -a</code>查看所有container（跑起来or停掉的）</li></ol><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a> dockerfile写法</p>]]></content>
    
    
    <categories>
      
      <category>Backend development</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend development</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录</title>
    <link href="/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    <url>/2022/04/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="第3章-数组"><a href="#第3章-数组" class="headerlink" title="第3章 数组"></a>第3章 数组</h1><h2 id="3-2-二分查找"><a href="#3-2-二分查找" class="headerlink" title="3.2 二分查找"></a>3.2 二分查找</h2><p><strong>704. Binary Search</strong></p><p><strong>Q:</strong> Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> pivot, left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>      pivot = left + (right - left) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[pivot] == target) <span class="hljs-keyword">return</span> pivot;<br>      <span class="hljs-keyword">if</span> (target &lt; nums[pivot]) right = pivot - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> left = pivot + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 (left + right) / 2 = left + (right / 2) - (left / 2) = left + (right - left) / 2</p><p>我采用的是 [left, right] 闭区间，所以判断条件是 &lt;= ，left和right相等的时候有意义。</p><h2 id="3-3-移除元素"><a href="#3-3-移除元素" class="headerlink" title="3.3 移除元素"></a><strong>3.3 移除元素</strong></h2><p><strong>27. Remove Element</strong></p><p><strong>Q: </strong>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <strong>in-place</strong>. The relative order of the elements may be changed.</p><p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p><p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] != val) &#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1⃣️ 由于有空间复杂度的限制，所以不能建立另外一个数组来进行赋值，暗示我们用双指针法，双指针法是常用的降低时间复杂度的方法。</p><p>2⃣️ nums = [0, 1 ,4 ,0 ,3 , _ , _] 因为数组中的元素在内存地址上是连续的，不能单独删除数组中的某个元素，只能覆盖。</p><h2 id="3-4-长度最小的子数组"><a href="#3-4-长度最小的子数组" class="headerlink" title="3.4 长度最小的子数组"></a>3.4 长度最小的子数组</h2><p><strong>209. Minimum Size Subarray Sum</strong></p><p><strong>Q: </strong>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p><p><strong>A1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span> MAX;<br>        <span class="hljs-type">int</span> subSum;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历数组中的每一个作为开头</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            subSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-comment">// 求子数组的和</span><br>                subSum += nums[j];<br>                <span class="hljs-keyword">if</span> (subSum &gt;= target) &#123;<br>                    subLength = j - i + <span class="hljs-number">1</span>;<br>                    resultLength = resultLength &gt; subLength ? subLength : resultLength;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span>= MAX ? <span class="hljs-number">0</span> : resultLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>暴力解法，不过也有巧妙思路，通过MAX这个变量增加了判断是否返回0的方法，是flag的另一种用法。</p><p><strong>A2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span> MAX;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 标记左边的起始位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 用j标记的是窗口右边指针的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            subSum += nums[j];<br>            <span class="hljs-comment">// 保证窗口内的sum值永远是大于等于target的</span><br>            <span class="hljs-keyword">while</span> (subSum &gt;= target) &#123;<br>                <span class="hljs-comment">// 获取子数组的长度并判断是否是最小的，+1是因为数组是从0开始的</span><br>                subLength = j - i + <span class="hljs-number">1</span>;<br>                resultLength = resultLength &gt; subLength ? subLength : resultLength;<br>                <span class="hljs-comment">// 收缩左边的指针的位置</span><br>                subSum -= nums[i++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">resultLength</span> <span class="hljs-operator">=</span>= MAX ? <span class="hljs-number">0</span> : resultLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要考虑三个问题：</p><p>1⃣️ 窗口内的元素是什么？</p><p>2⃣️ 窗口的起始位置？</p><p>3⃣️ 窗口的结束位置？</p><p>滑动窗口的精妙之处在于根据当前子数组和的大小，不断调节子数组的起始位置，从而将时间复杂度从O(n^2)变成O(n)。</p><p>subLength和resultLength必须在满足subSum &gt;= target的时候才有意义，所以放在内部。</p><h2 id="3-5-螺旋矩阵"><a href="#3-5-螺旋矩阵" class="headerlink" title="3.5 螺旋矩阵"></a>3.5 螺旋矩阵</h2><p><strong>59. Spiral Matrix II</strong></p><p><strong>Q: </strong>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n2</code> in spiral order.</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/spiraln.jpg" alt="spiraln"></p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] Matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义列边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义行边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 填充值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> row;<br>        <span class="hljs-type">int</span> col;<br><br>        <span class="hljs-keyword">while</span> (value != (n * n) + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 从左向右走</span><br>            <span class="hljs-keyword">for</span> (col = left; col &lt;= right; col++) &#123;<br>                Matrix[up][col] = value;<br>                value++;<br>            &#125;<br>            up++;<br>            <span class="hljs-comment">// 从上向下走</span><br>            <span class="hljs-keyword">for</span> (row = up; row &lt;= down; row++) &#123;<br>                Matrix[row][right] = value;<br>                value++;<br>            &#125;<br>            right--;<br>            <span class="hljs-comment">// 从右向左走</span><br>            <span class="hljs-keyword">for</span> (col = right; col &gt;= left; col--) &#123;<br>                Matrix[down][col] = value;<br>                value++;<br>            &#125;<br>            down--;<br>            <span class="hljs-comment">// 从下向上走</span><br>            <span class="hljs-keyword">for</span> (row = down; row &gt;= up; row--) &#123;<br>                Matrix[row][left] = value;<br>                value++;<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>规定出四个边界，每个方向遍历一次以后通过 ++ 操作来使此行或者此列不再遍历。循环终止的方法有两种，其一是方阵的情况下进行特殊判断，其二是不规则矩阵的情况下进行每个方向上的判断。</p><h1 id="第4章-链表"><a href="#第4章-链表" class="headerlink" title="第4章 链表"></a>第4章 链表</h1><h2 id="4-2-虚拟头节点链表删除"><a href="#4-2-虚拟头节点链表删除" class="headerlink" title="4.2 虚拟头节点链表删除"></a>4.2 虚拟头节点链表删除</h2><p><strong>203. Remove Linked List Elements</strong></p><p><strong>Q: </strong>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/removelinked-list.jpg" alt="removelinked-list"></p><p><strong>A1: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 虚拟头结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fakeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        fakeHead.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> fakeHead, cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>                pre.next = cur.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = pre.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过加入虚拟头节点来解决如果是第一位就要删除的pre和cur不好指向的问题</p><p><strong>A2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        head.next = removeElements(head.next, val);<br>        <span class="hljs-keyword">return</span> head.val == val ? head.next : head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归的方法实现，先递归到最底层，然后往回一点点走，每次都判断，如果有要删除的值就返回前一个，没有要删除的就返回当前的结点，直到回到最初的位置。</p><h2 id="4-3-链表常见的六个操作"><a href="#4-3-链表常见的六个操作" class="headerlink" title="4.3 链表常见的六个操作"></a>4.3 链表常见的六个操作</h2><p><strong>707. Design Linked List</strong></p><p><strong>Q: </strong>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.<br>A node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code>is the value of the current node, and <code>next</code> is a pointer/reference to the next node.<br>If you want to use the doubly linked list, you will need one more attribute <code>prev</code>to indicate the previous node in the linked list. Assume all nodes in the linked list are <strong>0-indexed</strong>.</p><p>Implement the <code>MyLinkedList</code> class:</p><ul><li><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</li><li><code>int get(int index)</code> Get the value of the <code>indexth</code> node in the linked list. If the index is invalid, return <code>-1</code>.</li><li><code>void addAtHead(int val)</code> Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li><li><code>void addAtTail(int val)</code> Append a node of value <code>val</code> as the last element of the linked list.</li><li><code>void addAtIndex(int index, int val)</code> Add a node of value <code>val</code>before the <code>indexth</code> node in the linked list. If <code>index</code> equals the length of the linked list, the node will be appended to the end of the linked list. If <code>index</code> is greater than the length, the node <strong>will not be inserted</strong>.</li><li><code>void deleteAtIndex(int index)</code> Delete the <code>indexth</code> node in the linked list, if the index is valid.</li></ul><p><strong>A:</strong> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyLinkedList <span class="hljs-keyword">struct</span> &#123;<br>head *Node<br>&#125;<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>Val  <span class="hljs-type">int</span><br>Next *Node<br>Prev *Node<br>&#125;<br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyLinkedList &#123;<br><span class="hljs-keyword">return</span> MyLinkedList&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> Get(index <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>curr := this.head<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>curr = curr.Next<br>&#125;<br><span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> curr.Val<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="hljs-type">int</span>) &#123;<br>node := &amp;Node&#123;Val: val&#125;<br>node.Next = this.head<br><span class="hljs-keyword">if</span> this.head != <span class="hljs-literal">nil</span> &#123;<br>this.head.Prev = node<br>&#125;<br>this.head = node<br>&#125;<br><br><span class="hljs-comment">/** Append a node of value val to the last element of the linked list. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> this.head == <span class="hljs-literal">nil</span> &#123;<br>this.AddAtHead(val)<br><span class="hljs-keyword">return</span><br>&#125;<br>node := &amp;Node&#123;Val: val&#125;<br>curr := this.head<br><span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &amp;&amp; curr.Next != <span class="hljs-literal">nil</span> &#123;<br>curr = curr.Next<br>&#125;<br>node.Prev = curr<br>curr.Next = node<br>&#125;<br><br><span class="hljs-comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="hljs-type">int</span>, val <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>this.AddAtHead(val)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>node := &amp;Node&#123;Val: val&#125;<br>curr := this.head<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index<span class="hljs-number">-1</span> &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>curr = curr.Next<br>&#125;<br><span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &#123;<br>node.Next = curr.Next<br>node.Prev = curr<br><span class="hljs-keyword">if</span> node.Next != <span class="hljs-literal">nil</span> &#123;<br>node.Next.Prev = node<br>&#125;<br>curr.Next = node<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/** Delete the index-th node in the linked list, if the index is valid. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>this.head = this.head.Next<br><span class="hljs-keyword">if</span> this.head != <span class="hljs-literal">nil</span> &#123;<br>this.head.Prev = <span class="hljs-literal">nil</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>curr := this.head<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index<span class="hljs-number">-1</span> &amp;&amp; curr != <span class="hljs-literal">nil</span>; i++ &#123;<br>curr = curr.Next<br>&#125;<br><span class="hljs-keyword">if</span> curr != <span class="hljs-literal">nil</span> &amp;&amp; curr.Next != <span class="hljs-literal">nil</span> &#123;<br>curr.Next = curr.Next.Next<br><span class="hljs-keyword">if</span> curr.Next != <span class="hljs-literal">nil</span> &#123;<br>curr.Next.Prev = curr<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * param_1 := obj.Get(index);</span><br><span class="hljs-comment"> * obj.AddAtHead(val);</span><br><span class="hljs-comment"> * obj.AddAtTail(val);</span><br><span class="hljs-comment"> * obj.AddAtIndex(index,val);</span><br><span class="hljs-comment"> * obj.DeleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="4-4-反转链表"><a href="#4-4-反转链表" class="headerlink" title="4.4 反转链表"></a>4.4 反转链表</h2><p><strong>206. Reverse Linked List</strong></p><p><strong>Q:</strong> Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/rev1ex1.jpg" alt="rev1ex1"></p><p><strong>A:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//双指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> pre *ListNode<br>    cur := head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next := cur.Next<br>        cur.Next = pre<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br><br><span class="hljs-comment">//递归</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> help(<span class="hljs-literal">nil</span>, head)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">help</span><span class="hljs-params">(pre, head *ListNode)</span></span>*ListNode&#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> pre<br>    &#125;<br>    next := head.Next<br>    head.Next = pre<br>    <span class="hljs-keyword">return</span> help(head, next)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-5-删除倒数第n个字节"><a href="#4-5-删除倒数第n个字节" class="headerlink" title="4.5 删除倒数第n个字节"></a>4.5 删除倒数第n个字节</h2><p><strong>19. Remove Nth Node From End of List</strong></p><p><strong>Q: </strong>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head. </p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// fakeHead</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fakeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        fakeHead.next = head;<br>        <span class="hljs-comment">// fast &amp; slow, fast pointer faster than slow pointer n steps.</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> fakeHead;<br>        <span class="hljs-comment">// set the position of the fast pointer.</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// n represent the times of loop, if &#x27;i&#x27; start from 0.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> fakeHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过双指针的间距来找到倒数第n个的位置，我让fast提前等于head再往后走，是为了在找到最后的null的时候，slow正好是要删除的结点的前一个。</p><h2 id="4-6-环形链表"><a href="#4-6-环形链表" class="headerlink" title="4.6 环形链表"></a>4.6 环形链表</h2><p><strong>142. Linked List Cycle II</strong></p><p><strong>Q: </strong>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return</em> <code>null</code>.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p><p><strong>Do not modify</strong> the linked list.</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/circularlinkedlist.png" alt="circularlinkedlist"></p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<span class="hljs-comment">// 有环</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> fast;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span><br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1.next;<br>                    index2 = index2.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针的思想，具体推导过程见书P66。</p><p>1⃣️判断是否有环？</p><p>2⃣️判断环的入口在哪里？</p><p>x为起始位置到循环入口的距离，y为循环入口到fast和slow的相遇位置，z为相遇位置到循环入口处的距离。</p><p><strong>x = (n - 1)(y + z) + z</strong>，当n = 1时x = z。代表着走了一圈就相遇了。若n &gt; 1的话，道理一样，总之是index2会比index1少转一圈并且相遇。</p><p>z是fast相遇的位置开始走，最起码要走一圈，多的就是在入口点前相遇的时候，转了几圈y + z代表的是走一圈要的距离。</p><p>ps: n一定大于等于1，因为index1必须最起码走一圈才能够和index2相遇。</p><h1 id="第5章-哈希表"><a href="#第5章-哈希表" class="headerlink" title="第5章 哈希表"></a>第5章 哈希表</h1><h2 id="5-2-有效的字母异位词"><a href="#5-2-有效的字母异位词" class="headerlink" title="5.2 有效的字母异位词"></a>5.2 有效的字母异位词</h2><p><strong>242. Valid Anagram</strong></p><p><strong>Q: </strong>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code><em>otherwise</em>.</p><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            record[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            record[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用到了一个常用的处理字符出现次数的方法。字符 - ‘a’也算是一种哈希函数，它可以把字符串通过ASCII转换，用26位的数组存储他们出现的次数。</p><h2 id="5-3-两个数组的交集"><a href="#5-3-两个数组的交集" class="headerlink" title="5.3 两个数组的交集"></a>5.3 两个数组的交集</h2><p><strong>349. Intersection of Two Arrays</strong></p><p><strong>Q: </strong>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; intersect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;<br>            set.add(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(nums2[i])) &#123;<br>                intersect.add(nums2[i]);<br>            &#125;<br>        &#125;<br>  <span class="hljs-comment">// set turn to the int[]</span><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[intersect.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer num : intersect) &#123;<br>            result[i++] = num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/java-hashset-hierarchy.png" alt="java-hashset-hierarchy"></p><ul><li><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p></li><li><p>HashSet 允许有 null 值。</p></li><li><p>HashSet 是无序的，即不会记录插入的顺序。</p></li><li><p>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。</p></li><li><p>HashSet 实现了 Set 接口。</p></li></ul><p>进行了两步，第一步初筛有哪些value，第二步确定相交的value又有哪些。</p><h2 id="5-4-两数之和"><a href="#5-4-两数之和" class="headerlink" title="5.4 两数之和"></a>5.4 两数之和</h2><p><strong>1. Two Sum</strong></p><p><strong>Q: </strong>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(target - nums[i]), i&#125;;<br>            &#125;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;No two sum solution&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路</p><p>标签：哈希映射</p><ul><li>这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n^2)</li><li>由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度</li><li>遍历数组 nums, i为当前下标，每个值都判断map中是否存在 target - nums[i] 的 key 值</li><li>如果存在则找到了两个值，如果不存在则将当前的 (nums[i], i) 存入 map 中，继续遍历直到找到为止</li></ul><p>每次都是先判断已有的map里面是否有答案，若没有答案就放进map里，这样只要找到答案立马可以得到结果（通过 target - nums[i] 和此时的 i 得到对应的下标）并且有最优的空间复杂度。之所以用map也是因为我们需要的答案是下标，map可以存储每个数组的下标，而单一的数组是做不到的。</p><h2 id="5-5-四数相加"><a href="#5-5-四数相加" class="headerlink" title="5.5 四数相加"></a>5.5 四数相加</h2><p><strong>454. 4Sum II</strong></p><p><strong>Q:</strong> Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span>[] B, <span class="hljs-type">int</span>[] C, <span class="hljs-type">int</span>[] D)</span> &#123;<br>        Map&lt;Integer,Integer&gt; sums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : B) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a + b;<br>                <span class="hljs-keyword">if</span>(sums.containsKey(sum)) &#123;<br>                    sums.put(sum, sums.get(sum)+<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    sums.put(sum, <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : C) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : D)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> -(c + d);<br>                <span class="hljs-keyword">if</span> (sums.containsKey(sum)) &#123;<br>                    count+=sums.get(sum);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>利用两数之和的思想，先把四个数组融合成两个，把前两个数组可以组成的所有都放在一个map里面，利用双层遍历把后续的两个数组都进行做差查找。</p><h2 id="5-6-三数之和"><a href="#5-6-三数之和" class="headerlink" title="5.6 三数之和"></a>5.6 三数之和</h2><p><strong>15. 3Sum</strong></p><p><strong>Q: </strong>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p><p>Notice that the solution set must not contain duplicate triplets.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + <span class="hljs-number">2</span> &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;              <span class="hljs-comment">// skip same result</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, k = nums.length - <span class="hljs-number">1</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> -nums[i];<br>        <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] + nums[k] == target) &#123;<br>                res.add(Arrays.asList(nums[i], nums[j], nums[k]));<br>                j++;<br>                k--;<br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) j++;  <span class="hljs-comment">// skip same result</span><br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]) k--;  <span class="hljs-comment">// skip same result</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j] + nums[k] &gt; target) &#123;<br>                k--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>Array.sort(int[] arr)用来sort数组默认是从小到大。</p><p>res.add(Arrays.asList(nums[i], nums[j], nums[k]));这是List加入一系列数的方法。</p><p>把三个动点变成一个定点，两个动点。定点作为循环条件，在循环的基础上进行判断，一个左指针和一个右指针来判断在定点基础上，有没有组合使结果成立。这个的优点是判断了一个重复的情况直接跳过，因为题目说了不能有重复的三元组。</p><h2 id="5-7-四数之和"><a href="#5-7-四数之和" class="headerlink" title="5.7 四数之和"></a>5.7 四数之和</h2><p><strong>18. 4Sum</strong></p><p><strong>Q: </strong>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong>quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>You may return the answer in <strong>any order</strong>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> targetDiff;<br>        <span class="hljs-type">int</span> left, right;<br>        <span class="hljs-comment">// sort input</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-comment">// skip the same result, if the cur value is same as the former value, the skip the cur value.</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 在 nums[i] 基础上，从 i + 1 处开始遍历，继续三数之和的思想</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-comment">// skip the same result</span><br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                left = j + <span class="hljs-number">2</span>;<br>                right = nums.length - <span class="hljs-number">1</span>;<br>                targetDiff = target - nums[i] - nums[j];<br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-comment">// 若包含的元素能够做差满足问题</span><br>                    <span class="hljs-keyword">if</span> (targetDiff - nums[left] - nums[right] == <span class="hljs-number">0</span>) &#123;<br>                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));<br>                        left++;<br>                        right--;<br>                        <span class="hljs-comment">// skip the same result</span><br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="hljs-number">1</span>]) &#123; left++; &#125;<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="hljs-number">1</span>]) &#123; right--; &#125;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetDiff - nums[left] - nums[right] &gt; <span class="hljs-number">0</span>) &#123;<br>                        left++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在三数之和的基础上，增加了一个维度，他的时间复杂度的增加完全是因为固定的前两位，若是五数之和时间复杂度再*n。</p><h1 id="第6章-字符串"><a href="#第6章-字符串" class="headerlink" title="第6章 字符串"></a>第6章 字符串</h1><h2 id="6-2-反转字符串"><a href="#6-2-反转字符串" class="headerlink" title="6.2 反转字符串"></a>6.2 反转字符串</h2><p><strong>344. Reverse String</strong></p><p><strong>Q: </strong>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p><p>You must do this by modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> with <code>O(1)</code> extra memory.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">char</span> temp;<br>      <br>        <span class="hljs-keyword">while</span>(i &lt;= j)&#123;<br>            temp = s[i];<br>            s[i] = s[j];<br>            s[j] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本的swap思想，关注点在于 i &lt;= j 和 i &lt; j 都是成立的，但是后者可以少判断一个i = j，可以节省判断的一点点时间。</p><h2 id="6-3-反转字符串-II"><a href="#6-3-反转字符串-II" class="headerlink" title="6.3 反转字符串 II"></a>6.3 反转字符串 II</h2><p><strong>541. Reverse String II</strong></p><p><strong>Q: </strong>Given a string <code>s</code> and an integer <code>k</code>, reverse the first <code>k</code> characters for every <code>2k</code> characters counting from the start of the string.</p><p>If there are fewer than <code>k</code> characters left, reverse all of them. If there are less than <code>2k</code> but greater than or equal to <code>k</code> characters, then reverse the first <code>k</code>characters and leave the other as original.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] charArr = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i += (<span class="hljs-number">2</span> * k)) &#123;<br>            <span class="hljs-comment">// the rest is less than the k, reverse all the rest</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> s.length() - i;<br>            <span class="hljs-keyword">if</span> (rest &lt; k) &#123;<br>                reverseChar(charArr, i, s.length() - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArr);<br>            &#125; <br><br>            <span class="hljs-comment">// 交换的位置是左边i，右边i + (k - 1)</span><br>            reverseChar(charArr, i, (i + k) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArr);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseChar</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">char</span> temp;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            temp = arr[left];<br>            arr[left] = arr[right];<br>            arr[right] = temp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路：先分析出交换的方法总共就有两种，交换前k个和交换所有，交换剩余所有是特殊的，所以我们把它放在前面当作特殊条件，只要出现了直接得到结果不用进行多余的判断。</p><h2 id="6-4-反转字符串里的单词"><a href="#6-4-反转字符串里的单词" class="headerlink" title="6.4 反转字符串里的单词"></a>6.4 反转字符串里的单词</h2><p><strong>151. Reverse Words in a String</strong></p><p><strong>Q: </strong>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p><p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p><p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p><p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>      <span class="hljs-type">char</span>[] a = s.toCharArray();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length;<br><br>      <span class="hljs-comment">// step 1. reverse the whole string</span><br>      reverse(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// step 2. reverse each word</span><br>      reverseWords(a, n);<br>      <span class="hljs-comment">// step 3. clean up spaces</span><br>      <span class="hljs-keyword">return</span> cleanSpaces(a, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j || i &lt; n &amp;&amp; a[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++; <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; i || j &lt; n &amp;&amp; a[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++; <span class="hljs-comment">// skip non spaces</span><br>        reverse(a, i, j - <span class="hljs-number">1</span>);                      <span class="hljs-comment">// reverse the word</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// trim leading, trailing and multiple spaces</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">cleanSpaces</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="hljs-string">&#x27; &#x27;</span>) j++;             <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] != <span class="hljs-string">&#x27; &#x27;</span>) a[i++] = a[j++]; <span class="hljs-comment">// keep non spaces</span><br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="hljs-string">&#x27; &#x27;</span>) j++;             <span class="hljs-comment">// skip spaces</span><br>        <span class="hljs-keyword">if</span> (j &lt; n) a[i++] = <span class="hljs-string">&#x27; &#x27;</span>;                      <span class="hljs-comment">// keep only one space</span><br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(a).substring(<span class="hljs-number">0</span>, i);<br>    &#125;<br><br>    <span class="hljs-comment">// reverse a[] from a[i] to a[j]</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>      <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[i];<br>        a[i++] = a[j];<br>        a[j--] = t;<br>      &#125;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>三大关键部分：字符串反转，单词反转，去除空格。</p><p>reverseWords部分，i代表的是字符串的起点，j代表的是字符串的终点，i先跳过空格，j再跳过所有字符。</p><p>CleanSpace部分，把循环里面的步骤分为：1⃣️ 跳过空格，直到找到非空停止。2⃣️ 把非空的值填入到数组的头部，一直重复，直到找到下一个空格。(j &lt; n) 就是用来防止如果后面不再出现空格了，如何退出循环。<3⃣️ 找到下次非空的话，代表有下一个需要进行处理的字母，就将之前填充好的字母的下一位填充一个空格，结束本次循环> </p><h2 id="6-6-使用KMP匹配字符串"><a href="#6-6-使用KMP匹配字符串" class="headerlink" title="6.6 使用KMP匹配字符串"></a>6.6 使用KMP匹配字符串</h2><p><strong>28. Implement strStr()</strong></p><p><strong>Q: </strong>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p><p><strong>Clarification:</strong></p><p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String">indexOf()</a>).</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span>(haystack == <span class="hljs-literal">null</span> || needle == <span class="hljs-literal">null</span> || needle.length() &gt; haystack.length()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-type">int</span>[] next = kmpPreprocess(needle);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; haystack.length() &amp;&amp; j &lt; needle.length()) &#123;<br>          <span class="hljs-comment">// 找到了就继续往后找</span><br>            <span class="hljs-keyword">if</span>(haystack.charAt(i) == needle.charAt(j)) &#123;<br>                i++; j++;<br>            <span class="hljs-comment">// 如果匹配串中此位置不相等，匹配串就回退next数组的j - 1位置的值</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 如果字符串没有找到匹配串中的值，并且匹配串还未成功匹配</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span>= needle.length() ? i - j : -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] kmpPreprocess(String s) &#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-comment">// 直接用前缀表作next数组</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>          <span class="hljs-comment">// 向前回退，在j = 0或者s[i] == s[j]时退出</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 找到相同的前后缀</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-comment">// 将j(前缀的长度)赋给next[i]</span><br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>KMP思想，利用next数组作为匹配的方法。两种构造next数组方法的区别就在于匹配的地方，如果由前缀表统一减一来构造next数组，那么遇到不匹配的地方直接回归对应下标的next数组的数值就行了；不减一的方法，遇到不匹配的地方就查找前一位下标的next数组对应的数值进行回退。</p><p>之所以为什么是next[j - 1]是因为，由于当前j位置是不匹配的但j - 1的位置之前的都是匹配的，所以我们要回到尽可能远离起始的位置（根据相同前后缀），也就是next[j - 1]存储的位置信息。</p><h2 id="6-7-找到重复的子字符串"><a href="#6-7-找到重复的子字符串" class="headerlink" title="6.7 找到重复的子字符串"></a>6.7 找到重复的子字符串</h2><p><strong>459. Repeated Substring Pattern</strong></p><p><strong>Q: </strong>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] next = kmpPreprocess(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % (len - (next[len - <span class="hljs-number">1</span>])) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] kmpPreprocess(String s) &#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-comment">// 直接用前缀表作next数组</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br>          <span class="hljs-comment">// 向前回退，在j = 0或者s[i] == s[j]时退出</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 找到相同的前后缀</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-comment">// 将j(前缀的长度)赋给next[i]</span><br>            next[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果len % (len - (next[len - 1])) == 0，则说明(数组长度 - 最长相等前后缀的长度)正好可以被数组的长度整除，该字符串中有重复的数组。</p><p>len - 1代表的是最后一位next数组。用前缀表不用-1，因为前缀表本身就+1了。</p><p>Cral哥写的这种比较好理解，我一直让j充当相同的j前缀的长度，如果往后遍历的i一直是后缀的起始位置。不用考虑i和j之间的元素，只需要看i和j的位置。基本步调是(和初始是一样的)i在前面，j在后面，如果相同了j++跟上，i继续走一个，如果出现了不一样的，则一直往前回退到有相同的(也可能一直回退到开头)，然后继续按之前的步调走，直到后缀遍历完成。</p><p>PS：其中对于前缀表减1的那种方法和这种方法主要的区别是前缀表那种，预处理方便，前缀表减少1那种，遍历的时候方便。方便指好思考。</p><h1 id="第7章-栈与队列"><a href="#第7章-栈与队列" class="headerlink" title="第7章 栈与队列"></a>第7章 栈与队列</h1><h2 id="7-2-用栈组成队列"><a href="#7-2-用栈组成队列" class="headerlink" title="7.2 用栈组成队列"></a>7.2 用栈组成队列</h2><p><strong>232. Implement Queue using Stacks</strong></p><p><strong>Q: </strong>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p><p>Implement the <code>MyQueue</code> class:</p><ul><li><code>void push(int x)</code> Pushes element x to the back of the queue.</li><li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li><li><code>int peek()</code> Returns the element at the front of the queue.</li><li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code>otherwise.</li></ul><p><strong>Notes:</strong></p><ul><li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li><li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</li></ul><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <br>    <span class="hljs-comment">// 待处理part</span><br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">stkIn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <span class="hljs-comment">// 预备输出part</span><br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">stkOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stkIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 只有当stkOut为空的时候才导入stkIn的peek</span><br>        <span class="hljs-keyword">if</span> (stkOut.empty()) &#123;<br>            <span class="hljs-comment">// 导入全部的stkIn</span><br>            <span class="hljs-keyword">while</span> (!stkIn.empty()) &#123;<br>                stkOut.push(stkIn.peek());<br>                stkIn.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出栈不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) stkOut.peek();<br>        stkOut.pop();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 只有当stkOut为空的时候才导入stkIn的peek</span><br>        <span class="hljs-keyword">if</span> (stkOut.empty()) &#123;<br>            <span class="hljs-comment">// 导入全部的stkIn</span><br>            <span class="hljs-keyword">while</span> (!stkIn.empty()) &#123;<br>                stkOut.push(stkIn.peek());<br>                stkIn.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出栈不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) stkOut.peek();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (stkIn.empty() &amp;&amp; stkOut.empty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用两个队列，一个用来输入一个用来输出。特别要注意的是关注输出栈是不是空的，如果非空要优先处理输出栈的（pop和peek方法）</p><h2 id="7-3-用队列组成栈"><a href="#7-3-用队列组成栈" class="headerlink" title="7.3 用队列组成栈"></a>7.3 用队列组成栈</h2><p><strong>225. Implement Stack using Queues</strong></p><p><strong>Q: </strong></p><p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p><p>Implement the <code>MyStack</code> class:</p><ul><li><code>void push(int x)</code> Pushes element x to the top of the stack.</li><li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li><li><code>int top()</code> Returns the element on the top of the stack.</li><li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code>otherwise.</li></ul><p><strong>Notes:</strong></p><ul><li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code>operations are valid.</li><li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</li></ul><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// Push element x onto stack.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue.add(x);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)<br>            queue.add(queue.poll());<br>            n--;<br>    &#125;<br><br>    <span class="hljs-comment">// Removes the element on top of the stack.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        queue.poll();<br>    &#125;<br><br>    <span class="hljs-comment">// Get the top element.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br><br>    <span class="hljs-comment">// Return whether the stack is empty.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里和之前的用栈组成队列不太一样，可以只使用一个，总体来讲是个缓存的思想，将队头的元素重新放回到队尾(双队列也如此)。</p><h2 id="7-4-匹配括号"><a href="#7-4-匹配括号" class="headerlink" title="7.4 匹配括号"></a>7.4 匹配括号</h2><p><strong>20. Valid Parentheses</strong></p><p><strong>Q: </strong>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code>and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Character&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>      <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>)<br>        stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() != c)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先学会一点，匹配对的问题可以用栈来解决(先出现的左符号要最后匹配右符号，这样正好符合栈的特点)。对于这道题我们反过来想，当匹配到左符号，就将对应的右符号压入栈，然后往后匹配看看后面有没有对应的右符号。</p><h2 id="7-5-逆波兰表达式"><a href="#7-5-逆波兰表达式" class="headerlink" title="7.5 逆波兰表达式"></a>7.5 逆波兰表达式</h2><p><strong>150. Evaluate Reverse Polish Notation</strong></p><p><strong>Q: </strong>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</p><p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer or another expression.</p><p><strong>Note</strong> that division between two integers should truncate toward zero.</p><p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        <span class="hljs-type">int</span> a,b;<br>Stack&lt;Integer&gt; S = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br><span class="hljs-keyword">for</span> (String s : tokens) &#123;<br><span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;+&quot;</span>)) &#123;<br>S.add(S.pop()+S.pop());<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>b = S.pop();<br>a = S.pop();<br>S.add(a / b);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;*&quot;</span>)) &#123;<br>S.add(S.pop() * S.pop());<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>b = S.pop();<br>a = S.pop();<br>S.add(a - b);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>S.add(Integer.parseInt(s));<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> S.pop();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用栈来存之前的路径，如果是数字就入栈，如果是符号就出栈前两位数字进行计算，将结果再入栈。</p><h2 id="7-6-滑动窗口最大值"><a href="#7-6-滑动窗口最大值" class="headerlink" title="7.6 滑动窗口最大值"></a>7.6 滑动窗口最大值</h2><p><strong>239. Sliding Window Maximum</strong></p><p><strong>Q: </strong>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code>which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p><p>Return <em>the max sliding window</em>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义数组</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-comment">//弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出</span><br>    <span class="hljs-comment">//同时判断队列当前是否为空</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; val == deque.peek()) &#123;<br>            deque.poll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出</span><br>    <span class="hljs-comment">//保证队列元素单调递减</span><br>    <span class="hljs-comment">//比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.add(val);<br>    &#125;<br>    <span class="hljs-comment">//队列队顶元素始终为最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> deque.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//存放结果元素的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//自定义队列</span><br>        <span class="hljs-type">MyQueue</span> <span class="hljs-variable">myQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br>        <span class="hljs-comment">//先将前k的元素放入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            myQueue.add(nums[i]);<br>        &#125;<br>        res[num++] = myQueue.peek();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//滑动窗口移除最前面的元素，移除是判断该元素是否放入队列</span><br>            myQueue.poll(nums[i - k]);<br>            <span class="hljs-comment">//滑动窗口加入最后面的元素</span><br>            myQueue.add(nums[i]);<br>            <span class="hljs-comment">//记录对应的最大值</span><br>            res[num++] = myQueue.peek();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//解法二</span><br><span class="hljs-comment">//利用双端队列手动实现单调队列</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可</span><br><span class="hljs-comment"> * 单调队列类似 （tail --&gt;） 3 --&gt; 2 --&gt; 1 --&gt; 0 (--&gt; head) (右边为头结点，元素存的是下标)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        ArrayDeque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span><br>            <span class="hljs-comment">// 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="hljs-number">1</span>)&#123;<br>                deque.poll();<br>            &#125;<br>            <span class="hljs-comment">// 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br><br>            deque.offer(i);<br><br>            <span class="hljs-comment">// 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span><br>            <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>)&#123;<br>                res[idx++] = nums[deque.peek()];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>deque 双端队列：如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名 <strong>Deque</strong> 。 <strong>Java</strong>集合提供了接口 <strong>Deque</strong> 来实现一个双端队列，它的功能是： 既可以添加到队尾，也可以添加到队首； 既可以从队首获取，又可以从队尾获取。</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Queue</th><th style="text-align:left">Deque</th></tr></thead><tbody><tr><td style="text-align:left">添加元素到队尾</td><td style="text-align:left">add(E e) / offer(E e)</td><td style="text-align:left">addLast(E e) / offerLast(E e)</td></tr><tr><td style="text-align:left">取队首元素并删除</td><td style="text-align:left">E remove() / E poll()</td><td style="text-align:left">E removeFirst() / E pollFirst()</td></tr><tr><td style="text-align:left">取队首元素但不删除</td><td style="text-align:left">E element() / E peek()</td><td style="text-align:left">E getFirst() / E peekFirst()</td></tr><tr><td style="text-align:left">添加元素到队首</td><td style="text-align:left">无</td><td style="text-align:left">addFirst(E e) / offerFirst(E e)</td></tr><tr><td style="text-align:left">取队尾元素并删除</td><td style="text-align:left">无</td><td style="text-align:left">E removeLast() / E pollLast()</td></tr><tr><td style="text-align:left">取队尾元素但不删除</td><td style="text-align:left">无</td><td style="text-align:left">E getLast() / E peekLast()</td></tr></tbody></table></div><h2 id="7-7-前k个高频元素"><a href="#7-7-前k个高频元素" class="headerlink" title="7.7 前k个高频元素"></a>7.7 前k个高频元素</h2><p><strong>347. Top K Frequent Elements</strong></p><p><strong>Q: </strong>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-comment">// 记录频率</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();<br>        <span class="hljs-comment">// 根据map的value值正序排，相当于一个小顶堆</span><br>        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;<br>            queue.offer(entry);<br>            <span class="hljs-keyword">if</span> (queue.size() &gt; k) &#123;<br>                queue.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = queue.poll().getKey();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题目主要涉及到如下三块内容：</p><ol><li>要统计元素出现频率</li><li>对频率排序</li><li>找出前K个高频元素</li></ol><h2 id="7-8-接雨水"><a href="#7-8-接雨水" class="headerlink" title="7.8 接雨水"></a>7.8 接雨水</h2><p><strong>42. Trapping Rain Water</strong></p><p><strong>Q: </strong>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><p><strong>A: </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftMax[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> rightMax[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        rightMax[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; n;i++) &#123;<br>            leftMax[i] = Math.max(leftMax[i - <span class="hljs-number">1</span>], height[i]);<br>            rightMax[n - i - <span class="hljs-number">1</span>] = Math.max(rightMax[n - i], height[n - i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">trappedWater</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>            trappedWater += Math.min(leftMax[i], rightMax[i]) - height[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> trappedWater;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一列雨水的高度主要取决于左侧最高的柱子和右侧的最高的柱子之间的最矮的柱子的高度</p><p>由于决定当前坐标的位置盛水的高度只取决于其左右两边的围栏的最小值（木桶效应），所以我们需要建立两个数组用来存储当前位置的其左右两边的水桶的高度最大值。</p><p>Step1: 我们先将同一个坐标位置下的左右两边最大的高度存储下来</p><p>Step2: 我们求解水量 Math.min(leftMax[i], rightMax[i]) - height[i]</p><h1 id="第8章-二叉树"><a href="#第8章-二叉树" class="headerlink" title="第8章 二叉树"></a>第8章 二叉树</h1><h2 id="8-1-二叉树前中后序遍历"><a href="#8-1-二叉树前中后序遍历" class="headerlink" title="8.1 二叉树前中后序遍历"></a>8.1 二叉树前中后序遍历</h2><h3 id="8-1-1-前序遍历"><a href="#8-1-1-前序遍历" class="headerlink" title="8.1.1 前序遍历"></a>8.1.1 前序遍历</h3><p><strong>144. Binary Tree Preorder Traversal</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        preorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        result.add(root.val);   <span class="hljs-comment">// get value of root</span><br>        preorder(root.left, result); <span class="hljs-comment">// left</span><br>        preorder(root.right, result); <span class="hljs-comment">// right</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根左右顺序递归进去，遍历树和图还是比较好想的，因为可以正向思维往深了走。</p><h3 id="8-1-2-中序遍历"><a href="#8-1-2-中序遍历" class="headerlink" title="8.1.2 中序遍历"></a><strong>8.1.2 中序遍历</strong></h3><p><strong>94. Binary Tree Inorder Traversal</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p><p><strong>A:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        inorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorder(root.left, result);    <span class="hljs-comment">// left</span><br>        result.add(root.val); <span class="hljs-comment">// get value of root</span><br>        inorder(root.right, result); <span class="hljs-comment">// right</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>左根右顺序递归进去</p><h3 id="8-1-3-后序遍历"><a href="#8-1-3-后序遍历" class="headerlink" title="8.1.3 后序遍历"></a><strong>8.1.3 后序遍历</strong></h3><p><strong>145. Binary Tree Postorder Traversal</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the postorder traversal of its nodes’ values</em>.</p><p><strong>A：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        postorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorder(root.left, result); <span class="hljs-comment">// left</span><br>        postorder(root.right, result); <span class="hljs-comment">// right</span><br>        result.add(root.val); <span class="hljs-comment">// get value of root</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-2-二叉树层序遍历"><a href="#8-2-二叉树层序遍历" class="headerlink" title="8.2 二叉树层序遍历"></a>8.2 二叉树层序遍历</h2><p><strong>102. Binary Tree Level Order Traversal</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p><p><strong>A：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;  <br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();  <br>        queue.add(root);  <br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;  <br>          List&lt;Integer&gt; itemList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>          <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();  <br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;  <br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();  <br>            itemList.add(node.val);  <br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;  <br>              queue.offer(node.left);  <br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;  <br>              queue.offer(node.right);  <br>            &#125;  <br>          &#125;  <br>          res.add(itemList);   <br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>层序遍历的关键在于队列的使用。我们先将根放入队列中，然后终止判定为队列为空，那么如何保证他不会空呢？由于每次出栈一个元素后就把他的左右子树放进队列（如果有的话），这样可以保证队列不会空而退出循环，并且是按照左右子树的顺序也保证了后面的层序遍历仍然是从左往右。</p><p>跟行有关的二叉树可以优先选择层序遍历。</p><p><strong>EXTEND QUESTIONS:</strong></p><p>107、199、637、429、515、116、104</p><h2 id="8-11-二叉树的所有路径"><a href="#8-11-二叉树的所有路径" class="headerlink" title="8.11 二叉树的所有路径"></a>8.11 二叉树的所有路径</h2><p><strong>257. Binary Tree Paths</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p><p>A <strong>leaf</strong> is a node with no children.</p><p><strong>A:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>    &#125;<br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;strconv.Itoa(root.Val)&#125;<br>    &#125;<br>    tmpLeft := binaryTreePaths(root.Left)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmpLeft); i++ &#123;<br>      res = <span class="hljs-built_in">append</span>(res, strconv.Itoa(root.Val)+<span class="hljs-string">&quot;-&gt;&quot;</span>+tmpLeft[i])<br>    &#125;<br>    tmpRight := binaryTreePaths(root.Right)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmpRight); i++ &#123;<br>      res = <span class="hljs-built_in">append</span>(res, strconv.Itoa(root.Val)+<span class="hljs-string">&quot;-&gt;&quot;</span>+tmpRight[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>也是递归的思想，从根向子节点遍历的话用前序遍历（根左右）。tmpLeft代表的是左边收集到的路径，同理tmpRight就是右边收集到的路径。</p><h2 id="8-12-路径总和"><a href="#8-12-路径总和" class="headerlink" title="8.12 路径总和"></a>8.12 路径总和</h2><p><strong>112. Path Sum</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p><p>A <strong>leaf</strong> is a node with no children.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> pathSum(root, targetSum - root.Val)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, count <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &amp;&amp; count == <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 遇到叶子结点，并且计数为0</span><br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 遇到叶子节点,Count不为0，直接返回</span><br>    <br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        count -= root.Left.Val  <span class="hljs-comment">// 递归，处理节点</span><br>        <span class="hljs-keyword">if</span> pathSum(root.Left, count) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        count += root.Left.Val  <span class="hljs-comment">// 回溯，撤销处理结果</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        count -= root.Right.Val  <span class="hljs-comment">// 递归，处理节点</span><br>        <span class="hljs-keyword">if</span> pathSum(root.Right, count) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        count += root.Right.Val  <span class="hljs-comment">// 回溯，撤销处理结果</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>递归和回溯是要在一起的，每一次递归都要有对应的回溯，这里用到的是根左右的形式。递归的话不要仔细去想具体的每一步是怎么样的，而是要关注三部曲，1⃣️入口的样子，2⃣️终止条件，3⃣️中间的处理逻辑。本篇通过leetcode上 <strong>112. 路径总和</strong> 和 <strong>113. 路径总和ii</strong> 详细的讲解了递归函数什么时候需要返回值，什么不需要返回值。</p><p><strong>113. Path Sum II</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals</em> <code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p><p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, sum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> slice [][]<span class="hljs-type">int</span><br>slice = findPath(root, sum, slice, []<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>))<br>    fmt.Println(slice)<br><span class="hljs-keyword">return</span> slice<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPath</span><span class="hljs-params">(root *TreeNode, sum <span class="hljs-type">int</span>, slice [][]<span class="hljs-type">int</span>, path []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;    <br>      <span class="hljs-keyword">return</span> slice<br>    &#125;<br>    sum -= root.Val  <span class="hljs-comment">// 进入一个节点就用当前val减少sum的值</span><br>    path = <span class="hljs-built_in">append</span>(path, root.Val)  <span class="hljs-comment">// 将当前val这个结果加入（一个切片）</span><br>    <span class="hljs-keyword">if</span> sum == <span class="hljs-number">0</span> &amp;&amp; root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// 如果摸到了最末端一个节点并且sum已经被减光</span><br>      slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, path...))  <span class="hljs-comment">// 把之前栈的结果全部导入到slice里面</span><br>        <span class="hljs-keyword">return</span> slice<br>    &#125;<br>    slice = findPath(root.Left, sum, slice, path)<br>    slice = findPath(root.Right, sum, slice, path)<br>    <span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure><p>学习的别人的思路，整体采用的是根左右也就是从上向下遍历的过程。slice是要输出的结果，path用来存储之前走过的路径。只有当sum == 0完全符合条件的时候才将之前存的所有路径都放入切片。</p><p>PS: slice的切片是左闭右开的，所以<code>len(stack) - 1</code>相当于退出去了一位数。</p><h2 id="8-13-构造一颗二叉树"><a href="#8-13-构造一颗二叉树" class="headerlink" title="8.13 构造一颗二叉树"></a>8.13 构造一颗二叉树</h2><p><strong>106. Construct Binary Tree from Inorder and Postorder Traversal</strong></p><p><strong>Q：</strong>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(inorder []<span class="hljs-type">int</span>, postorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>   postorderLen := <span class="hljs-built_in">len</span>(postorder)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>root := &amp;TreeNode&#123;Val: postorder[postorderLen<span class="hljs-number">-1</span>]&#125;<br>    postorder = postorder[:postorderLen<span class="hljs-number">-1</span>]<br>    <br>    <span class="hljs-keyword">for</span> pos, node := <span class="hljs-keyword">range</span> inorder &#123;<br>        <span class="hljs-keyword">if</span> node == root.Val &#123;<br>            root.Left = buildTree(inorder[:pos], postorder[:<span class="hljs-built_in">len</span>(inorder[:pos])])<br>            root.Right = buildTree(inorder[pos+<span class="hljs-number">1</span>:], postorder[<span class="hljs-built_in">len</span>(inorder[:pos]):])<br>        &#125;<br>&#125;<br>  <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>来看一下一共分几步：</p><ul><li>第一步：如果数组大小为零的话，说明是空节点了。</li><li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li><li>第三步：找到当前节点在中序的位置，此处节点看为根</li><li>第四步：<code>root.Left = buildTree(inorder[:pos], postorder[:len(inorder[:pos])])</code>区间是左闭右开，所以我们进行切片，取中序中此点的左侧，和后序中的左边。</li><li>第五步：<code>root.Right = buildTree(inorder[pos+1:], postorder[len(inorder[:pos]):])</code>区间是左闭右开，进行切片，取中序中此点的右侧，和后序列中的右边（因为已经抛开了根节点，所以右侧的所有都是右子树的所有内容。</li></ul><p>全程都是抠出来后序遍历中的数值制作节点，root.Left = [ return root ] 同理right也是这样，我们每一层叠戴的都是下一层的某一个根节点</p><p><strong>105. Construct Binary Tree from Preorder and Inorder Traversal</strong></p><p><strong>Q：</strong>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    root := &amp;TreeNode&#123; Val: preorder[<span class="hljs-number">0</span>] &#125;    <br>    preorder = preorder[<span class="hljs-number">1</span>:]  <span class="hljs-comment">// poll the first preorder value</span><br>    <br>    <span class="hljs-keyword">for</span> pos, node := <span class="hljs-keyword">range</span> inorder &#123; <span class="hljs-comment">// preorder:(before) N L R (now) L R</span><br>        <span class="hljs-keyword">if</span> node == root.Val &#123;<br>            root.Left = buildTree(preorder[:pos], inorder[:pos])<br>            root.Right = buildTree(preorder[pos:], inorder[pos+<span class="hljs-number">1</span>:])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>同理上面的不同的是，pos这里是inorder中L的长度。</p><h2 id="8-14-合并两个二叉树"><a href="#8-14-合并两个二叉树" class="headerlink" title="8.14 合并两个二叉树"></a>8.14 合并两个二叉树</h2><p><strong>617. Merge Two Binary Trees</strong></p><p><strong>Q：</strong>You are given two binary trees <code>root1</code> and <code>root2</code>.</p><p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p><p>Return <em>the merged tree</em>.</p><p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTrees</span><span class="hljs-params">(root1 *TreeNode, root2 *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root2 &#125;<br>    <span class="hljs-keyword">if</span> root2 == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> root1 &#125;<br>    <br>    root1.Val += root2.Val<br>    root1.Left = mergeTrees(root1.Left, root2.Left)<br>    root1.Right = mergeTrees(root1.Right, root2.Right)<br>    <span class="hljs-keyword">return</span> root1<br>&#125;<br></code></pre></td></tr></table></figure><p>以其中一个为根，以其中一个为参照物进行合并。</p><ul><li>简单题。采用深搜的思路，分别从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。两个二叉树的对应节点可能存在以下三种情况：<ul><li>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</li><li>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</li><li>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</li></ul></li><li>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。用递归实现即可</li></ul><h2 id="8-15-二叉搜索树中的搜索"><a href="#8-15-二叉搜索树中的搜索" class="headerlink" title="8.15 二叉搜索树中的搜索"></a>8.15 二叉搜索树中的搜索</h2><p><strong>700. Search in a Binary Search Tree</strong></p><p><strong>Q：</strong>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p><p>Find the node in the BST that the node’s value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || root.Val == val &#123; <span class="hljs-keyword">return</span> root &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Val &gt; val &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.Left, val)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt; val &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.Right, val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p><strong>因为搜索到目标节点了，就要立即return了，这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。</strong></p><p>（如果你没有写return那么就算找到了我们也没有回去的路了，相当于是停在了找到的点那里）</p><h2 id="8-16-验证二叉搜索树"><a href="#8-16-验证二叉搜索树" class="headerlink" title="8.16 验证二叉搜索树"></a>8.16 验证二叉搜索树</h2><p><strong>98. Validate Binary Search Tree</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p><p>A <strong>valid BST</strong> is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong>the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;&#125;<br>    inOrder(root, &amp;arr)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>        <span class="hljs-keyword">if</span> arr[i - <span class="hljs-number">1</span>] &gt;= arr[i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, arr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, arr)<br>    *arr = <span class="hljs-built_in">append</span>(*arr, root.Val)<br>    inOrder(root.Right, arr)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。</strong></p><p>中序遍历，验证遍历的元素是不是从小到大。我们先存储左根右的数组序列，然后check他的顺序是否是对的。</p><p><code>*arr = append(*arr, root.Val)</code>这里如果不加*的话，代表arr就是个指向isValidBST的arr的一个指针，加了星号才能提取到他指向的内容，并且操作他指向的内容！</p><h2 id="8-17-二叉搜索树的最小绝对值差"><a href="#8-17-二叉搜索树的最小绝对值差" class="headerlink" title="8.17 二叉搜索树的最小绝对值差"></a>8.17 二叉搜索树的最小绝对值差</h2><p><strong>530. Minimum Absolute Difference in BST</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum absolute difference between the values of any two different nodes in the tree</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;&#125;<br>    inOrder(root, &amp;arr)<br>    diff := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>        diff = <span class="hljs-built_in">append</span>(diff, abs(arr[i - <span class="hljs-number">1</span>] - arr[i]))<br>    &#125;<br>    fmt.Print(<span class="hljs-string">&quot;diff: &quot;</span>)<br>    fmt.Println(diff)<br>    min := diff[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(diff); j++ &#123;<br>        <span class="hljs-keyword">if</span> diff[j] &lt; min &#123;<br>            min = diff[j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> min<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -a<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, arr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, arr)<br>    *arr = <span class="hljs-built_in">append</span>(*arr, root.Val)<br>    inOrder(root.Right, arr)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>由于是 BST 树，利用它有序的性质，中根遍历的结果是有序的。中根遍历过程中动态维护前后两个节点的差值，即可找到最小差值。</li><li>此题与第 783 题完全相同。</li></ul><h2 id="8-18-二叉搜索树中的众数"><a href="#8-18-二叉搜索树中的众数" class="headerlink" title="8.18 二叉搜索树中的众数"></a>8.18 二叉搜索树中的众数</h2><p><strong>501. Find Mode in Binary Search Tree</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary search tree (BST) with duplicates, return <em>all the <a href="https://en.wikipedia.org/wiki/Mode_(statistics">mode(s)</a>) (i.e., the most frequently occurred element) in it</em>.</p><p>If the tree has more than one mode, return them in <strong>any order</strong>.</p><p>Assume a BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMode</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    inOrder(root, m)<br>    max := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">if</span> val &gt;= max &#123;<br>            max = val<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">if</span> val == max &#123;<br>            res = <span class="hljs-built_in">append</span>(res, key)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(root *TreeNode, m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    inOrder(root.Left, m)<br>    <span class="hljs-keyword">if</span> _, exist := m[root.Val]; !exist &#123;<br>        m[root.Val] = <span class="hljs-number">1</span><br>    &#125;<br>    m[root.Val] += <span class="hljs-number">1</span><br>    inOrder(root.Right, m)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-19-二叉树的最近公共祖先"><a href="#8-19-二叉树的最近公共祖先" class="headerlink" title="8.19 二叉树的最近公共祖先"></a>8.19 二叉树的最近公共祖先</h2><p><strong>236. Lowest Common Ancestor of a Binary Tree</strong></p><p><strong>Q：</strong>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// stop</span><br>    <span class="hljs-keyword">if</span> root == p || root == q || root == <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-comment">// left</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br>    <span class="hljs-comment">// right</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br>    <span class="hljs-comment">// root</span><br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &amp;&amp; left != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 搜索一条边的写法：</span><br><span class="hljs-keyword">if</span> (递归函数(root.left)) <span class="hljs-keyword">return</span> <br><br><span class="hljs-keyword">if</span> (递归函数(root.right)) <span class="hljs-keyword">return</span> <br><br><span class="hljs-comment">// 搜索整个树写法：</span><br>left = 递归函数(root.left)<br>right = 递归函数(root.right)<br>left与right的逻辑处理<br></code></pre></td></tr></table></figure><p>注意：</p><p>1、p和q如果写了肯定是在这个BST里面的，所以必然不会有nil的结果。</p><p>2、我们为什么要回溯某一个right或者left？如果是最简单的情况，我们找的p和q在同一个子树上面，那么返回的就是他们的祖先，如果不在同一个子树上面，返回的就是他们的根节点。知道了这个规则以后，就很好理解了为什么要返回right或者left了，并且为什么是从下往上找而不是从上往下找。逻辑就是，我从下往上左右去找是否有满足的p和q如果都满足了那么此时的root就是p和q的祖父，如果没有满足就是nil，继续往上找。</p><h2 id="8-20-在二叉搜索树中插入一个节点"><a href="#8-20-在二叉搜索树中插入一个节点" class="headerlink" title="8.20 在二叉搜索树中插入一个节点"></a>8.20 在二叉搜索树中插入一个节点</h2><p><strong>701. Insert into a Binary Search Tree</strong></p><p><strong>Q：</strong>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p><p><strong>Notice</strong> that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: val&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &lt; root.Val &#123;<br>        root.Left = insertIntoBST(root.Left, val)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.Right = insertIntoBST(root.Right, val)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这道题目其实是一道简单题目，<strong>但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人</strong>，瞬间感觉题目复杂了很多。</p><p>其实<strong>可以不考虑题目中提示所说的改变树的结构的插入方式。</strong></p><p><strong>有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作</strong>。</p><p>思路：我们找的是一条边，如果是空的节点的话就是找到了该插入的位置，插入即可，剩下的返回的都是现存的节点值。</p><h2 id="8-21-在二叉搜索树中删除一个节点"><a href="#8-21-在二叉搜索树中删除一个节点" class="headerlink" title="8.21 在二叉搜索树中删除一个节点"></a>8.21 在二叉搜索树中删除一个节点</h2><p><strong>450. Delete Node in a BST</strong></p><p><strong>Q：</strong>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p><p>Basically, the deletion can be divided into two stages:</p><ol><li>Search for a node to remove.</li><li>If the node is found, delete the node.</li></ol><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(root *TreeNode, key <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val == key &#123;<br>        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Right<br>        &#125;<br>        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Left<br>        &#125;<br>        tmp := root.Right<br>        <span class="hljs-keyword">for</span> tmp.Left != <span class="hljs-literal">nil</span> &#123;<br>            tmp = tmp.Left<br>        &#125;<br>        tmp.Left = root.Left<br>        <span class="hljs-keyword">return</span> root.Right<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> key &lt; root.Val &#123;<br>        root.Left = deleteNode(root.Left, key)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.Right = deleteNode(root.Right, key)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>主要的点在于考虑删除节点的位置，有以下五种情况：</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li></ul></li></ul><h2 id="8-22-修剪二叉搜索树"><a href="#8-22-修剪二叉搜索树" class="headerlink" title="8.22 修剪二叉搜索树"></a>8.22 修剪二叉搜索树</h2><p><strong>669. Trim a Binary Search Tree</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p><p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trimBST</span><span class="hljs-params">(root *TreeNode, low <span class="hljs-type">int</span>, high <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    <br>    <span class="hljs-keyword">if</span> root.Val &lt; low &#123;<br>        right := trimBST(root.Right, low, high)<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &gt; high &#123;<br>        left := trimBST(root.Left, low, high)<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <br>    root.Right = trimBST(root.Right, low, high)<br>    root.Left = trimBST(root.Left, low, high)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。</p><p>思路：</p><p>1、如果此时的节点值小于了最小边界（因为是闭区间），那这个节点就废掉，我们找比他大的（他的右子树中是否有符合的节点）</p><p>2、如果此时的节点值大于了最大边界（因为是闭区间），那这个节点就废掉，我们找比他小的（他的左子树中是否有符合的节点）</p><p>3、拼接分支，类似于之前的用法，如果没有裁剪就返回的是root（当前的节点）如果有裁剪，返回的就是获取的left或者right</p><h2 id="8-23-构建一棵平衡二叉树"><a href="#8-23-构建一棵平衡二叉树" class="headerlink" title="8.23 构建一棵平衡二叉树"></a>8.23 构建一棵平衡二叉树</h2><p><strong>108. Convert Sorted Array to Binary Search Tree</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a <strong>height-balanced</strong> binary search tree</em>.</p><p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;TreeNode&#123;<br>        Val: nums[<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>], <br>        Left: sortedArrayToBST(nums[:<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>]), <br>        Right: sortedArrayToBST(nums[<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>:])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除二叉树节点，增加二叉树节点，都是用递归函数的返回值来完成，这样是比较方便的。</p><ul><li>确定递归终止条件</li></ul><p>如果nums的长度为0，则说明没有数需要放入了，利用了go的切片，注意切片是左闭右开</p><p>Step：</p><p>1、将此时的节点值写成nums的中心</p><p>2、左支是此点的左边所有数组</p><p>3、右支是此点右边的所有数组</p><p>4、迭代，终止条件如上</p><h1 id="第9章-回溯算法"><a href="#第9章-回溯算法" class="headerlink" title="第9章 回溯算法"></a>第9章 回溯算法</h1><p>回溯问题的模板</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">backtracking(参数) &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-1-组合问题"><a href="#9-1-组合问题" class="headerlink" title="9.1 组合问题"></a>9.1 组合问题</h2><p><strong>77. Combinations</strong></p><p><strong>Q：</strong>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers out of the range</em> <code>[1, n]</code>.</p><p>You may return the answer in <strong>any order</strong>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span> || k &gt; n &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;  <span class="hljs-comment">// c is combine</span><br>    generateCombinations(n, k, <span class="hljs-number">1</span>, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateCombinations</span><span class="hljs-params">(n, k, start <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == k &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// for i := start; i &lt;= n; i++ 不剪枝头的写法</span><br>    <span class="hljs-keyword">for</span> i := start; i &lt;= n - (k - <span class="hljs-built_in">len</span>(c)) + <span class="hljs-number">1</span>; i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, i)<br>        generateCombinations(n, k, i + <span class="hljs-number">1</span>, c, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20201123195242899.png" alt="77. Combinations"></p><p><code>i &lt;= n - (k - len(c)) + 1</code>这个条件很关键他可以帮助我们减少分支，去除那些本身为空的答案。n 本身是我们可选项的上限，我们只靠start来控制不重复。</p><ol><li>已经选择的元素个数：len(c)</li><li>还需要的元素个数为: k - len(c)          （从后往前数，最开始一层就是k，所以倒数后k个数是最远的起始位置）</li><li><p>在集合n中至多要从该起始位置 : n - (k - len(c)) + 1(start)，开始遍历  </p><p>(翻译过来就是如果总共的n个数减去我们还需要的元素后剩余的最大个数，作为我们起始位置的最远端)</p></li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><h2 id="9-2-组合总和-III"><a href="#9-2-组合总和-III" class="headerlink" title="9.2 组合总和 III"></a>9.2 组合总和 III</h2><p><strong>216. Combination Sum III</strong></p><p><strong>Q：</strong>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p><ul><li>Only numbers <code>1</code> through <code>9</code> are used.</li><li>Each number is used <strong>at most once</strong>.</li></ul><p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum3</span><span class="hljs-params">(k <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span> || k &gt; n &#123;<br>        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    generateCombinations(k, n, <span class="hljs-number">1</span>, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateCombinations</span><span class="hljs-params">(k, target, start <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == k &amp;&amp; target == <span class="hljs-number">0</span>&#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>  <br>  <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> &#125;<br><br>    <span class="hljs-keyword">for</span> i := start; i &lt;= <span class="hljs-number">9</span>; i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, i)<br>        generateCombinations(k, target - i, i + <span class="hljs-number">1</span>, c, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>雷同77题，不过遇到一个问题就是当对i进行剪枝的时候，他会爆栈。</p><h2 id="9-3-电话号码的字母组合"><a href="#9-3-电话号码的字母组合" class="headerlink" title="9.3 电话号码的字母组合"></a>9.3 电话号码的字母组合</h2><p><strong>17. Letter Combinations of a Phone Number</strong></p><p><strong>Q：</strong>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> result []<span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;2&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;3&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;4&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;5&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;j&quot;</span>, <span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;6&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;7&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;8&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;v&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;9&quot;</span> : []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(digits <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    result = []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> digits == <span class="hljs-string">&quot;&quot;</span> &#123;<br>      <span class="hljs-keyword">return</span> result<br>    &#125;<br>    letterFunc(<span class="hljs-string">&quot;&quot;</span>, digits)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterFunc</span><span class="hljs-params">(res <span class="hljs-type">string</span>, digits <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> digits == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        result = <span class="hljs-built_in">append</span>(result, res)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    k := digits[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<span class="hljs-comment">// 选取第一个字母</span><br>    digits = digits[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 剔除第一个字母</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dict[k]); i++ &#123;<br>        res += dict[k][i]<br>        letterFunc(res, digits)<br>        res = res[:<span class="hljs-built_in">len</span>(res) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于go中string的理解不够深。string的处理使用切片的，并且切片以后才能slice才是可以用append的。</p><p><img src="https://img-blog.csdnimg.cn/20201123200304469.png" alt="17. 电话号码的字母组合"></p><p>剩下的就是按照回溯的公式去套题。for里面装的是每层要处理的子集。</p><h2 id="9-4-组合总和（二）"><a href="#9-4-组合总和（二）" class="headerlink" title="9.4 组合总和（二）"></a>9.4 组合总和（二）</h2><p><strong>39. Combination Sum</strong></p><p><strong>Q：</strong>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p><p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p><p>It is <strong>guaranteed</strong> that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    findCombination(candidates, c, target, <span class="hljs-number">0</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCombination</span><span class="hljs-params">(cand, c []<span class="hljs-type">int</span>, target, index <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(cand); i++ &#123;<br>        c = <span class="hljs-built_in">append</span>(c, cand[i])<br>        findCombination(cand, c, target - cand[i], i, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为元素可以重复，所以index和i组合保证他不往回头（向前）找元素就可以了。</p><p>✨<strong>其中为什么一定要有c附魔给b呢？</strong>这里是深复制和浅复制的问题。如果不 copy 一份，直接把 c 加入到 res 结果数组中，下一轮递归过程中，c 会变，这个变化也会影响到 res 里面的值。如果还不明白的话，你可以把 copy c 的那 2 行代码注释掉，直接把 c append 到 res 中，你再看输出结果就能看到原因了。</p><p><strong>浅拷贝</strong>: 对于仅仅是复制了引用（地址），换句话说，复制了之后，原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响，为<strong>浅拷贝</strong>。 <strong>深拷贝</strong>：而如果是在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响，为<strong>深拷贝</strong></p><p>（简而言之：浅拷贝拷贝的是值，他和原本的指针指的是同一个地方，类似引用，当指针所指内容变了这个拷贝值也变；而深拷贝拷贝的是另一个对象，一个一模一样的对象但是占用的另一个空间，这样就算前者再变也不会影响新拷贝出来的对象）</p><h2 id="9-5-组合总和（三）"><a href="#9-5-组合总和（三）" class="headerlink" title="9.5 组合总和（三）"></a>9.5 组合总和（三）</h2><p><strong>40. Combination Sum II</strong></p><p><strong>Q：</strong>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.</p><p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p><p><strong>Note:</strong> The solution set must not contain duplicate combinations.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum2</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(candidates) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br>c, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>sort.Ints(candidates) <span class="hljs-comment">// 这里是去重的关键逻辑</span><br>    findCombination(candidates, c, target, <span class="hljs-number">0</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCombination</span><span class="hljs-params">(cand, c []<span class="hljs-type">int</span>, target, index <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> target &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(cand); i++ &#123;<br>        <span class="hljs-comment">// 这里是去重的关键逻辑,本次不取重复数字，下次循环可能会取重复数字</span><br>        <span class="hljs-keyword">if</span> i &gt; index &amp;&amp; cand[i] == cand[i<span class="hljs-number">-1</span>] &#123; <br><span class="hljs-keyword">continue</span><br>&#125;<br>        c = <span class="hljs-built_in">append</span>(c, cand[i])<br>        findCombination(cand, c, target - cand[i], i + <span class="hljs-number">1</span>, res)<br>        c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>题目要求出总和为 sum 的所有组合，组合需要去重。这一题是第 39 题的加强版，第 39 题中元素可以重复利用(重复元素可无限次使用)，这一题中元素只能有限次数的利用，因为存在重复元素，并且每个元素只能用一次(重复元素只能使用有限次)</li><li>这一题和第 47 题类似，只不过元素可以反复使用。</li><li>总体来说需要注意的两个重复位置，第一个是通过取得重复的根，从而得到两个同样的结果，第二个就是出现前后颠倒但集合相同的问题。</li></ul><p>所以先排好序（保证了结果肯定是递增的顺序，不会出现 [1, 7] 和 [7, 1] 这种组合，再判断。i &gt; index 表示除了本层的第一个选取的数以外的数，并且这个数和前一个数相同的话跳过。本质上这个判断是去除同一层重复获取的数字是forbidden的。</p><p>选择过程树形结构如图所示</p><p><img src="https://img-blog.csdnimg.cn/20201123202736384.png" alt="40.组合总和II"></p><h2 id="9-6-分割回文串"><a href="#9-6-分割回文串" class="headerlink" title="9.6 分割回文串"></a>9.6 分割回文串</h2><p><strong>131. Palindrome Partitioning</strong></p><p><strong>Q：</strong>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a <strong>palindrome</strong>. Return all possible palindrome partitioning of <code>s</code>.</p><p>A <strong>palindrome</strong> string is a string that reads the same backward as forward.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    c, res := []<span class="hljs-type">string</span>&#123;&#125;, [][]<span class="hljs-type">string</span>&#123;&#125;<br>    findPartition(<span class="hljs-number">0</span>, s, c, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPartition</span><span class="hljs-params">(start <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, c []<span class="hljs-type">string</span>, res *[][]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(s) &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        sub := s[start : i + <span class="hljs-number">1</span>]  <span class="hljs-comment">// partition</span><br>        <span class="hljs-keyword">if</span> IsPalindrome(sub) &#123; <span class="hljs-comment">// combine</span><br>            c = <span class="hljs-built_in">append</span>(c, sub)<br>            findPartition(i + <span class="hljs-number">1</span>, s, c, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    length := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= length/<span class="hljs-number">2</span>; i++ &#123;<br>      <span class="hljs-keyword">if</span> s[i] != s[length - <span class="hljs-number">1</span> - i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其树形结构为下图</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p><p>这一题的关键在于分割和组合的思想。要先切割，判断是否符合回文串？符合的话才继续进行组合递归下一层。</p><h2 id="9-7-复原IP地址"><a href="#9-7-复原IP地址" class="headerlink" title="9.7 复原IP地址"></a>9.7 复原IP地址</h2><p><strong>93. Restore IP Addresses</strong></p><p><strong>Q：</strong>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p><ul><li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li></ul><p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into</em> <code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;<br>&#125;<br>res, ip := []<span class="hljs-type">string</span>&#123;&#125;, []<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ip, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s <span class="hljs-type">string</span>, start, cut <span class="hljs-type">int</span>, ip []<span class="hljs-type">int</span>, res *[]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> cut == <span class="hljs-number">4</span> &amp;&amp; start == <span class="hljs-built_in">len</span>(s) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ip))<br>        <span class="hljs-built_in">copy</span>(tmp, ip)<br>        resIp := getIp(tmp)<br>        *res = <span class="hljs-built_in">append</span>(*res, resIp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> cut &gt; <span class="hljs-number">4</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        sub := s[start : i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> isValid(sub) &#123;<br>            tmp, _ := strconv.Atoi(sub)<br>            ip = <span class="hljs-built_in">append</span>(ip, tmp)<br>            cut++<br>            dfs(s, i + <span class="hljs-number">1</span>, cut, ip, res)<br>            ip = ip[:<span class="hljs-built_in">len</span>(ip) - <span class="hljs-number">1</span>]<br>            cut--<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; <span class="hljs-built_in">len</span>(s) != <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 0开头的不可以</span><br>    tmp, _ := strconv.Atoi(s)<br>    <span class="hljs-keyword">if</span> (tmp &gt; <span class="hljs-number">255</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIp</span><span class="hljs-params">(ip []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    resIp := strconv.Itoa(ip[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(ip); i++ &#123;<br>      resIp += <span class="hljs-string">&quot;.&quot;</span> + strconv.Itoa(ip[i])<br>    &#125;<br><span class="hljs-keyword">return</span> resIp<br>&#125;<br></code></pre></td></tr></table></figure><p>主要考虑到如下三点：</p><ul><li>段位以0为开头的数字不合法</li><li>段位里有非正整数字符不合法</li><li>段位如果大于255了不合法</li></ul><p><img src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p><p>对于语法的一些注意点，首先int转string（strconv.Itoa）是返回一个值的；string转int（strconv.Atoi）是返回两个值的。</p><p>一些注意点，这道题和分割回文串是很类似的，思想是一样的。首先我们要分割，接着我们要判断分割的sub是否符合条件，如果符合才继续深入到下一层，如果不符合就不继续。</p><h2 id="9-8-子集问题（一）"><a href="#9-8-子集问题（一）" class="headerlink" title="9.8 子集问题（一）"></a>9.8 子集问题（一）</h2><p><strong>78. Subsets</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    cur, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(<span class="hljs-number">0</span>, nums, cur, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, nums, cur []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>  <span class="hljs-comment">// 和之前最不一样的地方就是这里，不限制到叶子结点才加入res</span><br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cur))<br>    <span class="hljs-built_in">copy</span>(tmp, cur)<br>    *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>    <br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(nums) &#123; <span class="hljs-keyword">return</span> &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        cur = <span class="hljs-built_in">append</span>(cur, nums[i]) <span class="hljs-comment">// 原来是切掉一部分，现在是找某一个值</span><br>        dfs(i + <span class="hljs-number">1</span>, nums, cur, res)<br>        cur = cur[:<span class="hljs-built_in">len</span>(cur) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p><p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong></p><p><img src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p><p>从图中红线部分，可以看出<strong>遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合</strong>。</p><h2 id="9-9-子集问题（二）"><a href="#9-9-子集问题（二）" class="headerlink" title="9.9 子集问题（二）"></a><strong>9.9 子集问题（二）</strong></h2><p><strong>90. Subsets II</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsetsWithDup</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    cur, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    sort.Ints(nums)<br>    dfs(<span class="hljs-number">0</span>, nums, cur, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, nums, cur []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cur))<br>    <span class="hljs-built_in">copy</span>(tmp, cur)<br>    *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>    <br>    <span class="hljs-comment">// if start == len(nums) &#123; return &#125;</span><br>    <br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> i &gt; start &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        cur = <span class="hljs-built_in">append</span>(cur, nums[i]) <br>        dfs(i + <span class="hljs-number">1</span>, nums, cur, res)<br>        cur = cur[:<span class="hljs-built_in">len</span>(cur) - <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 []int, []float, []string 这种元素类型是基础类型的切片使用 sort 包提供的下面几个函数进行排序。</p><p>sort.Ints<br>sort.Floats<br>sort.Strings</p><p>用到了之前剪枝的方法，先排序，这样保证如果重复的元素都是挨着的</p><h2 id="9-10-递增子序列"><a href="#9-10-递增子序列" class="headerlink" title="9.10 递增子序列"></a>9.10 递增子序列</h2><p><strong>491. Increasing Subsequences</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code>, return all the different possible increasing subsequences of the given array with <strong>at least two elements</strong>. You may return the answer in <strong>any order</strong>.</p><p>The given array may contain duplicates, and two equal integers should also be considered a special case of increasing sequence.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findSubsequences</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    c, visited, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> _, ok := visited[nums[i]]; ok &#123;<br>          <span class="hljs-keyword">continue</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            visited[nums[i]] = <span class="hljs-literal">true</span><br>            generateIncSubsets(nums, i, c, &amp;res)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateIncSubsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, current <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    c = <span class="hljs-built_in">append</span>(c, nums[current])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) &gt;= <span class="hljs-number">2</span> &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(b, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, b)<br>    &#125;<br>    visited := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := current + <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>      <span class="hljs-comment">// 如果当前数值大于前一个数值，并且没有用过，进入DFS下一层</span><br>        <span class="hljs-keyword">if</span> nums[current] &lt;= nums[i] &#123;<br>            <span class="hljs-keyword">if</span> _, ok := visited[nums[i]]; ok &#123;<br>              <span class="hljs-keyword">continue</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                visited[nums[i]] = <span class="hljs-literal">true</span><br>                generateIncSubsets(nums, i, c, res)<br>            &#125;<br>        &#125;<br>    &#125;<br>    c = c[:<span class="hljs-built_in">len</span>(c)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>给出一个数组，要求找出这个数组中所有长度大于 2 的非递减子序列。子序列顺序和原数组元素下标必须是顺序的，不能是逆序的。</li><li>这一题和第 78 题和第 90 题是类似的题目。第 78 题和第 90 题是求所有子序列，这一题在这两题的基础上增加了非递减和长度大于 2 的条件。需要注意的两点是，原数组中元素可能会重复，最终结果输出的时候需要去重。最终结果输出的去重用 map 处理，数组中重复元素用 DFS 遍历搜索。在每次 DFS 中，用 map 记录遍历过的元素，保证本轮 DFS 中不出现重复的元素，递归到下一层还可以选择值相同，但是下标不同的另外一个元素。外层循环也要加一个 map，这个 map 是过滤每组解因为重复元素导致的重复解，经过过滤以后，起点不同了，最终的解也会不同。</li><li>重点在于对于同一层不能够重复</li></ul><p>树结构</p><p><img src="https://img-blog.csdnimg.cn/20201124200229824.png" alt="491. 递增子序列1"></p><h2 id="9-11-排列问题（一）"><a href="#9-11-排列问题（一）" class="headerlink" title="9.11 排列问题（一）"></a>9.11 排列问题（一）</h2><p><strong>46. Permutations</strong></p><p><strong>Q：</strong>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br>    c, used, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(nums, c, used, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, used <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(tmp, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> !used[nums[i]] &#123;<br>          used[nums[i]] = <span class="hljs-literal">true</span><br>            c = <span class="hljs-built_in">append</span>(c, nums[i])<br>            dfs(nums, c, used, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>            used[nums[i]] = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>树状图</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p><p>大家此时可以感受出排列问题的不同：</p><ul><li>每层都是从0开始搜索而不是startIndex</li><li>需要used数组记录path里都放了哪些元素了</li></ul><p>排列问题是回溯算法解决的经典题目。</p><p>注意map[key]的返回值（value，isExist）</p><h2 id="9-12-排列问题（二）"><a href="#9-12-排列问题（二）" class="headerlink" title="9.12 排列问题（二）"></a>9.12 排列问题（二）</h2><p><strong>47. Permutations II</strong></p><p><strong>Q：</strong>Given a collection of numbers, <code>nums</code>, that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permuteUnique</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br>    c, used, res := []<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;, [][]<span class="hljs-type">int</span>&#123;&#125;<br>    sort.Ints(nums)<br>    dfs(nums, c, used, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>, used <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(c))<br>        <span class="hljs-built_in">copy</span>(tmp, c)<br>        *res = <span class="hljs-built_in">append</span>(*res, tmp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> !used[i] &#123;<br>          <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>] &#123; <span class="hljs-comment">// 关键去重语句</span><br>              <span class="hljs-comment">// 当前数值的数在前面已经出现过，并且他的前一个数没有被用过才跳过</span><br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            used[i] = <span class="hljs-literal">true</span><br>            c = <span class="hljs-built_in">append</span>(c, nums[i])<br>            dfs(nums, c, used, res)<br>            c = c[:<span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>]<br>            used[i] = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>树状图</p><p><img src="https://img-blog.csdnimg.cn/20201124201331223.png" alt="47.全排列II1"></p><p>和 9.11 不同的是我们不但要消除纵向的重复，也要消除横向的重复。纵向的重复就不能单单只是消除。</p><p><code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]</code>为什么要加 !used[i - 1] 呢？因为每一层都要遍历所有的数，如果只是单单的nums[i] == nums[i-1] 就跳过的话，那么所有的层都会跳过，加入 !used[i - 1] 后代表着，在同一层的情况下（因为同一层如果相同的话只能选择其中一个数字，所以相同的数字只能有一位是 true 其他都是 false）如果当前数字和前一个相同的时候跳过。</p><h2 id="9-13-N-皇后问题"><a href="#9-13-N-皇后问题" class="headerlink" title="9.13 N 皇后问题"></a>9.13 N 皇后问题</h2><p><strong>51. N-Queens</strong></p><p><strong>Q：</strong>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code>chessboard such that no two queens attack each other.</p><p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p><p>Each solution contains a distinct board configuration of the n-queens’ placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space, respectively.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    idx, res := []<span class="hljs-type">int</span>&#123;&#125;, [][]<span class="hljs-type">string</span>&#123;&#125;<br>    dfs(n, <span class="hljs-number">0</span>, idx, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(n, row <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> row == n &#123;<br>        *res = <span class="hljs-built_in">append</span>(*res, generateBoard(n, idx))<br>        fmt.Println()<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>        <span class="hljs-keyword">if</span> isValid(row, col, n, idx) &#123;<br>            idx = <span class="hljs-built_in">append</span>(idx, col)<br>            dfs(n, row + <span class="hljs-number">1</span>, idx, res)<br>            idx = idx[:<span class="hljs-built_in">len</span>(idx) - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(row, col, n <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    col45 := col<br>    col135 := col<br>    <span class="hljs-comment">// 检查列</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(idx); i++ &#123;<br>        <span class="hljs-keyword">if</span> col == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查45˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col45++<br>        <span class="hljs-keyword">if</span> col45 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查135˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col135--<br>        <span class="hljs-keyword">if</span> col135 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateBoard</span><span class="hljs-params">(n <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    board := []<span class="hljs-type">string</span>&#123;&#125;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>      res += <span class="hljs-string">&quot;.&quot;</span><br>    &#125;<br>    <span class="hljs-comment">// 生成棋盘让所有的内容都是...</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; n; row++ &#123;<br>      board = <span class="hljs-built_in">append</span>(board, res)<br>    &#125;<br>    <span class="hljs-comment">// 按照收集到的位置，进行改写有皇后的位置</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; n; row++ &#123;<br>        tmp := []<span class="hljs-type">byte</span>(board[row]) <span class="hljs-comment">// byte才能够修改string的某一位</span><br>        tmp[idx[row]] = <span class="hljs-string">&#x27;Q&#x27;</span><br>        board[row] = <span class="hljs-type">string</span>(tmp)<br>    &#125;<br>    <span class="hljs-keyword">return</span> board<br>&#125;<br></code></pre></td></tr></table></figure><p>首先来看一下皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>树结构</p><p><img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后"></p><p>这种题的大概dfs流程是这样的，首先确定终止条件，然后是难点在于要判断是否要进入下一层这个判断条件是一个难点，第二个难点就是生成棋盘的时间，我是先记录要放棋子的位置再放在最后来生成，也可以从始至终就生成一点点填充。总体来说这两种方法不同的点在于判断的过程不同。</p><h2 id="9-14-解数独"><a href="#9-14-解数独" class="headerlink" title="9.14 解数独"></a>9.14 解数独</h2><p><strong>37. Sudoku Solver</strong></p><p><strong>Q：</strong>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p><ol><li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li><li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li><li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code>sub-boxes of the grid.</li></ol><p>The <code>&#39;.&#39;</code> character indicates empty cells.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>)</span></span>  &#123;<br>    dfs(&amp;board)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(board *[][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// scan</span><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">9</span>; row++ &#123;<br>        <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; <span class="hljs-number">9</span>; col++ &#123;<br>            <span class="hljs-keyword">if</span> (*board)[row][col] != <span class="hljs-string">&#x27;.&#x27;</span> &#123; <span class="hljs-keyword">continue</span> &#125;<br>            <span class="hljs-comment">// fill</span><br>            <span class="hljs-keyword">var</span> num <span class="hljs-type">byte</span><br>            <span class="hljs-keyword">for</span> num = <span class="hljs-string">&#x27;1&#x27;</span>; num &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; num++ &#123;<br>                <span class="hljs-keyword">if</span> isValid(row, col, num, board) &#123;<br>                  (*board)[row][col] = num   <span class="hljs-comment">// 填充</span><br>                  <span class="hljs-keyword">if</span> dfs(board) == <span class="hljs-literal">true</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                  (*board)[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>   <span class="hljs-comment">// 回溯</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 遍历完了都没有false，返回true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(row, col <span class="hljs-type">int</span>, num <span class="hljs-type">byte</span>, board *[][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// check row</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> num == (*board)[i][col] &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// check col</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++ &#123;<br>        <span class="hljs-keyword">if</span> num == (*board)[row][j] &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// check inner-9</span><br>    startRow := (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span><br>    startCol := (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">for</span> i := startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> num == (*board)[i][j] &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>树状图：</p><p><img src="https://img-blog.csdnimg.cn/2020111720451790.png" alt="37.解数独"></p><p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p><p>判断棋盘是否合法有如下三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>9宫格里是否重复</li></ul><p>注意如果要提取二维数组的地址的元素的话要写 (*a)[ ] [ ] 这样。</p><p>在 check inner-9 的时候遇到检查那9块的问题。首先他们的起始点有 (0, 0) (3, 3) (6, 6)…..通过除 3 以后发现在第一块，但具体的坐标要乘 3 因为毕竟除法过（0，1，2来进行乘法）</p><p>答案有可能不唯一，真正退出的位置是在<code>if dfs(board) == true &#123; return true &#125; // 如果找到合适一组立刻返回</code>这一行。</p><h1 id="第10章-贪心算法"><a href="#第10章-贪心算法" class="headerlink" title="第10章 贪心算法"></a>第10章 贪心算法</h1><ul><li>将问题分解为若子问题。</li><li>找出适合的贪心策略。</li><li>求解每一个子问题的最优解。</li><li>将局部最优堆叠成全局最优</li></ul><h2 id="10-1-分发饼干"><a href="#10-1-分发饼干" class="headerlink" title="10.1 分发饼干"></a>10.1 分发饼干</h2><p><strong>455. Assign Cookie</strong></p><p><strong>Q：</strong>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p><p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code>will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(g []<span class="hljs-type">int</span>, s []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sort.Ints(g)<br>sort.Ints(s)<br>gi, si, res := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> gi &lt; <span class="hljs-built_in">len</span>(g) &amp;&amp; si &lt; <span class="hljs-built_in">len</span>(s) &#123;<br><span class="hljs-keyword">if</span> s[si] &gt;= g[gi] &#123;<br>res++<br>si++<br>gi++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>si++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。</p><p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p><p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p><p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p><p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p><ul><li>假设你想给小朋友们饼干，每个小朋友最多能够给一块饼干。每个小朋友都有一个“贪心指数”，称为 <code>g[i]</code>，<code>g[i]</code> 表示的是这名小朋友需要的饼干大小的最小值。同时，每个饼干都有一个大小值 <code>s[i]</code>，如果 <code>s[j] ≥ g[i]</code>，我们将饼干 <code>j</code> 分给小朋友 <code>i</code> 后，小朋友会很开心。给定数组 <code>g[]</code> 和 <code>s[]</code>，问如何分配饼干，能让更多的小朋友开心。</li><li>这是一道典型的简单贪心题。贪心题一般都伴随着排序。将 <code>g[]</code> 和 <code>s[]</code> 分别排序。按照最难满足的小朋友开始给饼干，依次往下满足，最终能满足的小朋友数就是最终解。</li></ul><p>注意一个饼干最多给一个孩子。</p><h2 id="10-2-摆动排序"><a href="#10-2-摆动排序" class="headerlink" title="10.2 摆动排序"></a>10.2 摆动排序</h2><p><strong>376. Wiggle Subsequence</strong></p><p><strong>Q：</strong>A <strong>wiggle sequence</strong> is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.</p><ul><li>For example, <code>[1, 7, 4, 9, 2, 5]</code> is a <strong>wiggle sequence</strong> because the differences <code>(6, -3, 5, -7, 3)</code> alternate between positive and negative.</li><li>In contrast, <code>[1, 4, 7, 2, 5]</code> and <code>[1, 7, 4, 5, 5]</code> are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.</li></ul><p>A <strong>subsequence</strong> is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.</p><p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>wiggle subsequence</strong> of</em> <code>nums</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br>&#125;<br>res := <span class="hljs-number">1</span><br>prevDiff := nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> prevDiff != <span class="hljs-number">0</span> &#123;<br>res = <span class="hljs-number">2</span><br>&#125;<br>    <span class="hljs-comment">// 从第三个数开始，i下标的位置是 前中后 的后</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        diff := nums[i] - nums[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-comment">// 如果是波峰或者波谷的话</span><br>        <span class="hljs-keyword">if</span> diff &gt; <span class="hljs-number">0</span> &amp;&amp; prevDiff &lt;= <span class="hljs-number">0</span> || diff &lt; <span class="hljs-number">0</span> &amp;&amp; prevDiff &gt;= <span class="hljs-number">0</span> &#123;<br>            res++<br>            prevDiff = diff<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>题目要求找到摆动序列最长的子序列。本题可以用贪心的思路，记录当前序列的上升和下降的趋势。扫描数组过程中，每扫描一个元素都判断是“峰”还是“谷”，根据前一个是“峰”还是“谷”做出对应的决定。利用贪心的思想找到最长的摆动子序列。</li></ul><p><code>diff &gt; 0 &amp;&amp; prevDiff &lt;= 0 || diff &lt; 0 &amp;&amp; prevDiff &gt;= 0</code>这句的判断里面为什么要有等号呢？因为其实你只要保证在 i - 1 位置之前的都是平的，或者与其后面的单调趋势是相反的，就可以保证单调性的不同（平 to 增减，增 to 减，减 to 增）</p><h2 id="10-3-最大子序和"><a href="#10-3-最大子序和" class="headerlink" title="10.3 最大子序和"></a>10.3 最大子序和</h2><p><strong>53. Maximum Subarray</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p><p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSum := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>      <span class="hljs-comment">// 就加正数</span><br>        <span class="hljs-keyword">if</span> nums[i] + nums[i<span class="hljs-number">-1</span>] &gt; nums[i] &#123;<br>            nums[i] += nums[i<span class="hljs-number">-1</span>]<br>        &#125;<br>      <span class="hljs-comment">// 如果当前子序列大于了之前存的总和就存下</span><br>        <span class="hljs-keyword">if</span> nums[i] &gt; maxSum &#123;<br>            maxSum = nums[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>局部最优：</strong>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p>全局最优：选取最大“连续和”</p><p>这个思想主要是不利用额外的存储空间。举例，[-2,1,-3,4,-1,2,1,-5,4] 我们贪心的点在于必须要子序列要是在增加的才加上。尽管倒数第二个 -5 + 6 = 1 是比自身大的但是没有大过 maxSum，也无所谓。所以总结一下就是，我们要加入当前数的前一个数，如果是上升的值就保存，并且如果当前 sum 后整体大于了统计的 max，就更新 max 要不就继续遍历。就像我们的人生一样，我们就记录我们能前进的值，忘掉那些退步的地方，并且记录下我们max的里程碑。</p><p>golang的最大值和最小值的定义 <a href="https://blog.csdn.net/lishanleilixin/article/details/103269904">https://blog.csdn.net/lishanleilixin/article/details/103269904</a></p><h2 id="10-4-买卖股票的最佳时机-II"><a href="#10-4-买卖股票的最佳时机-II" class="headerlink" title="10.4 买卖股票的最佳时机 II"></a>10.4 买卖股票的最佳时机 II</h2><p><strong>122. Best Time to Buy and Sell Stock II</strong></p><p><strong>Q：</strong>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p><p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    profit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        <span class="hljs-keyword">if</span> prices[i] - prices[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &#123;<br>            profit += prices[i] - prices[i - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II"></p><p>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p><p>那么只收集正利润就是贪心所贪的地方！</p><p><strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</p><h2 id="10-5-跳跃游戏"><a href="#10-5-跳跃游戏" class="headerlink" title="10.5 跳跃游戏"></a>10.5 跳跃游戏</h2><p><strong>55. Jump Game</strong></p><p><strong>Q：</strong>You are given an integer array <code>nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p><p>Return <code>true</code> <em>if you can reach the last index, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    cover := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果是跳跃数组的长度为1</span><br>    <span class="hljs-comment">// 每次在当前范围里面找每个数</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= cover; i++ &#123;<br>        cover = max(i + nums[i], cover) <span class="hljs-comment">// 覆盖面的选择，从当前cover范围和当前位置代表的未来cover范围二选一</span><br>        <span class="hljs-keyword">if</span> cover &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 如果能包含到最后一个位置就代表能跳到</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 没找到就false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> a &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>图片势力</p><p><img src="https://img-blog.csdnimg.cn/20201124154758229.png" alt="55.跳跃游戏"></p><h2 id="10-6-跳跃游戏-II"><a href="#10-6-跳跃游戏-II" class="headerlink" title="10.6 跳跃游戏 II"></a>10.6 跳跃游戏 II</h2><p><strong>45. Jump Game II</strong></p><p><strong>Q：</strong>Given an array of non-negative integers <code>nums</code>, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Your goal is to reach the last index in the minimum number of jumps.</p><p>You can assume that you can always reach the last index.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    curDistance := <span class="hljs-number">0</span> <span class="hljs-comment">// 当前覆盖的最远距离下标</span><br>    step := <span class="hljs-number">0</span> <span class="hljs-comment">// 记录走的最大步数</span><br>    nextDistance := <span class="hljs-number">0</span> <span class="hljs-comment">// 下一步覆盖的最远距离下标</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i++ &#123; <span class="hljs-comment">// 注意这里是小于等于nums.size() - 2，这是关键所在</span><br>        nextDistance = max(i + nums[i], nextDistance) <span class="hljs-comment">// 更新下一步覆盖的最远距离下标</span><br>        <span class="hljs-keyword">if</span> i == curDistance &#123; <span class="hljs-comment">// 遇到当前覆盖的最远距离下标</span><br>            curDistance = nextDistance <span class="hljs-comment">// 更新当前覆盖的最远距离下标</span><br>            step++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> step<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> a &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>理解本题的关键在于：<strong>以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点</strong>，这个范围内最小步数一定可以跳到，不用管具体是怎么跳的，不纠结于一步究竟跳一个单位还是两个单位。</p><p><img src="https://img-blog.csdnimg.cn/20201201232445286.png" alt="45.跳跃游戏II2"></p><p>一个个找，找每个范围内的最远距离。cur 记录的是当前可以跳的最远距离，所以一旦 i = cur 的时候说明要走下一跳了</p><p>（只有 i 到达了上一次记录的最远距离的时候，才更新 cur = next 的最远距离）</p><h2 id="10-7-加油站"><a href="#10-7-加油站" class="headerlink" title="10.7 加油站"></a>10.7 加油站</h2><p><strong>134. Gas Station</strong></p><p><strong>Q：</strong>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>ith</code> station is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>ith</code> station to its next <code>(i + 1)th</code> station. You begin the journey with an empty tank at one of the gas stations.</p><p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong></p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(gas []<span class="hljs-type">int</span>, cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>curSum := <span class="hljs-number">0</span><br>totalSum := <span class="hljs-number">0</span><br>start := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(gas); i++ &#123;<br>curSum += gas[i] - cost[i]<br>totalSum += gas[i] - cost[i]<br><span class="hljs-keyword">if</span> curSum &lt; <span class="hljs-number">0</span> &#123;<br>start = i+<span class="hljs-number">1</span><br>curSum = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> totalSum &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">return</span> start<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20201213162821958.png" alt="134.加油站"></p><p>我把所有的差值加一遍只要是能总和大于0肯定能跑完，然后找第一个可以 gas - cost &gt; 0 的位置作为起点</p><h2 id="10-8-分发糖果"><a href="#10-8-分发糖果" class="headerlink" title="10.8 分发糖果"></a>10.8 分发糖果</h2><p><strong>135. Candy</strong></p><p><strong>Q：</strong>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p><p>You are giving candies to these children subjected to the following requirements:</p><ul><li>Each child must have at least one candy.</li><li>Children with a higher rating get more candies than their neighbors.</li></ul><p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">candy</span><span class="hljs-params">(ratings []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// initialization</span><br>    candy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(ratings))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(ratings); i++ &#123;<br>        candy[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// front to back</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(ratings); i++ &#123;<br>        <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>] &#123;<br>            candy[i] = candy[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    fmt.Println(candy)<br>    <span class="hljs-comment">// back to front</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(ratings) - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] &#123;<br>            candy[i] = max(candy[i], candy[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment">// 因为是更新数值，所以用max，并不是单纯的覆盖</span><br>        &#125;<br>    &#125;<br>    fmt.Println(candy)<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> candy &#123;<br>        res += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>这在leetcode上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p><p>那么本题我采用了两次贪心的策略：</p><ul><li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li><li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li></ul><p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p><h2 id="10-9-柠檬水找零"><a href="#10-9-柠檬水找零" class="headerlink" title="10.9 柠檬水找零"></a>10.9 柠檬水找零</h2><p><strong>860. Lemonade Change</strong></p><p><strong>Q：</strong>At a lemonade stand, each lemonade costs <code>$5</code>. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a <code>$5</code>, <code>$10</code>, or <code>$20</code> bill. You must provide the correct change to each customer so that the net transaction is that the customer pays <code>$5</code>.</p><p>Note that you do not have any change in hand at first.</p><p>Given an integer array <code>bills</code> where <code>bills[i]</code> is the bill the <code>ith</code> customer pays, return <code>true</code> <em>if you can provide every customer with the correct change, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(bills []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    count5 := <span class="hljs-number">0</span><br>    count10 := <span class="hljs-number">0</span><br>    count20 := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(bills); i++ &#123;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">5</span> &#123;<br>            count5++<br>        &#125;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">if</span> count5 &lt;= <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>            count5--<br>            count10++<br>        &#125;<br>        <span class="hljs-keyword">if</span> bills[i] == <span class="hljs-number">20</span> &#123;<br>          <span class="hljs-comment">// 优先处理10块的，再处理5块的</span><br>            <span class="hljs-keyword">if</span> count5 &gt; <span class="hljs-number">0</span> &amp;&amp; count10 &gt; <span class="hljs-number">0</span> &#123;<br>                count5--<br>                count10--<br>                count20++<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> count10 == <span class="hljs-number">0</span> &amp;&amp; count5 &gt;= <span class="hljs-number">3</span> &#123;<br>                count5 -= <span class="hljs-number">3</span><br>                count20++<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li></ul><p>局部最优推算出全局最优</p><h2 id="10-10-用最少数量的箭射爆气球"><a href="#10-10-用最少数量的箭射爆气球" class="headerlink" title="10.10 用最少数量的箭射爆气球"></a>10.10 用最少数量的箭射爆气球</h2><p><strong>452. Minimum Number of Arrows to Burst Balloons</strong></p><p><strong>Q：</strong>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array <code>points</code> where <code>points[i] = [xstart, xend]</code> denotes a balloon whose <strong>horizontal diameter</strong>stretches between <code>xstart</code> and <code>xend</code>. You do not know the exact y-coordinates of the balloons.</p><p>Arrows can be shot up <strong>directly vertically</strong> (in the positive y-direction) from different points along the x-axis. A balloon with <code>xstart</code> and <code>xend</code> is <strong>burst</strong> by an arrow shot at <code>x</code> if <code>xstart &lt;= x &lt;= xend</code>. There is <strong>no limit</strong> to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</p><p>Given the array <code>points</code>, return <em>the <strong>minimum</strong> number of arrows that must be shot to burst all balloons</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(points [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// 弓箭数</span><br>    <span class="hljs-comment">// 先按照第一位排序</span><br>    sort.Slice(points, <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> points[i][<span class="hljs-number">0</span>] &lt; points[j][<span class="hljs-number">0</span>]<br>    &#125;)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(points); i++&#123;<br>        <span class="hljs-keyword">if</span> points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; points[i][<span class="hljs-number">0</span>] &#123; <span class="hljs-comment">// 如果前一位的右边界小于后一位的左边界，则一定不重合</span><br>            res++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            points[i][<span class="hljs-number">1</span>] = min(points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], points[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界,覆盖该位置的值，留到下一步使用</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><p>贪心，先确定一个思路，再看这个思路是否有bug，没有bug就可以使用贪心</p><p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？</p><p>尝试一下举反例，发现没有这种情况。</p><p>sort.Slice使用指南<a href="http://books.studygolang.com/Mastering_Go_ZH_CN/eBook/chapter3/03.3.7.html">http://books.studygolang.com/Mastering_Go_ZH_CN/eBook/chapter3/03.3.7.html</a></p><h2 id="10-11-合并区间"><a href="#10-11-合并区间" class="headerlink" title="10.11 合并区间"></a>10.11 合并区间</h2><p><strong>56. Merge Intervals</strong></p><p><strong>Q：</strong>Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//先从小到大排序</span><br>    sort.Slice(intervals,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>]&lt;intervals[j][<span class="hljs-number">0</span>]<br>    &#125;)<br>    <span class="hljs-comment">//再弄重复的</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(intervals)<span class="hljs-number">-1</span>;i++&#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">1</span>] &gt;= intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&#123;<br>            intervals[i][<span class="hljs-number">1</span>] = max(intervals[i][<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<span class="hljs-comment">//赋值最大值</span><br>            intervals = <span class="hljs-built_in">append</span>(intervals[:i+<span class="hljs-number">1</span>],intervals[i+<span class="hljs-number">2</span>:]...)<br>            i--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> intervals<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a &gt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我按照左边界排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。</p><p><code>intervals = append(intervals[:i+1],intervals[i+2:]...)</code>将第一位提取出来，后面跳过下一位把后面的接过来，相当于剔除了第二位。</p><h2 id="10-12-单调递增的数字"><a href="#10-12-单调递增的数字" class="headerlink" title="10.12 单调递增的数字"></a>10.12 单调递增的数字</h2><p><strong>738. Monotone Increasing Digits</strong></p><p><strong>Q：</strong>An integer has <strong>monotone increasing digits</strong> if and only if each pair of adjacent digits <code>x</code> and <code>y</code> satisfy <code>x &lt;= y</code>.</p><p>Given an integer <code>n</code>, return <em>the largest number that is less than or equal to</em> <code>n</code><em>with <strong>monotone increasing digits</strong></em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(N <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    s := strconv.Itoa(N) <span class="hljs-comment">// 将数字转为字符串，方便使用下标</span><br>    ss := []<span class="hljs-type">byte</span>(s) <span class="hljs-comment">// 将字符串转为byte数组，方便更改。</span><br>    n := <span class="hljs-built_in">len</span>(ss)<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> N<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span> ; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> ss[i - <span class="hljs-number">1</span>] &gt; ss[i] &#123; <span class="hljs-comment">// 前一个大于后一位,前一位减1，后面的全部置为9</span><br>            ss[i - <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j := i ; j &lt; n; j++ &#123; <span class="hljs-comment">// 后面的全部置为9</span><br>                ss[j] = <span class="hljs-string">&#x27;9&#x27;</span><br>            &#125;<br>        &#125; <br>    &#125;<br>    res, _ := strconv.Atoi(<span class="hljs-type">string</span>(ss))<br>    <span class="hljs-keyword">return</span> res <br>&#125;<br></code></pre></td></tr></table></figure><p>从前往后遍历不行，因为会修改原本的值，但是从后往前不会。</p><p>对于go语言如果要修改string的内容最好先转化成byte数组。</p><p>前一个大于后一位,前一位减1，后面的全部置为9（因为要求最大）！</p><h1 id="第11章-动态规划"><a href="#第11章-动态规划" class="headerlink" title="第11章 动态规划"></a>第11章 动态规划</h1><p>动规五部曲：</p><p>这里我们要用一个一维dp数组来保存递归的结果</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol><li>确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p><ol><li>dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></table></figure><ol><li>确定遍历顺序</li></ol><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><h2 id="11-1-斐波那契数列"><a href="#11-1-斐波那契数列" class="headerlink" title="11.1 斐波那契数列"></a>11.1 斐波那契数列</h2><p><strong>509. Fibonacci Number</strong></p><p><strong>Q：</strong>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(n)</span></span> = <span class="hljs-built_in">F</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(n - <span class="hljs-number">2</span>), <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p>Given <code>n</code>, calculate <code>F(n)</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> n&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>      dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-2-爬楼梯"><a href="#11-2-爬楼梯" class="headerlink" title="11.2 爬楼梯"></a>11.2 爬楼梯</h2><p><strong>70. Climbing Stairs</strong></p><p><strong>Q：</strong>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p><p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> n&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">// 第一层的方法数量</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span> <span class="hljs-comment">// 第二层的方法数量</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化第一步和第二步，然后递归后面的步子，关键在于递推公式的生成</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p><p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p><p>走一步和走两步的方法总和</p><h2 id="11-3-使用最小花费爬楼梯"><a href="#11-3-使用最小花费爬楼梯" class="headerlink" title="11.3 使用最小花费爬楼梯"></a>11.3 使用最小花费爬楼梯</h2><p><strong>746. Min Cost Climbing Stairs</strong></p><p><strong>Q：</strong>You are given an integer array <code>cost</code> where <code>cost[i]</code> is the cost of <code>ith</code> step on a staircase. Once you pay the cost, you can either climb one or two steps.</p><p>You can either start from the step with index <code>0</code>, or the step with index <code>1</code>.</p><p>Return <em>the minimum cost to reach the top of the floor</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(cost))<br>    dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>]<br>    dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(cost); i++ &#123;<br>        dp[i] = min(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> min(dp[<span class="hljs-built_in">len</span>(dp) - <span class="hljs-number">1</span>], dp[<span class="hljs-built_in">len</span>(dp) - <span class="hljs-number">2</span>]) <span class="hljs-comment">// 返回的是踏上楼顶的前一步或者前两步</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]</strong>。</p><p><strong>可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]</strong>。</p><p>那么究竟是选dp[i-1]还是dp[i-2]呢？</p><p>一定是选最小的，所以dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];</p><p><strong>注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的</strong>，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值</p><h2 id="11-4-不同路径-I"><a href="#11-4-不同路径-I" class="headerlink" title="11.4 不同路径 I"></a>11.4 不同路径 I</h2><p><strong>62. Unique Paths</strong></p><p><strong>Q：</strong>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>&#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> dp[<span class="hljs-number">0</span>] &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>] <span class="hljs-comment">// 从左边来的和右边来的数量的总和</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>按照动规五部曲来分析：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i] [j] ：表示从（0 ，0）出发，到(i, j) 有dp[i] [j]条不同的路径。</p><ol><li>确定递推公式</li></ol><p>想要求dp[i] [j]，只能有两个方向来推导出来，即dp[i - 1] [j] 和 dp[i] [j - 1]。</p><p>此时在回顾一下 dp[i - 1] [j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。</p><p>那么很自然，dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，因为dp[i] [j]只有这两个方向过来。</p><ol><li>dp数组的初始化</li></ol><p>如何初始化呢，首先dp[i] [0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0] [j]也同理。</p><p>所以初始化代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ol><li>确定遍历顺序</li></ol><p>这里要看一下递归公式dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，dp[i] [j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p><p>这样就可以保证推导dp[i] [j]的时候，dp[i - 1] [j] 和 dp[i] [j - 1]一定是有数值的。</p><ol><li>举例推导dp数组</li></ol><h2 id="11-5-不同路径-II"><a href="#11-5-不同路径-II" class="headerlink" title="11.5 不同路径 II"></a>11.5 不同路径 II</h2><p><strong>63. Unique Paths II</strong></p><p><strong>Q：</strong>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m-1][n-1]</code>). The robot can only move either down or right at any point in time.</p><p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p><p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The testcases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(obstacleGrid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(obstacleGrid)<br>    n := <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">if</span> obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">for</span> k := i; k &lt; m; k++ &#123;<br>                dp[k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果发现了这一行有一个石头，那么这一行从石头开始后面的全部到达不了</span><br>            &#125;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">for</span> k := j; k &lt; n; k++ &#123;<br>                dp[<span class="hljs-number">0</span>][k] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果发现了这一列有一个石头，那么这一列从石头开始后面的全部到达不了</span><br>            &#125;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span> &#123;   <br>                dp[i][j] = <span class="hljs-number">0</span> <span class="hljs-comment">// 如果此点有障碍物，那么这点就不是通路就为0</span><br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>有两个关键点，第一个是初始化的时候要注意，如果出现了障碍物，那么剩下的一行或者一列将都是0；第二个是当进行的时候如果当前点是障碍点了，那么就把它置0，因为对于下一个点来说，他并不能帮助下一点到达自己的目的地。</p><h2 id="11-6-整数拆分"><a href="#11-6-整数拆分" class="headerlink" title="11.6 整数拆分"></a>11.6 整数拆分</h2><p><strong>343. Integer Break</strong></p><p><strong>Q：</strong>Given an integer <code>n</code>, break it into the sum of <code>k</code> <strong>positive integers</strong>, where <code>k &gt;= 2</code>, and maximize the product of those integers.</p><p>Return <em>the maximum product you can get</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123; <span class="hljs-comment">// 真正dp序列的循环，把n这个数拆出来一个然后分析看看这么拆是不是最小的乘积</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i - <span class="hljs-number">1</span>; j++ &#123; <span class="hljs-comment">// 正整数所以j从1开始，为什么不能到达i-1，比如n是10，那么我能拆开的两个数就是9和1</span><br>            dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)) <span class="hljs-comment">// j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n] <span class="hljs-comment">// 由于前面在比较的同时需要给dp[n]赋值，必须保证当到达dp[n]的时候，其数值是最大的，所以在递推公式中有dp[n]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>动规五部曲，分析如下：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p><p>dp[i]的定义讲贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！</p><ol><li>确定递推公式🌟</li></ol><p>可以想 dp[i]最大乘积是怎么得到的呢？</p><p>其实可以从1遍历j，然后有两种渠道得到dp[i].</p><p>一个是j * (i - j) 直接相乘。</p><p>一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。</p><p><strong>也可以这么理解，j <em> (i - j) 是单纯的把整数拆分为两个数相乘，而j </em> dp[i - j]是拆分成两个以及两个以上的个数相乘。</strong></p><p>如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了</p><ol><li>dp的初始化</li></ol><p>不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？</p><p>有的题解里会给出dp[0] = 1，dp[1] = 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。</p><p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。</p><p>拆分0和拆分1的最大乘积是多少？</p><p>这是无解的。</p><p>这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！</p><ol><li>确定遍历顺序</li></ol><p>确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) <em> j, dp[i - j] </em> j));</p><p>dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。</p><p>枚举j的时候，是从1开始的。i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。</p><ol><li>举例推导dp数组</li></ol><h2 id="11-7-不同的二叉树搜索树"><a href="#11-7-不同的二叉树搜索树" class="headerlink" title="11.7 不同的二叉树搜索树"></a>11.7 不同的二叉树搜索树</h2><p><strong>96. Unique Binary Search Trees</strong></p><p><strong>Q：</strong>Given an integer <code>n</code>, return <em>the number of structurally unique <strong>BST’</strong>s (binary search trees) which has exactly</em> <code>n</code> <em>nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>) <span class="hljs-comment">// 包含 0 + (1 to n)</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i; j++ &#123; <span class="hljs-comment">// 假如只有左子树或者右子树的时候就会 j = i</span><br>            dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]</strong>。</p><p>也可以理解是i个的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p><p>以下分析如果想不清楚，就来回想一下dp[i]的定义</p><ol><li>确定递推公式</li></ol><p>在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p><p>j相当于是头结点的元素，从1遍历到i为止。</p><p>所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p><p>其中第二个循环for j的那个就是为了找寻不同的数量的左子树。之所以右子树的数量为 i - j 是因为左子树加上右子树的总和为 i - 1</p><ol><li>dp数组如何初始化</li></ol><p>初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。</p><p>那么dp[0]应该是多少呢？</p><p>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。</p><p>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。</p><p>所以初始化dp[0] = 1</p><ol><li>确定遍历顺序</li></ol><p>首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p><p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>        dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>举例推导dp数组</li></ol><p>n为5时候的dp数组状态如图：</p><p><img src="https://img-blog.csdnimg.cn/20210107093253987.png" alt="96.不同的二叉搜索树3"></p><h2 id="11-8-0-1背包理论基础"><a href="#11-8-0-1背包理论基础" class="headerlink" title="11.8 0 - 1背包理论基础"></a>11.8 0 - 1背包理论基础</h2><p>依然动规五部曲分析一波。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>只看这个二维数组的定义，大家一定会有点懵，看下面这个图：</p><p><img src="https://img-blog.csdnimg.cn/20210110103003361.png" alt="动态规划-背包问题1"></p><p><strong>要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的</strong>，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。</p><ol><li>确定递推公式</li></ol><p>再回顾一下dp[i] [j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p><p>那么可以有两个方向推出来dp[i] [j]，</p><ul><li><strong>不放物品i</strong>：由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i] [j]就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li><li><strong>放物品i</strong>：由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1] [j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>所以递归公式： dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</p><ol><li>dp数组如何初始化</li></ol><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：</p><p><img src="https://img-blog.csdnimg.cn/2021011010304192.png" alt="动态规划-背包问题2"></p><p>在看其他情况。</p><p>状态转移方程 dp[i][j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p>dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当j &gt;= weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><p>代码初始化如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; weight[<span class="hljs-number">0</span>]; j++) &#123;  <span class="hljs-comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br>    dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>此时dp数组初始化情况如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210110103109140.png" alt="动态规划-背包问题7"></p><p>dp[0] [j] 和 dp[i] [0] 都已经初始化了，那么其他下标应该初始化多少呢？</p><p>其实从递归公式： dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p><p><strong>初始-1，初始-2，初始100，都可以！</strong></p><p>但只不过一开始就统一把dp数组统一初始为0，更方便一些。</p><p>如图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg" alt="动态规划-背包问题10"></p><p>最后初始化代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">// 初始化 dp<br>vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0));<br>for (int j = weight[0]; j &lt;= bagweight; j++) &#123;<br>    dp[0][j] = value[0];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的</strong>。</p><ol><li>确定遍历顺序</li></ol><p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量</p><p><img src="https://img-blog.csdnimg.cn/2021011010314055.png" alt="动态规划-背包问题3"></p><p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？</strong></p><p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p><p>那么我先给出先遍历物品，然后遍历背包重量的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）</strong></p><p>例如这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么也是可以的呢？</p><p><strong>要理解递归的本质和递推的方向</strong>。</p><p>dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 递归公式中可以看出dp[i] [j]是靠dp[i-1] [j]和dp[i - 1] [j - weight[i]]推导出来的。</p><p>dp[i-1] [j]和dp[i - 1] [j - weight[i]] 都在dp[i] [j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：</p><p><img src="https://img-blog.csdnimg.cn/202101101032124.png" alt="动态规划-背包问题5"></p><p>再来看看先遍历背包，再遍历物品呢，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210110103244701.png" alt="动态规划-背包问题6"></p><p><strong>大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！</strong></p><p>但先遍历物品再遍历背包这个顺序更好理解。</p><p><strong>其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了</strong>。</p><ol><li>举例推导dp数组</li></ol><p>来看一下对应的dp数组的数值，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210118163425129.jpg" alt="动态规划-背包问题4"></p><p>最终结果就是dp[2] [4]。</p><p>建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。</p><p><strong>做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！</strong></p><p>二维变成一维后的主要变化在遍历顺序上。</p><p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p><p>举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15</p><p>如果正序遍历</p><p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p><p>dp[2] = dp[2 - weight[0]] + value[0] = 30</p><p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p><p>为什么倒序遍历，就可以保证物品只放入一次呢？</p><p>倒序就是先算dp[2]</p><p>dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）</p><p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p><p>正序就是迭代的过程，不会考虑上层有什么会随机添加，他会添加同样的东西；而倒序是递归，他会根据当前状态去往下找状态，他需要底层的内容支持，是有规则规定的。</p><p>二维数组数据是隔离的，而一维的都在同一行，所以不能够正序遍历。</p><h2 id="11-9-分割等和子集"><a href="#11-9-分割等和子集" class="headerlink" title="11.9 分割等和子集"></a>11.9 分割等和子集</h2><p><strong>416. Partition Equal Subset Sum</strong></p><p><strong>Q：</strong>Given a <strong>non-empty</strong> array <code>nums</code> containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 分割等和子集 动态规划</span><br><span class="hljs-comment">// 时间复杂度O(n^2) 空间复杂度O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += num<br>    &#125;<br>    <span class="hljs-comment">// 如果 nums 的总和为奇数则不可能平分成两个子集</span><br>    <span class="hljs-keyword">if</span> sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <br>    target := sum / <span class="hljs-number">2</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, target + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">for</span> j := target; j &gt;= num; j-- &#123;<br>            <span class="hljs-keyword">if</span> dp[j] &lt; dp[j - num] + num &#123; <span class="hljs-comment">// 如果能能放下num（重量j - num）并且价值增加为num后大于当前的价值，那么就更新</span><br>                dp[j] = dp[j - num] + num<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target] == target<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    动态五部曲：</span><br><span class="hljs-comment">        1.确定dp数组和下标含义</span><br><span class="hljs-comment">        2.确定递推公式</span><br><span class="hljs-comment">        3.dp数组初始化</span><br><span class="hljs-comment">        4.dp遍历顺序</span><br><span class="hljs-comment">        5.打印</span><br><span class="hljs-comment">    **/</span><br>    <span class="hljs-comment">//确定和</span><br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> nums&#123;<br>        sum+=v<br>    &#125;<br>    <span class="hljs-keyword">if</span> sum%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>&#123;   <span class="hljs-comment">//如果和为奇数，则不可能分成两个相等的数组</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    sum/=<span class="hljs-number">2</span><br>    <span class="hljs-comment">//确定dp数组和下标含义</span><br>    <span class="hljs-keyword">var</span> dp [][]<span class="hljs-type">bool</span> <span class="hljs-comment">//dp[i][j] 表示： 前i个石头是否总和不大于j</span><br>    <span class="hljs-comment">//初始化数组</span><br>    dp=<span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>,<span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i,_:=<span class="hljs-keyword">range</span> dp&#123;<br>        dp[i]=<span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>,sum+<span class="hljs-number">1</span>)<br>        dp[i][<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(nums);i++&#123;<br>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=sum;j++&#123;<span class="hljs-comment">//j是固定总量</span><br>            <span class="hljs-keyword">if</span> j&gt;=nums[i<span class="hljs-number">-1</span>]&#123;<span class="hljs-comment">//如果容量够用则可放入背包</span><br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]||dp[i<span class="hljs-number">-1</span>][j-nums[i<span class="hljs-number">-1</span>]]<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果容量不够用则不拿，维持前一个状态</span><br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)][sum]<br>&#125;<br></code></pre></td></tr></table></figure><p>那么只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。</p><p>关键点判断能不能重复放入（我们需要不可重复放入）</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum / 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><ol><li>确定dp数组以及下标的含义</li></ol><p>​       <strong>dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]</strong>。但是dp[j]是肯定小于等于sum/2的。j代表能存放的所有可能性</p><ol><li><p>确定递推公式</p><p>dp[j] = max(dp[j], dp[j - 1] + nums[i])</p></li><li><p>dp数组如何初始化</p><p>dp[0] = 0</p><p>dp[1] = nums[0]</p></li><li><p>确定遍历顺序</p><p>选数字是从前往后，选数值是从后往前</p></li><li><p>举例推导dp数组</p></li></ol><p>01背包相对于本题，主要要理解，题目中物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2。</p><h2 id="11-10-目标和"><a href="#11-10-目标和" class="headerlink" title="11.10 目标和"></a>11.10 目标和</h2><p><strong>494. Target Sum</strong></p><p><strong>Q：</strong>You are given an integer array <code>nums</code> and an integer <code>target</code>.</p><p>You want to build an <strong>expression</strong> out of nums by adding one of the symbols <code>&#39;+&#39;</code> and <code>&#39;-&#39;</code> before each integer in nums and then concatenate all the integers.</p><ul><li>For example, if <code>nums = [2, 1]</code>, you can add a <code>&#39;+&#39;</code> before <code>2</code> and a <code>&#39;-&#39;</code> before <code>1</code> and concatenate them to build the expression <code>&quot;+2-1&quot;</code>.</li></ul><p>Return the number of different <strong>expressions</strong> that you can build, which evaluates to <code>target</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>sum += v<br>&#125;<br><span class="hljs-keyword">if</span> abs(target) &gt; sum &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">if</span> (sum+target)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">// 计算背包大小</span><br>bag := (sum + target) / <span class="hljs-number">2</span><br><span class="hljs-comment">// 定义dp数组</span><br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, bag+<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 初始化</span><br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-comment">// 遍历顺序</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br><span class="hljs-keyword">for</span> j := bag; j &gt;= nums[i]; j-- &#123;<br><span class="hljs-comment">//推导公式</span><br>dp[j] += dp[j-nums[i]]<br><span class="hljs-comment">//fmt.Println(dp)</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[bag]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(math.Abs(<span class="hljs-type">float64</span>(x)))<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个组合的问题</p><p>题目要求在数组元素前加上 + 或者 - 号，其实相当于把数组分成了 2 组，一组全部都加 + 号，一组都加 - 号。记 + 号的一组 P ，记 - 号的一组 N，那么可以推出以下的关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">sum(P) - sum(N) = target<br>sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)<br>                       <span class="hljs-number">2</span> * sum(P) = target + sum(nums)<br></code></pre></td></tr></table></figure><p>等号两边都加上 <code>sum(N) + sum(P)</code>，于是可以得到结果 <code>2 * sum(P) = target + sum(nums)</code>，那么这道题就转换成了，能否在数组中找到这样一个集合，和等于 <code>(target + sum(nums)) / 2</code>。那么这题就转化为了第 416 题了。<code>dp[i]</code> 中存储的是能使和为 <code>i</code>的方法个数。</p><h2 id="11-11-一和零"><a href="#11-11-一和零" class="headerlink" title="11.11 一和零"></a>11.11 一和零</h2><p><strong>474. Ones and Zeroes</strong></p><p><strong>Q：</strong>You are given an array of binary strings <code>strs</code> and two integers <code>m</code> and <code>n</code>.</p><p>Return <em>the size of the largest subset of <code>strs</code> such that there are <strong>at most</strong></em> <code>m``0</code><em>‘s and</em> <code>n</code> <code>1</code><em>‘s in the subset</em>.</p><p>A set <code>x</code> is a <strong>subset</strong> of a set <code>y</code> if all elements of <code>x</code> are also elements of <code>y</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>, m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 定义数组</span><br>dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i,_ := <span class="hljs-keyword">range</span> dp &#123;<br>dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span> )<br>&#125;<br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(strs);i++ &#123;<br>zeroNum,oneNum := <span class="hljs-number">0</span> , <span class="hljs-number">0</span><br><span class="hljs-comment">//计算0,1 个数</span><br><span class="hljs-comment">//或者直接strings.Count(strs[i],&quot;0&quot;)</span><br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> strs[i] &#123;<br><span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>zeroNum++<br>&#125;<br>&#125;<br>oneNum = <span class="hljs-built_in">len</span>(strs[i])-zeroNum<br><span class="hljs-comment">// 从后往前 遍历背包容量</span><br><span class="hljs-keyword">for</span> j:= m ; j &gt;= zeroNum;j-- &#123;<br><span class="hljs-keyword">for</span> k:=n ; k &gt;= oneNum;k-- &#123;<br><span class="hljs-comment">// 推导公式</span><br>dp[j][k] = max(dp[j][k],dp[j-zeroNum][k-oneNum]+<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><span class="hljs-comment">//fmt.Println(dp)</span><br>&#125;<br><span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1"></p><p>0 1背包的问题，大体感觉就是我本身没有东西，我一点点放东西所以初始值可以为0，迭代公式就是xxx + 1</p><p>状态图</p><p><img src="https://img-blog.csdnimg.cn/20210120111201512.jpg" alt="474.一和零"></p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值。压缩以后行没有了，所以只剩下dp[j]。</p><h2 id="11-12-零钱兑换-II"><a href="#11-12-零钱兑换-II" class="headerlink" title="11.12 零钱兑换 II"></a>11.12 零钱兑换 II</h2><p><strong>518. Coin Change 2</strong></p><p><strong>Q：</strong>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p><p>Return <em>the number of combinations that make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.</p><p>You may assume that you have an infinite number of each kind of coin.</p><p>The answer is <strong>guaranteed</strong> to fit into a signed <strong>32-bit</strong> integer.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(amount <span class="hljs-type">int</span>, coins []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 定义dp数组</span><br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 初始化,0大小的背包, 当然是不装任何东西了, 就是1种方法</span><br>dp[<span class="hljs-number">0</span>]  = <span class="hljs-number">1</span><br><span class="hljs-comment">// 遍历顺序</span><br><span class="hljs-comment">// 遍历物品</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span> ;i &lt; <span class="hljs-built_in">len</span>(coins);i++ &#123;<br><span class="hljs-comment">// 遍历背包</span><br><span class="hljs-keyword">for</span> j:= coins[i] ; j &lt;= amount ;j++ &#123;<br><span class="hljs-comment">// 推导公式</span><br>dp[j] += dp[j-coins[i]]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历顺序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设：coins[0] = 1，coins[1] = 5。</p><p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p><p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p><p>如果把两个for交换顺序，代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">for (int j = 0; j &lt;= amount; j++) &#123; // 遍历背包容量<br>    for (int i = 0; i &lt; coins.size(); i++) &#123; // 遍历物品<br>        if (j - coins[i] &gt;= 0) dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p><p><strong>此时dp[j]里算出来的就是排列数！</strong></p><p>dp推导</p><p><img src="https://img-blog.csdnimg.cn/20210120181331461.jpg" alt="518.零钱兑换II"></p><p>在求装满背包有几种方案的时候，认清遍历顺序是非常关键的。</p><p><strong>如果求【组合数】就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求【排列数】就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p>组合内容不能重复，排列内容可以重复。</p><h2 id="11-13-拼凑一个正整数"><a href="#11-13-拼凑一个正整数" class="headerlink" title="11.13 拼凑一个正整数"></a>11.13 拼凑一个正整数</h2><p><strong>377. Combination Sum IV</strong></p><p><strong>Q：</strong>Given an array of <strong>distinct</strong> integers <code>nums</code> and a target integer <code>target</code>, return <em>the number of possible combinations that add up to</em> <code>target</code>.</p><p>The test cases are generated so that the answer can fit in a <strong>32-bit</strong> integer.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">//定义dp数组</span><br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, target+<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 初始化</span><br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-comment">// 遍历顺序, 先遍历背包,再循环遍历物品</span><br><span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;=target;j++ &#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i &lt; <span class="hljs-built_in">len</span>(nums);i++ &#123;<br><span class="hljs-keyword">if</span> j &gt;= nums[i] &#123;<br>dp[j] += dp[j-nums[i]] <span class="hljs-comment">// j容量下，我放入不同的nums[i]的量，如果可以放进去看看，当前j容量下可以放几种</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[target]<br>&#125;<br></code></pre></td></tr></table></figure><p>弄清什么是组合，什么是排列很重要。</p><p>组合不强调顺序，(1,5)和(5,1)是同一个组合。</p><p>排列强调顺序，(1,5)和(5,1)是两个不同的排列。</p><p>个数可以不限使用，说明这是一个完全背包。</p><p>得到的集合是排列，说明需要考虑元素之间的顺序。</p><p>本题要求的是排列，那么这个for循环嵌套的顺序可以有说法了。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p>这道题背包容量可以是从1开始的因为0容量的时候是没有意义的，肯定到达不了target。</p><h2 id="11-14-零钱兑换"><a href="#11-14-零钱兑换" class="headerlink" title="11.14 零钱兑换"></a>11.14 零钱兑换</h2><p><strong>322. Coin Change</strong></p><p><strong>Q：</strong>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p><p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p><p>You may assume that you have an infinite number of each kind of coin.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 初始化dp[0]</span><br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-comment">// 遍历背包,从1开始</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= amount; j++ &#123;<br><span class="hljs-comment">// 初始化为math.MaxInt32</span><br>dp[j] = math.MaxInt32<br><span class="hljs-comment">// 遍历物品</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(coins); i++ &#123;<br><span class="hljs-keyword">if</span> j &gt;= coins[i] &#123;<br><span class="hljs-comment">// 推导公式</span><br>dp[j] = min(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>)<br><span class="hljs-comment">//fmt.Println(dp)</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 没找到能装满背包的, 就返回-1</span><br><span class="hljs-keyword">if</span> dp[amount] == math.MaxInt32 &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>math.MaxInt32，最大可以是64</p><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p><ol><li>确定递推公式</li></ol><p>得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</p><p><code>dp[j] = min(dp[j], dp[j-coins[i]]+1)</code> 在当前容量j下，投放硬币所有可能性coins[i]（如果你选择一个很大的，他就会往前跳很多去找，这样跳的步长大，走的次数就少），将与dp[j]（如果没有更新过为Max）更小的数量为dp[j]的数量</p><h2 id="11-15-完全平方数"><a href="#11-15-完全平方数" class="headerlink" title="11.15 完全平方数"></a>11.15 完全平方数</h2><p><strong>279. Perfect Squares</strong></p><p><strong>Q：</strong>Given an integer <code>n</code>, return <em>the least number of perfect square numbers that sum to</em> <code>n</code>.</p><p>A <strong>perfect square</strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code>are perfect squares while <code>3</code> and <code>11</code> are not.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        dp[i] = math.MaxInt32<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j * j &lt;= i; j++ &#123;<br>            dp[i] = min(dp[i], dp[i - (j * j)] + <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></p><ol><li>确定递推公式</li></ol><p>dp[j] = min(dp[j], dp[j - (i * i)] + 1)，是不放还是放当前的数看看组合出来的数量哪个小，选哪个作为当前的数量。</p><ol><li>dp数组如何初始化</li></ol><p>dp[0] = 0 因为平方数是从1开始的</p><h2 id="11-16-单词拆分"><a href="#11-16-单词拆分" class="headerlink" title="11.16 单词拆分"></a>11.16 单词拆分</h2><p><strong>139. Word Break</strong></p><p><strong>Q：</strong>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(s <span class="hljs-type">string</span>, wordDict []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    wordDictSet := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br>    <span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> wordDict&#123;<br>        wordDictSet[w] = <span class="hljs-literal">true</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[j] &amp;&amp; wordDictSet[s[j:i]] &#123; <span class="hljs-comment">// dp[j]用来确保之前的都是已经匹配到的，i是下次匹配的起点</span><br>                dp[i] = <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p><ol><li>确定递推公式</li></ol><p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p><p>所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</p><ol><li>dp数组如何初始化</li></ol><p>从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</p><p>那么dp[0]有没有意义呢？</p><p>dp[0]表示如果字符串为空的话，说明出现在字典里。</p><p>但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</p><p>下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</p><ol><li>确定遍历顺序</li></ol><p>题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</p><p>还要讨论两层for循环的前后循序。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><h2 id="11-17-买卖股票的最佳时机"><a href="#11-17-买卖股票的最佳时机" class="headerlink" title="11.17 买卖股票的最佳时机"></a>11.17 买卖股票的最佳时机</h2><p><strong>121. Best Time to Buy and Sell Stock</strong></p><p><strong>Q：</strong>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p><p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 贪心</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    low := math.MaxInt32<br>    rlt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> prices&#123;<br>        low = min(low, prices[i])<br>        rlt = max(rlt, prices[i]-low)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> rlt<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>length:=<span class="hljs-built_in">len</span>(prices)<br><span class="hljs-keyword">if</span> length==<span class="hljs-number">0</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>dp:=<span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,length)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;length;i++&#123;<br>dp[i]=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">2</span>)<br>&#125;<br><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=-prices[<span class="hljs-number">0</span>]<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;length;i++&#123;<br>dp[i][<span class="hljs-number">0</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],-prices[i])<br>dp[i][<span class="hljs-number">1</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+prices[i])<br>&#125;<br><span class="hljs-keyword">return</span> dp[length<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a&gt;b&#123;<br>        <span class="hljs-keyword">return</span> a <br>    &#125;<br>    <span class="hljs-keyword">return</span> b <br>&#125;<br></code></pre></td></tr></table></figure><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i] [0] 表示第i天持有股票所得最多现金 ，<strong>这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</strong></p><p>其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。</p><p>dp[i] [1] 表示第i天不持有股票所得最多现金</p><p><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></p><p>很多同学把“持有”和“买入”没分区分清楚。</p><p>在下面递推公式分析中，我会进一步讲解。</p><ol><li>确定递推公式</li></ol><p>如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</li><li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</li></ul><p>那么dp[i] [0]应该选所得现金最大的，所以dp[i] [0] = max(dp[i - 1] [0], -prices[i]);</p><p>如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</li><li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1] [0]</li></ul><p>同样dp[i] [1]取最大的，dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</p><p>这样递归公式我们就分析完了</p><ol><li>dp数组如何初始化</li></ol><p>由递推公式 dp[i] [0] = max(dp[i - 1] [0], -prices[i]); 和 dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);可以看出</p><p>其基础都是要从dp[0] [0]和dp[0] [1]推导出来。</p><p>那么dp[0] [0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -= prices[0];</p><p>dp[0] [1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] = 0;</p><ol><li>确定遍历顺序</li></ol><p>从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。</p><ol><li>举例推导dp数组</li></ol><p>以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：</p><p><img src="https://img-blog.csdnimg.cn/20210224225642465.png" alt="121.买卖股票的最佳时机"></p><p>dp[5] [1]就是最终结果。</p><p>为什么不是dp[5] [0]呢？</p><p><strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p><p>此题只买卖股票一次！相当于用同一个时间拆分成两部分，持有股票给不持有股票服务，如何服务呢？就是在不持有股票的情况下肯定是比持有的多，那么我们就根据不持有股票的的值进行售卖看看现在的差价是，直接摆烂的多还是卖出以后多，最后推移到最后得到结果。</p><h2 id="11-18-买卖股票的最佳时机-II"><a href="#11-18-买卖股票的最佳时机-II" class="headerlink" title="11.18 买卖股票的最佳时机 II"></a>11.18 买卖股票的最佳时机 II</h2><p><strong>122. Best Time to Buy and Sell Stock II</strong></p><p><strong>Q：</strong>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p><p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 买卖股票的最佳时机Ⅱ 动态规划</span><br><span class="hljs-comment">// 时间复杂度：O(n) 空间复杂度：O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(prices))<br>    status := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(prices) * <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = status[:<span class="hljs-number">2</span>]<br>        status = status[<span class="hljs-number">2</span>:]<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i])<br>        dp[i][<span class="hljs-number">1</span>] = max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i])<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(prices) - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>和上一题不同的是可以多次买卖股票以谋求最大利润</p><p>唯一的区别<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);</code></p><p>就是当你买入的时候一定是前一个状态售出后才能够买入。</p><h2 id="11-19-买卖股票的最佳时机-III"><a href="#11-19-买卖股票的最佳时机-III" class="headerlink" title="11.19 买卖股票的最佳时机 III"></a>11.19 买卖股票的最佳时机 III</h2><p><strong>123. Best Time to Buy and Sell Stock III</strong></p><p><strong>Q：</strong>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>Find the maximum profit you can achieve. You may complete <strong>at most two transactions</strong>.</p><p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp:=<span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(prices))<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(prices);i++&#123;<br>        dp[i]=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=-prices[<span class="hljs-number">0</span>]<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]=-prices[<span class="hljs-number">0</span>]<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(prices);i++&#123;<br>        dp[i][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]<span class="hljs-comment">// 没有操作</span><br>        dp[i][<span class="hljs-number">1</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]-prices[i]) <span class="hljs-comment">// 第一次买入</span><br>        dp[i][<span class="hljs-number">2</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+prices[i]) <span class="hljs-comment">// 第一次卖出</span><br>        dp[i][<span class="hljs-number">3</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]-prices[i]) <span class="hljs-comment">// 第二次买入</span><br>        dp[i][<span class="hljs-number">4</span>]=max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">4</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>]+prices[i]) <span class="hljs-comment">// 第二次卖出</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(prices)<span class="hljs-number">-1</span>][<span class="hljs-number">4</span>]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a&gt;b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>举例推导dp数组</strong></p><p>以输入[1,2,3,4,5]为例</p><p><img src="https://img-blog.csdnimg.cn/20201228181724295.png" alt="123.买卖股票的最佳时机III"></p><p>大家可以看到红色框为最后两次卖出的状态。</p><p>现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。</p><p>所以最终最大利润是dp[4] [4]</p><h2 id="11-20-买卖股票的最佳时机-IV"><a href="#11-20-买卖股票的最佳时机-IV" class="headerlink" title="11.20 买卖股票的最佳时机 IV"></a>11.20 买卖股票的最佳时机 IV</h2><p><strong>188. Best Time to Buy and Sell Stock IV</strong></p><p><strong>Q：</strong>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day, and an integer <code>k</code>.</p><p>Find the maximum profit you can achieve. You may complete at most <code>k</code>transactions.</p><p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">## 11.21 买卖股票的最佳时机含冷冻期</span><br><span class="hljs-string"></span><br><span class="hljs-string">**309. Best Time to Buy and Sell Stock with Cooldown**</span><br><span class="hljs-string"></span><br><span class="hljs-string">**Q：**You are given an array `</span>prices<span class="hljs-string">` where `</span>prices[i]<span class="hljs-string">` is the price of a given stock on the `</span>ith<span class="hljs-string">` day.</span><br><span class="hljs-string"></span><br><span class="hljs-string">Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:</span><br><span class="hljs-string"></span><br><span class="hljs-string">- After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</span><br><span class="hljs-string"></span><br><span class="hljs-string">**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</span><br><span class="hljs-string"></span><br><span class="hljs-string">**A：**</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><span class="hljs-keyword">go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">4</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]) - prices[i])<br>        dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>])<br>        dp[i][<span class="hljs-number">2</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + prices[i]<br>        dp[i][<span class="hljs-number">3</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], max(dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>], dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>]))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>确定dp数组以及下标的含义</p><p>dp[i] [j]，第i天状态为j，所剩的最多现金为dp[i] [j]。</p><p><strong>其实本题很多同学搞的比较懵，是因为出现冷冻期之后，状态其实是比较复杂度</strong>，例如今天买入股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。 具体可以区分出如下四个状态：</p><ul><li>状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</li><li>卖出股票状态，这里就有两种卖出股票状态<ul><li>状态二：两天前就卖出了股票，度过了冷冻期；一直没操作，今天保持卖出股票状态</li><li>状态三：今天卖出了股票</li></ul></li><li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！(冷冻期也属于卖出股票的一种)</li></ul><p>转移方程：</p><p>达到买入股票状态（状态一）即：dp[i] [0]，有两个具体操作：</p><ul><li>操作一：前一天就是持有股票状态（状态一），dp[i] [0] = dp[i - 1] [0]</li><li>操作二：今天买入了，有两种情况<ul><li>前一天是冷冻期（状态四），dp[i - 1] [3] - prices[i]</li><li>前一天是保持卖出股票状态（状态二），dp[i - 1] [1] - prices[i]</li></ul></li></ul><p>所以操作二取最大值，即：max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]</p><p>那么dp[i] [0] = max(dp[i - 1] [0], max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]);</p><p>达到保持卖出股票状态（状态二）即：dp[i] [1]，有两个具体操作：</p><ul><li>操作一：前一天就是状态二</li><li>操作二：前一天是冷冻期（状态四）</li></ul><p>dp[i][1] = max(dp[i - 1] [1], dp[i - 1] [3]);</p><p>达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：</p><ul><li>操作一：昨天一定是买入股票状态（状态一），今天卖出</li></ul><p>即：dp[i] [2] = dp[i - 1] [0] + prices[i];</p><p>达到冷冻期状态（状态四），即：dp[i] [3]，只有一个操作：</p><ul><li>操作一：昨天卖出了股票（状态三）</li></ul><p>dp[i] [3] = dp[i - 1] [2];</p><h2 id="11-22-买卖股票的最佳时机含手续费"><a href="#11-22-买卖股票的最佳时机含手续费" class="headerlink" title="11.22 买卖股票的最佳时机含手续费"></a>11.22 买卖股票的最佳时机含手续费</h2><p><strong>714. Best Time to Buy and Sell Stock with Transaction Fee</strong></p><p><strong>Q：</strong>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day, and an integer <code>fee</code> representing a transaction fee.</p><p>Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.</p><p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>, fee <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>    dp := <span class="hljs-built_in">make</span>([][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>, n) <span class="hljs-comment">// 两种初始化的方法</span><br><span class="hljs-comment">//    for i := 0; i &lt; n; i++ &#123;</span><br><span class="hljs-comment">//        dp[i] = make([]int, 2)</span><br><span class="hljs-comment">//    &#125;</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] - prices[i]) <span class="hljs-comment">// 持有股票</span><br>        dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + prices[i] - fee) <span class="hljs-comment">// 未持有股票</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>本题只需要在计算卖出操作的时候减去手续费就可以了</p><p>状态1 买入，持有股票（昨天已经买入了；昨天没有买入，今天买入）</p><p>状态2 卖出，未持有股票（昨天卖出了；今天卖出）</p><h2 id="11-23-最长递增子序列"><a href="#11-23-最长递增子序列" class="headerlink" title="11.23 最长递增子序列"></a>11.23 最长递增子序列</h2><p><strong>300. Longest Increasing Subsequence</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code>, return the length of the longest strictly increasing subsequence.</p><p>A <strong>subsequence</strong> is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, <code>[3,6,2,7]</code> is a subsequence of the array <code>[0,3,1,6,2,2,7]</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划求解</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// dp数组的定义 dp[i]表示取第i个元素的时候，表示子序列的长度，其中包括 nums[i] 这个元素</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br><br>    <span class="hljs-comment">// 初始化，所有的元素都应该初始化为1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-number">1</span><br>    &#125;<br><br>    ans := dp[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[j] &#123;<br>                dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> dp[i] &gt; ans &#123;<br>            ans = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>dp[i]的定义</li></ol><p><strong>dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度</strong></p><ol><li>状态转移方程</li></ol><p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p>所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p><p><strong>注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值</strong>。</p><ol><li>dp[i]的初始化</li></ol><p>每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是1.</p><ol><li>确定遍历顺序</li></ol><p>dp[i] 是有0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。</p><p>最长自增子序列的定义，只要有比他小的就算上。</p><h2 id="11-24-最长连续递增序列"><a href="#11-24-最长连续递增序列" class="headerlink" title="11.24 最长连续递增序列"></a>11.24 最长连续递增序列</h2><p><strong>674. Longest Continuous Increasing Subsequence</strong></p><p><strong>Q：</strong>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest <strong>continuous increasing subsequence</strong> (i.e. subarray)</em>. The subsequence must be <strong>strictly</strong> increasing.</p><p>A <strong>continuous increasing subsequence</strong> is defined by two indices <code>l</code> and <code>r</code>(<code>l &lt; r</code>) such that it is <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> and for each <code>l &lt;= i &lt; r</code>, <code>nums[i] &lt; nums[i + 1]</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        dp[i] = <span class="hljs-number">1</span><br>    &#125;<br>    res := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &gt; nums[i<span class="hljs-number">-1</span>] &#123;<br>            dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> dp[i] &gt; res &#123;<br>            res = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>由于要求连续所以我们用一层循环就可以了。</p><h2 id="11-25-最长重复子数组"><a href="#11-25-最长重复子数组" class="headerlink" title="11.25 最长重复子数组"></a>11.25 最长重复子数组</h2><p><strong>718. Maximum Length of Repeated Subarray</strong></p><p><strong>Q：</strong>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>the maximum length of a subarray that appears in <strong>both</strong> arrays</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLength</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(nums1)<br>    n := <span class="hljs-built_in">len</span>(nums2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> dp[i][j] &gt; res &#123;<br>                res = dp[i][j]<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//fmt.Println(dp[i][1:])</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题状态图比较重要</p><p>dp[i] [j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i] [j]。 （<strong>特别注意</strong>： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）</p><p>之所以为了增加一位是因为这样的话他的棋盘格就很清晰。</p><p><code>nums1[i-1] == nums2[j-1]</code>之所以这里比较的是i-1和j-1是因为，我们多加了一位所以从下图就可以看到他是偏移了一位，想要获得对应的值需要让序列号-1</p><p><img src="https://img-blog.csdnimg.cn/2021011215282060.jpg" alt="718.最长重复子数组"></p><p>我们可以看到通过一个巧妙的相同的数字为标准，如果连续的子列的话他会是成斜线的。</p><h2 id="11-26-最长公共子序列"><a href="#11-26-最长公共子序列" class="headerlink" title="11.26 最长公共子序列"></a>11.26 最长公共子序列</h2><p><strong>1143. Longest Common Subsequence</strong></p><p><strong>Q：</strong>Given two strings <code>text1</code> and <code>text2</code>, return <em>the length of their longest <strong>common subsequence</strong>.</em> If there is no <strong>common subsequence</strong>, return <code>0</code>.</p><p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p><ul><li>For example, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code>.</li></ul><p>A <strong>common subsequence</strong> of two strings is a subsequence that is common to both strings.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(text1)<br>    n := <span class="hljs-built_in">len</span>(text2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p><p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i] [j] = dp[i - 1] [j - 1] + 1;</p><p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p><p>即：dp[i] [j] = max(dp[i - 1] [j], dp[i] [j - 1]);</p><p>与11.24不同的是他不需要考虑连续，只要相同就可以了。由于是存在即可计算的情况，所以说我们可以单纯的记录当前最大的重复量。但11.24不可以，他要求是连续的，所以只要有不同的了就清零（在代码中就是不赋值）</p><p><img src="https://img-blog.csdnimg.cn/20210210150215918.jpg" alt="1143.最长公共子序列1"></p><h2 id="11-27-不相交的线"><a href="#11-27-不相交的线" class="headerlink" title="11.27 不相交的线"></a>11.27 不相交的线</h2><p><strong>1035. Uncrossed Lines</strong></p><p><strong>Q：</strong>You are given two integer arrays <code>nums1</code> and <code>nums2</code>. We write the integers of <code>nums1</code> and <code>nums2</code> (in the order they are given) on two separate horizontal lines.</p><p>We may draw connecting lines: a straight line connecting two numbers <code>nums1[i]</code> and <code>nums2[j]</code> such that:</p><ul><li><code>nums1[i] == nums2[j]</code>, and</li><li>the line we draw does not intersect any other connecting (non-horizontal) line.</li></ul><p>Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).</p><p>Return <em>the maximum number of connecting lines we can draw in this way</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxUncrossedLines</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(nums1)<br>    n := <span class="hljs-built_in">len</span>(nums2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//fmt.Println(dp[i][1:])</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！</strong></p><p>我们可以这样理解，我们按照列扫描，行代表我们侦查其中一个字符串的内容长度。重点在于我们如何控制数据不往回看（通过从前往后遍历）</p><h2 id="11-28-最大子序和"><a href="#11-28-最大子序和" class="headerlink" title="11.28 最大子序和"></a>11.28 最大子序和</h2><p><strong>53. Maximum Subarray</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p><p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    res := dp[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        dp[i] = max(dp[i<span class="hljs-number">-1</span>] + nums[i], nums[i]) <span class="hljs-comment">// 选 or 不继续累加清零</span><br>        <span class="hljs-keyword">if</span> dp[i] &gt; res &#123;<br>            res = dp[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-29-判断子序和"><a href="#11-29-判断子序和" class="headerlink" title="11.29 判断子序和"></a>11.29 判断子序和</h2><p><strong>392. Is Subsequence</strong></p><p><strong>Q：</strong>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is a <strong>subsequence</strong> of</em> <code>t</code><em>, or</em> <code>false</code> <em>otherwise</em>.</p><p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(s)<br>    n := <span class="hljs-built_in">len</span>(t)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i<span class="hljs-number">-1</span>] == t[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> dp[m][n] == m &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>dp[i] [j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i] [j]</strong>。</p><p>注意这里是判断s是否为t的子序列。即t的长度是大于等于s的。</p><p>有同学问了，为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？</p><p>用i来表示也可以！</p><p>但我统一以下标i-1为结尾的字符串来计算，这样在下面的递归公式中会容易理解一些，如果还有疑惑，可以继续往下看。</p><p>这道题和最长公共子序列很像不过是加了一个判断而已。注意由于没有要求连续，所以要赋值所有需要不相等的位置。</p><p><img src="https://img-blog.csdnimg.cn/20210303173115966.png" alt="392.判断子序列"></p><h2 id="11-30-不同的子序列"><a href="#11-30-不同的子序列" class="headerlink" title="11.30 不同的子序列"></a>11.30 不同的子序列</h2><p><strong>115. Distinct Subsequences</strong></p><p><strong>Q：</strong>Given two strings <code>s</code> and <code>t</code>, return <em>the number of distinct subsequences of <code>s</code>which equals <code>t</code></em>.</p><p>A string’s <strong>subsequence</strong> is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters’ relative positions. (i.e., <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p><p>The test cases are generated so that the answer fits on a 32-bit signed integer.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp:= <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(dp);i++&#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(t)+<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(dp);i++&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// dp[0][j] 为 0，默认值，因此不需要初始化</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(dp);i++&#123;<br>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;<span class="hljs-built_in">len</span>(dp[i]);j++&#123;<br>            <span class="hljs-keyword">if</span> s[i<span class="hljs-number">-1</span>] == t[j<span class="hljs-number">-1</span>]&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-1</span>][j]<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(dp)<span class="hljs-number">-1</span>][<span class="hljs-built_in">len</span>(dp[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>dp[i] [j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i] [j]。</p><p>这一类问题，基本是要分析两种情况</p><ul><li>s[i - 1] 与 t[j - 1]相等</li><li>s[i - 1] 与 t[j - 1] 不相等</li></ul><p>当s[i - 1] 与 t[j - 1]相等时，dp[i] [j]可以有两部分组成。</p><p>一部分是用s[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]。</p><p>一部分是不用s[i - 1]来匹配，个数为dp[i - 1] [j]。</p><p>这里可能有同学不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。</p><p>例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。</p><p>当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p><p>所以当s[i - 1] 与 t[j - 1]相等时，dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j];</p><p>当s[i - 1] 与 t[j - 1]不相等时，dp[i] [j]只有一部分组成，不用s[i - 1]来匹配，即：dp[i - 1] [j]</p><p>所以递推公式为：dp[i] [j] = dp[i - 1] [j];</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg" alt="115.不同的子序列"></p><p>此题关键在于用不用当前扫描的这一位来匹配。不用的话直接j-1变成j跳过当前位直接扫描下一个有没有。</p><h2 id="11-31-两个字符串的删除操作"><a href="#11-31-两个字符串的删除操作" class="headerlink" title="11.31 两个字符串的删除操作"></a>11.31 两个字符串的删除操作</h2><p><strong>583. Delete Operation for Two Strings</strong></p><p><strong>Q：</strong>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of <strong>steps</strong>required to make</em> <code>word1</code> <em>and</em> <code>word2</code> <em>the same</em>.</p><p>In one <strong>step</strong>, you can delete exactly one character in either string.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(word1)<br>    n := <span class="hljs-built_in">len</span>(word2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] != word2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = min(dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, min(dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>))<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p><ul><li>当word1[i - 1] 与 word2[j - 1]相同的时候</li><li>当word1[i - 1] 与 word2[j - 1]不相同的时候</li></ul><p>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i] [j] = dp[i - 1] [j - 1];</p><p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p><p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1] [j] + 1</p><p>情况二：删word2[j - 1]，最少操作次数为dp[i] [j - 1] + 1</p><p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1] [j - 1] + 2</p><p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i] [j] = min({dp[i - 1] [j - 1] + 2, dp[i - 1] [j] + 1, dp[i] [j - 1] + 1});</p><p>小难点，删除word1[i-1]为什么是dp[i - 1] [j] + 1，因为这道题和不同的子序列不同，他是删除思维是反着的，所以删除一个元素就是直接由跳过j方向，让i-1加1。这里的加就是删除一个元素</p><p><img src="https://img-blog.csdnimg.cn/20210714101750205.png" alt="583.两个字符串的删除操作1"></p><h2 id="11-32-编辑距离"><a href="#11-32-编辑距离" class="headerlink" title="11.32 编辑距离"></a>11.32 编辑距离</h2><p><strong>72. Edit Distance</strong></p><p><strong>Q：</strong>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.</p><p>You have the following three operations permitted on a word:</p><ul><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ul><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(word1)<br>    n := <span class="hljs-built_in">len</span>(word2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>) <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], min(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span> <span class="hljs-comment">// 替换，删除i-1方向，删除j方向</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<span class="hljs-keyword">return</span> a&#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-comment">// min的不同写法，语法糖写法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>m, n := <span class="hljs-built_in">len</span>(word1), <span class="hljs-built_in">len</span>(word2)<br>dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m+<span class="hljs-number">1</span>; i++ &#123;<br>dp[i][<span class="hljs-number">0</span>] = i <span class="hljs-comment">// word1[i] 变成 word2[0], 删掉 word1[i], 需要 i 部操作</span><br>&#125;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n+<span class="hljs-number">1</span>; j++ &#123;<br>dp[<span class="hljs-number">0</span>][j] = j <span class="hljs-comment">// word1[0] 变成 word2[j], 插入 word1[j]，需要 j 部操作</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m+<span class="hljs-number">1</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; j++ &#123;<br><span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>] &#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Min(插入，删除，替换)</span><br>dp[i][j] = Min(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span><span class="hljs-params">(args ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>min := args[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> args &#123;<br><span class="hljs-keyword">if</span> item &lt; min &#123;<br>min = item<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> min<br>&#125;<br></code></pre></td></tr></table></figure><p>在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">if (word1[i - 1] == word2[j - 1])<br>    不操作<br>if (word1[i - 1] != word2[j - 1])<br>    增<br>    删<br>    换<br></code></pre></td></tr></table></figure><p>也就是如上4种情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>])<span class="hljs-string">` 那么说明不用任何编辑，`</span>dp[i][j]<span class="hljs-string">` 就应该是 `</span>dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<span class="hljs-string">`，即`</span>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>此时可能有同学有点不明白，为啥要即<code>dp[i][j] = dp[i - 1][j - 1]</code>呢？</p><p>那么就在回顾上面讲过的<code>dp[i][j]</code>的定义，<code>word1[i - 1]</code> 与 <code>word2[j - 1]</code>相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串<code>word2</code>的最近编辑距离<code>dp[i - 1][j - 1]</code>就是 <code>dp[i][j]</code>了。</p><p>在下面的讲解中，如果哪里看不懂，就回想一下<code>dp[i][j]</code>的定义，就明白了。</p><p><strong>在整个动规的过程中，最为关键就是正确理解<code>dp[i][j]</code>的定义！</strong></p><p><code>if (word1[i - 1] != word2[j - 1])</code>，此时就需要编辑了，如何编辑呢？</p><ul><li>操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。</li></ul><p>即 <code>dp[i][j] = dp[i - 1][j] + 1;</code></p><ul><li>操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。</li></ul><p>即 <code>dp[i][j] = dp[i][j - 1] + 1;</code></p><p>这里有同学发现了，怎么都是删除元素，添加元素去哪了。</p><p><strong>word2添加一个元素，相当于word1删除一个元素</strong>，例如 <code>word1 = &quot;ad&quot; ，word2 = &quot;a&quot;</code>，<code>word1</code>删除元素<code>&#39;d&#39;</code> 和 <code>word2</code>添加一个元素<code>&#39;d&#39;</code>，变成<code>word1=&quot;a&quot;, word2=&quot;ad&quot;</code>， 最终的操作数是一样！ dp数组如下图所示意的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">           a                         a     d<br>  +-----+-----+             +-----+-----+-----+<br>  |  0  |  1  |             |  0  |  1  |  2  |<br>  +-----+-----+   ===&gt;      +-----+-----+-----+<br>a |  1  |  0  |           a |  1  |  0  |  1  |<br>  +-----+-----+             +-----+-----+-----+<br>d |  2  |  1  |<br>  +-----+-----+<br></code></pre></td></tr></table></figure><p>操作三：替换元素，<code>word1</code>替换<code>word1[i - 1]</code>，使其与<code>word2[j - 1]</code>相同，此时不用增加元素，那么以下标<code>i-2</code>为结尾的<code>word1</code> 与 <code>j-2</code>为结尾的<code>word2</code>的最近编辑距离 加上一个替换元素的操作。</p><p>即 <code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p><p>综上，当 <code>if (word1[i - 1] != word2[j - 1])</code> 时取最小的，即：<code>dp[i][j] = min(&#123;dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]&#125;) + 1;</code></p><p>递归公式代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]&#125;) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210114162113131.jpg" alt="72.编辑距离"></p><h2 id="11-33-回文子串"><a href="#11-33-回文子串" class="headerlink" title="11.33 回文子串"></a>11.33 回文子串</h2><p><strong>647. Palindromic Substrings</strong></p><p><strong>Q：</strong>Given a string <code>s</code>, return <em>the number of <strong>palindromic substrings</strong> in it</em>.</p><p>A string is a <strong>palindrome</strong> when it reads the same backward as forward.</p><p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res:=<span class="hljs-number">0</span><br>    dp:=<span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>,<span class="hljs-built_in">len</span>(s))<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;<br>        dp[i]=<span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>,<span class="hljs-built_in">len</span>(s))<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;<br>        <span class="hljs-keyword">for</span> j:=i;j&lt;<span class="hljs-built_in">len</span>(s);j++&#123;<br>            <span class="hljs-keyword">if</span> s[i]==s[j]&#123;<br>                <span class="hljs-keyword">if</span> j-i&lt;=<span class="hljs-number">1</span>&#123;<br>                    res++<br>                    dp[i][j]=<span class="hljs-literal">true</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]&#123;<br>                    res++<br>                    dp[i][j]=<span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>在确定递推公式时，就要分析如下几种情况。</p><p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p><p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true。</li></ul><h2 id="11-34-最长回文子序列"><a href="#11-34-最长回文子序列" class="headerlink" title="11.34 最长回文子序列"></a>11.34 最长回文子序列</h2><p><strong>516. Longest Palindromic Subsequence</strong></p><p><strong>Q：</strong>Given a string <code>s</code>, find <em>the longest palindromic <strong>subsequence</strong>‘s length in</em> <code>s</code>.</p><p>A <strong>subsequence</strong> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>size := <span class="hljs-built_in">len</span>(s)<br>max := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br>dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, size)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, size)<br>dp[i][i] = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">for</span> i := size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; size; j++ &#123;<br><span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dp[i][j] = max(dp[i][j<span class="hljs-number">-1</span>], dp[i+<span class="hljs-number">1</span>][j])<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][size<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h1><p>算法时间复杂度</p><p><img src="https://images0.cnblogs.com/i/608996/201408/141025088894028.png" alt="img"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-旋转数组"><a href="#1-旋转数组" class="headerlink" title="1. 旋转数组"></a>1. 旋转数组</h3><p><strong>189. Rotate Array</strong></p><p><strong>Q：Given an array, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</strong></p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span>  &#123;<br>    k = k % <span class="hljs-built_in">len</span>(nums)<br>    reverse(nums)<br>    reverse(nums[:k])<br>    reverse(nums[k:])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>&#123;<br>    l:=<span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;l/<span class="hljs-number">2</span>;i++&#123;<br>        nums[i], nums[l<span class="hljs-number">-1</span>-i] = nums[l<span class="hljs-number">-1</span>-i], nums[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下步骤就可以<strong>左旋转</strong>字符串：</p><ol><li>反转区间为前n的子串</li><li>反转区间为n到末尾的子串</li><li>反转整个字符串</li></ol><p>本题是<strong>右旋转</strong>，其实就是反转的顺序改动一下，优先反转整个字符串，步骤如下：</p><ol><li>反转整个字符串</li><li>反转区间为前k的子串</li><li>反转区间为k到末尾的子串</li></ol><p>右旋转为了将右边的元素放到左边需要先镜像一下所有的元素，然后我反转需要移动的前k个元素，剩下的元素由于被镜像了我仍然需要反转。</p><p>左旋转就是先反转要移动的左边位数，再反转右边的，最后反转全部，和上述不同的在于他们反转过后要去的地方不一样，左旋转的最左边位置，反转过后不在最右边，而是在中间的右边。</p><h3 id="2-在排序数组中查找元素的第一个和最后一个位置（不太会，要再看）"><a href="#2-在排序数组中查找元素的第一个和最后一个位置（不太会，要再看）" class="headerlink" title="2. 在排序数组中查找元素的第一个和最后一个位置（不太会，要再看）"></a>2. 在排序数组中查找元素的第一个和最后一个位置（不太会，要再看）</h3><p><strong>34. Find First and Last Position of Element in Sorted Array</strong></p><p><strong>Q：</strong>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p><p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    leftBorder := getLeft(nums, target)<br>    rightBorder := getRight(nums, target)<br>    <span class="hljs-comment">// 情况一</span><br>    <span class="hljs-keyword">if</span> leftBorder == <span class="hljs-number">-2</span> || rightBorder == <span class="hljs-number">-2</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>    &#125;<br>    <span class="hljs-comment">// 情况三</span><br>    <span class="hljs-keyword">if</span> rightBorder - leftBorder &gt; <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;leftBorder + <span class="hljs-number">1</span>, rightBorder - <span class="hljs-number">1</span>&#125;<br>    &#125;<br>    <span class="hljs-comment">// 情况二</span><br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLeft</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    border := <span class="hljs-number">-2</span> <span class="hljs-comment">// 记录border没有被赋值的情况；这里不能赋值-1，target = num[0]时，会无法区分情况一和情况二</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123; <span class="hljs-comment">// []闭区间</span><br>        mid := left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123; <span class="hljs-comment">// 找到第一个等于target的位置</span><br>            right = mid - <span class="hljs-number">1</span><br>            border = right<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left =  mid + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> border<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRight</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    border := <span class="hljs-number">-2</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        mid := left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123; <br>            right = mid - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 找到第一个大于target的位置</span><br>            left = mid + <span class="hljs-number">1</span><br>            border = left<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> border<br><br>&#125;<br></code></pre></td></tr></table></figure><p>寻找target在数组里的左右边界，有如下三种情况：</p><ul><li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li><li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li><li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li></ul><p>这三种情况都考虑到，说明就想的很清楚了。</p><p>接下来，在去寻找左边界，和右边界了。</p><h3 id="3-两两交换链表中的节点"><a href="#3-两两交换链表中的节点" class="headerlink" title="3. 两两交换链表中的节点"></a>3. 两两交换链表中的节点</h3><p><strong>24. Swap Nodes in Pairs</strong></p><p><strong>Q：</strong>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>fakeHead := &amp;ListNode&#123;Val: <span class="hljs-number">0</span>, Next: head&#125;<br>curr := fakeHead<br><br><span class="hljs-keyword">for</span> curr.Next != <span class="hljs-literal">nil</span> &amp;&amp; curr.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        <br>next1 := curr.Next<br>next2 := curr.Next.Next<br>        next3 := curr.Next.Next.Next<br>        next1.Next = next3 <br>        <br><span class="hljs-comment">// curr.Next = next2 </span><br><span class="hljs-comment">// curr.Next.Next = next1 </span><br><span class="hljs-comment">// curr = curr.Next.Next </span><br>        next2.Next = next1<br>        curr.Next = next2 <span class="hljs-comment">// 第一次连接fakeHead用的</span><br>        curr = next1 <span class="hljs-comment">// 更新为下一组的前一个节点，相当于fakeHead</span><br>&#125;<br><br><span class="hljs-keyword">return</span> fakeHead.Next<br>&#125;<br><br><span class="hljs-comment">// 递归版本</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    next := head.Next<br>    head.Next = swapPairs(next.Next) <span class="hljs-comment">// 连接以2号位为头节点的交换处</span><br>    next.Next = head<br>    <span class="hljs-keyword">return</span> next<br>&#125;<br></code></pre></td></tr></table></figure><p>新思路，我们将不用pre和cur的方式，我们可以将我们要处理的所有节点用next1、next2…进行编号，然后再进行处理，个人感觉思路会更加清晰一些。</p><h3 id="4-重排链表"><a href="#4-重排链表" class="headerlink" title="4. 重排链表"></a>4. 重排链表</h3><p><strong>143. Reorder List</strong></p><p><strong>Q：</strong>You are given the head of a singly linked-list. The list can be represented as:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-symbol">L1</span> → … → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-built_in">Ln</span><br></code></pre></td></tr></table></figure><p><em>Reorder the list to be on the following form:</em></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-built_in">Ln</span> → <span class="hljs-symbol">L1</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-symbol">L2</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">2</span> → …<br></code></pre></td></tr></table></figure><p>You may not modify the values in the list’s nodes. Only nodes themselves may be changed.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(head *ListNode)</span></span>  &#123;<br>    <span class="hljs-keyword">var</span> slow=head<br>    <span class="hljs-keyword">var</span> fast=head<br>    <span class="hljs-keyword">for</span> fast!=<span class="hljs-literal">nil</span>&amp;&amp;fast.Next!=<span class="hljs-literal">nil</span>&#123;<br>        slow=slow.Next<br>        fast=fast.Next.Next<br>    &#125;  <span class="hljs-comment">//双指针将链表分为左右两部分</span><br>    <span class="hljs-keyword">var</span> right =<span class="hljs-built_in">new</span>(ListNode)<br>    <span class="hljs-keyword">for</span> slow!=<span class="hljs-literal">nil</span>&#123;<br>        temp:=slow.Next<br>        slow.Next=right.Next <span class="hljs-comment">// 指向之前保存的前一个头</span><br>        right.Next=slow<br>        slow=temp<br>    &#125;  <span class="hljs-comment">//翻转链表右半部分</span><br>    right=right.Next  <span class="hljs-comment">//right为反转后得右半部分</span><br>    h:=head<br>    <span class="hljs-keyword">for</span> right.Next!=<span class="hljs-literal">nil</span>&#123;<br>        temp:=right.Next<br>        right.Next=h.Next<br>        h.Next=right<br>        h=h.Next.Next<br>        right=temp<br>    &#125; <span class="hljs-comment">//将左右两部分重新组合</span><br>&#125;<br></code></pre></td></tr></table></figure><p>利用快慢指针来找到一半的起点位置。</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.png" alt="img"></p><p>这里的反转就是反转链表那个流程，right就是我们之前总用的pre</p><p><code>right.Next!=nil</code>才有继续下去的意义</p><p>所有while循环的地方就是让我们思考什么情况下是有意义的</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1-求根到叶子节点数字之和"><a href="#1-求根到叶子节点数字之和" class="headerlink" title="1. 求根到叶子节点数字之和"></a>1. 求根到叶子节点数字之和</h3><p><strong>129. Sum Root to Leaf Numbers</strong></p><p><strong>Q：</strong>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p><p>Each root-to-leaf path in the tree represents a number.</p><ul><li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li></ul><p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p><p>A <strong>leaf</strong> node is a node with no children.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    dfs(root, root.Val, &amp;sum)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, tmpSum <span class="hljs-type">int</span>, sum *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        *sum += tmpSum<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>            dfs(root.Left, tmpSum*<span class="hljs-number">10</span> + root.Left.Val, sum)<br>        &#125;<br>        <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>            dfs(root.Right, tmpSum*<span class="hljs-number">10</span> + root.Right.Val, sum)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-将二叉搜索树变平衡"><a href="#2-将二叉搜索树变平衡" class="headerlink" title="2. 将二叉搜索树变平衡"></a>2. 将二叉搜索树变平衡</h3><p><strong>1382. Balance a Binary Search Tree</strong></p><p><strong>Q：</strong>Given the <code>root</code> of a binary search tree, return <em>a <strong>balanced</strong> binary search tree with the same node values</em>. If there is more than one answer, return <strong>any of them</strong>.</p><p>A binary search tree is <strong>balanced</strong> if the depth of the two subtrees of every node never differs by more than <code>1</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">balanceBST</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>   <span class="hljs-comment">// 二叉搜索树中序遍历得到有序数组</span><br>nums := []<span class="hljs-type">int</span>&#123;&#125;<br>   <span class="hljs-comment">// 中序递归遍历二叉树</span><br><span class="hljs-keyword">var</span> travel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>travel = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>travel(node.Left)<br>nums = <span class="hljs-built_in">append</span>(nums, node.Val)<br>travel(node.Right)<br>&#125;<br><span class="hljs-comment">// 二分法保证左右子树高度差不超过一（题目要求返回的仍是二叉搜索树）</span><br><span class="hljs-keyword">var</span> buildTree <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, left, right <span class="hljs-type">int</span>)</span></span> *TreeNode<br>buildTree = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, left, right <span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br><span class="hljs-keyword">if</span> left &gt; right &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>mid := left + (right-left) &gt;&gt; <span class="hljs-number">1</span><br>root := &amp;TreeNode&#123;Val: nums[mid]&#125;<br>root.Left = buildTree(nums, left, mid<span class="hljs-number">-1</span>)<br>root.Right = buildTree(nums, mid+<span class="hljs-number">1</span>, right)<br><span class="hljs-keyword">return</span> root<br>&#125;<br>travel(root)<br><span class="hljs-keyword">return</span> buildTree(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>1.先排序</p><p>2.二分法插入</p><h3 id="3-填充每个节点的下一个右侧节点指针"><a href="#3-填充每个节点的下一个右侧节点指针" class="headerlink" title="3. 填充每个节点的下一个右侧节点指针"></a>3. 填充每个节点的下一个右侧节点指针</h3><p><strong>116. Populating Next Right Pointers in Each Node</strong></p><p><strong>Q：</strong>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 迭代法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(root *Node)</span></span> *Node &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    stack := <span class="hljs-built_in">make</span>([]*Node, <span class="hljs-number">0</span>)<br>    stack = <span class="hljs-built_in">append</span>(stack, root)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 如果stack里面有元素的话</span><br>        n := <span class="hljs-built_in">len</span>(stack) <span class="hljs-comment">// 记录当前层节点个数</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>            node := stack[<span class="hljs-number">0</span>] <span class="hljs-comment">// 依次弹出节点</span><br>            stack = stack[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> i == n - <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 如果是这层最右的节点，next指向nil</span><br>                node.Next = <span class="hljs-literal">nil</span> <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node.Next = stack[<span class="hljs-number">0</span>] <span class="hljs-comment">// 如果不是最右的节点，next指向右边的节点</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果存在左子节点，放入栈中</span><br>                stack = <span class="hljs-built_in">append</span>(stack, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果存在右子节点，放入栈中</span><br>                stack = <span class="hljs-built_in">append</span>(stack, node.Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>其左子树指向其父节点的右子树</p><p>其右子树指向其父节点next的左子树</p><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="1-N皇后II"><a href="#1-N皇后II" class="headerlink" title="1. N皇后II"></a>1. N皇后II</h3><p><strong>52. N-Queens II</strong></p><p><strong>Q：</strong>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code>chessboard such that no two queens attack each other.</p><p>Given an integer <code>n</code>, return <em>the number of distinct solutions to the <strong>n-queens puzzle</strong></em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    idx := []<span class="hljs-type">int</span>&#123;&#125;<br>    res := <span class="hljs-number">0</span><br>    dfs(n, <span class="hljs-number">0</span>, idx, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(n, row <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> row == n &#123;<br>        *res++<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>        <span class="hljs-keyword">if</span> isValid(row, col, n, idx) &#123;<br>            idx = <span class="hljs-built_in">append</span>(idx, col)<br>            dfs(n, row + <span class="hljs-number">1</span>, idx, res)<br>            idx = idx[:<span class="hljs-built_in">len</span>(idx) - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(row, col, n <span class="hljs-type">int</span>, idx []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    col45 := col<br>    col135 := col<br>    <span class="hljs-comment">// 检查列</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(idx); i++ &#123;<br>        <span class="hljs-keyword">if</span> col == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查45˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col45++<br>        <span class="hljs-keyword">if</span> col45 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查135˚</span><br>    <span class="hljs-keyword">for</span> i := row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        col135--<br>        <span class="hljs-keyword">if</span> col135 == idx[i] &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>跟8皇后一样，原来是显示棋盘，现在就是统计数量。</p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="1-Dota2-参议院"><a href="#1-Dota2-参议院" class="headerlink" title="1. Dota2 参议院"></a>1. Dota2 参议院</h3><p><strong>649. Dota2 Senate</strong></p><p><strong>Q：</strong>In the world of Dota2, there are two parties: the Radiant and the Dire.</p><p>The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise <strong>one</strong> of the two rights:</p><ul><li><strong>Ban one senator’s right:</strong> A senator can make another senator lose all his rights in this and all the following rounds.</li><li><strong>Announce the victory:</strong> If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.</li></ul><p>Given a string <code>senate</code> representing each senator’s party belonging. The character <code>&#39;R&#39;</code> and <code>&#39;D&#39;</code> represent the Radiant party and the Dire party. Then if there are <code>n</code> senators, the size of the given string will be <code>n</code>.</p><p>The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.</p><p>Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be <code>&quot;Radiant&quot;</code> or <code>&quot;Dire&quot;</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">predictPartyVictory</span><span class="hljs-params">(senateStr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// R = true表示本轮循环结束后，字符串里依然有R。D同理</span><br>R, D := <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br><span class="hljs-comment">// 当flag大于0时，R在D前出现，R可以消灭D。当flag小于0时，D在R前出现，D可以消灭R</span><br>flag := <span class="hljs-number">0</span><br><br>senate := []<span class="hljs-type">byte</span>(senateStr)<br><span class="hljs-keyword">for</span> R &amp;&amp; D &#123; <span class="hljs-comment">// 一旦R或者D为false，就结束循环，说明本轮结束后只剩下R或者D了</span><br>R = <span class="hljs-literal">false</span><br>D = <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(senate); i++ &#123;<br><span class="hljs-keyword">if</span> senate[i] == <span class="hljs-string">&#x27;R&#x27;</span> &#123;<br><span class="hljs-keyword">if</span> flag &lt; <span class="hljs-number">0</span>  &#123;<br> senate[i] = <span class="hljs-number">0</span>  <span class="hljs-comment">// 消灭R，R此时为false</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>R = <span class="hljs-literal">true</span> <span class="hljs-comment">// 如果没被消灭，本轮循环结束有R</span><br>&#125;<br>flag++;<br>&#125;<br><span class="hljs-keyword">if</span> senate[i] == <span class="hljs-string">&#x27;D&#x27;</span> &#123;<br><span class="hljs-keyword">if</span> flag &gt; <span class="hljs-number">0</span> &#123;<br>senate[i] = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span>  &#123;<br>D = <span class="hljs-literal">true</span><br>&#125;<br>flag--<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 循环结束之后，R和D只能有一个为true</span><br><span class="hljs-keyword">if</span> R &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Radiant&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dire&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如输入”RRDDD”，执行过程应该是什么样呢？</p><ul><li>第一轮：senate[0]的R消灭senate[2]的D，senate[1]的R消灭senate[3]的D，senate[4]的D消灭senate[0]的R，此时剩下”RD”，第一轮结束！</li><li>第二轮：senate[0]的R消灭senate[1]的D，第二轮结束</li><li>第三轮：只有R了，R胜利</li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="1-最长回文子串"><a href="#1-最长回文子串" class="headerlink" title="1. 最长回文子串"></a>1. 最长回文子串</h3><p><strong>5. Longest Palindromic Substring</strong></p><p><strong>Q：</strong>Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    maxLen := <span class="hljs-number">0</span><br>    left := <span class="hljs-number">0</span><br>    length := <span class="hljs-number">0</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(s))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>,<span class="hljs-built_in">len</span>(s))<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; <span class="hljs-built_in">len</span>(s); j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i] == s[j]&#123;<br>                <span class="hljs-keyword">if</span> j-i &lt;= <span class="hljs-number">1</span>&#123;<br>                    length = j-i<br>                    dp[i][j]=<span class="hljs-literal">true</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]&#123; <span class="hljs-comment">// 根据前一个状态推导</span><br>                    length = j-i<br>                    dp[i][j]=<span class="hljs-literal">true</span><br>                &#125;<br>                fmt.Print(<span class="hljs-string">&quot;i: &quot;</span>)<br>                fmt.Println(i)<br>                fmt.Print(<span class="hljs-string">&quot;j: &quot;</span>)<br>                fmt.Println(j)<br>                fmt.Print(<span class="hljs-string">&quot;tmp_s: &quot;</span>)<br>                fmt.Println(s[i:j+<span class="hljs-number">1</span>])<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> length &gt; maxLen &#123;<br>            maxLen = length<br>            left = i<br>        &#125;<br>        fmt.Println(<span class="hljs-string">&quot;-----------&quot;</span>)<br>        fmt.Print(<span class="hljs-string">&quot;left: &quot;</span>)<br>        fmt.Println(left)<br>        fmt.Print(<span class="hljs-string">&quot;maxLen: &quot;</span>)<br>        fmt.Println(maxLen)<br>    &#125;<br>    <span class="hljs-keyword">return</span> s[left:left+maxLen+<span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p><p>当s[i]与s[j]不相等，那没啥好说的了，dp[i] [j]一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true。</li></ul><p>遍历顺序可有有点讲究了。</p><p>首先从递推公式中可以看出，情况三是根据dp[i + 1] [j - 1]是否为true，在对dp[i] [j]进行赋值true的。</p><p>dp[i + 1] [j - 1] 在 dp[i] [j]的左下角，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210121171032473.jpg" alt="647.回文子串"></p><p>如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的dp[i + 1] [j - 1]，也就是根据不确定是不是回文的区间[i+1, j-1]，来判断了[i,j]是不是回文，那结果一定是不对的。</p><p><strong>所以一定要从下到上，从左到右遍历，这样保证dp[i + 1] [j - 1]都是经过计算的</strong>。</p><h3 id="2-最长递增子序列的个数"><a href="#2-最长递增子序列的个数" class="headerlink" title="2. 最长递增子序列的个数"></a>2. 最长递增子序列的个数</h3><p><strong>673. Number of Longest Increasing Subsequence</strong></p><p><strong>Q：</strong>Given an integer array <code>nums</code>, return <em>the number of longest increasing subsequences.</em></p><p><strong>Notice</strong> that the sequence has to be <strong>strictly</strong> increasing.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findNumberOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>size := <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">if</span> size &lt;= <span class="hljs-number">1</span>  &#123;<br><span class="hljs-keyword">return</span> size<br>&#125;<br><br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, size);<br><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>dp[i] = <span class="hljs-number">1</span><br>&#125;<br>count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, size);<br><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> count &#123;<br>count[i] = <span class="hljs-number">1</span><br>&#125;<br><br>maxCount := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; size; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br><span class="hljs-keyword">if</span> nums[i] &gt; nums[j] &#123;<br><span class="hljs-keyword">if</span> dp[j] + <span class="hljs-number">1</span> &gt; dp[i] &#123;<br>dp[i] = dp[j] + <span class="hljs-number">1</span><br>count[i] = count[j] <span class="hljs-comment">// 如果长度变了那么就是新的规格了</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dp[j] + <span class="hljs-number">1</span> == dp[i] &#123;<br>count[i] += count[j] <span class="hljs-comment">// 同一个规格，不同的组合</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> dp[i] &gt; maxCount &#123;<br>maxCount = dp[i] <span class="hljs-comment">// 记录最长子序列的长度</span><br>&#125;<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">// 找最长的</span><br>result := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br><span class="hljs-keyword">if</span> maxCount == dp[i] &#123;<br>result += count[i]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>即：位置i的最长递增子序列长度 等于j从0到i-1各个位置的最长升序子序列 + 1的最大值。</p><p>本题就没那么简单了，我们要考虑两个维度，一个是dp[i]的更新，一个是count[i]的更新。</p><p>那么如何更新count[i]呢？</p><p>以nums[i]为结尾的字符串，最长递增子序列的个数为count[i]。</p><p>那么在nums[i] &gt; nums[j]前提下，如果在[0, i-1]的范围内，找到了j，使得dp[j] + 1 &gt; dp[i]，说明找到了一个更长的递增子序列。</p><p>那么以j为结尾的子串的最长递增子序列的个数，就是最新的以i为结尾的子串的最长递增子序列的个数，即：count[i] = count[j]。</p><p>在nums[i] &gt; nums[j]前提下，如果在[0, i-1]的范围内，找到了j，使得dp[j] + 1 == dp[i]，说明找到了两个相同长度的递增子序列。</p><p>那么以i为结尾的子串的最长递增子序列的个数 就应该加上以j为结尾的子串的最长递增子序列的个数，即：count[i] += count[j];</p><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="1-钥匙和房间"><a href="#1-钥匙和房间" class="headerlink" title="1. 钥匙和房间"></a>1. 钥匙和房间</h3><p><strong>841. Keys and Rooms</strong></p><p><strong>Q：</strong>There are <code>n</code> rooms labeled from <code>0</code> to <code>n - 1</code> and all the rooms are locked except for room <code>0</code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p><p>When you visit a room, you may find a set of <strong>distinct keys</strong> in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p><p>Given an array <code>rooms</code> where <code>rooms[i]</code> is the set of keys that you can obtain if you visited room <code>i</code>, return <code>true</code> <em>if you can visit <strong>all</strong> the rooms, or</em> <code>false</code><em>otherwise</em>.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(key <span class="hljs-type">int</span>, rooms [][]<span class="hljs-type">int</span>, visited []<span class="hljs-type">bool</span> )</span></span> &#123;<br><span class="hljs-keyword">if</span> visited[key] &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>visited[key] = <span class="hljs-literal">true</span><br>keys := rooms[key]<br><span class="hljs-keyword">for</span> _ , key := <span class="hljs-keyword">range</span> keys &#123;<br><span class="hljs-comment">// 深度优先搜索遍历</span><br>dfs(key, rooms, visited);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canVisitAllRooms</span><span class="hljs-params">(rooms [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(rooms));<br>dfs(<span class="hljs-number">0</span>, rooms, visited);<br><span class="hljs-comment">//检查是否都访问到了</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(visited); i++ &#123;<br><span class="hljs-keyword">if</span> !visited[i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题其实给我们是一个有向图， 意识到这是有向图很重要！</p><p>图中给我的两个示例： <code>[[1],[2],[3],[]]</code> <code>[[1,3],[3,0,1],[2],[0]]</code>，画成对应的图如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220714101414.png" alt="img"></p><p>我们可以看出图1的所有节点都是链接的，而图二中，节点2 是孤立的。</p><p>这就很容易让我们想起岛屿问题，只要发现独立的岛，就是不能进入所有房间。</p><p>此时也容易想到用并查集的方式去解决。</p><p><strong>但本题是有向图</strong>，在有向图中，即使所有节点都是链接的，但依然不可能从0出发遍历所有边。 给大家举一个例子：</p><p>图3：[[5], [], [1, 3], [5]] ，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220714102201.png" alt="img"></p><p>在图3中，大家可以发现，节点0只能到节点5，然后就哪也去不了了。</p><p>所以本题是一个有向图搜索全路径的问题。 只能用深搜（BFS）或者广搜（DFS）来搜。</p><h3 id="2-单词接龙"><a href="#2-单词接龙" class="headerlink" title="2. 单词接龙"></a>2. 单词接龙</h3><p><strong>127. Word Ladder</strong></p><p><strong>Q：</strong>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that:</p><ul><li>Every adjacent pair of words differs by a single letter.</li><li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li><li><code>sk == endWord</code></li></ul><p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em><code>beginWord</code> <em>to</em> <code>endWord</code><em>, or</em> <code>0</code> <em>if no such sequence exists.</em></p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(beginWord <span class="hljs-type">string</span>, endWord <span class="hljs-type">string</span>, wordList []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>wordMap, que, depth := getWordMap(wordList, beginWord), []<span class="hljs-type">string</span>&#123;beginWord&#125;, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(que) &gt; <span class="hljs-number">0</span> &#123;<br>depth++<br>qLen := <span class="hljs-built_in">len</span>(que)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; qLen; i++ &#123;<br>word := que[<span class="hljs-number">0</span>]<br>que = que[<span class="hljs-number">1</span>:]<br>candidates := getCandidates(word)<br><span class="hljs-keyword">for</span> _, candidate := <span class="hljs-keyword">range</span> candidates &#123;<br><span class="hljs-keyword">if</span> _, exist := wordMap[candidate]; exist &#123;<br><span class="hljs-keyword">if</span> candidate == endWord &#123;<br><span class="hljs-keyword">return</span> depth + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-built_in">delete</span>(wordMap, candidate)<br>que = <span class="hljs-built_in">append</span>(que, candidate)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getWordMap</span><span class="hljs-params">(wordList []<span class="hljs-type">string</span>, beginWord <span class="hljs-type">string</span>)</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>wordMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> wordList &#123;<br><span class="hljs-keyword">if</span> _, exist := wordMap[word]; !exist &#123;<br><span class="hljs-keyword">if</span> word != beginWord &#123;<br>wordMap[word] = i<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> wordMap<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getCandidates</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(word); j++ &#123;<br><span class="hljs-keyword">if</span> word[j] != <span class="hljs-type">byte</span>(<span class="hljs-type">int</span>(<span class="hljs-string">&#x27;a&#x27;</span>)+i) &#123;<br>res = <span class="hljs-built_in">append</span>(res, word[:j]+<span class="hljs-type">string</span>(<span class="hljs-type">int</span>(<span class="hljs-string">&#x27;a&#x27;</span>)+i)+word[j+<span class="hljs-number">1</span>:])<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是求起点和终点的最短路径长度，<strong>这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径</strong>。因为广搜就是以起点中心向四周扩散的搜索。</p><ul><li>这一题要求输出从 <code>beginWord</code> 变换到 <code>endWord</code> 最短变换次数。可以用 BFS，从 <code>beginWord</code> 开始变换，把该单词的每个字母都用 <code>&#39;a&#39;~&#39;z&#39;</code> 变换一次，生成的数组到 <code>wordList</code> 中查找，这里用 Map 来记录查找。找得到就入队列，找不到就输出 0 。入队以后按照 BFS 的算法依次遍历完，当所有单词都 <code>len(queue)&lt;=0</code> 出队以后，整个程序结束。</li><li>这一题题目中虽然说了要求找到一条最短的路径，但是实际上最短的路径的寻找方法已经告诉你了：<ol><li>每次只变换一个字母</li><li>每次变换都必须在 <code>wordList</code> 中<br>所以不需要单独考虑何种方式是最短的。</li></ol></li></ul><p>相当于一个一个的找，找到一层，就筛选所有的可能的结果，再找到就下一层。</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="1-冗余连接"><a href="#1-冗余连接" class="headerlink" title="1. 冗余连接"></a>1. 冗余连接</h3><p><strong>684. Redundant Connection</strong></p><p><strong>Q：</strong>In this problem, a tree is an <strong>undirected graph</strong> that is connected and has no cycles.</p><p>You are given a graph that started as a tree with <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, with one additional edge added. The added edge has two <strong>different</strong>vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed. The graph is represented as an array <code>edges</code> of length <code>n</code> where <code>edges[i] = [ai, bi]</code> indicates that there is an edge between nodes <code>ai</code> and <code>bi</code> in the graph.</p><p>Return <em>an edge that can be removed so that the resulting graph is a tree of</em> <code>n</code><em>nodes</em>. If there are multiple answers, return the answer that occurs last in the input.</p><p><strong>A：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">var</span> (<br>    n = <span class="hljs-number">1005</span> <span class="hljs-comment">// 节点数量3 到 1000</span><br>    father = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1005</span>)<br>)<br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>father[i] = i<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find</span><span class="hljs-params">(u <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> u == father[u] &#123;<br><span class="hljs-keyword">return</span> u<br>&#125;<br>father[u] = find(father[u])<br><span class="hljs-keyword">return</span> father[u]<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">join</span><span class="hljs-params">(u, v <span class="hljs-type">int</span>)</span></span> &#123;<br>u = find(u)<br>v = find(v)<br><span class="hljs-keyword">if</span> u == v &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>father[v] = u<br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根，本题用不上</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">same</span><span class="hljs-params">(u, v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>u = find(u)<br>v = find(v)<br><span class="hljs-keyword">return</span> u == v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(edges [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>initialize()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(edges); i++ &#123;<br><span class="hljs-keyword">if</span> same(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]) &#123;<br><span class="hljs-keyword">return</span> edges[i]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>join(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并查集主要有三个功能。</p><ol><li>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</li><li>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上</li><li>判断两个节点是否在同一个集合，函数：same(int u, int v)，就是判断两个节点是不是同一个根节点</li></ol><p>简单介绍并查集之后，我们再来看一下这道题目。</p><p>题目说是无向图，返回一条可以删去的边，使得结果图是一个有着N个节点的树。</p><p>如果有多个答案，则返回二维数组中最后出现的边。</p><p>那么我们就可以从前向后遍历每一条边，边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。</p><p>如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，如果再加入这条边一定就出现环了。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Study</title>
    <link href="/2022/04/20/SQL-Study/"/>
    <url>/2022/04/20/SQL-Study/</url>
    
    <content type="html"><![CDATA[<h1 id="基本书写规范"><a href="#基本书写规范" class="headerlink" title="基本书写规范"></a>基本书写规范</h1><p>对于 SQL 初学者，在写 SQL 语句时，只要遵守下面几个书写规则，就可以避免很多错误。这些规则都非常简单，下面我们来逐一介绍。</p><p><strong>SQL 语句要以分号<code>;</code>结尾</strong></p><p>在 RDBMS （关系型数据库）当中，SQL 语句是逐条执行的，一条 SQL 语句代表着数据库的一个操作。</p><p>我们通常在句子的句尾加注标点表示这句话结束，中文句子以句号<code>。</code>结尾，英文以点号<code>.</code>结尾，而 SQL 语句则使用英文分号<code>;</code>结尾。</p><p><strong>SQL 语句不区分大小写</strong></p><p>SQL 不区分关键字的大小写。例如，不管写成 SELECT 还是 select，解释都是一样的。表名和列名也是如此。（但是注意字符串是要分大小写的）</p><p>提示：关键字是数据库事先定义的，有特别意义的单词。</p><p>虽然可以根据个人喜好选择大写还是小写（或大小写混杂），但为了理解起来更加容易，本教程使用以下规则来书写 SQL 语句。</p><ul><li>关键字大写</li><li>数据库名、表名和列名等小写</li></ul><p>需要注意的是，插入到表中的数据是区分大小写的。例如，向数据库中插入单词 Computer、COMPUTER 或 computer，这三个是不一样的数据</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/dbStudy.png" alt="dbStudy"></p><p>自学网网址：<a href="http://www.xuesql.cn/">http://www.xuesql.cn/</a></p><h1 id="一-SQL的SELECT使用"><a href="#一-SQL的SELECT使用" class="headerlink" title="一. SQL的SELECT使用"></a>一. SQL的SELECT使用</h1><h2 id="1-1-条件查询语法"><a href="#1-1-条件查询语法" class="headerlink" title="1.1 条件查询语法"></a>1.1 条件查询语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql"># 条件查询语法<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition<br>    AND/OR another_condition<br>    AND/OR …;<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Operator（操作符）</th><th>Condition（解释）</th><th>Example（例子）</th></tr></thead><tbody><tr><td>=</td><td>Case sensitive exact string comparison (<em>notice the single equals</em>)完全等于</td><td>col_name = “abc”</td></tr><tr><td>!= or &lt;&gt;</td><td>Case sensitive exact string inequality comparison 不等于</td><td>col_name != “abcd”</td></tr><tr><td>LIKE</td><td>Case insensitive exact string comparison 没有用通配符等价于 =</td><td>col_name LIKE “ABC”</td></tr><tr><td>NOT LIKE</td><td>Case insensitive exact string inequality comparison 没有用通配符等价于 !=</td><td>col_name NOT LIKE”ABCD”</td></tr><tr><td>%</td><td>Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) 通配符，代表匹配0个以上的字符</td><td>col_name LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”) “%AT%” 代表AT 前后可以有任意字符</td></tr><tr><td>_</td><td>Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) 和% 相似，代表1个字符</td><td>col_name LIKE “AN_” (matches “AND”, but not “AN”)</td></tr><tr><td>IN (…)</td><td>String exists in a list 在列表</td><td>col_name IN (“A”, “B”, “C”)</td></tr></tbody></table></div><h2 id="1-2-DISTINCT语法"><a href="#1-2-DISTINCT语法" class="headerlink" title="1.2 DISTINCT语法"></a>1.2 DISTINCT语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 选取出唯一的结果的语法<br>SELECT DISTINCT column, another_column, …<br>FROM mytable<br>WHERE condition(s);<br></code></pre></td></tr></table></figure><p>因为 <code>DISTINCT</code> 语法会直接删除重复的行，我们还会学习 <code>GROUP BY</code> 语句， <code>GROUP BY</code> 也会返回唯一的行，不过可以对具有相同的 属性值的行做一些统计计算，比如：求和。</p><h2 id="1-3-结果排序-Ordering-results"><a href="#1-3-结果排序-Ordering-results" class="headerlink" title="1.3 结果排序(Ordering results)"></a>1.3 结果排序(Ordering results)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 结果排序（ordered results）<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition(s)<br>ORDER BY column ASC/DESC;<br></code></pre></td></tr></table></figure><p><code>ORDER BY col_name</code> 这句话的意思就是让结果按照 col_name 列的具体值做 ASC升序 或 DESC 降序，对数字来说就是升序 1，2，3，… 或降序 … 3,2,1。对于文本列，升序和降序指的是按文本的字母序。</p><h2 id="1-4-通过Limit选取部分结果"><a href="#1-4-通过Limit选取部分结果" class="headerlink" title="1.4 通过Limit选取部分结果"></a>1.4 通过Limit选取部分结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># limited查询<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE condition(s)<br>ORDER BY column ASC/DESC<br>LIMIT num_limit OFFSET num_offset;<br></code></pre></td></tr></table></figure><p><code>LIMIT</code> 和 <code>OFFSET</code> 子句通常和<code>ORDER BY</code> 语句一起使用，当我们对整个结果集排序之后，我们可以 <code>LIMIT</code>来指定只返回多少行结果 ,用 <code>OFFSET</code>来指定从哪一行开始返回。你可以想象一下从一条长绳子剪下一小段的过程，我们通过 <code>OFFSET</code> 指定从哪里开始剪，用 <code>LIMIT</code> 指定剪下多少长度。</p><p>PS：num_offset 是从0开始的</p><h2 id="1-5-数据库范式"><a href="#1-5-数据库范式" class="headerlink" title="1.5 数据库范式"></a>1.5 数据库范式</h2><p>数据库范式是数据表设计的规范，在范式规范下，数据库里每个表存储的<strong>重复数据降到最少（这有助于数据的一致性维护）</strong>，同时在数据库范式下，表和表之间不再有很强的数据耦合，可以独立的增长 (ie. 比如汽车引擎的增长和汽车的增长是完全独立的). 范式带来了很多好处，但随着数据表的分离，意味着我们要查询多个数据属性时，需要更复杂的SQL语句，也就是本节开始介绍的多表连接技术。这样SQL的性能也会面临更多的挑战，特别是当大数据量的表很多的情况下。</p><p>如果一个实体（比如Dog）的属性数据被分散到多个数据表中，我们就需要学习如何通过 <code>JOIN</code>连表技术来整合这些数据并找到我们想要查询的数据项。</p><h2 id="1-6-用JOINs进行多表联合查询"><a href="#1-6-用JOINs进行多表联合查询" class="headerlink" title="1.6 用JOINs进行多表联合查询"></a>1.6 用JOINs进行多表联合查询</h2><p><code>主键(primary key)</code>, 一般关系数据表中，都会有一个属性列设置为 <code>主键(primary key)</code>。主键是唯一标识一条数据的，不会重复复（想象你的身份证号码)。一个最常见的主键就是auto-incrementing integer(自增ID，每写入一行数据ID+1, 当然字符串，hash值等只要是每条数据是唯一的也可以设为主键.</p><p>借助<code>主键(primary key)</code>（当然其他唯一性的属性也可以），我们可以把两个表中具有相同 主键ID的数据连接起来（因为一个ID可以简要的识别一条数据，所以连接之后还是表达的同一条数据）（你可以想象一个左右连线游戏）。具体我们用到 <code>JOIN</code> 关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">用LEFT/RIGHT/FULL JOINs 做多表查询<br>SELECT column, another_column, …<br>FROM mytable<br>INNER/LEFT/RIGHT/FULL JOIN another_table<br>    ON mytable.id = another_table.matching_id<br>WHERE condition(s)<br>ORDER BY column, … ASC/DESC<br>LIMIT num_limit OFFSET num_offset;<br></code></pre></td></tr></table></figure><p>PS：<code>INNER JOIN</code> 可以简写做 <code>JOIN</code>. 两者是相同的意思，但我们还是会继续写作 <code>INNER JOIN</code> 以便和后面的 <code>LEFT JOIN</code>， <code>RIGHT JOIN</code>等相比较。(内连接，左连接，右连接)</p><p>LEFT JOIN：左边的全部存在，右边的有缺失就NULL</p><p>RIGHT JOIN：右边的全部存在，左边的有缺失就NULL</p><h2 id="1-7-查询条件中处理NULL"><a href="#1-7-查询条件中处理NULL" class="headerlink" title="1.7 查询条件中处理NULL"></a>1.7 查询条件中处理NULL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 在查询条件中处理 NULL<br>SELECT column, another_column, …<br>FROM mytable<br>WHERE column IS/IS NOT NULL<br>AND/OR another_condition<br>AND/OR …;<br></code></pre></td></tr></table></figure><p>判断是否为NULL</p><h2 id="1-8-查询中使用表达式"><a href="#1-8-查询中使用表达式" class="headerlink" title="1.8 查询中使用表达式"></a>1.8 查询中使用表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 包含表达式的例子<br>SELECT  particle_speed / 2.0 AS half_particle_speed (对结果做了一个除2）<br>FROM physics_data<br>WHERE ABS(particle_position) * 10.0 &gt;500<br>            （条件要求这个属性绝对值乘以10大于500）;<br>         <br># AS使用别名<br>SELECT col_expression AS expr_description, …<br>FROM mytable;<br><br># 属性列和表取别名的例子<br>SELECT column AS better_column_name, …<br>FROM a_long_widgets_table_name AS mywidgets<br>INNER JOIN widget_sales<br>  ON mywidgets.id = widget_sales.widget_id;<br></code></pre></td></tr></table></figure><p><strong>e.g【难题】John Lasseter导演的每部电影每分钟值多少钱,告诉我最高的3个电影名和价值就可以</strong> </p><p>Table: Movies(Read - Only)</p><div class="table-container"><table><thead><tr><th>Id</th><th>Title</th><th>Director</th><th>Year</th><th>Length_minutes</th></tr></thead><tbody><tr><td>1</td><td>Toy Story</td><td>John Lasseter</td><td>1995</td><td>81</td></tr><tr><td>2</td><td>A Bug’s Life</td><td>John Lasseter</td><td>1998</td><td>95</td></tr><tr><td>3</td><td>Toy Story 2</td><td>John Lasseter</td><td>1999</td><td>93</td></tr><tr><td>4</td><td>Monsters, Inc.</td><td>Pete Docter</td><td>2001</td><td>92</td></tr><tr><td>5</td><td>Finding Nemo</td><td>Finding Nemo</td><td>2003</td><td>107</td></tr><tr><td>6</td><td>The Incredibles</td><td>Brad Bird</td><td>2004</td><td>116</td></tr><tr><td>7</td><td>Cars</td><td>John Lasseter</td><td>2006</td><td>117</td></tr><tr><td>8</td><td>Ratatouille</td><td>Brad Bird</td><td>2007</td><td>115</td></tr><tr><td>9</td><td>WALL-E</td><td>Andrew Stanton</td><td>2008</td><td>104</td></tr><tr><td>10</td><td>Up</td><td>Pete Docter</td><td>2009</td><td>101</td></tr><tr><td>11</td><td>Toy Story 3</td><td>Lee Unkrich</td><td>2010</td><td>103</td></tr><tr><td>12</td><td>Cars 2</td><td>John Lasseter</td><td>2011</td><td>120</td></tr><tr><td>13</td><td>Brave</td><td>Brenda Chapman</td><td>2012</td><td>102</td></tr><tr><td>14</td><td>Monsters University</td><td>Dan Scanlon</td><td>2013</td><td>110</td></tr></tbody></table></div><p>Table: Boxoffice(Read - Only)</p><div class="table-container"><table><thead><tr><th>Movie_id</th><th>Rating</th><th>Domestic_sales</th><th>International_sales</th></tr></thead><tbody><tr><td>5</td><td>8.2</td><td>380843261</td><td>555900000</td></tr><tr><td>14</td><td>7.4</td><td>268492764</td><td>475066843</td></tr><tr><td>8</td><td>8</td><td>206445654</td><td>417277164</td></tr><tr><td>12</td><td>6.4</td><td>191452396</td><td>368400000</td></tr><tr><td>3</td><td>7.9</td><td>245852179</td><td>239163000</td></tr><tr><td>6</td><td>8</td><td>261441092</td><td>370001000</td></tr><tr><td>9</td><td>8.5</td><td>223808164</td><td>297503696</td></tr><tr><td>11</td><td>8.4</td><td>415004880</td><td>648167031</td></tr><tr><td>1</td><td>8.3</td><td>191796233</td><td>170162503</td></tr><tr><td>7</td><td>7.2</td><td>244082982</td><td>217900167</td></tr><tr><td>10</td><td>8.3</td><td>293004164</td><td>438338580</td></tr><tr><td>4</td><td>8.1</td><td>289916256</td><td>272900000</td></tr><tr><td>2</td><td>7.2</td><td>162798565</td><td>200600000</td></tr><tr><td>13</td><td>7.2</td><td>237283207</td><td>301700000</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 输出变量，AS用来起别名<br>SELECT title, ((domestic_sales + international_sales) / length_minutes) AS sale_value FROM movies AS m<br><br># 内连接两个表，ON通过什么属性<br>INNER JOIN boxoffice AS b<br>ON m.id = b.movie_id<br><br># WHERE逻辑控制判断<br>WHERE director = &quot;John Lasseter&quot;<br><br># ORDER BY排序<br>ORDER BY sale_value DESC<br><br># LIMIT限制，OFFSET表示起始位置<br>LIMIT 3 <br></code></pre></td></tr></table></figure><h2 id="1-9-常见的统计函数"><a href="#1-9-常见的统计函数" class="headerlink" title="1.9 常见的统计函数"></a>1.9 常见的统计函数</h2><p>下面介绍几个常用统计函数:</p><div class="table-container"><table><thead><tr><th>Function</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td><strong>COUNT(<em>*</em></strong>)<strong>, </strong>COUNT(<strong><em>column</em></strong>)**</td><td style="text-align:left">计数！COUNT(*) 统计数据行数，COUNT(column) 统计column非NULL的行数。</td></tr><tr><td><strong>MIN(*</strong>column<strong>*)</strong></td><td style="text-align:left">找column最小的一行。</td></tr><tr><td><strong>MAX(*</strong>column<strong>*)</strong></td><td style="text-align:left">找column最大的一行。</td></tr><tr><td><strong>AVG(*</strong>column*)</td><td style="text-align:left">对column所有行取平均值。</td></tr><tr><td><strong>SUM(*</strong>column<strong>*)</strong></td><td style="text-align:left">对column所有行求和。</td></tr></tbody></table></div><p>分组统计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 用分组的方式统计，通过分组的方式对局部特征进行处理<br>SELECT AGG_FUNC(column_or_expression) AS aggregate_description, …<br>FROM mytable<br>WHERE constraint_expression<br>GROUP BY column;<br></code></pre></td></tr></table></figure><p>到目前为止，我们的Query查询已经有点复杂了，不过还好我们已经基本把查询语法介绍完了。在 <code>GROUP BY</code> 分组语法中，我们知道数据库是先对数据做<code>WHERE</code>，然后对结果做分组，如果我们要对分组完的数据再筛选出几条如何办？ （想一下按年份统计电影票房，要筛选出&gt;100万的年份？） </p><p>一个不常用的语法 <code>HAVING</code> 语法将用来解决这个问题，他可以对分组之后的数据再做SELECT筛选.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 用HAVING进行筛选，进行GROUP BY之后的二级分类<br>SELECT group_by_column, AGG_FUNC(column_expression) AS aggregate_result_alias, …<br>FROM mytable<br>WHERE condition<br>GROUP BY column<br>HAVING group_condition;<br></code></pre></td></tr></table></figure><p><strong>e.g【难题】按角色分组算出每个角色按有办公室和没办公室的统计人数(列出角色，数量，有无办公室,注意一个角色如果部分有办公室，部分没有需分开统计）</strong> </p><div class="table-container"><table><thead><tr><th>Role</th><th>Name</th><th>Building</th><th>Years_employed</th></tr></thead><tbody><tr><td>Engineer</td><td>Becky A.</td><td>1e</td><td>4</td></tr><tr><td>Engineer</td><td>Dan B.</td><td>1e</td><td>2</td></tr><tr><td>Engineer</td><td>Sharon F.</td><td>1e</td><td>6</td></tr><tr><td>Engineer</td><td>Dan M.</td><td>1e</td><td>4</td></tr><tr><td>Engineer</td><td>Malcom S.</td><td>1e</td><td>1</td></tr><tr><td>Artist</td><td>Tylar S.</td><td>2w</td><td>2</td></tr><tr><td>Artist</td><td>Sherman D.</td><td>2w</td><td>8</td></tr><tr><td>Artist</td><td>Jakob J.</td><td>2w</td><td>6</td></tr><tr><td>Artist</td><td>Lillia A.</td><td>2w</td><td>7</td></tr><tr><td>Artist</td><td>Brandon J.</td><td>2w</td><td>7</td></tr><tr><td>Manager</td><td>Scott K.</td><td>1e</td><td>9</td></tr><tr><td>Manager</td><td>Shirlee M.</td><td>1e</td><td>3</td></tr><tr><td>Manager</td><td>Daria O.</td><td>2w</td><td>6</td></tr><tr><td>Engineer</td><td>Yancy I.</td><td>null</td><td>0</td></tr><tr><td>Artist</td><td>Oliver P.</td><td>null</td><td>0</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT count(*) as count,Role,building is not null as have_building<br>FROM employees <br>group by Role,building is not null<br></code></pre></td></tr></table></figure><p>这里学到了GROUP BY可以进行二级分类。</p><h2 id="1-10-总结"><a href="#1-10-总结" class="headerlink" title="1.10 总结"></a>1.10 总结</h2><p>集合所有的查询相关的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 这才是完整的SELECT查询<br>SELECT DISTINCT column, AGG_FUNC(column_or_expression), …<br>FROM mytable<br>    JOIN another_table<br>      ON mytable.column = another_table.column<br>    WHERE constraint_expression<br>    GROUP BY column<br>    HAVING constraint_expression<br>    ORDER BY column ASC/DESC<br>    LIMIT count OFFSET COUNT;<br></code></pre></td></tr></table></figure><p>一个查询SQL的执行总是先从数据里按条件选出数据，然后对这些数据再次做一些整理处理，按要求返回成结果，让结果尽可能是简单直接的。因为一个查询SQL由很多部分组成，所以搞清楚这些部分的执行顺序还挺重要的，这有助于我们更深刻的理解SQL执行过程。</p><p><strong>‼️查询执行顺序</strong></p><h3 id="1-FROM-和-JOINs"><a href="#1-FROM-和-JOINs" class="headerlink" title="1. FROM 和 JOINs"></a>1. <code>FROM</code> 和 <code>JOIN</code>s</h3><p><code>FROM</code> 或 <code>JOIN</code>会第一个执行，确定一个整体的数据范围. 如果要JOIN不同表，可能会生成一个临时Table来用于 下面的过程。总之第一步可以简单理解为确定一个数据源表（含临时表)</p><h3 id="2-WHERE"><a href="#2-WHERE" class="headerlink" title="2. WHERE"></a>2. <code>WHERE</code></h3><p>我们确定了数据来源 <code>WHERE</code> 语句就将在这个数据源中按要求进行数据筛选，并丢弃不符合要求的数据行，所有的筛选col属性 只能来自<code>FROM</code>圈定的表. AS别名还不能在这个阶段使用，因为可能别名是一个还没执行的表达式</p><h3 id="3-GROUP-BY"><a href="#3-GROUP-BY" class="headerlink" title="3. GROUP BY"></a>3. <code>GROUP BY</code></h3><p>如果你用了 <code>GROUP BY</code> 分组，那<code>GROUP BY</code> 将对之前的数据进行分组，统计等，并将是结果集缩小为分组数.这意味着 其他的数据在分组后丢弃.</p><h3 id="4-HAVING"><a href="#4-HAVING" class="headerlink" title="4. HAVING"></a>4. <code>HAVING</code></h3><p>如果你用了 <code>GROUP BY</code> 分组, <code>HAVING</code> 会在分组完成后对结果集再次筛选。AS别名也不能在这个阶段使用.</p><h3 id="5-SELECT"><a href="#5-SELECT" class="headerlink" title="5. SELECT"></a>5. <code>SELECT</code></h3><p>确定结果之后，<code>SELECT</code>用来对结果col简单筛选或计算，决定输出什么数据.</p><h3 id="6-DISTINCT"><a href="#6-DISTINCT" class="headerlink" title="6. DISTINCT"></a>6. <code>DISTINCT</code></h3><p>如果数据行有重复<code>DISTINCT</code> 将负责排重.</p><h3 id="7-ORDER-BY"><a href="#7-ORDER-BY" class="headerlink" title="7. ORDER BY"></a>7. <code>ORDER BY</code></h3><p>在结果集确定的情况下，<code>ORDER BY</code> 对结果做排序。因为<code>SELECT</code>中的表达式已经执行完了。此时可以用AS别名.</p><h3 id="8-LIMIT-OFFSET"><a href="#8-LIMIT-OFFSET" class="headerlink" title="8. LIMIT / OFFSET"></a>8. <code>LIMIT</code> / <code>OFFSET</code></h3><p>最后 <code>LIMIT</code> 和 <code>OFFSET</code> 从排序的结果中截取部分数据.</p><p><strong>结论</strong></p><p>不是每一个SQL语句都要用到所有的句法，但灵活运用以上的句法组合和深刻理解SQL执行原理将能在SQL层面更好的解决数据问题，而不用把问题 都抛给程序逻辑.</p><p>Table：Movies(Read - Only)</p><div class="table-container"><table><thead><tr><th>Id</th><th>Title</th><th>Director</th><th>Year</th><th>Length_minutes</th></tr></thead><tbody><tr><td>1</td><td>Toy Story</td><td>John Lasseter</td><td>1995</td><td>81</td></tr><tr><td>2</td><td>A Bug’s Life</td><td>John Lasseter</td><td>1998</td><td>95</td></tr><tr><td>3</td><td>Toy Story 2</td><td>John Lasseter</td><td>1999</td><td>93</td></tr><tr><td>4</td><td>Monsters, Inc.</td><td>Pete Docter</td><td>2001</td><td>92</td></tr><tr><td>5</td><td>Finding Nemo</td><td>Finding Nemo</td><td>2003</td><td>107</td></tr><tr><td>6</td><td>The Incredibles</td><td>Brad Bird</td><td>2004</td><td>116</td></tr><tr><td>7</td><td>Cars</td><td>John Lasseter</td><td>2006</td><td>117</td></tr><tr><td>8</td><td>Ratatouille</td><td>Brad Bird</td><td>2007</td><td>115</td></tr><tr><td>9</td><td>WALL-E</td><td>Andrew Stanton</td><td>2008</td><td>104</td></tr><tr><td>10</td><td>Up</td><td>Pete Docter</td><td>2009</td><td>101</td></tr><tr><td>11</td><td>Toy Story 3</td><td>Lee Unkrich</td><td>2010</td><td>103</td></tr><tr><td>12</td><td>Cars 2</td><td>John Lasseter</td><td>2011</td><td>120</td></tr><tr><td>13</td><td>Brave</td><td>Brenda Chapman</td><td>2012</td><td>102</td></tr><tr><td>14</td><td>Monsters University</td><td>Dan Scanlon</td><td>2013</td><td>110</td></tr></tbody></table></div><p>Table：Boxoffice(Read - Only)</p><div class="table-container"><table><thead><tr><th>Movie_id</th><th>Rating</th><th>Domestic_sales</th><th>International_sales</th></tr></thead><tbody><tr><td>5</td><td>8.2</td><td>380843261</td><td>555900000</td></tr><tr><td>14</td><td>7.4</td><td>268492764</td><td>475066843</td></tr><tr><td>8</td><td>8</td><td>206445654</td><td>417277164</td></tr><tr><td>12</td><td>6.4</td><td>191452396</td><td>368400000</td></tr><tr><td>3</td><td>7.9</td><td>245852179</td><td>239163000</td></tr><tr><td>6</td><td>8</td><td>261441092</td><td>370001000</td></tr><tr><td>9</td><td>8.5</td><td>223808164</td><td>297503696</td></tr><tr><td>11</td><td>8.4</td><td>415004880</td><td>648167031</td></tr><tr><td>1</td><td>8.3</td><td>191796233</td><td>170162503</td></tr><tr><td>7</td><td>7.2</td><td>244082982</td><td>217900167</td></tr><tr><td>10</td><td>8.3</td><td>293004164</td><td>438338580</td></tr><tr><td>4</td><td>8.1</td><td>289916256</td><td>272900000</td></tr><tr><td>2</td><td>7.2</td><td>162798565</td><td>200600000</td></tr><tr><td>13</td><td>7.2</td><td>237283207</td><td>301700000</td></tr></tbody></table></div><p><strong>e.g【难题】按导演分组计算销售总额,求出平均销售额冠军（统计结果过滤掉只有单部电影的导演，列出导演名，总销量，电影数量，平均销量) </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(domestic_sales + international_sales) sum_sale, director,COUNT(*) count, AVG(domestic_sales + international_sales) ave_sale FROM movies m<br>INNER JOIN boxoffice b<br>ON m.id = b.movie_id<br>GROUP BY director<br>HAVING count != 1<br>ORDER BY ave_sale DESC<br>LIMIT 1<br></code></pre></td></tr></table></figure><p><strong>Q：</strong>为什么where里面不能count()而having里面可以</p><p><strong>A：</strong>因为聚合函数是做统计用的，所有的聚合方式使用都是，函数名(字段) 对这一个字段进行聚合。但在mysql内部运行机制中，where后面还没有结果，只有select后面才有结果集。所以聚合函数是不能放在where后面,却可以放在select后面。</p><p><strong>e.g【变态难】找出每部电影和单部电影销售冠军之间的销售差，列出电影名，销售额差额</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT title,<br>(SELECT (Domestic_sales + International_sales) FROM movies m<br>JOIN boxoffice b<br>ON m.id = b.movie_id <br>ORDER BY(Domestic_sales+<br>International_sales) DESC <br>LIMIT 1)<br>  - (Domestic_sales+International_sales) as sale_diff<br>FROM movies m<br>LEFT JOIN boxoffice b<br>ON m.id = b.movie_id <br>ORDER BY sale_diff DESC<br></code></pre></td></tr></table></figure><p>SELECT是可以嵌套的，SELECT是输出的表达式。</p><h1 id="二-数据库基本性质"><a href="#二-数据库基本性质" class="headerlink" title="二. 数据库基本性质"></a>二. 数据库基本性质</h1><h2 id="1-事务（Transaction）"><a href="#1-事务（Transaction）" class="headerlink" title="1. 事务（Transaction）"></a>1. 事务（Transaction）</h2><p>概念：是由一组SQL语句组成的一个程序执行单元（Unit），它需要满足ACID特性。<br><strong>ACID：</strong><br>原子性（Atomicity）：事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。\<br>一致性（Consistency）：数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。\<br>隔离性（Isolation）：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其他事务运行结果。\<br>持久性（Durability）：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p><p><strong>Redo Log（重做日志）：</strong></p><p>Redo Log记录的是物理日志，也就是磁盘数据的修改。<br>用来保证服务崩溃后，仍能把事务中变更的数据持久化到磁盘上。 </p><p>如果没有Redo Log的话，会发生什么？ </p><p>修改数据的过程就变成这样了： </p><ol><li>从磁盘加载数据到内存 </li><li>在内存中修改数据 </li><li>把新数据持久化到磁盘</li></ol><p><img src="https://uploadfiles.nowcoder.com/images/20220623/662287616_1655986216392/66115853BADB7271963A156CA74C77C4" alt="img"></p><p>这样做，会有严重的性能问题。 </p><ol><li>InnoDB在磁盘中存储的基本单元是页，可能本次修改只变更一页中几个字节，但是需要刷新整页的数据，就很浪费资源。 </li><li>一个事务可能修改了多页中的数据，页之间又是不连续的，就会产生随机IO，性能更差。 </li></ol><p>所以为了提高写入性能，于是就引入了Redo Log。 </p><p>看一下引入Redo Log后修改流程： </p><ol><li>从磁盘加载数据到内存 </li><li>在内存中修改数据 </li><li>把新数据写到<strong>Redo Log Buffer</strong>中 </li><li>把<strong>Redo Log Buffer</strong>中数据持久化到<strong>Redo Log</strong>文件中 </li><li>把<strong>Redo Log</strong>文件中数据持久化到数据库磁盘中</li></ol><p><img src="https://uploadfiles.nowcoder.com/images/20220623/662287616_1655986226028/5708D19E4669F6A45620337CF900C548" alt="img"></p><p><strong>Undo Log（回滚日志）：</strong></p><p>Undo Log记录的是逻辑日志，用来回滚事务时，恢复到修改前的数据。 </p><p>比如：当我们执行一条insert语句时，Undo Log就记录一条相反的delete语句。 </p><p>加入Undo Log之后的修改流程就是这样的：</p><p><img src="https://uploadfiles.nowcoder.com/images/20220623/662287616_1655986232575/816A79F9839780944D5BE8A640D681F2" alt="img"></p><p><strong>MVCC（多版本并发控制，Multi-Version Concurrency Control）：</strong></p><p>记录的是某个时间点上的数据快照，用来实现不同事务之间数据的隔离性。 </p><p>提到隔离性，一定要说一下事务的隔离级别。 </p><p>说事务隔离级别之前，必须要先说一下并发事务产生的问题： </p><p><strong>脏读：</strong> 一个事务读到其他事务未提交的数据。 </p><p><strong>不可重复读：</strong> 多次读取相同的数据，得到的结果集不一致，即读到其他事务提交后的数据。 </p><p><strong>幻读：</strong> 相同的查询条件，多次读取的结果不一致，即读到其他事务提交后的数据。 </p><p><strong>不可重复读与幻读的区别是：</strong> 不可重复读是读到了其他事务执行update、delete后的数据，而幻读是读到其他事务执行insert后的数据。 </p><p><strong>隔离级别</strong></p><p><strong>Read UnCommitted（读未提交）：</strong> 读到其他事务未提交的数据，会出现脏读、不可重复读、幻读。 </p><p><strong>Read Committed（读已提交）：</strong> 读到其他事务已提交的数据，解决了脏读，会出现不可重复读、幻读。 </p><p><strong>Repeatable Read（可重复读）：</strong> 相同的数据，多次读取到的结果集一致。解决了不可重复读，还是会出现幻读。 </p><p><strong>Serializable（串行化）：</strong> 所有事务串行执行，解决了幻读。 </p><p>再谈MVCC： </p><p>MVCC解决了读写冲突，实现了读写并行，提升了事务的性能。 </p><p>由于Read UnCommitted隔离级别下，每次都读取最新的数据。而Serializable隔离级别下，对所有读取数据都加锁。这两种隔离级不需要MVCC，所以MVCC只在Read Committed和Repeatable Read两种隔离级别下起作用。 </p><p>MVCC的实现方式通过两个隐藏列trx_id（最近一次提交事务的ID）和roll_pointer（上个版本的地址），建立一个版本链。并在事务中读取的时候生成一个ReadView（读视图），在Read Committed隔离级别下，每次读取都会生成一个读视图，而在Repeatable Read隔离级别下，只会在第一次读取时生成一个读视图。 </p><p>因为<strong>可重复读</strong>直接在开启事务的时候就锁住了某一行，别的人根本读不了，所以就生成一个读视图，来记录他的修改。</p><p><img src="https://uploadfiles.nowcoder.com/images/20220623/662287616_1655986240370/3D78F006E535818D637B7C33BADB13AB" alt="img"></p><p>InnoDB如何解决幻读的？ </p><p>先普及一下快照读和当前读。 </p><p><strong>当前读：</strong> 读取数据的最新版本，并对数据进行加锁。 </p><p>例如：insert、update、delete、select for update </p><p><strong>快照读：</strong> 读取数据的历史版本，不对数据加锁。 </p><p>例如：select </p><p>在当前读的情况下，是通过加锁来解决幻读。 </p><p>在快照读的情况下，是通过MVCC来解决幻读。</p><h2 id="2-并发一致性问题"><a href="#2-并发一致性问题" class="headerlink" title="2. 并发一致性问题"></a>2. 并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h3 id="2-1-丢失修改"><a href="#2-1-丢失修改" class="headerlink" title="2.1 丢失修改"></a>2.1 丢失修改</h3><p>T1事务和T2事务同时进行更新操作同一个数据，T1在前，T2在后，T2的修改覆盖了T1的修改。</p><h3 id="2-2-读脏数据"><a href="#2-2-读脏数据" class="headerlink" title="2.2 读脏数据"></a>2.2 读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><h3 id="2-3-不可重复读"><a href="#2-3-不可重复读" class="headerlink" title="2.3 不可重复读"></a>2.3 不可重复读</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h3 id="2-4-幻读"><a href="#2-4-幻读" class="headerlink" title="2.4 幻读"></a>2.4 幻读</h3><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。与不可重复读不同的是，前者是读了更新的数据内容，后者是读了更新的数据项</p><h2 id="3-封锁"><a href="#3-封锁" class="headerlink" title="3. 封锁"></a>3. 封锁</h2><h3 id="3-1-封锁类型"><a href="#3-1-封锁类型" class="headerlink" title="3.1 封锁类型"></a>3.1 封锁类型</h3><h4 id="3-1-1-读写锁"><a href="#3-1-1-读写锁" class="headerlink" title="3.1.1 读写锁"></a>3.1.1 读写锁</h4><ul><li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。<br>有两个规定：<br>1）T 拿到 X 锁的时候，其他的读写数据的请求都要隔离。<br>2）T 拿到 S 锁的时候，其他的更新数据的请求都要隔离。</li></ul><p>XS锁兼容关系<br>|      | X    | S    |<br>| —— | —— | —— |<br>| X    | ❌    | ❌    |<br>| S    | ❌    | ✅    |</p><h4 id="3-1-2-意向锁"><a href="#3-1-2-意向锁" class="headerlink" title="3.1.2 意向锁"></a>3.1.2 意向锁</h4><p>在T对数据加入X锁或者S锁之前要拿到意向锁，确认没有别的事务对数据表和某行数据进行操作意向。</p><h2 id="4-隔离级别"><a href="#4-隔离级别" class="headerlink" title="4. 隔离级别"></a>4. 隔离级别</h2><h3 id="4-1-未提交读（READ-UNCOMMITTED）"><a href="#4-1-未提交读（READ-UNCOMMITTED）" class="headerlink" title="4.1 未提交读（READ UNCOMMITTED）"></a>4.1 未提交读（READ UNCOMMITTED）</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h3 id="4-2-提交读（READ-COMMITTED）"><a href="#4-2-提交读（READ-COMMITTED）" class="headerlink" title="4.2 提交读（READ COMMITTED）"></a>4.2 提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。解决脏读。</p><h3 id="4-3-可重复读（REPEATABLE-READ）"><a href="#4-3-可重复读（REPEATABLE-READ）" class="headerlink" title="4.3 可重复读（REPEATABLE READ）"></a>4.3 可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。解决不可重复读，脏读。</p><h3 id="4-4-可序列化（SERIALIZABLE）"><a href="#4-4-可序列化（SERIALIZABLE）" class="headerlink" title="4.4 可序列化（SERIALIZABLE）"></a>4.4 可序列化（SERIALIZABLE）</h3><p>强制事务串行的执行，并且通过锁来规定同一时间执行的事务只有一个，规定好了执行的秩序。解决脏读、不可重复读、幻读。</p><p>隔离级别能解决的并发一致性问题</p><div class="table-container"><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>提交读</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>可重复读</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>可序列化</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table></div><h2 id="5-多版本并发控制MVCC"><a href="#5-多版本并发控制MVCC" class="headerlink" title="5. 多版本并发控制MVCC"></a>5. 多版本并发控制MVCC</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><p><strong>MVCC</strong>(Multi Version Concurrency Control的简称)，代表<strong>多版本并发控制</strong>。</p><p>MVCC最大的优势：<strong>读不加锁，读写不冲突</strong>。读写不冲突是非常重要的，极大的增加了系统的并发性能。<strong>MVCC机制也是乐观锁的一种体现。</strong></p><p><strong>基本思想</strong></p><p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p><p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p><p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p><h1 id="三-数据库的原理"><a href="#三-数据库的原理" class="headerlink" title="三. 数据库的原理"></a>三. 数据库的原理</h1><h2 id="一、索引优化"><a href="#一、索引优化" class="headerlink" title="一、索引优化"></a>一、索引优化</h2><h3 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;<br></code></pre></td></tr></table></figure><h3 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT film_id, actor_ id FROM sakila.film_actor<br>WHERE actor_id = 1 AND film_id = 1;<br></code></pre></td></tr></table></figure><h3 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,<br>COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,<br>COUNT(*)<br>FROM payment;<br>   staff_id_selectivity: 0.0001<br>customer_id_selectivity: 0.0373<br>               COUNT(*): 16049<br></code></pre></td></tr></table></figure><h3 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引</li></ul><h2 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h2><h3 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有：</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><h4 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h4><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><p><strong>准确自己查询的内容！</strong></p><h4 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h4><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="三、重构查询方式"><a href="#三、重构查询方式" class="headerlink" title="三、重构查询方式"></a>三、重构查询方式</h2><h3 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> messages <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">create</span> &lt; DATE_SUB(NOW(), INTERVAL <span class="hljs-number">3</span> MONTH);<br>rows_affected = 0<br>do &#123;<br>    rows_affected = do_query(<br>    &quot;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> messages <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">create</span>  &lt; DATE_SUB(NOW(), INTERVAL <span class="hljs-number">3</span> MONTH) <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10000</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">&#125; while rows_affected &gt; 0</span><br></code></pre></td></tr></table></figure><h3 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM tag<br>JOIN tag_post ON tag_post.tag_id=tag.id<br>JOIN post ON tag_post.post_id=post.id<br>WHERE tag.tag=&#x27;mysql&#x27;;<br>SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;<br>SELECT * FROM tag_post WHERE tag_id=1234;<br>SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>0、如果语句是<code>select * from T where ID=500</code>，即<strong>主键查询</strong>方式，则只需要搜索ID这棵B+树；</p><p>如果语句是<code>select * from T where k=5</code>，即<strong>普通索引</strong>查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</p><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><p>1、能多列索引就多列索引</p><p>2、把选择性高的放前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>3、索引使用条件：</p><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><h1 id="四、基础篇"><a href="#四、基础篇" class="headerlink" title="四、基础篇"></a>四、基础篇</h1><h2 id="通用语法及分类"><a href="#通用语法及分类" class="headerlink" title="通用语法及分类"></a>通用语法及分类</h2><ul><li>DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）</li><li>DML: 数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL: 数据查询语言，用来查询数据库中表的记录</li><li>DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><h3 id="DDL（数据定义语言）"><a href="#DDL（数据定义语言）" class="headerlink" title="DDL（数据定义语言）"></a>DDL（数据定义语言）</h3><p>数据定义语言</p><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><p>查询所有数据库：<br><code>SHOW DATABASES;</code><br>查询当前数据库：<br><code>SELECT DATABASE();</code><br>创建数据库：<br><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code><br>删除数据库：<br><code>DROP DATABASE [ IF EXISTS ] 数据库名;</code><br>使用数据库：<br><code>USE 数据库名;</code></p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</li></ul><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><p>查询当前数据库所有表：<br><code>SHOW TABLES;</code><br>查询表结构：<br><code>DESC 表名;</code><br>查询指定表的建表语句：<br><code>SHOW CREATE TABLE 表名;</code></p><p>创建表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段1 字段1类型 [COMMENT 字段1注释],<br>字段2 字段2类型 [COMMENT 字段2注释],<br>字段3 字段3类型 [COMMENT 字段3注释],<br>...<br>字段n 字段n类型 [COMMENT 字段n注释]<br>)[ COMMENT 表注释 ];<br></code></pre></td></tr></table></figure><p><strong>最后一个字段后面没有逗号</strong></p><p>添加字段：<br><code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：<code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></p><p>修改数据类型：<br><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code><br>修改字段名和字段类型：<br><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：将emp表的nickname字段修改为username，类型为varchar(30)<br><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></p><p>删除字段：<br><code>ALTER TABLE 表名 DROP 字段名;</code></p><p>修改表名：<br><code>ALTER TABLE 表名 RENAME TO 新表名</code></p><p>删除表：<br><code>DROP TABLE [IF EXISTS] 表名;</code><br>删除表，并重新创建该表：<br><code>TRUNCATE TABLE 表名;</code></p><h3 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>指定字段：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code><br>全部字段：<br><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></p><p>批量添加数据：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code><br><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></p><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li></ul><h4 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h4><p>修改数据：<br><code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code><br>例：<br><code>UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1;</code></p><p>删除数据：<br><code>DELETE FROM 表名 [ WHERE 条件 ];</code></p><h3 id="DQL（数据查询语言）"><a href="#DQL（数据查询语言）" class="headerlink" title="DQL（数据查询语言）"></a>DQL（数据查询语言）</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>字段列表<br>FROM<br>表名字段<br>WHERE<br>条件列表<br>GROUP BY<br>分组字段列表<br>HAVING<br>分组后的条件列表<br>ORDER BY<br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></table></figure><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><p>查询多个字段：<br><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名;</code><br><code>SELECT * FROM 表名;</code></p><p>设置别名：<br><code>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;</code><br><code>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</code></p><p>去除重复记录：<br><code>SELECT DISTINCT 字段列表 FROM 表名;</code></p><p>转义：<br><code>SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;</code><br>/ 之后的_不作为通配符</p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></p><p>条件：</p><div class="table-container"><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !=</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 &#124;&#124;</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr></tbody></table></div><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 年龄等于30<br>select * from employee where age = 30;<br>-- 年龄小于30<br>select * from employee where age &lt; 30;<br>-- 小于等于<br>select * from employee where age &lt;= 30;<br>-- 没有身份证<br>select * from employee where idcard is null or idcard = &#x27;&#x27;;<br>-- 有身份证<br>select * from employee where idcard;<br>select * from employee where idcard is not null;<br>-- 不等于<br>select * from employee where age != 30;<br>-- 年龄在20到30之间<br>select * from employee where age between 20 and 30;<br>select * from employee where age &gt;= 20 and age &lt;= 30;<br>-- 下面语句不报错，但查不到任何信息<br>select * from employee where age between 30 and 20;<br>-- 性别为女且年龄小于30<br>select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;<br>-- 年龄等于25或30或35<br>select * from employee where age = 25 or age = 30 or age = 35;<br>select * from employee where age in (25, 30, 35);<br>-- 姓名为两个字<br>select * from employee where name like &#x27;__&#x27;;<br>-- 身份证最后为X<br>select * from employee where idcard like &#x27;%X&#x27;;<br></code></pre></td></tr></table></figure><h4 id="聚合查询（聚合函数）"><a href="#聚合查询（聚合函数）" class="headerlink" title="聚合查询（聚合函数）"></a>聚合查询（聚合函数）</h4><p>常见聚合函数：</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table></div><p>语法：<br><code>SELECT 聚合函数(字段列表) FROM 表名;</code><br>例：<br><code>SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</code></p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></p><p>where 和 having 的区别：</p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）<br>select count(*) from employee group by gender;<br>-- 根据性别分组，统计男性和女性数量<br>select gender, count(*) from employee group by gender;<br>-- 根据性别分组，统计男性和女性的平均年龄<br>select gender, avg(age) from employee group by gender;<br>-- 年龄小于45，并根据工作地址分组<br>select workaddress, count(*) from employee where age &lt; 45 group by workaddress;<br>-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址<br>select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;<br></code></pre></td></tr></table></figure><h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></p><p>排序方式：</p><ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 根据年龄升序排序<br>SELECT * FROM employee ORDER BY age ASC;<br>SELECT * FROM employee ORDER BY age;<br>-- 两字段排序，根据年龄升序排序，入职时间降序排序<br>SELECT * FROM employee ORDER BY age ASC, entrydate DESC;<br></code></pre></td></tr></table></figure><h5 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h5><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询第一页数据，展示10条<br>SELECT * FROM employee LIMIT 0, 10;<br>-- 查询第二页<br>SELECT * FROM employee LIMIT 10, 10;<br></code></pre></td></tr></table></figure><h5 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><h4 id="DQL执行顺序"><a href="#DQL执行顺序" class="headerlink" title="DQL执行顺序"></a>DQL执行顺序</h4><p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><p>查询用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">USER mysql;<br>SELECT * FROM user;<br></code></pre></td></tr></table></figure><p>创建用户:<br><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></p><p>修改用户密码：<br><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code></p><p>删除用户：<br><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建用户test，只能在当前主机localhost访问<br>create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;<br>-- 创建用户test，能在任意主机访问<br>create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;<br>create user &#x27;test&#x27; identified by &#x27;123456&#x27;;<br>-- 修改密码<br>alter user &#x27;test&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;1234&#x27;;<br>-- 删除用户<br>drop user &#x27;test&#x27;@&#x27;localhost&#x27;;<br></code></pre></td></tr></table></figure><h5 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>主机名可以使用 % 通配</li></ul><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>常用权限：</p><div class="table-container"><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table></div><p>更多权限请看<a href="#权限一览表" title="权限一览表">权限一览表</a></p><p>查询权限：<br><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p><p>授予权限：<br><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></p><p>撤销权限：<br><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></p><h5 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>常用函数：</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table></div><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 拼接<br>SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);<br>-- 小写<br>SELECT LOWER(&#x27;Hello&#x27;);<br>-- 大写<br>SELECT UPPER(&#x27;Hello&#x27;);<br>-- 左填充<br>SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);<br>-- 右填充<br>SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);<br>-- 去除空格<br>SELECT TRIM(&#x27; Hello World &#x27;);<br>-- 切片（起始索引为1）<br>SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5);<br></code></pre></td></tr></table></figure><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>常见函数：</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x, y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x, y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table></div><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>常用函数：</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table></div><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- DATE_ADD<br>SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);<br></code></pre></td></tr></table></figure><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p>常用函数：</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table></div><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>name,<br>(case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)<br>from employee;<br>select<br>name,<br>(case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;<br>from employee;<br></code></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>分类：</p><div class="table-container"><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.1版本后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table></div><p>约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。</p><h3 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h3><div class="table-container"><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table></div><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table user(<br>id int primary key auto_increment,<br>name varchar(10) not null unique,<br>age int check(age &gt; 0 and age &lt; 120),<br>status char(1) default &#x27;1&#x27;,<br>gender char(1)<br>);<br></code></pre></td></tr></table></figure><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>添加外键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段名 字段类型,<br>...<br>[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)<br>);<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);<br><br>-- 例子<br>alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);<br></code></pre></td></tr></table></figure><p>删除外键：<br><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p><h4 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除/更新行为"></a>删除/更新行为</h4><div class="table-container"><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td></tr><tr><td>SET NULL</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table></div><p>更改删除/更新行为：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在<strong>多的</strong>一方建立外键，指向一的一方的主键</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：<strong>建立第三张中间表</strong>，中间表至少包含两个外键，分别关联两方主键</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：<strong>在任意一方加入外键</strong>，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>合并查询（笛卡尔积，会展示所有组合结果）：<br><code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积：<br><code>select * from employee, dept where employee.dept = dept.id;</code></p><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><p>内连接查询的是两张表交集的部分</p><p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p><p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p><p>显式性能比隐式高</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工姓名，及关联的部门的名称<br>-- 隐式<br>select e.name, d.name from employee as e, dept as d where e.dept = d.id;<br>-- 显式<br>select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;<br></code></pre></td></tr></table></figure><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>左外连接：<br>查询左表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code><br>相当于查询表1的所有数据，包含表1和表2交集部分数据</p><p>右外连接：<br>查询右表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 左<br>select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;<br>select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样<br>-- 右<br>select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;<br></code></pre></td></tr></table></figure><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h3 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h3><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法：<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工及其所属领导的名字<br>select a.name, b.name from employee a, employee b where a.manager = b.id;<br>-- 没有领导的也查询出来<br>select a.name, b.name from employee a left join employee b on a.manager = b.id;<br></code></pre></td></tr></table></figure><h3 id="联合查询-union-union-all"><a href="#联合查询-union-union-all" class="headerlink" title="联合查询 union, union all"></a>联合查询 union, union all</h3><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表A ...<br>UNION [ALL]<br>SELECT 字段列表 FROM 表B ...<br></code></pre></td></tr></table></figure><h4 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>UNION ALL 会有重复结果，UNION 不会</li><li><strong>联合查询</strong>比使用or效率高，不会使索引失效</li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。<br><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code><br><strong>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;=</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部所有员工<br>select id from dept where name = &#x27;销售部&#x27;;<br>-- 根据销售部部门ID，查询员工信息<br>select * from employee where dept = 4;<br>-- 合并（子查询）<br>select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);<br><br>-- 查询xxx入职之后的员工信息<br>select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;);<br></code></pre></td></tr></table></figure><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><div class="table-container"><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table></div><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部和市场部的所有员工信息<br>select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);<br>-- 查询比财务部所有人工资都高的员工信息<br>select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));<br>-- 查询比研发部任意一人工资高的员工信息<br>select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;));<br></code></pre></td></tr></table></figure><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>返回的结果是一行（可以是多列）。<br>常用操作符：=, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询与xxx的薪资及直属领导相同的员工信息<br>select * from employee where (salary, manager) = (12500, 1);<br>select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;);<br></code></pre></td></tr></table></figure><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>返回的结果是多行多列<br>常用操作符：IN</p><p>满足IN中其中一条就可以查询到结果</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询与xxx1，xxx2的职位和薪资相同的员工<br>select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);<br>-- 查询入职日期是2006-01-01之后的员工，及其部门信息<br>select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id;<br></code></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 1. 查询张三账户余额<br>select * from account where name = &#x27;张三&#x27;;<br>-- 2. 将张三账户余额-1000<br>update account set money = money - 1000 where name = &#x27;张三&#x27;;<br>-- 此语句出错后张三钱减少但是李四钱没有增加<br>模拟sql语句错误<br>-- 3. 将李四账户余额+1000<br>update account set money = money + 1000 where name = &#x27;李四&#x27;;<br><br>-- 查看事务提交方式<br>SELECT @@AUTOCOMMIT;<br>-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效<br>SET @@AUTOCOMMIT = 0;<br>-- 提交事务<br>COMMIT;<br>-- 回滚事务<br>ROLLBACK;<br><br>-- 设置手动提交后上面代码改为：<br>select * from account where name = &#x27;张三&#x27;;<br>update account set money = money - 1000 where name = &#x27;张三&#x27;;<br>update account set money = money + 1000 where name = &#x27;李四&#x27;;<br>commit;<br></code></pre></td></tr></table></figure><p>操作方式二：</p><p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：<br><code>ROLLBACK;</code></p><p>操作实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction;<br>select * from account where name = &#x27;张三&#x27;;<br>update account set money = money - 1000 where name = &#x27;张三&#x27;;<br>update account set money = money + 1000 where name = &#x27;李四&#x27;;<br>commit;<br></code></pre></td></tr></table></figure><h3 id="四大特性ACID"><a href="#四大特性ACID" class="headerlink" title="四大特性ACID"></a>四大特性ACID</h3><ul><li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><div class="table-container"><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table></div><blockquote><p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a> </p></blockquote><p>并发事务隔离级别：</p><div class="table-container"><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table></div><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：<br><code>SELECT @@TRANSACTION_ISOLATION;</code><br>设置事务隔离级别：<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code><br>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h1 id="五、进阶篇"><a href="#五、进阶篇" class="headerlink" title="五、进阶篇"></a>五、进阶篇</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL体系结构：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/MySQL体系结构_20220315034329549927.png" alt="结构图" title="结构图"><br><img src="https://dhc.pythonanywhere.com/media/editor/MySQL体系结构层级含义_20220315034359342837.png" alt="层级描述" title="层级描述"></p><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>默认存储引擎是InnoDB。</p><p>相关操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询建表语句<br>show create table account;<br>-- 建表时指定存储引擎<br>CREATE TABLE 表名(<br>...<br>) ENGINE=INNODB;<br>-- 查看当前数据库支持的存储引擎<br>show engines;<br></code></pre></td></tr></table></figure><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：<br><code>show variables like &#39;innodb_file_per_table&#39;;</code></p><p>从idb文件提取表结构数据：<br>（在cmd运行）<br><code>ibd2sdi xxx.ibd</code></p><p>InnoDB 逻辑存储结构：<br><img src="https://dhc.pythonanywhere.com/media/editor/逻辑存储结构_20220316030616590001.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><p><strong>行</strong>就是一行数据，<strong>页</strong>就是数据表，<strong>区</strong>就是一个数据库，<strong>段</strong>就是多个数据库</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><div class="table-container"><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table></div><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code> 或者 <code>SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code><br>例：<code>show global status like &#39;Com_______&#39;</code></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p><div class="code-wrapper"><pre><code class="hljs"># 开启慢查询日志开关slow_query_log=1# 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2</code></pre></div><p>更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log</p><p>查看慢查询日志开关状态：<br><code>show variables like &#39;slow_query_log&#39;;</code></p><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code><br>profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：<br><code>SET profiling = 1;</code><br>查看所有语句的耗时：<br><code>show profiles;</code><br>查看指定query_id的SQL语句各个阶段的耗时：<br><code>show profile for query query_id;</code><br>查看指定query_id的SQL语句CPU的使用情况<br><code>show profile cpu for query query_id;</code></p><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：</p><div class="code-wrapper"><pre><code class="hljs"># 直接在select语句之前加上关键字 explain / descEXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</code></pre></div><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><div class="table-container"><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table></div><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p><img src="https://dhc.pythonanywhere.com/media/editor/二叉树_20220316153214227108.png" alt="二叉树" title="二叉树"></p><p>二叉树的缺点可以用红黑树来解决：<br><img src="https://dhc.pythonanywhere.com/media/editor/红黑树_20220316163142686602.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B-Tree结构_20220316163813441163.png" alt="B-Tree结构" title="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>结构图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B+Tree结构图_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/结构图_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Hash索引原理图_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图"></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><div class="table-container"><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table></div><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><div class="table-container"><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table></div><p>演示图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/原理图_20220318194454880073.png" alt="大致原理" title="大致原理"><br><img src="https://dhc.pythonanywhere.com/media/editor/演示图_20220319215403721066.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id = 10;<br>select * from user where name = &#x27;Arm&#x27;;<br>-- 备注：id为主键，name字段创建的有索引<br></code></pre></td></tr></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p><p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引<br>create index idx_user_name on tb_user(name);<br>-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引<br>create unique index idx_user_phone on tb_user (phone);<br>-- 为profession, age, status创建联合索引<br>create index idx_user_pro_age_stat on tb_user(profession, age, status);<br>-- 为email建立合适的索引来提升查询效率<br>create index idx_user_email on tb_user(email);<br><br>-- 删除索引<br>drop index idx_user_email on tb_user;<br></code></pre></td></tr></table></figure><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。</p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol><li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code></li><li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code>，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h4 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h4 id="覆盖索引-amp-回表查询"><a href="#覆盖索引-amp-回表查询" class="headerlink" title="覆盖索引&amp;回表查询"></a>覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name=&#39;xxx&#39;;</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name=&#39;xxx&#39;;</code></p><p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code></p><p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(distinct email) / count(*) from tb_user;<br>select count(distinct substring(email, 1, 5)) / count(*) from tb_user;<br></code></pre></td></tr></table></figure><p>show index 里面的sub_part可以看到接取的长度</p><h4 id="单列索引-amp-联合索引"><a href="#单列索引-amp-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：<br><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code><br>这句只会用到phone索引字段</p><h5 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>普通插入：</p><ol><li>采用批量插入（一次插入的数据不建议超过1000条）</li><li>手动提交事务</li><li>主键顺序插入</li></ol><p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）<br>mysql --local-infile -u root -p<br># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关<br>set global local_infile = 1;<br>select @@local_infile;<br># 执行load指令将准备好的数据，加载到表结构中<br>load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;<br></code></pre></td></tr></table></figure><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><blockquote><p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p></blockquote><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 此语句耗时很长<br>select * from tb_sku limit 9000000, 10;<br>-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询<br>select id from tb_sku order by id limit 9000000, 10;<br>-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit<br>-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);<br>-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度<br>select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;<br></code></pre></td></tr></table></figure><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h3 id="update优化（避免行锁升级为表锁）"><a href="#update优化（避免行锁升级为表锁）" class="headerlink" title="update优化（避免行锁升级为表锁）"></a>update优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><div class="table-container"><table><thead><tr><th>类型名称</th><th>取值范围</th><th>大小</th></tr></thead><tbody><tr><td>TINYINT</td><td>-128〜127</td><td>1个字节</td></tr><tr><td>SMALLINT</td><td>-32768〜32767</td><td>2个宇节</td></tr><tr><td>MEDIUMINT</td><td>-8388608〜8388607</td><td>3个字节</td></tr><tr><td>INT (INTEGHR)</td><td>-2147483648〜2147483647</td><td>4个字节</td></tr><tr><td>BIGINT</td><td>-9223372036854775808〜9223372036854775807</td><td>8个字节</td></tr></tbody></table></div><p>无符号在数据类型后加 unsigned 关键字。</p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><div class="table-container"><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>FLOAT</td><td>单精度浮点数</td><td>4 个字节</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td><td>8 个字节</td></tr><tr><td>DECIMAL (M, D)，DEC</td><td>压缩的“严格”定点数</td><td>M+2 个字节</td></tr></tbody></table></div><h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><div class="table-container"><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td>TIME</td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td>DATE</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td>DATETIME</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td>4 个字节</td></tr></tbody></table></div><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><div class="table-container"><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度非二进制字符串</td><td>M 字节，1&lt;=M&lt;=255</td></tr><tr><td>VARCHAR(M)</td><td>变长非二进制字符串</td><td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>L+1字节，在此，L&lt;2^8</td></tr><tr><td>TEXT</td><td>小的非二进制字符串</td><td>L+2字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>L+3字节，在此，L&lt;2^24</td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>L+4字节，在此，L&lt;2^32</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table></div><h3 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h3><div class="table-container"><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>BIT(M)</td><td>位字段类型</td><td>大约 (M+7)/8 字节</td></tr><tr><td>BINARY(M)</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY (M)</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB (M)</td><td>非常小的BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB (M)</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB (M)</td><td>中等大小的BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB (M)</td><td>非常大的BLOB</td><td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table></div><h1 id="六、权限一览表"><a href="#六、权限一览表" class="headerlink" title="六、权限一览表"></a>六、权限一览表</h1><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><div class="table-container"><table><thead><tr><th style="text-align:left">Privilege</th><th style="text-align:left">Grant Table Column</th><th style="text-align:left">Context</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td><td style="text-align:left">Synonym for “all privileges”</td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td><td style="text-align:left"><code>Alter_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td><td style="text-align:left"><code>Alter_routine_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td><td style="text-align:left"><code>Create_priv</code></td><td style="text-align:left">Databases, tables, or indexes</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td><td style="text-align:left"><code>Create_role_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td><td style="text-align:left"><code>Create_routine_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td><td style="text-align:left"><code>Create_tablespace_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td><td style="text-align:left"><code>Create_tmp_table_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td><td style="text-align:left"><code>Create_user_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td><td style="text-align:left"><code>Create_view_priv</code></td><td style="text-align:left">Views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td><td style="text-align:left"><code>Delete_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td><td style="text-align:left"><code>Drop_priv</code></td><td style="text-align:left">Databases, tables, or views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td><td style="text-align:left"><code>Drop_role_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td><td style="text-align:left"><code>Event_priv</code></td><td style="text-align:left">Databases</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td><td style="text-align:left"><code>Execute_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td><td style="text-align:left"><code>File_priv</code></td><td style="text-align:left">File access on server host</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td><td style="text-align:left"><code>Grant_priv</code></td><td style="text-align:left">Databases, tables, or stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td><td style="text-align:left"><code>Index_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td><td style="text-align:left"><code>Insert_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td><td style="text-align:left"><code>Lock_tables_priv</code></td><td style="text-align:left">Databases</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td><td style="text-align:left"><code>Process_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td><td style="text-align:left">See <code>proxies_priv</code> table</td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td><td style="text-align:left"><code>References_priv</code></td><td style="text-align:left">Databases or tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td><td style="text-align:left"><code>Reload_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td><td style="text-align:left"><code>Repl_client_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td><td style="text-align:left"><code>Repl_slave_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td><td style="text-align:left"><code>Select_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td><td style="text-align:left"><code>Show_db_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td><td style="text-align:left"><code>Show_view_priv</code></td><td style="text-align:left">Views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td><td style="text-align:left"><code>Shutdown_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td><td style="text-align:left"><code>Super_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td><td style="text-align:left"><code>Trigger_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td><td style="text-align:left"><code>Update_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td><td style="text-align:left">Synonym for “no privileges”</td><td style="text-align:left">Server administration</td></tr></tbody></table></div><p>GRANT 和 REVOKE 允许的动态权限</p><div class="table-container"><table><thead><tr><th style="text-align:left">Privilege</th><th style="text-align:left">Context</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td><td style="text-align:left">Dual password administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td><td style="text-align:left">Allow queries blocked by audit log filter</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td><td style="text-align:left">Audit log administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td><td style="text-align:left">Authentication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td><td style="text-align:left">Backup administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td><td style="text-align:left">Backup and Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td><td style="text-align:left">Backup and Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td><td style="text-align:left">Clone administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td><td style="text-align:left">Redo log archiving administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td><td style="text-align:left">NDB Cluster</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td><td style="text-align:left">Authentication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td><td style="text-align:left"><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td><td style="text-align:left">Resource group administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td><td style="text-align:left">Resource group administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr></tbody></table></div><p><strong>小技巧</strong></p><ol><li>在SQL语句之后加上<code>\G</code>会将结果的表格形式转换成行文本形式</li><li>查看Mysql数据库占用空间：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT table_schema &quot;Database Name&quot;<br>     , SUM(data_length + index_length) / (1024 * 1024) &quot;Database Size in MB&quot;<br>FROM information_schema.TABLES<br>GROUP BY table_schema;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data base</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Systems: A Programmer‘s Perspective</title>
    <link href="/2022/04/15/Computer-Systems-A-Programmer-s-Perspective/"/>
    <url>/2022/04/15/Computer-Systems-A-Programmer-s-Perspective/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-A-Tour-of-Computer-System"><a href="#Chapter-1-A-Tour-of-Computer-System" class="headerlink" title="Chapter 1: A Tour of Computer System"></a>Chapter 1: A Tour of Computer System</h1><p><strong>由一个helloworld的整个生命周期来演示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/The-Compilation-System.png" alt="The-Compilation-System"></p><p><strong>为什么我们要理解编译系统？</strong></p><p>1⃣️ Optimizing program performance(优化程序性能)</p><p>e.g. 一个switch语句是不是要比一连串的if-else要高效的多？</p><p>2⃣️ Understanding link-time errors(理解链接时出现的错误)</p><p>e.g. 静态变量和全局变量的区别是什么？</p><p>3⃣️ Avoiding security holes(避免安全漏洞)</p><p>e.g. 缓冲区溢出错误产生？</p><p><strong>计算机硬件组成系统以及完成hello world程序的硬件处理过程</strong></p><p>PC(Program Count)：程序计数器，大小为一个字的存储区域。32位系统中，1 word = 4 byte，64位系统中，1 word = 8byte。</p><p>Register file：寄存器。</p><p>ALU：处理器。</p><p>Bus interface：总线。</p><p>Disk：磁盘。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP1-INPUT.png" alt="STEP1-INPUT"></p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP2-DMA.png" alt="STEP2-DMA"></p><p>DMA技术：数据可以不经过处理器，直接从磁盘抵达内存。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/STEP3-Display.png" alt="STEP3-Display"></p><p>tips：1⃣️ 大容量的设备会比小容量设备运行速度更慢。2⃣️ 运行速度更快的设备比低速设备更贵。</p><p>e.g. 内存虽小但价格和外存的价格差不多。</p><p><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/Memory%20Hierarchy.png" alt="Memory Hierarchy"></p><p>L1、L2、L3为我们常说的三级缓存。</p><p><strong>操作系统在应用程序和硬件系统之间的角色</strong></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/PanYuHaa/PicGo/img/The%20Operating%20System%20Manages%20Hardware.png" alt="The Operating System Manages Hardware"></h4><p>1⃣️ 防止硬件被失控的应用程序滥用</p><p>2⃣️ 操作系统提供统一的机制来控制这些复杂的底层硬件</p><p>—————————————————————————————————————</p><h2 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位 + 上下文"></a>1.1 信息就是位 + 上下文</h2><p>1⃣️ <strong>何为上下文？</strong></p><p>上下文，也就是执行任务所需要的相关信息。这个任务可以是一段代码，一个线程，一个进程，一个函数。当这个“任务”，相关信息需要保存下来，就可以使用Context来记录了。</p><h2 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h2><p>1⃣️<strong>GNU是什么？</strong></p><p>GNU是项目开发工具它包含了：EMACS编译器、GCC编译器、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其它一些部件。目前随着发展已经支持许多不同的语言了。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer（第二版）</title>
    <link href="/2022/04/12/%E5%89%91%E6%8C%87offer/"/>
    <url>/2022/04/12/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h1 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3. 数组中重复的数字"></a>3. 数组中重复的数字</h1><p>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p><p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.</p><p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用map</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> _, exist := m[nums[i]]; !exist &#123;<br>            m[nums[i]] = <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> nums[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-comment">// 双指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    slow := nums[<span class="hljs-number">0</span>]<br>    fast := nums[nums[<span class="hljs-number">0</span>]]<br>    <span class="hljs-keyword">for</span> slow != fast &#123;<br>slow = nums[slow]<br>fast = nums[nums[fast]]<br>&#125;<br><br>fast = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> fast != slow &#123;<br>fast = nums[fast]<br>slow = nums[slow]<br>&#125;<br><span class="hljs-keyword">return</span> slow<br>&#125;<br></code></pre></td></tr></table></figure><p>map的解法使用了额外的存储空间。</p><p>还得是双指针，</p><h1 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4. 二维数组中的查找"></a>4. 二维数组中的查找</h1><p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code>integer matrix <code>matrix</code>. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    row, col := <span class="hljs-built_in">len</span>(matrix)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt;= <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">if</span> matrix[row][col] == target &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target) &#123;<br>            row--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            col++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(1)对于数组 arr [row] [col] 的row和col，我们是按先行后列来看的。用二维数组举例，arr.length 表示的是row的长度，arr[0].length 表示的是列的长度。</p><p>(2)这种问题的通常思路一般是双循环，时间复杂度自然到达了o(n^2)，所以最直接的优化方式就是降低时间复杂度，把二维数组的处理展平变成一围的地图然后通过排序的规律来找到突破口。</p><p>注意矩阵不一定是方阵！</p><h1 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5. 替换空格"></a>5. 替换空格</h1><p>请实现一个函数，将一个字符串s中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">func <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(s string)</span> string &#123;<br>    <span class="hljs-keyword">var</span> newS []<span class="hljs-type">byte</span><br>    <span class="hljs-keyword">for</span> i := range s &#123;<br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            newS = append(newS, <span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            newS = append(newS, s[i]) <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> string(newS)<br>&#125;<br></code></pre></td></tr></table></figure><p>遇到什么样的拼接什么。</p><h1 id="6-从尾到头打印列表"><a href="#6-从尾到头打印列表" class="headerlink" title="6. 从尾到头打印列表"></a>6. 从尾到头打印列表</h1><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 反转数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reversePrint</span><span class="hljs-params">(head *ListNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    tmp := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> tmp<br>    &#125;<br>    cur := head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        tmp = <span class="hljs-built_in">append</span>(tmp, cur.Val)<br>        cur = cur.Next<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmp)/<span class="hljs-number">2</span>; i++ &#123;<br>        tmp[i], tmp[<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>-i] = tmp[<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>-i], tmp[i]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> tmp<br>&#125;<br><br><span class="hljs-comment">// 反转链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reversePrint</span><span class="hljs-params">(head *ListNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;&#125;<br>    cur := reverseLink(head)<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        arr = <span class="hljs-built_in">append</span>(arr, cur.Val)<br>        cur = cur.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseLink</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> pre, next *ListNode<br>    cur := head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next = cur.Next<br>        cur.Next = pre<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7. 重建二叉树"></a>7. 重建二叉树</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; map;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123; <span class="hljs-comment">// 用map保存中序序列的数值对应位置</span><br>            map.put(inorder[i], i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> findNode(preorder, <span class="hljs-number">0</span>, preorder.length, inorder,  <span class="hljs-number">0</span>, inorder.length);  <span class="hljs-comment">// 前闭后开</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preBegin, <span class="hljs-type">int</span> preEnd, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inBegin, <span class="hljs-type">int</span> inEnd)</span> &#123;<br>        <span class="hljs-comment">// 参数里的范围都是前闭后开</span><br>        <span class="hljs-keyword">if</span> (preBegin &gt;= preEnd || inBegin &gt;= inEnd) &#123;  <span class="hljs-comment">// 不满足左闭右开，说明没有元素，返回空树</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> map.get(preorder[preBegin]);  <span class="hljs-comment">// 找到前序遍历的第一个元素在中序遍历中的位置</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(inorder[rootIndex]);  <span class="hljs-comment">// 构造结点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenOfLeft</span> <span class="hljs-operator">=</span> rootIndex - inBegin;  <span class="hljs-comment">// 保存中序左子树个数，用来确定前序数列的个数</span><br>        root.left = findNode(preorder, preBegin + <span class="hljs-number">1</span>, preBegin + lenOfLeft + <span class="hljs-number">1</span>,  <br>                            inorder, inBegin, rootIndex);<br>        root.right = findNode(preorder, preBegin + lenOfLeft + <span class="hljs-number">1</span>, preEnd,<br>                            inorder, rootIndex + <span class="hljs-number">1</span>, inEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、用map来存储中序序列的数值和其位置。</p><p>2、找无论前序还是后续的第一个（最后一个）元素出来（作为root）</p><p>3、确定在中序列的位置找到后分开其左右子序列。</p><p>4、保存中序左子树个数，用来确定前序数列的个数（因为前序是根左右）</p><p>5、确定几个左 [preBegin + 1, preBegin + lenOfLeft + 1) 作为下一级的左子树，剩下的为右子树 [preBegin + lenOfLeft + 1, preEnd)。</p><p>pre：[<strong>3</strong>,9,20,15,7] </p><p>in：   [9,<strong>3</strong>,15,20,7]</p><h1 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9. 用两个栈实现队列"></a>9. 用两个栈实现队列</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br>    Stack&lt;Integer&gt; inStack;<br>    Stack&lt;Integer&gt; outStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>        inStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;(); <span class="hljs-comment">// in</span><br>        outStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;(); <span class="hljs-comment">// out</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        inStack.push(value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (inStack.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>            in2out();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in2out</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>            outStack.push(inStack.pop());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意题目说（若队列中没有元素，<code>deleteHead</code> 操作返回 -1）所以要判断当两个栈都空的时候要返回-1，要不就自然的装箱out，然后pop（），并且细节上，Java若Stack为空，peek()会报错，pop（）复用了，判断了是否空。</p><h1 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10.1 斐波那契数列"></a>10.1 斐波那契数列</h1><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n+<span class="hljs-number">1</span>; i++) &#123;<br>            dp[i] = (dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]) % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题取模单纯因为题目要求。但要区分两个情况，首先如果为0的话，那么就是0。另外不是0的情况，但仍然要初始化0，因为数组从0开始。但0其实是占位的所以要弄n+1空间。</p><h1 id="10-2-青蛙跳台阶问题"><a href="#10-2-青蛙跳台阶问题" class="headerlink" title="10.2 青蛙跳台阶问题"></a>10.2 青蛙跳台阶问题</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n+<span class="hljs-number">1</span>; i++) &#123;<br>            dp[i] = (dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]) % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a>11. 旋转数组的最小数字</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  </p><p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> numbers[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; numbers.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (numbers[i] &lt; min) &#123;<br>                min = numbers[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这题有问题吧……太简单了吧。</p><h1 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径"></a>12. 矩阵中的路径</h1><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 </p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> board.length, w = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[h][w];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; h; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; w; j++) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> check(board, visited, i, j, word, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (flag) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">boolean</span>[][] visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (board[i][j] != s.charAt(k)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == s.length() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span>[][] directions = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : directions) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newi</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], newj = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (newi &gt;= <span class="hljs-number">0</span> &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= <span class="hljs-number">0</span> &amp;&amp; newj &lt; board[<span class="hljs-number">0</span>].length) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[newi][newj]) &#123;<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> check(board, visited, newi, newj, s, k + <span class="hljs-number">1</span>); <span class="hljs-comment">// 新的方向下一步能不能走通</span><br>                    <span class="hljs-keyword">if</span> (flag) &#123;<br>                        result = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 走的通结果此位置就是有效的res就为true，要不此位置没用了。</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        visited[i][j] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果能继续走下去代码是不会到这一行的，这是当前位置有问题的时候才取消这个位置的资格。</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本问题是典型的矩阵搜索问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。</p><p>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。<br>剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</p><p>步骤：</p><p>1、如果不匹配直接返回false</p><p>2、如果匹配到末尾了字符串依旧匹配，直接返回true</p><p>3、没有结束就遍历周围所有可能的方向（如果是继续scan的话，要求即没有走过并且没有也没有参观过。）</p><p>java做String的题可以先<code>char[] words = word.toCharArray();</code></p><p><code>int h = board.length, w = board[0].length;</code>用来控制边界</p><p><code>int[][] directions = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;</code>用来保存移动字典</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : directions) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newi</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], newj = j + dir[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>用这个来控制方向</p><p>visited数组体现回溯，只不过DFS是四个方向。</p><p>result的出现是为了解决bool返回值是在if内部，代码块内部所以无法提取出来作为return的返回值。</p><h1 id="14-1-剪绳子-I"><a href="#14-1-剪绳子-I" class="headerlink" title="14.1 剪绳子-I"></a>14.1 剪绳子-I</h1><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>      <span class="hljs-comment">// dp[1] = 1;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));<br>            &#125;<br>            dp[i] = curMax;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一为什么这个题可以用dp。因为这其实也类似于递归，我们可以通过上一个切法再继续切。那具体切法有哪些呢？有两种，第一种是切完当前的长度j后不切了，即j <em> (i - j)；另一种是，切完了以后和之前的切法合并j </em> dp[i - j])。这样她的递归公式就出来了。</p><p>curMax需要从0开始计算，因为每次都是要每个位置的最大值才有意义。</p><p>第二个问题为什么这个不需要初始化？java默认你开一个长度为n的数组他初始化为全是0。巧合了其实赋值为dp[1]=1也一样。而且切割的话最低也是index是1所以有dp[1]肯定不会是空的，而且为了到达n的长度开数组要到n+1。</p><h1 id="14-2-剪绳子-II"><a href="#14-2-剪绳子-II" class="headerlink" title="14.2 剪绳子-II"></a>14.2 剪绳子-II</h1><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">4</span>)&#123;<br>            res *= <span class="hljs-number">3</span>;<br>            res = res % <span class="hljs-number">1000000007</span>;<br>            n -= <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(res * n % <span class="hljs-number">1000000007</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至今不明白这个取模干啥的。这个是个找规律的方法，大概看看就行。</p><h1 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15. 二进制中1的个数"></a>15. 二进制中1的个数</h1><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法一 一位位对比</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) != <span class="hljs-number">0</span>) &#123;<br>                ret++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>方法一：首先我们知道固定给我们一个32位的长度二进制，所以我们制作一个二进制位<code>1 &lt;&lt; 2</code>这样我们让n与其对比。也巧了java的int默认就是32位。</p><h1 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方"></a>16. 数值的整数次方</h1><p>实现 <code>pow(x, n)</code> ，即计算 x 的 n 次幂函数（即，x^n）。不得使用库函数，同时不需要考虑大数问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? quickMul(x, N) : <span class="hljs-number">1.0</span> / quickMul(x, -N);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">quickMul</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> N)</span> &#123;<br>        <span class="hljs-keyword">if</span> (N == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> quickMul(x, N / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? y * y : y * y * x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们一点点乘需要乘n-1次，所以为了减少乘法次数，我们采用迭代的方式。如果是负数我们采用1.0/y的方式求倒数。然后在迭代的时候判断一下每一层是不是整除如果不是整除就多乘一个x。（因为N/2如果不是偶数，会吞一位）</p><h1 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17. 打印从1到最大的n位数"></a>17. 打印从1到最大的n位数</h1><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] printNumbers(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">// init</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">volumn</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            volumn *= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[volumn-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; volumn-<span class="hljs-number">1</span>; i++) &#123;<br>            res[i] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>秒杀，注意这个volumn定义在外面，初始化一下经典的一个pow的写法。</p><h1 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a>18. 删除链表的节点</h1><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fakeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        fakeHead.next = head;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> fakeHead;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (curr.val == val) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            curr = curr.next;<br>            prev = prev.next;<br>        &#125;<br>        prev.next = curr.next;<br>        <span class="hljs-keyword">return</span> fakeHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="19-正则表达式匹配（暂时pass）"><a href="#19-正则表达式匹配（暂时pass）" class="headerlink" title="19. 正则表达式匹配（暂时pass）"></a>19. 正则表达式匹配（暂时pass）</h1><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">boolean</span> f[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//f[0][0]代表s和p均为空字符串，f[1][1]代表s和p的第一个字符（即在s和p中下标为0的字符）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m ; ++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span>(p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<span class="hljs-comment">//p的第j个字符为*</span><br>                    <span class="hljs-keyword">if</span>(matches(s, p, i, j - <span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//匹配s的第i个字符和p的第j-1个字符</span><br>                        f[i][j] = f[i - <span class="hljs-number">1</span>][j] || f[i][j - <span class="hljs-number">2</span>];<span class="hljs-comment">//p中*前面的字符在s中出现多次或者在s中只出现1次</span><br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        f[i][j] = f[i][j - <span class="hljs-number">2</span>];<span class="hljs-comment">//p中*前面的在s中字符出现0次</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//p的第j个字符不为*</span><br>                   <span class="hljs-keyword">if</span>(matches(s, p, i, j)) &#123;<span class="hljs-comment">//匹配s的第i个字符和p的第j个字符</span><br>                       f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<span class="hljs-comment">//匹配成功，状态转移；匹配不成功，默认是false</span><br>                   &#125; <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m][n];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(String s, String p, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<span class="hljs-comment">//注意在字符串中的下标变换</span><br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.charAt(i - <span class="hljs-number">1</span>) == p.charAt(j - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意哈，这个<em>不是通配符，他不是万能匹配而是和`</em>`前一个字符一样就行可以是0到多个。</p><h1 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20. 表示数值的字符串"></a>20. 表示数值的字符串</h1><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;State, Map&lt;CharType, State&gt;&gt;();<br>        Map&lt;CharType, State&gt; initialMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_SPACE, State.STATE_INITIAL);<br>            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);<br>            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);<br>            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_INITIAL, initialMap);<br>        Map&lt;CharType, State&gt; intSignMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);<br>            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_INT_SIGN, intSignMap);<br>        Map&lt;CharType, State&gt; integerMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);<br>            put(CharType.CHAR_EXP, State.STATE_EXP);<br>            put(CharType.CHAR_POINT, State.STATE_POINT);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_INTEGER, integerMap);<br>        Map&lt;CharType, State&gt; pointMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);<br>            put(CharType.CHAR_EXP, State.STATE_EXP);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_POINT, pointMap);<br>        Map&lt;CharType, State&gt; pointWithoutIntMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);<br>        Map&lt;CharType, State&gt; fractionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);<br>            put(CharType.CHAR_EXP, State.STATE_EXP);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_FRACTION, fractionMap);<br>        Map&lt;CharType, State&gt; expMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);<br>            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_EXP, expMap);<br>        Map&lt;CharType, State&gt; expSignMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_EXP_SIGN, expSignMap);<br>        Map&lt;CharType, State&gt; expNumberMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);<br>        Map&lt;CharType, State&gt; endMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;<br>            put(CharType.CHAR_SPACE, State.STATE_END);<br>        &#125;&#125;;<br>        transfer.put(State.STATE_END, endMap);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> State.STATE_INITIAL;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">CharType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> toCharType(s.charAt(i));<br>            <span class="hljs-keyword">if</span> (!transfer.get(state).containsKey(type)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                state = transfer.get(state).get(type);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span>= State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> CharType <span class="hljs-title function_">toCharType</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_NUMBER;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;e&#x27;</span> || ch == <span class="hljs-string">&#x27;E&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_EXP;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_POINT;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;+&#x27;</span> || ch == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_SIGN;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_SPACE;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> CharType.CHAR_ILLEGAL;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>        STATE_INITIAL,<br>        STATE_INT_SIGN,<br>        STATE_INTEGER,<br>        STATE_POINT,<br>        STATE_POINT_WITHOUT_INT,<br>        STATE_FRACTION,<br>        STATE_EXP,<br>        STATE_EXP_SIGN,<br>        STATE_EXP_NUMBER,<br>        STATE_END<br>    &#125;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CharType</span> &#123;<br>        CHAR_NUMBER,<br>        CHAR_EXP,<br>        CHAR_POINT,<br>        CHAR_SIGN,<br>        CHAR_SPACE,<br>        CHAR_ILLEGAL<br>    &#125;<br>&#125;<br><br>方法二<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    ‘.’出现正确情况：只出现一次，且在e的前面</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ‘e’出现正确情况：只出现一次，且出现前有数字</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ‘+’‘-’出现正确情况：只能在开头和e后一位</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//去掉首位空格</span><br>        s = s.trim();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">numFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">dotFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">eFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">//判定为数字，则标记numFlag</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                numFlag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">//判定为.  需要没出现过.并且没出现过e</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !dotFlag &amp;&amp; !eFlag) &#123;<br>                dotFlag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">//判定为e，需要没出现过e，并且出过数字了</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((s.charAt(i) == <span class="hljs-string">&#x27;e&#x27;</span> || s.charAt(i) == <span class="hljs-string">&#x27;E&#x27;</span>) &amp;&amp; !eFlag &amp;&amp; numFlag) &#123;<br>                eFlag = <span class="hljs-literal">true</span>;<br>                numFlag = <span class="hljs-literal">false</span>;<span class="hljs-comment">//为了避免123e这种请求，出现e之后就标志为false</span><br>                <span class="hljs-comment">//判定为+-符号，只能出现在第一位或者紧接e后面</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((s.charAt(i) == <span class="hljs-string">&#x27;+&#x27;</span> || s.charAt(i) == <span class="hljs-string">&#x27;-&#x27;</span>) &amp;&amp; (i == <span class="hljs-number">0</span> || s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;e&#x27;</span> || s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;E&#x27;</span>)) &#123;<br><br>                <span class="hljs-comment">//其他情况，都是非法的</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numFlag;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断某个条件，我们可以抽象，然后我们不需要关注他是什么，我只需要知道他是哪类东西就行。</p><p><img src="https://assets.leetcode-cn.com/solution-static/jianzhi_20/jianzhi_20_fig1.png" alt="fig1"></p><p>我们没有单独地考虑每种字符，而是划分为若干类。由于全部 10 个数字字符彼此之间都等价，因此只需定义一种统一的「数字」类型即可。对于正负号也是同理。<br>在实际代码中，我们需要处理转移失败的情况。例如当位于状态 1（起始空格）时，没有对应字符 e 的状态。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。</p><p>第二种方法中，flag只是为了判断组合的可能性。最终返回numflag是为了确定是不是数字，其实这么多元素中只要里面没有数字，那么他一定不表示数值。</p><h1 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] exchange(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                res[left++] = num;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[right--] = num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断条件填数的思想。</p><h1 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22. 链表中倒数第k个节点"></a>22. 链表中倒数第k个节点</h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>快慢指针秒杀</p><h1 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a>24. 反转链表</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head, prev = <span class="hljs-literal">null</span>, tmp;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            tmp = curr.next;<br>            curr.next = prev;<br>            prev = curr;<br>            curr = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 递归</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> recur(head, <span class="hljs-literal">null</span>);    <span class="hljs-comment">// 调用递归并返回</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">recur</span><span class="hljs-params">(ListNode cur, ListNode pre)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> pre; <span class="hljs-comment">// 终止条件</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> recur(cur.next, cur);  <span class="hljs-comment">// 递归后继节点</span><br>        cur.next = pre;              <span class="hljs-comment">// 修改节点引用指向</span><br>        <span class="hljs-keyword">return</span> res;                  <span class="hljs-comment">// 返回反转链表的头节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两种方法一种是普通的交换，一个是递归。</p><p>递归的思想是怎么做的呢？其实很简单，终止条件为如果cur为null则说明说明我们已经走到了尽头，那么此时的新头节点就是pre。递归步骤是什么呢？首先搜集下一个节点res，其实这个和我们前面的tmp是一样的。然后我们在让当前指向前面，然后返回res。res会在下一层帮忙在指向现在这层的cur（下一层的pre），从而建立连接。</p><h1 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25. 合并两个排序的链表"></a>25. 合并两个排序的链表</h1><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <br>        <br>        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归方法。我们这么看，当前层我手里有一个l1节点和l2节点，如果他俩都存在，那么我们比较一下，谁更小，那么我们就return谁（这时我们发挥的是一个节点，因为前面我们已经用l1.next切断了和之前的连接），在return前我们要将其next更新一下，这个next是谁呢主要是从return的node的next和另一个列表的的全部中找下一个节点。</p><h1 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a>26. 树的子结构</h1><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> || B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode A, TreeNode B)</span>&#123;<br>        <span class="hljs-keyword">if</span>(B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> A.val == B.val &amp;&amp; dfs(A.left, B.left) &amp;&amp; dfs(A.right, B.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先说一下这个代码真的漂亮。然后分析一下思路，首先A or B是空的那么必然是不对，然后我们判空之后看看NLR中有没有其子串。但递归的入口是在dfs这个地方。</p><p>dfs函数里面又有些什么？首先B是空的代表我们是找到了（空子树情况已经在外层函数判断完成了）A是空的是错的，然后我们就要判断都存在的情况，那么就要求NLR都需要相同。</p><h1 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a>27. 二叉树的镜像</h1><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> root.right;<br>        root.right = dfs(root.left);<br>        root.left = dfs(tmp);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用tmp暂存一下root.right，然后我们让right获得调整好的左节点，再让left获得调整好的right节点，最后返回root。如果没有tmp调整好的right节点会被再次调整回去赋值给left，就重复了等于原地没有动。</p><h1 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a>28. 对称的二叉树</h1><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isMirror(root.left, root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMirror</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (left.val == right.val) &amp;&amp; isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>镜像关键点在判断左右，所以入口是左右子节点。然后判断是否都是null，都是null肯定是一样的，然后有一个是null绝对是false。然后再去各自的左和右对应的位置找，层层进入。</p><h1 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h1><p><strong>描述</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p><p><strong>思路</strong></p><p>简单来说，就是不断地收缩矩阵的边界，确定边界，锁一动一<br>定义四个变量代表范围，up、down、left、right</p><ol><li>向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错 </li><li>向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错 </li><li>向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错 </li><li>向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错</li></ol><p><strong>解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> h * w;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sum];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bottom = h - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>, right = w - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(count &lt; sum) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>                res[count] = matrix[top][i];<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (++top &gt; bottom) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) &#123;<br>                res[count] = matrix[i][right];<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (--right &lt; left) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) &#123;<br>                res[count] = matrix[bottom][i];<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (--bottom &lt; top) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) &#123;<br>                res[count] = matrix[i][left];<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (++left &gt; right) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    [[1,2,3],</span><br><span class="hljs-comment">     [4,5,6],</span><br><span class="hljs-comment">     [7,8,9]]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>我们要关注两个部分：1、判空 2、遍历。</p><p>重点说遍历的问题，首先遍历的话需要确定一个问题，他什么时候会停止？因为不一定是正正的矩形，所以说很可能随时会停（往上下左右四个方向），所以我们每次都要先判定<code>if (++left &gt; right) break;</code>其中++left已经帮left++了。</p><h1 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30. 包含min函数的栈"></a>30. 包含min函数的栈</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        <span class="hljs-type">int</span> min;<br>        Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> min, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.min = min;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node head;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(x, x, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(x, Math.min(head.min, x), head); <span class="hljs-comment">// 头插法，这样直接模拟出栈的结构了</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        head = head.next; <span class="hljs-comment">// 直接弹出栈顶</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head.val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head.min;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack obj = new MinStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * int param_4 = obj.min();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>很聪明，用链表来实现，轻松实现两头都有。关键点在于插入的时候要考虑判定当前min是谁？因为巧妙的链表结构，所以pop以后min的值自然会更新。</p><h1 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a>31. 栈的压入、弹出序列</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateStackSequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] pushed, <span class="hljs-type">int</span>[] popped)</span> &#123;<br><br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> elem : pushed) &#123;<br>            stack.push(elem);<br>            <span class="hljs-keyword">while</span> (j &lt; popped.length &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == popped[j]) &#123;<br>                stack.pop();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span>= popped.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断合不合法，用个栈试一试: 把压栈的元素按顺序压入，当栈顶元素和出栈的第一个元素相同，则将该元素弹出，出栈列表指针后移并继续判断。最后判断出栈列表指针是否指向出栈列表的末尾即可。</p><h1 id="32-从上到下打印二叉树-I"><a href="#32-从上到下打印二叉树-I" class="headerlink" title="32. 从上到下打印二叉树-I"></a>32. 从上到下打印二叉树-I</h1><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * offer &amp; pull</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            TreeNode node=queue.poll();<br>            list.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)queue.add(node.left);<br>            <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)queue.add(node.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray(); <span class="hljs-comment">//  将Integer类型list复制为int数组 只不过使用了java8的stram新特性</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_43314519/article/details/107811547">https://blog.csdn.net/weixin_43314519/article/details/107811547</a> stream流引入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-type">int</span>[] arr = list.stream().mapToInt(i -&gt; i).toArray(); <span class="hljs-comment">//[1, 2, 3, 4]</span><br><br>list.set(<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">//[1, null, 3, 4]</span><br>arr = list.stream().filter(i -&gt; i != <span class="hljs-literal">null</span>).mapToInt(i -&gt; i).toArray(); <span class="hljs-comment">//[1, 3, 4]</span><br></code></pre></td></tr></table></figure><h1 id="32-从上到下打印二叉树-II"><a href="#32-从上到下打印二叉树-II" class="headerlink" title="32. 从上到下打印二叉树-II"></a>32. 从上到下打印二叉树-II</h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> res;<br>        Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>    <br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                TreeNode node=queue.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)queue.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)queue.add(node.right);<br>            &#125;<br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="32-从上到下打印二叉树-III"><a href="#32-从上到下打印二叉树-III" class="headerlink" title="32. 从上到下打印二叉树-III"></a>32. 从上到下打印二叉树-III</h1><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> res;<br>        Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                TreeNode node=queue.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)queue.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)queue.add(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (depth % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                Collections.reverse(tmp);<br>            &#125;<br>            depth++;<br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Collections.reverse(tmp); 反转链表</p><h1 id="33-二叉搜索树的后续遍历序列"><a href="#33-二叉搜索树的后续遍历序列" class="headerlink" title="33. 二叉搜索树的后续遍历序列"></a>33. 二叉搜索树的后续遍历序列</h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 要点：二叉搜索树中根节点的值大于左子树中的任何一个节点的值，小于右子树中任何一个节点的值，子树也是</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">if</span> (postorder.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> verify(postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>); <br>    &#125;<br><br>    <span class="hljs-comment">// 递归实现</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 当前区域不合法的时候直接返回true就好</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootValue</span> <span class="hljs-operator">=</span> postorder[right]; <span class="hljs-comment">// 当前树的根节点的值</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-keyword">while</span> (k &lt; right &amp;&amp; postorder[k] &lt; rootValue)&#123; <span class="hljs-comment">// 从当前区域找到第一个大于根节点的，说明后续区域数值都在右子树中</span><br>            k++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; right; i++)&#123; <span class="hljs-comment">// 进行判断后续的区域是否所有的值都是大于当前的根节点，如果出现小于的值就直接返回false</span><br>            <span class="hljs-keyword">if</span> (postorder[i] &lt; rootValue) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 当前树没问题就检查左右子树</span><br>        <span class="hljs-keyword">if</span> (!verify(postorder, left, k - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 检查左子树</span><br><br>        <span class="hljs-keyword">if</span> (!verify(postorder, k, right - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 检查右子树</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 最终都没问题就返回true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后续遍历是LRN，每次都要用递归切L R N分界。</p><h1 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34. 二叉树中和为某一值的路径"></a>34. 二叉树中和为某一值的路径</h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;<br><br>    <span class="hljs-comment">// 二叉树中和为某一值的路径</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtrack(root, sum, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> target, List&lt;Integer&gt; collector)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        collector.add(node.val);<br>        target -= node.val;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span> &amp;&amp; node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(collector));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            backtrack(node.left, target, collector);<br>            backtrack(node.right, target, collector);<br>        &#125;<br>        collector.remove(collector.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>private List&lt;List&lt;Integer&gt;&gt; res;</code>全局定义变量。方便后续</p><p>记住java的左边是数据类型，右边是他构造器。</p><p>所以正确写法是<code>lists.add(new ArrayList&lt;&gt;(list));</code>开辟一块新的空间。正确写法。如果不这样写，他是引用对象共享空间，他在返回的路上全给你删除了。</p><h1 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a>35. 复杂链表的复制</h1><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node next;</span><br><span class="hljs-comment">    Node random;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">        this.next = null;</span><br><span class="hljs-comment">        this.random = null;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//哈希表，空间和时间都是O(n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//map中存的是（原节点，拷贝节点）的一个映射</span><br>        Map&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head; cur != <span class="hljs-literal">null</span>; cur = cur.next) &#123;<br>            map.put(cur, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.val));<br>        &#125;<br>        <span class="hljs-comment">//将拷贝的新节点组成一个链表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head; cur != <span class="hljs-literal">null</span>; cur = cur.next) &#123;<br>            map.get(cur).next = map.get(cur.next);<br>            map.get(cur).random = map.get(cur.random);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> map.get(head);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先把他复制出来用map存起来好索引，然后一个一个对应就行了。</p><h1 id="36-二叉搜索树与双向链表-不太会"><a href="#36-二叉搜索树与双向链表-不太会" class="headerlink" title="36. 二叉搜索树与双向链表(不太会)"></a>36. 二叉搜索树与双向链表(不太会)</h1><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" alt="img"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    public int val;</span><br><span class="hljs-comment">    public Node left;</span><br><span class="hljs-comment">    public Node right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val,Node _left,Node _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 1. 中序，递归，来自解题大佬</span><br>    Node pre, head;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">treeToDoublyList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-comment">// 边界值</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        dfs(root);<br><br>        <span class="hljs-comment">// 题目要球头尾连接</span><br>        head.left = pre;<br>        pre.right = head;<br>        <span class="hljs-comment">// 返回头节点</span><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node cur)</span> &#123;<br>        <span class="hljs-comment">// 递归结束条件</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>        dfs(cur.left);<br>        <span class="hljs-comment">// 如果pre为空，就说明是第一个节点，头节点，然后用head保存头节点，用于之后的返回。</span><br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">null</span>) head = cur;<br>        <span class="hljs-comment">// 如果不为空，那说明是中间的节点，并且pre保存的是上一个节点。</span><br>        <span class="hljs-comment">// 让上一个节点的有指针指向当前节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>) pre.right = cur;<br>        <span class="hljs-comment">// 再让当前节点的左指针指向父节点，也就连成了双向链表\</span><br>        cur.left = pre;<br>        <span class="hljs-comment">// 保存当前节点，用于下层递归创建</span><br>        pre = cur;<br>        dfs(cur.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先dfs往最左下的子树走。第一次head的头指向pre空。让pre更新到cur当前节点，成为下一个pre。</p><h1 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37. 序列化二叉树"></a>37. 序列化二叉树</h1><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><br>    <span class="hljs-keyword">private</span> TreeNode root;<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = root;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接偷鸡。</p><h1 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38. 字符串的排列"></a>38. 字符串的排列</h1><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;<br>        Set&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[arr.length];<br>        dfs(arr, <span class="hljs-string">&quot;&quot;</span>, visited, list);<br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 只是一个类型标示，用来告诉toArray方法具体转化成什么类型。list.toArray(new String[0]);//转化成String数组</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr, String tmp, <span class="hljs-type">boolean</span>[] visited, Set&lt;String&gt; list)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tmp.length() == arr.length) &#123;<br>            list.add(tmp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                visited[i] = <span class="hljs-literal">true</span>;<br>                dfs(arr, tmp + String.valueOf(arr[i]), visited, list); <span class="hljs-comment">// 在读取数据时需要对数据的强制转换，可采用String.valueOf(a)，把a强制转换成字符串类型</span><br>                visited[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>dfs的java版本其实这个写的用visit有点多余空间了，但其实不是这样的。 这是个组合问题，所以不能考虑顺序，考虑顺序如果要求是3个答案只有abc了。</p><p><strong>排列：</strong> 一般地，从n个不同元素中取出m（m≤n）个元素，按照一定的顺序排成一列，叫做从n个元素中取出m个元素的一个排列(permutation)。特别地，当m=n时，这个排列被称作全排列(all permutation)。</p><p><strong>组合：</strong> 一般地，从n个不同的元素中，任取m（m≤n）个元素为一组，叫作从n个不同元素中取出m个元素的一个组合。</p><h1 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a>39. 数组中出现次数超过一半的数字</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums.length / <span class="hljs-number">2</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(nums[i]) == <span class="hljs-literal">null</span>) &#123;<br>                map.put(nums[i], <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (map.get(nums[i]) + <span class="hljs-number">1</span> &gt; target) <span class="hljs-keyword">return</span> nums[i];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(nums[i]) + <span class="hljs-number">1</span>;<br>                map.put(nums[i], value);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[nums.length-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Map 来解决。</p><h1 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40. 最小的k个数"></a>40. 最小的k个数</h1><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        Arrays.sort(arr);<br>        res = Arrays.copyOfRange(arr, <span class="hljs-number">0</span>, k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更低的时间复杂度。</p><h1 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41. 数据流中的中位数"></a>41. 数据流中的中位数</h1><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    PriorityQueue&lt;Integer&gt; left;<span class="hljs-comment">//大顶</span><br>    PriorityQueue&lt;Integer&gt; right;<span class="hljs-comment">//小顶</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        left=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((n1,n2)-&gt;n2-n1);<br>        right=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        left.add(num);<br>        right.add(left.poll());<br>        <span class="hljs-keyword">if</span>(left.size()+<span class="hljs-number">1</span>&lt;right.size())<br>            left.add(right.poll());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(right.size()&gt;left.size())<span class="hljs-keyword">return</span> right.peek();<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)(left.peek()+right.peek())/<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntToDoubleDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>        <span class="hljs-comment">//1.隐式转换</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> i;<br>        System.out.println(d1);<br>         <br>        <span class="hljs-comment">//2.使用Double.valueOf()方法</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> Double.valueOf(i);<br>        System.out.println(d2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>indexOf方法</strong></p><p>从动态数组中返回指定元素的位置的索引值。</p><p>如果 obj 元素在动态数组中重复出现，返回在数组中最先出现 obj 的元素索引值。</p><p>如果动态数组中不存在指定的元素，则该 indexOf() 方法返回 -1。</p><p><strong>get方法</strong></p><p>返回动态数组中指定索引处的元素。</p><p>如果 index 值超出了范围，则抛出 IndexOutOfBoundsException 异常。</p><p><img src="https://www.cainiaojc.com/run/images/java-priorityqueue-implementation.png" alt="Java PriorityQueue类实现Queue接口。"></p><p>与普通队列不同，优先队列元素是按排序顺序检索的。</p><p>假设我们想以升序检索元素。在这种情况下，优先队列的头是最小的元素。检索到该元素后，下一个最小的元素将成为队列的头。</p><p>需要注意的是，优先队列的元素可能没有排序。但是，元素总是按排序顺序检索的。</p><p>大顶堆 <a href="https://blog.csdn.net/weixin_30363263/article/details/80862578">https://blog.csdn.net/weixin_30363263/article/details/80862578</a></p><p><strong>解法：</strong></p><p>用大顶堆+小顶堆方法，可以看作大顶堆是普通班，小顶堆是实验班。数量上时刻保持 小顶-大顶&lt;=1（两堆相等或者小顶比大顶多一个）。</p><p>新学生先入普通班（大顶堆），此时可能会失去平衡了，于是取大顶堆的第一个（班里最好的学生）加入实验班（小顶堆），判断若数量过多（不是等于或多一个），取第一个（实验班里最差的学生）到普通班（大顶堆）里。 取中位数的时候，若两堆数量相等，则各取堆顶取平均，若小顶比大顶多一，则多的那一个就是中位数。</p><h1 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a>42. 连续子数组的最大和</h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            dp[i] = Math.max(nums[i], dp[i-<span class="hljs-number">1</span>] + nums[i]);<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; max) &#123;<br>                max = dp[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很经典的一个dp，我们每一步就需要判断加入当前的要是大就保留此时大，要是当前的小则重新开始，这个连续的还是相对简单一些的。</p><h1 id="43-1～n整数中1出现的次数（不太会）"><a href="#43-1～n整数中1出现的次数（不太会）" class="headerlink" title="43. 1～n整数中1出现的次数（不太会）"></a>43. 1～n整数中1出现的次数（不太会）</h1><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDigitOne</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> count;<br>        <span class="hljs-type">long</span> rest;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i *= <span class="hljs-number">10</span>) &#123;<br>            count = (n / (i * <span class="hljs-number">10</span>)) * i; <span class="hljs-comment">// 分别统计个位的1  十位  百位.....</span><br>            <span class="hljs-comment">//111   个位共计11个1，  &#x27;1&#x27;, 1&#x27;1&#x27;, 2&#x27;1&#x27;, 3&#x27;1&#x27;, 4&#x27;1&#x27;, 5&#x27;1&#x27;, 6&#x27;1&#x27;, 7&#x27;1&#x27;, 8&#x27;1&#x27;, 9&#x27;1&#x27;, 10&#x27;1&#x27;</span><br>            <span class="hljs-comment">//只统计到小于等于110 多出为余数</span><br>            <span class="hljs-comment">//111  十位有10个1, &#x27;1&#x27;0, &#x27;1&#x27;1, &#x27;1&#x27;2, &#x27;1&#x27;3, &#x27;1&#x27;4, &#x27;1&#x27;5, &#x27;1&#x27;6, &#x27;1&#x27;7, &#x27;1&#x27;8, &#x27;1&#x27;9</span><br>            rest = Math.min(Math.max(n % (i * <span class="hljs-number">10</span>) - (i - <span class="hljs-number">1</span>), <span class="hljs-number">0</span>), i);  <span class="hljs-comment">// 1  0   // 10  9  //100 99</span><br>            <span class="hljs-comment">//下面举例100和111的余数</span><br>            <span class="hljs-comment">// 如果为负数则取余为0</span><br>            <span class="hljs-comment">// 100  个位为0 无余数</span><br>            <span class="hljs-comment">// 111  个位为1 有一个余数    111  第三位   11‘1’</span><br>            <span class="hljs-comment">// 100  十位为0 无余数</span><br>            <span class="hljs-comment">// 111  十位为1 有两个余数    110  111  中间位置1‘1’0 和1‘1’1</span><br>            <span class="hljs-comment">// 100  百位为1 有一个余数    100  第一位‘1’00</span><br>            <span class="hljs-comment">// 111  百位为1 有十二个余数  100....... 111  第一位 &#x27;1&#x27;00 ..........  &#x27;1&#x27;11</span><br>            ans += (count + rest);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单纯的检查，时间复杂度太高，超时。</p><p>数位dp检查。</p><p><code>String strNum = String.valueOf(num);</code></p><p><code>char[] charNum = strNum.toCharArray();</code></p><p>int -&gt; string -&gt; char[]</p><h1 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44. 数字序列中某一位的数字"></a>44. 数字序列中某一位的数字</h1><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 数字范围    数量  位数    占多少位</span><br><span class="hljs-comment">    1-9        9      1       9</span><br><span class="hljs-comment">    10-99      90     2       180</span><br><span class="hljs-comment">    100-999    900    3       2700</span><br><span class="hljs-comment">    1000-9999  9000   4       36000  ...</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    例如 2901 = 9 + 180 + 2700 + 12 即一定是4位数,第12位   n = 12;</span><br><span class="hljs-comment">    数据为 = 1000 + (12 - 1)/ 4  = 1000 + 2 = 1002</span><br><span class="hljs-comment">    定位1002中的位置 = (n - 1) %  4 = 3    s.charAt(3) = 2;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findNthDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;   <span class="hljs-comment">// n所在数字的位数</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 数字范围开始的第一个数</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;  <span class="hljs-comment">// 占多少位</span><br>        <span class="hljs-keyword">while</span>(n &gt; count)&#123;<br>            n -= count;<br>            digit++;<br>            start *= <span class="hljs-number">10</span>;<br>            count = digit * start * <span class="hljs-number">9</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> start + (n - <span class="hljs-number">1</span>) / digit;<br>        <span class="hljs-keyword">return</span> Long.toString(num).charAt((n - <span class="hljs-number">1</span>) % digit) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>数学规律题。首先先转换为多少位，确定占位多少；然后查看这个数是什么；最后看看这个数的对应位置是谁。 </p><p><code>return Long.toString(num).charAt((n - 1) % digit) - &#39;0&#39;;</code> long —&gt; String —&gt; char —&gt; int</p><h1 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45. 把数组排成最小的数"></a>45. 把数组排成最小的数</h1><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            list.add(String.valueOf(num));<br>        &#125;<br>        list.sort((o1, o2) -&gt; (o1 + o2).compareTo(o2 + o1));<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot;&quot;</span>, list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>开一个list 然后更新里面的数字都变成字符串。</p><p><code>x “小于” y 代表：排序完成后，数组中 x 应在 y 左边；“大于” 则反之。</code></p><p>Lambda第二次体验。</p><h1 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46. 把数字翻译成字符串"></a>46. 把数字翻译成字符串</h1><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">/*  </span><br><span class="hljs-comment">        动态规划 类似跳台阶的问题但是有额外的限制条件</span><br><span class="hljs-comment">        举例：给定数字 122 一共有三种翻译的可能 第一种bcc 122 第二种 bw 1 22 第三种 mc 12 2</span><br><span class="hljs-comment">        可以观察出当从左向右遍历时，存在选择选一格字符或者选两个字符的情况 类似跳一格或者跳两格</span><br><span class="hljs-comment">        但是题目给出了限制条件 当想要跳两格的时候 所选的二位数满足 &gt;=10且&lt;=25 ，当0作为十位数前置位时，不可取</span><br><span class="hljs-comment">        如果不满足上诉条件  则不存在跳两格 只能跳一格的形式到达目标</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        所以当num[i-1,i] 拼接成的十位数 &gt;=10且&lt;=25 时 有 dp[i] = dp[i-1] + dp[i-2] 即跳两格跳一格都可选 </span><br><span class="hljs-comment">        当num[i-1,i] 拼接成的十位数 &gt;25或者&lt;10 时 dp[i] = dp[i-1]   即只能选取跳一格的方案</span><br><span class="hljs-comment">    */</span>  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">translateNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(num);<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[str.length() + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//原地不动 or 走一步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= str.length(); i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">tmpStr</span> <span class="hljs-operator">=</span> str.substring(i - <span class="hljs-number">2</span>, i);<br><span class="hljs-keyword">if</span> (tmpStr.compareTo(<span class="hljs-string">&quot;10&quot;</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; tmpStr.compareTo(<span class="hljs-string">&quot;25&quot;</span>) &lt;= <span class="hljs-number">0</span>) &#123;<br>dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dp[i] = dp[i - <span class="hljs-number">1</span>];<br>&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[dp.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a>47. 礼物的最大价值</h1><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dfs复杂度太高了，要用dp</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    第一种：</span><br><span class="hljs-comment">    i 行 j 列</span><br><span class="hljs-comment">    转移方程 dp[i][j] = Math.max(dp[i][j-1] + grid[i][j], dp[i-1][j] + grid[i][j])</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 初始化都为0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                dp[i][j] = Math.max(dp[i][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j]) + grid[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    滚动数组的方法  </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                dp[j] = Math.max(dp[j], dp[j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125; <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很基础的一个dp问题。</p><p>为什么可以滚动数组呢？因为我们的dp[j]其实就记录了上一行的数据，dp[j-1]记录了左边过来的，加上当前位置的就是最新的大小。一个简单的压缩。</p><h1 id="48-最长不包含重复字符的子字符串"><a href="#48-最长不包含重复字符的子字符串" class="headerlink" title="48. 最长不包含重复字符的子字符串"></a>48. 最长不包含重复字符的子字符串</h1><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//if(s==null) return 0;这句话可以不加，s.length()长度为0时，不进入下面的循环，会直接返回max=0;</span><br>        <span class="hljs-comment">//划定当前窗口的坐标为(start,i],左开右闭,所以start的初始值为-1，而非0。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,start =-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//使用哈希表map统计各字符最后一次出现的索引位置</span><br>        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <br>            <span class="hljs-comment">//当字符在map中已经存储时，需要判断其索引值index和当前窗口start的大小以确定是否需要对start进行更新:</span><br>            <span class="hljs-comment">//当index&gt;start时，start更新为当前的index,否则保持不变。</span><br>            <span class="hljs-comment">//注意若index作为新的start，计算当前滑动空间的长度时也是不计入的，左开右闭，右侧s[i]会计入，这样也是防止字符的重复计入。</span><br>            <span class="hljs-keyword">if</span>(map.containsKey(tmp)) start = Math.max(start,map.get(tmp));<br>            <br>            <span class="hljs-comment">//如果map中不含tmp，此处是在map中新增一个键值对，否则是对原有的键值对进行更新</span><br>            map.put(tmp,i);<br>            <br>            <span class="hljs-comment">//i-start,为当前滑动空间(start,i]的长度，若其大于max，则需要进行更新。</span><br>            max = Math.max(max,i-start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心思想就是遍历的时候找一两个一样的字母呗，那么我们就用map存一下所有的字母的第一次出现的位置，然后遇到一样的就更新一下他自己的位置，然后求一下是不是比max大，大就更新结果。</p><h1 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a>49. 丑数</h1><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> uglyNums[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] uglyNums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">27</span>, <span class="hljs-number">30</span>, <span class="hljs-number">32</span>, <span class="hljs-number">36</span>, <span class="hljs-number">40</span>, <span class="hljs-number">45</span>, <span class="hljs-number">48</span>, <span class="hljs-number">50</span>, <span class="hljs-number">54</span>, <span class="hljs-number">60</span>, <span class="hljs-number">64</span>, <span class="hljs-number">72</span>, <span class="hljs-number">75</span>, <span class="hljs-number">80</span>, <span class="hljs-number">81</span>, <span class="hljs-number">90</span>, <span class="hljs-number">96</span>, <span class="hljs-number">100</span>, <span class="hljs-number">108</span>, <span class="hljs-number">120</span>, <span class="hljs-number">125</span>, <span class="hljs-number">128</span>, <span class="hljs-number">135</span>, <span class="hljs-number">144</span>, <span class="hljs-number">150</span>, <span class="hljs-number">160</span>, <span class="hljs-number">162</span>, <span class="hljs-number">180</span>, <span class="hljs-number">192</span>, <span class="hljs-number">200</span>, <span class="hljs-number">216</span>, <span class="hljs-number">225</span>, <span class="hljs-number">240</span>, <span class="hljs-number">243</span>, <span class="hljs-number">250</span>, <span class="hljs-number">256</span>, <span class="hljs-number">270</span>, <span class="hljs-number">288</span>, <span class="hljs-number">300</span>, <span class="hljs-number">320</span>, <span class="hljs-number">324</span>, <span class="hljs-number">360</span>, <span class="hljs-number">375</span>, <span class="hljs-number">384</span>, <span class="hljs-number">400</span>, <span class="hljs-number">405</span>, <span class="hljs-number">432</span>, <span class="hljs-number">450</span>, <span class="hljs-number">480</span>, <span class="hljs-number">486</span>, <span class="hljs-number">500</span>, <span class="hljs-number">512</span>, <span class="hljs-number">540</span>, <span class="hljs-number">576</span>, <span class="hljs-number">600</span>, <span class="hljs-number">625</span>, <span class="hljs-number">640</span>, <span class="hljs-number">648</span>, <span class="hljs-number">675</span>, <span class="hljs-number">720</span>, <span class="hljs-number">729</span>, <span class="hljs-number">750</span>, <span class="hljs-number">768</span>, <span class="hljs-number">800</span>, <span class="hljs-number">810</span>, <span class="hljs-number">864</span>, <span class="hljs-number">900</span>, <span class="hljs-number">960</span>, <span class="hljs-number">972</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">1080</span>, <span class="hljs-number">1125</span>, <span class="hljs-number">1152</span>, <span class="hljs-number">1200</span>, <span class="hljs-number">1215</span>, <span class="hljs-number">1250</span>, <span class="hljs-number">1280</span>, <span class="hljs-number">1296</span>, <span class="hljs-number">1350</span>, <span class="hljs-number">1440</span>, <span class="hljs-number">1458</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1536</span>, <span class="hljs-number">1600</span>, <span class="hljs-number">1620</span>, <span class="hljs-number">1728</span>, <span class="hljs-number">1800</span>, <span class="hljs-number">1875</span>, <span class="hljs-number">1920</span>, <span class="hljs-number">1944</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2025</span>, <span class="hljs-number">2048</span>, <span class="hljs-number">2160</span>, <span class="hljs-number">2187</span>, <span class="hljs-number">2250</span>, <span class="hljs-number">2304</span>, <span class="hljs-number">2400</span>, <span class="hljs-number">2430</span>, <span class="hljs-number">2500</span>, <span class="hljs-number">2560</span>, <span class="hljs-number">2592</span>, <span class="hljs-number">2700</span>, <span class="hljs-number">2880</span>, <span class="hljs-number">2916</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">3072</span>, <span class="hljs-number">3125</span>, <span class="hljs-number">3200</span>, <span class="hljs-number">3240</span>, <span class="hljs-number">3375</span>, <span class="hljs-number">3456</span>, <span class="hljs-number">3600</span>, <span class="hljs-number">3645</span>, <span class="hljs-number">3750</span>, <span class="hljs-number">3840</span>, <span class="hljs-number">3888</span>, <span class="hljs-number">4000</span>, <span class="hljs-number">4050</span>, <span class="hljs-number">4096</span>, <span class="hljs-number">4320</span>, <span class="hljs-number">4374</span>, <span class="hljs-number">4500</span>, <span class="hljs-number">4608</span>, <span class="hljs-number">4800</span>, <span class="hljs-number">4860</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5120</span>, <span class="hljs-number">5184</span>, <span class="hljs-number">5400</span>, <span class="hljs-number">5625</span>, <span class="hljs-number">5760</span>, <span class="hljs-number">5832</span>, <span class="hljs-number">6000</span>, <span class="hljs-number">6075</span>, <span class="hljs-number">6144</span>, <span class="hljs-number">6250</span>, <span class="hljs-number">6400</span>, <span class="hljs-number">6480</span>, <span class="hljs-number">6561</span>, <span class="hljs-number">6750</span>, <span class="hljs-number">6912</span>, <span class="hljs-number">7200</span>, <span class="hljs-number">7290</span>, <span class="hljs-number">7500</span>, <span class="hljs-number">7680</span>, <span class="hljs-number">7776</span>, <span class="hljs-number">8000</span>, <span class="hljs-number">8100</span>, <span class="hljs-number">8192</span>, <span class="hljs-number">8640</span>, <span class="hljs-number">8748</span>, <span class="hljs-number">9000</span>, <span class="hljs-number">9216</span>, <span class="hljs-number">9375</span>, <span class="hljs-number">9600</span>, <span class="hljs-number">9720</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10125</span>, <span class="hljs-number">10240</span>, <span class="hljs-number">10368</span>, <span class="hljs-number">10800</span>, <span class="hljs-number">10935</span>, <span class="hljs-number">11250</span>, <span class="hljs-number">11520</span>, <span class="hljs-number">11664</span>, <span class="hljs-number">12000</span>, <span class="hljs-number">12150</span>, <span class="hljs-number">12288</span>, <span class="hljs-number">12500</span>, <span class="hljs-number">12800</span>, <span class="hljs-number">12960</span>, <span class="hljs-number">13122</span>, <span class="hljs-number">13500</span>, <span class="hljs-number">13824</span>, <span class="hljs-number">14400</span>, <span class="hljs-number">14580</span>, <span class="hljs-number">15000</span>, <span class="hljs-number">15360</span>, <span class="hljs-number">15552</span>, <span class="hljs-number">15625</span>, <span class="hljs-number">16000</span>, <span class="hljs-number">16200</span>, <span class="hljs-number">16384</span>, <span class="hljs-number">16875</span>, <span class="hljs-number">17280</span>, <span class="hljs-number">17496</span>, <span class="hljs-number">18000</span>, <span class="hljs-number">18225</span>, <span class="hljs-number">18432</span>, <span class="hljs-number">18750</span>, <span class="hljs-number">19200</span>, <span class="hljs-number">19440</span>, <span class="hljs-number">19683</span>, <span class="hljs-number">20000</span>, <span class="hljs-number">20250</span>, <span class="hljs-number">20480</span>, <span class="hljs-number">20736</span>, <span class="hljs-number">21600</span>, <span class="hljs-number">21870</span>, <span class="hljs-number">22500</span>, <span class="hljs-number">23040</span>, <span class="hljs-number">23328</span>, <span class="hljs-number">24000</span>, <span class="hljs-number">24300</span>, <span class="hljs-number">24576</span>, <span class="hljs-number">25000</span>, <span class="hljs-number">25600</span>, <span class="hljs-number">25920</span>, <span class="hljs-number">26244</span>, <span class="hljs-number">27000</span>, <span class="hljs-number">27648</span>, <span class="hljs-number">28125</span>, <span class="hljs-number">28800</span>, <span class="hljs-number">29160</span>, <span class="hljs-number">30000</span>, <span class="hljs-number">30375</span>, <span class="hljs-number">30720</span>, <span class="hljs-number">31104</span>, <span class="hljs-number">31250</span>, <span class="hljs-number">32000</span>, <span class="hljs-number">32400</span>, <span class="hljs-number">32768</span>, <span class="hljs-number">32805</span>, <span class="hljs-number">33750</span>, <span class="hljs-number">34560</span>, <span class="hljs-number">34992</span>, <span class="hljs-number">36000</span>, <span class="hljs-number">36450</span>, <span class="hljs-number">36864</span>, <span class="hljs-number">37500</span>, <span class="hljs-number">38400</span>, <span class="hljs-number">38880</span>, <span class="hljs-number">39366</span>, <span class="hljs-number">40000</span>, <span class="hljs-number">40500</span>, <span class="hljs-number">40960</span>, <span class="hljs-number">41472</span>, <span class="hljs-number">43200</span>, <span class="hljs-number">43740</span>, <span class="hljs-number">45000</span>, <span class="hljs-number">46080</span>, <span class="hljs-number">46656</span>, <span class="hljs-number">46875</span>, <span class="hljs-number">48000</span>, <span class="hljs-number">48600</span>, <span class="hljs-number">49152</span>, <span class="hljs-number">50000</span>, <span class="hljs-number">50625</span>, <span class="hljs-number">51200</span>, <span class="hljs-number">51840</span>, <span class="hljs-number">52488</span>, <span class="hljs-number">54000</span>, <span class="hljs-number">54675</span>, <span class="hljs-number">55296</span>, <span class="hljs-number">56250</span>, <span class="hljs-number">57600</span>, <span class="hljs-number">58320</span>, <span class="hljs-number">59049</span>, <span class="hljs-number">60000</span>, <span class="hljs-number">60750</span>, <span class="hljs-number">61440</span>, <span class="hljs-number">62208</span>, <span class="hljs-number">62500</span>, <span class="hljs-number">64000</span>, <span class="hljs-number">64800</span>, <span class="hljs-number">65536</span>, <span class="hljs-number">65610</span>, <span class="hljs-number">67500</span>, <span class="hljs-number">69120</span>, <span class="hljs-number">69984</span>, <span class="hljs-number">72000</span>, <span class="hljs-number">72900</span>, <span class="hljs-number">73728</span>, <span class="hljs-number">75000</span>, <span class="hljs-number">76800</span>, <span class="hljs-number">77760</span>, <span class="hljs-number">78125</span>, <span class="hljs-number">78732</span>, <span class="hljs-number">80000</span>, <span class="hljs-number">81000</span>, <span class="hljs-number">81920</span>, <span class="hljs-number">82944</span>, <span class="hljs-number">84375</span>, <span class="hljs-number">86400</span>, <span class="hljs-number">87480</span>, <span class="hljs-number">90000</span>, <span class="hljs-number">91125</span>, <span class="hljs-number">92160</span>, <span class="hljs-number">93312</span>, <span class="hljs-number">93750</span>, <span class="hljs-number">96000</span>, <span class="hljs-number">97200</span>, <span class="hljs-number">98304</span>, <span class="hljs-number">98415</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">101250</span>, <span class="hljs-number">102400</span>, <span class="hljs-number">103680</span>, <span class="hljs-number">104976</span>, <span class="hljs-number">108000</span>, <span class="hljs-number">109350</span>, <span class="hljs-number">110592</span>, <span class="hljs-number">112500</span>, <span class="hljs-number">115200</span>, <span class="hljs-number">116640</span>, <span class="hljs-number">118098</span>, <span class="hljs-number">120000</span>, <span class="hljs-number">121500</span>, <span class="hljs-number">122880</span>, <span class="hljs-number">124416</span>, <span class="hljs-number">125000</span>, <span class="hljs-number">128000</span>, <span class="hljs-number">129600</span>, <span class="hljs-number">131072</span>, <span class="hljs-number">131220</span>, <span class="hljs-number">135000</span>, <span class="hljs-number">138240</span>, <span class="hljs-number">139968</span>, <span class="hljs-number">140625</span>, <span class="hljs-number">144000</span>, <span class="hljs-number">145800</span>, <span class="hljs-number">147456</span>, <span class="hljs-number">150000</span>, <span class="hljs-number">151875</span>, <span class="hljs-number">153600</span>, <span class="hljs-number">155520</span>, <span class="hljs-number">156250</span>, <span class="hljs-number">157464</span>, <span class="hljs-number">160000</span>, <span class="hljs-number">162000</span>, <span class="hljs-number">163840</span>, <span class="hljs-number">164025</span>, <span class="hljs-number">165888</span>, <span class="hljs-number">168750</span>, <span class="hljs-number">172800</span>, <span class="hljs-number">174960</span>, <span class="hljs-number">177147</span>, <span class="hljs-number">180000</span>, <span class="hljs-number">182250</span>, <span class="hljs-number">184320</span>, <span class="hljs-number">186624</span>, <span class="hljs-number">187500</span>, <span class="hljs-number">192000</span>, <span class="hljs-number">194400</span>, <span class="hljs-number">196608</span>, <span class="hljs-number">196830</span>, <span class="hljs-number">200000</span>, <span class="hljs-number">202500</span>, <span class="hljs-number">204800</span>, <span class="hljs-number">207360</span>, <span class="hljs-number">209952</span>, <span class="hljs-number">216000</span>, <span class="hljs-number">218700</span>, <span class="hljs-number">221184</span>, <span class="hljs-number">225000</span>, <span class="hljs-number">230400</span>, <span class="hljs-number">233280</span>, <span class="hljs-number">234375</span>, <span class="hljs-number">236196</span>, <span class="hljs-number">240000</span>, <span class="hljs-number">243000</span>, <span class="hljs-number">245760</span>, <span class="hljs-number">248832</span>, <span class="hljs-number">250000</span>, <span class="hljs-number">253125</span>, <span class="hljs-number">256000</span>, <span class="hljs-number">259200</span>, <span class="hljs-number">262144</span>, <span class="hljs-number">262440</span>, <span class="hljs-number">270000</span>, <span class="hljs-number">273375</span>, <span class="hljs-number">276480</span>, <span class="hljs-number">279936</span>, <span class="hljs-number">281250</span>, <span class="hljs-number">288000</span>, <span class="hljs-number">291600</span>, <span class="hljs-number">294912</span>, <span class="hljs-number">295245</span>, <span class="hljs-number">300000</span>, <span class="hljs-number">303750</span>, <span class="hljs-number">307200</span>, <span class="hljs-number">311040</span>, <span class="hljs-number">312500</span>, <span class="hljs-number">314928</span>, <span class="hljs-number">320000</span>, <span class="hljs-number">324000</span>, <span class="hljs-number">327680</span>, <span class="hljs-number">328050</span>, <span class="hljs-number">331776</span>, <span class="hljs-number">337500</span>, <span class="hljs-number">345600</span>, <span class="hljs-number">349920</span>, <span class="hljs-number">354294</span>, <span class="hljs-number">360000</span>, <span class="hljs-number">364500</span>, <span class="hljs-number">368640</span>, <span class="hljs-number">373248</span>, <span class="hljs-number">375000</span>, <span class="hljs-number">384000</span>, <span class="hljs-number">388800</span>, <span class="hljs-number">390625</span>, <span class="hljs-number">393216</span>, <span class="hljs-number">393660</span>, <span class="hljs-number">400000</span>, <span class="hljs-number">405000</span>, <span class="hljs-number">409600</span>, <span class="hljs-number">414720</span>, <span class="hljs-number">419904</span>, <span class="hljs-number">421875</span>, <span class="hljs-number">432000</span>, <span class="hljs-number">437400</span>, <span class="hljs-number">442368</span>, <span class="hljs-number">450000</span>, <span class="hljs-number">455625</span>, <span class="hljs-number">460800</span>, <span class="hljs-number">466560</span>, <span class="hljs-number">468750</span>, <span class="hljs-number">472392</span>, <span class="hljs-number">480000</span>, <span class="hljs-number">486000</span>, <span class="hljs-number">491520</span>, <span class="hljs-number">492075</span>, <span class="hljs-number">497664</span>, <span class="hljs-number">500000</span>, <span class="hljs-number">506250</span>, <span class="hljs-number">512000</span>, <span class="hljs-number">518400</span>, <span class="hljs-number">524288</span>, <span class="hljs-number">524880</span>, <span class="hljs-number">531441</span>, <span class="hljs-number">540000</span>, <span class="hljs-number">546750</span>, <span class="hljs-number">552960</span>, <span class="hljs-number">559872</span>, <span class="hljs-number">562500</span>, <span class="hljs-number">576000</span>, <span class="hljs-number">583200</span>, <span class="hljs-number">589824</span>, <span class="hljs-number">590490</span>, <span class="hljs-number">600000</span>, <span class="hljs-number">607500</span>, <span class="hljs-number">614400</span>, <span class="hljs-number">622080</span>, <span class="hljs-number">625000</span>, <span class="hljs-number">629856</span>, <span class="hljs-number">640000</span>, <span class="hljs-number">648000</span>, <span class="hljs-number">655360</span>, <span class="hljs-number">656100</span>, <span class="hljs-number">663552</span>, <span class="hljs-number">675000</span>, <span class="hljs-number">691200</span>, <span class="hljs-number">699840</span>, <span class="hljs-number">703125</span>, <span class="hljs-number">708588</span>, <span class="hljs-number">720000</span>, <span class="hljs-number">729000</span>, <span class="hljs-number">737280</span>, <span class="hljs-number">746496</span>, <span class="hljs-number">750000</span>, <span class="hljs-number">759375</span>, <span class="hljs-number">768000</span>, <span class="hljs-number">777600</span>, <span class="hljs-number">781250</span>, <span class="hljs-number">786432</span>, <span class="hljs-number">787320</span>, <span class="hljs-number">800000</span>, <span class="hljs-number">810000</span>, <span class="hljs-number">819200</span>, <span class="hljs-number">820125</span>, <span class="hljs-number">829440</span>, <span class="hljs-number">839808</span>, <span class="hljs-number">843750</span>, <span class="hljs-number">864000</span>, <span class="hljs-number">874800</span>, <span class="hljs-number">884736</span>, <span class="hljs-number">885735</span>, <span class="hljs-number">900000</span>, <span class="hljs-number">911250</span>, <span class="hljs-number">921600</span>, <span class="hljs-number">933120</span>, <span class="hljs-number">937500</span>, <span class="hljs-number">944784</span>, <span class="hljs-number">960000</span>, <span class="hljs-number">972000</span>, <span class="hljs-number">983040</span>, <span class="hljs-number">984150</span>, <span class="hljs-number">995328</span>, <span class="hljs-number">1000000</span>, <span class="hljs-number">1012500</span>, <span class="hljs-number">1024000</span>, <span class="hljs-number">1036800</span>, <span class="hljs-number">1048576</span>, <span class="hljs-number">1049760</span>, <span class="hljs-number">1062882</span>, <span class="hljs-number">1080000</span>, <span class="hljs-number">1093500</span>, <span class="hljs-number">1105920</span>, <span class="hljs-number">1119744</span>, <span class="hljs-number">1125000</span>, <span class="hljs-number">1152000</span>, <span class="hljs-number">1166400</span>, <span class="hljs-number">1171875</span>, <span class="hljs-number">1179648</span>, <span class="hljs-number">1180980</span>, <span class="hljs-number">1200000</span>, <span class="hljs-number">1215000</span>, <span class="hljs-number">1228800</span>, <span class="hljs-number">1244160</span>, <span class="hljs-number">1250000</span>, <span class="hljs-number">1259712</span>, <span class="hljs-number">1265625</span>, <span class="hljs-number">1280000</span>, <span class="hljs-number">1296000</span>, <span class="hljs-number">1310720</span>, <span class="hljs-number">1312200</span>, <span class="hljs-number">1327104</span>, <span class="hljs-number">1350000</span>, <span class="hljs-number">1366875</span>, <span class="hljs-number">1382400</span>, <span class="hljs-number">1399680</span>, <span class="hljs-number">1406250</span>, <span class="hljs-number">1417176</span>, <span class="hljs-number">1440000</span>, <span class="hljs-number">1458000</span>, <span class="hljs-number">1474560</span>, <span class="hljs-number">1476225</span>, <span class="hljs-number">1492992</span>, <span class="hljs-number">1500000</span>, <span class="hljs-number">1518750</span>, <span class="hljs-number">1536000</span>, <span class="hljs-number">1555200</span>, <span class="hljs-number">1562500</span>, <span class="hljs-number">1572864</span>, <span class="hljs-number">1574640</span>, <span class="hljs-number">1594323</span>, <span class="hljs-number">1600000</span>, <span class="hljs-number">1620000</span>, <span class="hljs-number">1638400</span>, <span class="hljs-number">1640250</span>, <span class="hljs-number">1658880</span>, <span class="hljs-number">1679616</span>, <span class="hljs-number">1687500</span>, <span class="hljs-number">1728000</span>, <span class="hljs-number">1749600</span>, <span class="hljs-number">1769472</span>, <span class="hljs-number">1771470</span>, <span class="hljs-number">1800000</span>, <span class="hljs-number">1822500</span>, <span class="hljs-number">1843200</span>, <span class="hljs-number">1866240</span>, <span class="hljs-number">1875000</span>, <span class="hljs-number">1889568</span>, <span class="hljs-number">1920000</span>, <span class="hljs-number">1944000</span>, <span class="hljs-number">1953125</span>, <span class="hljs-number">1966080</span>, <span class="hljs-number">1968300</span>, <span class="hljs-number">1990656</span>, <span class="hljs-number">2000000</span>, <span class="hljs-number">2025000</span>, <span class="hljs-number">2048000</span>, <span class="hljs-number">2073600</span>, <span class="hljs-number">2097152</span>, <span class="hljs-number">2099520</span>, <span class="hljs-number">2109375</span>, <span class="hljs-number">2125764</span>, <span class="hljs-number">2160000</span>, <span class="hljs-number">2187000</span>, <span class="hljs-number">2211840</span>, <span class="hljs-number">2239488</span>, <span class="hljs-number">2250000</span>, <span class="hljs-number">2278125</span>, <span class="hljs-number">2304000</span>, <span class="hljs-number">2332800</span>, <span class="hljs-number">2343750</span>, <span class="hljs-number">2359296</span>, <span class="hljs-number">2361960</span>, <span class="hljs-number">2400000</span>, <span class="hljs-number">2430000</span>, <span class="hljs-number">2457600</span>, <span class="hljs-number">2460375</span>, <span class="hljs-number">2488320</span>, <span class="hljs-number">2500000</span>, <span class="hljs-number">2519424</span>, <span class="hljs-number">2531250</span>, <span class="hljs-number">2560000</span>, <span class="hljs-number">2592000</span>, <span class="hljs-number">2621440</span>, <span class="hljs-number">2624400</span>, <span class="hljs-number">2654208</span>, <span class="hljs-number">2657205</span>, <span class="hljs-number">2700000</span>, <span class="hljs-number">2733750</span>, <span class="hljs-number">2764800</span>, <span class="hljs-number">2799360</span>, <span class="hljs-number">2812500</span>, <span class="hljs-number">2834352</span>, <span class="hljs-number">2880000</span>, <span class="hljs-number">2916000</span>, <span class="hljs-number">2949120</span>, <span class="hljs-number">2952450</span>, <span class="hljs-number">2985984</span>, <span class="hljs-number">3000000</span>, <span class="hljs-number">3037500</span>, <span class="hljs-number">3072000</span>, <span class="hljs-number">3110400</span>, <span class="hljs-number">3125000</span>, <span class="hljs-number">3145728</span>, <span class="hljs-number">3149280</span>, <span class="hljs-number">3188646</span>, <span class="hljs-number">3200000</span>, <span class="hljs-number">3240000</span>, <span class="hljs-number">3276800</span>, <span class="hljs-number">3280500</span>, <span class="hljs-number">3317760</span>, <span class="hljs-number">3359232</span>, <span class="hljs-number">3375000</span>, <span class="hljs-number">3456000</span>, <span class="hljs-number">3499200</span>, <span class="hljs-number">3515625</span>, <span class="hljs-number">3538944</span>, <span class="hljs-number">3542940</span>, <span class="hljs-number">3600000</span>, <span class="hljs-number">3645000</span>, <span class="hljs-number">3686400</span>, <span class="hljs-number">3732480</span>, <span class="hljs-number">3750000</span>, <span class="hljs-number">3779136</span>, <span class="hljs-number">3796875</span>, <span class="hljs-number">3840000</span>, <span class="hljs-number">3888000</span>, <span class="hljs-number">3906250</span>, <span class="hljs-number">3932160</span>, <span class="hljs-number">3936600</span>, <span class="hljs-number">3981312</span>, <span class="hljs-number">4000000</span>, <span class="hljs-number">4050000</span>, <span class="hljs-number">4096000</span>, <span class="hljs-number">4100625</span>, <span class="hljs-number">4147200</span>, <span class="hljs-number">4194304</span>, <span class="hljs-number">4199040</span>, <span class="hljs-number">4218750</span>, <span class="hljs-number">4251528</span>, <span class="hljs-number">4320000</span>, <span class="hljs-number">4374000</span>, <span class="hljs-number">4423680</span>, <span class="hljs-number">4428675</span>, <span class="hljs-number">4478976</span>, <span class="hljs-number">4500000</span>, <span class="hljs-number">4556250</span>, <span class="hljs-number">4608000</span>, <span class="hljs-number">4665600</span>, <span class="hljs-number">4687500</span>, <span class="hljs-number">4718592</span>, <span class="hljs-number">4723920</span>, <span class="hljs-number">4782969</span>, <span class="hljs-number">4800000</span>, <span class="hljs-number">4860000</span>, <span class="hljs-number">4915200</span>, <span class="hljs-number">4920750</span>, <span class="hljs-number">4976640</span>, <span class="hljs-number">5000000</span>, <span class="hljs-number">5038848</span>, <span class="hljs-number">5062500</span>, <span class="hljs-number">5120000</span>, <span class="hljs-number">5184000</span>, <span class="hljs-number">5242880</span>, <span class="hljs-number">5248800</span>, <span class="hljs-number">5308416</span>, <span class="hljs-number">5314410</span>, <span class="hljs-number">5400000</span>, <span class="hljs-number">5467500</span>, <span class="hljs-number">5529600</span>, <span class="hljs-number">5598720</span>, <span class="hljs-number">5625000</span>, <span class="hljs-number">5668704</span>, <span class="hljs-number">5760000</span>, <span class="hljs-number">5832000</span>, <span class="hljs-number">5859375</span>, <span class="hljs-number">5898240</span>, <span class="hljs-number">5904900</span>, <span class="hljs-number">5971968</span>, <span class="hljs-number">6000000</span>, <span class="hljs-number">6075000</span>, <span class="hljs-number">6144000</span>, <span class="hljs-number">6220800</span>, <span class="hljs-number">6250000</span>, <span class="hljs-number">6291456</span>, <span class="hljs-number">6298560</span>, <span class="hljs-number">6328125</span>, <span class="hljs-number">6377292</span>, <span class="hljs-number">6400000</span>, <span class="hljs-number">6480000</span>, <span class="hljs-number">6553600</span>, <span class="hljs-number">6561000</span>, <span class="hljs-number">6635520</span>, <span class="hljs-number">6718464</span>, <span class="hljs-number">6750000</span>, <span class="hljs-number">6834375</span>, <span class="hljs-number">6912000</span>, <span class="hljs-number">6998400</span>, <span class="hljs-number">7031250</span>, <span class="hljs-number">7077888</span>, <span class="hljs-number">7085880</span>, <span class="hljs-number">7200000</span>, <span class="hljs-number">7290000</span>, <span class="hljs-number">7372800</span>, <span class="hljs-number">7381125</span>, <span class="hljs-number">7464960</span>, <span class="hljs-number">7500000</span>, <span class="hljs-number">7558272</span>, <span class="hljs-number">7593750</span>, <span class="hljs-number">7680000</span>, <span class="hljs-number">7776000</span>, <span class="hljs-number">7812500</span>, <span class="hljs-number">7864320</span>, <span class="hljs-number">7873200</span>, <span class="hljs-number">7962624</span>, <span class="hljs-number">7971615</span>, <span class="hljs-number">8000000</span>, <span class="hljs-number">8100000</span>, <span class="hljs-number">8192000</span>, <span class="hljs-number">8201250</span>, <span class="hljs-number">8294400</span>, <span class="hljs-number">8388608</span>, <span class="hljs-number">8398080</span>, <span class="hljs-number">8437500</span>, <span class="hljs-number">8503056</span>, <span class="hljs-number">8640000</span>, <span class="hljs-number">8748000</span>, <span class="hljs-number">8847360</span>, <span class="hljs-number">8857350</span>, <span class="hljs-number">8957952</span>, <span class="hljs-number">9000000</span>, <span class="hljs-number">9112500</span>, <span class="hljs-number">9216000</span>, <span class="hljs-number">9331200</span>, <span class="hljs-number">9375000</span>, <span class="hljs-number">9437184</span>, <span class="hljs-number">9447840</span>, <span class="hljs-number">9565938</span>, <span class="hljs-number">9600000</span>, <span class="hljs-number">9720000</span>, <span class="hljs-number">9765625</span>, <span class="hljs-number">9830400</span>, <span class="hljs-number">9841500</span>, <span class="hljs-number">9953280</span>, <span class="hljs-number">10000000</span>, <span class="hljs-number">10077696</span>, <span class="hljs-number">10125000</span>, <span class="hljs-number">10240000</span>, <span class="hljs-number">10368000</span>, <span class="hljs-number">10485760</span>, <span class="hljs-number">10497600</span>, <span class="hljs-number">10546875</span>, <span class="hljs-number">10616832</span>, <span class="hljs-number">10628820</span>, <span class="hljs-number">10800000</span>, <span class="hljs-number">10935000</span>, <span class="hljs-number">11059200</span>, <span class="hljs-number">11197440</span>, <span class="hljs-number">11250000</span>, <span class="hljs-number">11337408</span>, <span class="hljs-number">11390625</span>, <span class="hljs-number">11520000</span>, <span class="hljs-number">11664000</span>, <span class="hljs-number">11718750</span>, <span class="hljs-number">11796480</span>, <span class="hljs-number">11809800</span>, <span class="hljs-number">11943936</span>, <span class="hljs-number">12000000</span>, <span class="hljs-number">12150000</span>, <span class="hljs-number">12288000</span>, <span class="hljs-number">12301875</span>, <span class="hljs-number">12441600</span>, <span class="hljs-number">12500000</span>, <span class="hljs-number">12582912</span>, <span class="hljs-number">12597120</span>, <span class="hljs-number">12656250</span>, <span class="hljs-number">12754584</span>, <span class="hljs-number">12800000</span>, <span class="hljs-number">12960000</span>, <span class="hljs-number">13107200</span>, <span class="hljs-number">13122000</span>, <span class="hljs-number">13271040</span>, <span class="hljs-number">13286025</span>, <span class="hljs-number">13436928</span>, <span class="hljs-number">13500000</span>, <span class="hljs-number">13668750</span>, <span class="hljs-number">13824000</span>, <span class="hljs-number">13996800</span>, <span class="hljs-number">14062500</span>, <span class="hljs-number">14155776</span>, <span class="hljs-number">14171760</span>, <span class="hljs-number">14348907</span>, <span class="hljs-number">14400000</span>, <span class="hljs-number">14580000</span>, <span class="hljs-number">14745600</span>, <span class="hljs-number">14762250</span>, <span class="hljs-number">14929920</span>, <span class="hljs-number">15000000</span>, <span class="hljs-number">15116544</span>, <span class="hljs-number">15187500</span>, <span class="hljs-number">15360000</span>, <span class="hljs-number">15552000</span>, <span class="hljs-number">15625000</span>, <span class="hljs-number">15728640</span>, <span class="hljs-number">15746400</span>, <span class="hljs-number">15925248</span>, <span class="hljs-number">15943230</span>, <span class="hljs-number">16000000</span>, <span class="hljs-number">16200000</span>, <span class="hljs-number">16384000</span>, <span class="hljs-number">16402500</span>, <span class="hljs-number">16588800</span>, <span class="hljs-number">16777216</span>, <span class="hljs-number">16796160</span>, <span class="hljs-number">16875000</span>, <span class="hljs-number">17006112</span>, <span class="hljs-number">17280000</span>, <span class="hljs-number">17496000</span>, <span class="hljs-number">17578125</span>, <span class="hljs-number">17694720</span>, <span class="hljs-number">17714700</span>, <span class="hljs-number">17915904</span>, <span class="hljs-number">18000000</span>, <span class="hljs-number">18225000</span>, <span class="hljs-number">18432000</span>, <span class="hljs-number">18662400</span>, <span class="hljs-number">18750000</span>, <span class="hljs-number">18874368</span>, <span class="hljs-number">18895680</span>, <span class="hljs-number">18984375</span>, <span class="hljs-number">19131876</span>, <span class="hljs-number">19200000</span>, <span class="hljs-number">19440000</span>, <span class="hljs-number">19531250</span>, <span class="hljs-number">19660800</span>, <span class="hljs-number">19683000</span>, <span class="hljs-number">19906560</span>, <span class="hljs-number">20000000</span>, <span class="hljs-number">20155392</span>, <span class="hljs-number">20250000</span>, <span class="hljs-number">20480000</span>, <span class="hljs-number">20503125</span>, <span class="hljs-number">20736000</span>, <span class="hljs-number">20971520</span>, <span class="hljs-number">20995200</span>, <span class="hljs-number">21093750</span>, <span class="hljs-number">21233664</span>, <span class="hljs-number">21257640</span>, <span class="hljs-number">21600000</span>, <span class="hljs-number">21870000</span>, <span class="hljs-number">22118400</span>, <span class="hljs-number">22143375</span>, <span class="hljs-number">22394880</span>, <span class="hljs-number">22500000</span>, <span class="hljs-number">22674816</span>, <span class="hljs-number">22781250</span>, <span class="hljs-number">23040000</span>, <span class="hljs-number">23328000</span>, <span class="hljs-number">23437500</span>, <span class="hljs-number">23592960</span>, <span class="hljs-number">23619600</span>, <span class="hljs-number">23887872</span>, <span class="hljs-number">23914845</span>, <span class="hljs-number">24000000</span>, <span class="hljs-number">24300000</span>, <span class="hljs-number">24576000</span>, <span class="hljs-number">24603750</span>, <span class="hljs-number">24883200</span>, <span class="hljs-number">25000000</span>, <span class="hljs-number">25165824</span>, <span class="hljs-number">25194240</span>, <span class="hljs-number">25312500</span>, <span class="hljs-number">25509168</span>, <span class="hljs-number">25600000</span>, <span class="hljs-number">25920000</span>, <span class="hljs-number">26214400</span>, <span class="hljs-number">26244000</span>, <span class="hljs-number">26542080</span>, <span class="hljs-number">26572050</span>, <span class="hljs-number">26873856</span>, <span class="hljs-number">27000000</span>, <span class="hljs-number">27337500</span>, <span class="hljs-number">27648000</span>, <span class="hljs-number">27993600</span>, <span class="hljs-number">28125000</span>, <span class="hljs-number">28311552</span>, <span class="hljs-number">28343520</span>, <span class="hljs-number">28697814</span>, <span class="hljs-number">28800000</span>, <span class="hljs-number">29160000</span>, <span class="hljs-number">29296875</span>, <span class="hljs-number">29491200</span>, <span class="hljs-number">29524500</span>, <span class="hljs-number">29859840</span>, <span class="hljs-number">30000000</span>, <span class="hljs-number">30233088</span>, <span class="hljs-number">30375000</span>, <span class="hljs-number">30720000</span>, <span class="hljs-number">31104000</span>, <span class="hljs-number">31250000</span>, <span class="hljs-number">31457280</span>, <span class="hljs-number">31492800</span>, <span class="hljs-number">31640625</span>, <span class="hljs-number">31850496</span>, <span class="hljs-number">31886460</span>, <span class="hljs-number">32000000</span>, <span class="hljs-number">32400000</span>, <span class="hljs-number">32768000</span>, <span class="hljs-number">32805000</span>, <span class="hljs-number">33177600</span>, <span class="hljs-number">33554432</span>, <span class="hljs-number">33592320</span>, <span class="hljs-number">33750000</span>, <span class="hljs-number">34012224</span>, <span class="hljs-number">34171875</span>, <span class="hljs-number">34560000</span>, <span class="hljs-number">34992000</span>, <span class="hljs-number">35156250</span>, <span class="hljs-number">35389440</span>, <span class="hljs-number">35429400</span>, <span class="hljs-number">35831808</span>, <span class="hljs-number">36000000</span>, <span class="hljs-number">36450000</span>, <span class="hljs-number">36864000</span>, <span class="hljs-number">36905625</span>, <span class="hljs-number">37324800</span>, <span class="hljs-number">37500000</span>, <span class="hljs-number">37748736</span>, <span class="hljs-number">37791360</span>, <span class="hljs-number">37968750</span>, <span class="hljs-number">38263752</span>, <span class="hljs-number">38400000</span>, <span class="hljs-number">38880000</span>, <span class="hljs-number">39062500</span>, <span class="hljs-number">39321600</span>, <span class="hljs-number">39366000</span>, <span class="hljs-number">39813120</span>, <span class="hljs-number">39858075</span>, <span class="hljs-number">40000000</span>, <span class="hljs-number">40310784</span>, <span class="hljs-number">40500000</span>, <span class="hljs-number">40960000</span>, <span class="hljs-number">41006250</span>, <span class="hljs-number">41472000</span>, <span class="hljs-number">41943040</span>, <span class="hljs-number">41990400</span>, <span class="hljs-number">42187500</span>, <span class="hljs-number">42467328</span>, <span class="hljs-number">42515280</span>, <span class="hljs-number">43046721</span>, <span class="hljs-number">43200000</span>, <span class="hljs-number">43740000</span>, <span class="hljs-number">44236800</span>, <span class="hljs-number">44286750</span>, <span class="hljs-number">44789760</span>, <span class="hljs-number">45000000</span>, <span class="hljs-number">45349632</span>, <span class="hljs-number">45562500</span>, <span class="hljs-number">46080000</span>, <span class="hljs-number">46656000</span>, <span class="hljs-number">46875000</span>, <span class="hljs-number">47185920</span>, <span class="hljs-number">47239200</span>, <span class="hljs-number">47775744</span>, <span class="hljs-number">47829690</span>, <span class="hljs-number">48000000</span>, <span class="hljs-number">48600000</span>, <span class="hljs-number">48828125</span>, <span class="hljs-number">49152000</span>, <span class="hljs-number">49207500</span>, <span class="hljs-number">49766400</span>, <span class="hljs-number">50000000</span>, <span class="hljs-number">50331648</span>, <span class="hljs-number">50388480</span>, <span class="hljs-number">50625000</span>, <span class="hljs-number">51018336</span>, <span class="hljs-number">51200000</span>, <span class="hljs-number">51840000</span>, <span class="hljs-number">52428800</span>, <span class="hljs-number">52488000</span>, <span class="hljs-number">52734375</span>, <span class="hljs-number">53084160</span>, <span class="hljs-number">53144100</span>, <span class="hljs-number">53747712</span>, <span class="hljs-number">54000000</span>, <span class="hljs-number">54675000</span>, <span class="hljs-number">55296000</span>, <span class="hljs-number">55987200</span>, <span class="hljs-number">56250000</span>, <span class="hljs-number">56623104</span>, <span class="hljs-number">56687040</span>, <span class="hljs-number">56953125</span>, <span class="hljs-number">57395628</span>, <span class="hljs-number">57600000</span>, <span class="hljs-number">58320000</span>, <span class="hljs-number">58593750</span>, <span class="hljs-number">58982400</span>, <span class="hljs-number">59049000</span>, <span class="hljs-number">59719680</span>, <span class="hljs-number">60000000</span>, <span class="hljs-number">60466176</span>, <span class="hljs-number">60750000</span>, <span class="hljs-number">61440000</span>, <span class="hljs-number">61509375</span>, <span class="hljs-number">62208000</span>, <span class="hljs-number">62500000</span>, <span class="hljs-number">62914560</span>, <span class="hljs-number">62985600</span>, <span class="hljs-number">63281250</span>, <span class="hljs-number">63700992</span>, <span class="hljs-number">63772920</span>, <span class="hljs-number">64000000</span>, <span class="hljs-number">64800000</span>, <span class="hljs-number">65536000</span>, <span class="hljs-number">65610000</span>, <span class="hljs-number">66355200</span>, <span class="hljs-number">66430125</span>, <span class="hljs-number">67108864</span>, <span class="hljs-number">67184640</span>, <span class="hljs-number">67500000</span>, <span class="hljs-number">68024448</span>, <span class="hljs-number">68343750</span>, <span class="hljs-number">69120000</span>, <span class="hljs-number">69984000</span>, <span class="hljs-number">70312500</span>, <span class="hljs-number">70778880</span>, <span class="hljs-number">70858800</span>, <span class="hljs-number">71663616</span>, <span class="hljs-number">71744535</span>, <span class="hljs-number">72000000</span>, <span class="hljs-number">72900000</span>, <span class="hljs-number">73728000</span>, <span class="hljs-number">73811250</span>, <span class="hljs-number">74649600</span>, <span class="hljs-number">75000000</span>, <span class="hljs-number">75497472</span>, <span class="hljs-number">75582720</span>, <span class="hljs-number">75937500</span>, <span class="hljs-number">76527504</span>, <span class="hljs-number">76800000</span>, <span class="hljs-number">77760000</span>, <span class="hljs-number">78125000</span>, <span class="hljs-number">78643200</span>, <span class="hljs-number">78732000</span>, <span class="hljs-number">79626240</span>, <span class="hljs-number">79716150</span>, <span class="hljs-number">80000000</span>, <span class="hljs-number">80621568</span>, <span class="hljs-number">81000000</span>, <span class="hljs-number">81920000</span>, <span class="hljs-number">82012500</span>, <span class="hljs-number">82944000</span>, <span class="hljs-number">83886080</span>, <span class="hljs-number">83980800</span>, <span class="hljs-number">84375000</span>, <span class="hljs-number">84934656</span>, <span class="hljs-number">85030560</span>, <span class="hljs-number">86093442</span>, <span class="hljs-number">86400000</span>, <span class="hljs-number">87480000</span>, <span class="hljs-number">87890625</span>, <span class="hljs-number">88473600</span>, <span class="hljs-number">88573500</span>, <span class="hljs-number">89579520</span>, <span class="hljs-number">90000000</span>, <span class="hljs-number">90699264</span>, <span class="hljs-number">91125000</span>, <span class="hljs-number">92160000</span>, <span class="hljs-number">93312000</span>, <span class="hljs-number">93750000</span>, <span class="hljs-number">94371840</span>, <span class="hljs-number">94478400</span>, <span class="hljs-number">94921875</span>, <span class="hljs-number">95551488</span>, <span class="hljs-number">95659380</span>, <span class="hljs-number">96000000</span>, <span class="hljs-number">97200000</span>, <span class="hljs-number">97656250</span>, <span class="hljs-number">98304000</span>, <span class="hljs-number">98415000</span>, <span class="hljs-number">99532800</span>, <span class="hljs-number">100000000</span>, <span class="hljs-number">100663296</span>, <span class="hljs-number">100776960</span>, <span class="hljs-number">101250000</span>, <span class="hljs-number">102036672</span>, <span class="hljs-number">102400000</span>, <span class="hljs-number">102515625</span>, <span class="hljs-number">103680000</span>, <span class="hljs-number">104857600</span>, <span class="hljs-number">104976000</span>, <span class="hljs-number">105468750</span>, <span class="hljs-number">106168320</span>, <span class="hljs-number">106288200</span>, <span class="hljs-number">107495424</span>, <span class="hljs-number">108000000</span>, <span class="hljs-number">109350000</span>, <span class="hljs-number">110592000</span>, <span class="hljs-number">110716875</span>, <span class="hljs-number">111974400</span>, <span class="hljs-number">112500000</span>, <span class="hljs-number">113246208</span>, <span class="hljs-number">113374080</span>, <span class="hljs-number">113906250</span>, <span class="hljs-number">114791256</span>, <span class="hljs-number">115200000</span>, <span class="hljs-number">116640000</span>, <span class="hljs-number">117187500</span>, <span class="hljs-number">117964800</span>, <span class="hljs-number">118098000</span>, <span class="hljs-number">119439360</span>, <span class="hljs-number">119574225</span>, <span class="hljs-number">120000000</span>, <span class="hljs-number">120932352</span>, <span class="hljs-number">121500000</span>, <span class="hljs-number">122880000</span>, <span class="hljs-number">123018750</span>, <span class="hljs-number">124416000</span>, <span class="hljs-number">125000000</span>, <span class="hljs-number">125829120</span>, <span class="hljs-number">125971200</span>, <span class="hljs-number">126562500</span>, <span class="hljs-number">127401984</span>, <span class="hljs-number">127545840</span>, <span class="hljs-number">128000000</span>, <span class="hljs-number">129140163</span>, <span class="hljs-number">129600000</span>, <span class="hljs-number">131072000</span>, <span class="hljs-number">131220000</span>, <span class="hljs-number">132710400</span>, <span class="hljs-number">132860250</span>, <span class="hljs-number">134217728</span>, <span class="hljs-number">134369280</span>, <span class="hljs-number">135000000</span>, <span class="hljs-number">136048896</span>, <span class="hljs-number">136687500</span>, <span class="hljs-number">138240000</span>, <span class="hljs-number">139968000</span>, <span class="hljs-number">140625000</span>, <span class="hljs-number">141557760</span>, <span class="hljs-number">141717600</span>, <span class="hljs-number">143327232</span>, <span class="hljs-number">143489070</span>, <span class="hljs-number">144000000</span>, <span class="hljs-number">145800000</span>, <span class="hljs-number">146484375</span>, <span class="hljs-number">147456000</span>, <span class="hljs-number">147622500</span>, <span class="hljs-number">149299200</span>, <span class="hljs-number">150000000</span>, <span class="hljs-number">150994944</span>, <span class="hljs-number">151165440</span>, <span class="hljs-number">151875000</span>, <span class="hljs-number">153055008</span>, <span class="hljs-number">153600000</span>, <span class="hljs-number">155520000</span>, <span class="hljs-number">156250000</span>, <span class="hljs-number">157286400</span>, <span class="hljs-number">157464000</span>, <span class="hljs-number">158203125</span>, <span class="hljs-number">159252480</span>, <span class="hljs-number">159432300</span>, <span class="hljs-number">160000000</span>, <span class="hljs-number">161243136</span>, <span class="hljs-number">162000000</span>, <span class="hljs-number">163840000</span>, <span class="hljs-number">164025000</span>, <span class="hljs-number">165888000</span>, <span class="hljs-number">167772160</span>, <span class="hljs-number">167961600</span>, <span class="hljs-number">168750000</span>, <span class="hljs-number">169869312</span>, <span class="hljs-number">170061120</span>, <span class="hljs-number">170859375</span>, <span class="hljs-number">172186884</span>, <span class="hljs-number">172800000</span>, <span class="hljs-number">174960000</span>, <span class="hljs-number">175781250</span>, <span class="hljs-number">176947200</span>, <span class="hljs-number">177147000</span>, <span class="hljs-number">179159040</span>, <span class="hljs-number">180000000</span>, <span class="hljs-number">181398528</span>, <span class="hljs-number">182250000</span>, <span class="hljs-number">184320000</span>, <span class="hljs-number">184528125</span>, <span class="hljs-number">186624000</span>, <span class="hljs-number">187500000</span>, <span class="hljs-number">188743680</span>, <span class="hljs-number">188956800</span>, <span class="hljs-number">189843750</span>, <span class="hljs-number">191102976</span>, <span class="hljs-number">191318760</span>, <span class="hljs-number">192000000</span>, <span class="hljs-number">194400000</span>, <span class="hljs-number">195312500</span>, <span class="hljs-number">196608000</span>, <span class="hljs-number">196830000</span>, <span class="hljs-number">199065600</span>, <span class="hljs-number">199290375</span>, <span class="hljs-number">200000000</span>, <span class="hljs-number">201326592</span>, <span class="hljs-number">201553920</span>, <span class="hljs-number">202500000</span>, <span class="hljs-number">204073344</span>, <span class="hljs-number">204800000</span>, <span class="hljs-number">205031250</span>, <span class="hljs-number">207360000</span>, <span class="hljs-number">209715200</span>, <span class="hljs-number">209952000</span>, <span class="hljs-number">210937500</span>, <span class="hljs-number">212336640</span>, <span class="hljs-number">212576400</span>, <span class="hljs-number">214990848</span>, <span class="hljs-number">215233605</span>, <span class="hljs-number">216000000</span>, <span class="hljs-number">218700000</span>, <span class="hljs-number">221184000</span>, <span class="hljs-number">221433750</span>, <span class="hljs-number">223948800</span>, <span class="hljs-number">225000000</span>, <span class="hljs-number">226492416</span>, <span class="hljs-number">226748160</span>, <span class="hljs-number">227812500</span>, <span class="hljs-number">229582512</span>, <span class="hljs-number">230400000</span>, <span class="hljs-number">233280000</span>, <span class="hljs-number">234375000</span>, <span class="hljs-number">235929600</span>, <span class="hljs-number">236196000</span>, <span class="hljs-number">238878720</span>, <span class="hljs-number">239148450</span>, <span class="hljs-number">240000000</span>, <span class="hljs-number">241864704</span>, <span class="hljs-number">243000000</span>, <span class="hljs-number">244140625</span>, <span class="hljs-number">245760000</span>, <span class="hljs-number">246037500</span>, <span class="hljs-number">248832000</span>, <span class="hljs-number">250000000</span>, <span class="hljs-number">251658240</span>, <span class="hljs-number">251942400</span>, <span class="hljs-number">253125000</span>, <span class="hljs-number">254803968</span>, <span class="hljs-number">255091680</span>, <span class="hljs-number">256000000</span>, <span class="hljs-number">258280326</span>, <span class="hljs-number">259200000</span>, <span class="hljs-number">262144000</span>, <span class="hljs-number">262440000</span>, <span class="hljs-number">263671875</span>, <span class="hljs-number">265420800</span>, <span class="hljs-number">265720500</span>, <span class="hljs-number">268435456</span>, <span class="hljs-number">268738560</span>, <span class="hljs-number">270000000</span>, <span class="hljs-number">272097792</span>, <span class="hljs-number">273375000</span>, <span class="hljs-number">276480000</span>, <span class="hljs-number">279936000</span>, <span class="hljs-number">281250000</span>, <span class="hljs-number">283115520</span>, <span class="hljs-number">283435200</span>, <span class="hljs-number">284765625</span>, <span class="hljs-number">286654464</span>, <span class="hljs-number">286978140</span>, <span class="hljs-number">288000000</span>, <span class="hljs-number">291600000</span>, <span class="hljs-number">292968750</span>, <span class="hljs-number">294912000</span>, <span class="hljs-number">295245000</span>, <span class="hljs-number">298598400</span>, <span class="hljs-number">300000000</span>, <span class="hljs-number">301989888</span>, <span class="hljs-number">302330880</span>, <span class="hljs-number">303750000</span>, <span class="hljs-number">306110016</span>, <span class="hljs-number">307200000</span>, <span class="hljs-number">307546875</span>, <span class="hljs-number">311040000</span>, <span class="hljs-number">312500000</span>, <span class="hljs-number">314572800</span>, <span class="hljs-number">314928000</span>, <span class="hljs-number">316406250</span>, <span class="hljs-number">318504960</span>, <span class="hljs-number">318864600</span>, <span class="hljs-number">320000000</span>, <span class="hljs-number">322486272</span>, <span class="hljs-number">324000000</span>, <span class="hljs-number">327680000</span>, <span class="hljs-number">328050000</span>, <span class="hljs-number">331776000</span>, <span class="hljs-number">332150625</span>, <span class="hljs-number">335544320</span>, <span class="hljs-number">335923200</span>, <span class="hljs-number">337500000</span>, <span class="hljs-number">339738624</span>, <span class="hljs-number">340122240</span>, <span class="hljs-number">341718750</span>, <span class="hljs-number">344373768</span>, <span class="hljs-number">345600000</span>, <span class="hljs-number">349920000</span>, <span class="hljs-number">351562500</span>, <span class="hljs-number">353894400</span>, <span class="hljs-number">354294000</span>, <span class="hljs-number">358318080</span>, <span class="hljs-number">358722675</span>, <span class="hljs-number">360000000</span>, <span class="hljs-number">362797056</span>, <span class="hljs-number">364500000</span>, <span class="hljs-number">368640000</span>, <span class="hljs-number">369056250</span>, <span class="hljs-number">373248000</span>, <span class="hljs-number">375000000</span>, <span class="hljs-number">377487360</span>, <span class="hljs-number">377913600</span>, <span class="hljs-number">379687500</span>, <span class="hljs-number">382205952</span>, <span class="hljs-number">382637520</span>, <span class="hljs-number">384000000</span>, <span class="hljs-number">387420489</span>, <span class="hljs-number">388800000</span>, <span class="hljs-number">390625000</span>, <span class="hljs-number">393216000</span>, <span class="hljs-number">393660000</span>, <span class="hljs-number">398131200</span>, <span class="hljs-number">398580750</span>, <span class="hljs-number">400000000</span>, <span class="hljs-number">402653184</span>, <span class="hljs-number">403107840</span>, <span class="hljs-number">405000000</span>, <span class="hljs-number">408146688</span>, <span class="hljs-number">409600000</span>, <span class="hljs-number">410062500</span>, <span class="hljs-number">414720000</span>, <span class="hljs-number">419430400</span>, <span class="hljs-number">419904000</span>, <span class="hljs-number">421875000</span>, <span class="hljs-number">424673280</span>, <span class="hljs-number">425152800</span>, <span class="hljs-number">429981696</span>, <span class="hljs-number">430467210</span>, <span class="hljs-number">432000000</span>, <span class="hljs-number">437400000</span>, <span class="hljs-number">439453125</span>, <span class="hljs-number">442368000</span>, <span class="hljs-number">442867500</span>, <span class="hljs-number">447897600</span>, <span class="hljs-number">450000000</span>, <span class="hljs-number">452984832</span>, <span class="hljs-number">453496320</span>, <span class="hljs-number">455625000</span>, <span class="hljs-number">459165024</span>, <span class="hljs-number">460800000</span>, <span class="hljs-number">466560000</span>, <span class="hljs-number">468750000</span>, <span class="hljs-number">471859200</span>, <span class="hljs-number">472392000</span>, <span class="hljs-number">474609375</span>, <span class="hljs-number">477757440</span>, <span class="hljs-number">478296900</span>, <span class="hljs-number">480000000</span>, <span class="hljs-number">483729408</span>, <span class="hljs-number">486000000</span>, <span class="hljs-number">488281250</span>, <span class="hljs-number">491520000</span>, <span class="hljs-number">492075000</span>, <span class="hljs-number">497664000</span>, <span class="hljs-number">500000000</span>, <span class="hljs-number">503316480</span>, <span class="hljs-number">503884800</span>, <span class="hljs-number">506250000</span>, <span class="hljs-number">509607936</span>, <span class="hljs-number">510183360</span>, <span class="hljs-number">512000000</span>, <span class="hljs-number">512578125</span>, <span class="hljs-number">516560652</span>, <span class="hljs-number">518400000</span>, <span class="hljs-number">524288000</span>, <span class="hljs-number">524880000</span>, <span class="hljs-number">527343750</span>, <span class="hljs-number">530841600</span>, <span class="hljs-number">531441000</span>, <span class="hljs-number">536870912</span>, <span class="hljs-number">537477120</span>, <span class="hljs-number">540000000</span>, <span class="hljs-number">544195584</span>, <span class="hljs-number">546750000</span>, <span class="hljs-number">552960000</span>, <span class="hljs-number">553584375</span>, <span class="hljs-number">559872000</span>, <span class="hljs-number">562500000</span>, <span class="hljs-number">566231040</span>, <span class="hljs-number">566870400</span>, <span class="hljs-number">569531250</span>, <span class="hljs-number">573308928</span>, <span class="hljs-number">573956280</span>, <span class="hljs-number">576000000</span>, <span class="hljs-number">583200000</span>, <span class="hljs-number">585937500</span>, <span class="hljs-number">589824000</span>, <span class="hljs-number">590490000</span>, <span class="hljs-number">597196800</span>, <span class="hljs-number">597871125</span>, <span class="hljs-number">600000000</span>, <span class="hljs-number">603979776</span>, <span class="hljs-number">604661760</span>, <span class="hljs-number">607500000</span>, <span class="hljs-number">612220032</span>, <span class="hljs-number">614400000</span>, <span class="hljs-number">615093750</span>, <span class="hljs-number">622080000</span>, <span class="hljs-number">625000000</span>, <span class="hljs-number">629145600</span>, <span class="hljs-number">629856000</span>, <span class="hljs-number">632812500</span>, <span class="hljs-number">637009920</span>, <span class="hljs-number">637729200</span>, <span class="hljs-number">640000000</span>, <span class="hljs-number">644972544</span>, <span class="hljs-number">645700815</span>, <span class="hljs-number">648000000</span>, <span class="hljs-number">655360000</span>, <span class="hljs-number">656100000</span>, <span class="hljs-number">663552000</span>, <span class="hljs-number">664301250</span>, <span class="hljs-number">671088640</span>, <span class="hljs-number">671846400</span>, <span class="hljs-number">675000000</span>, <span class="hljs-number">679477248</span>, <span class="hljs-number">680244480</span>, <span class="hljs-number">683437500</span>, <span class="hljs-number">688747536</span>, <span class="hljs-number">691200000</span>, <span class="hljs-number">699840000</span>, <span class="hljs-number">703125000</span>, <span class="hljs-number">707788800</span>, <span class="hljs-number">708588000</span>, <span class="hljs-number">716636160</span>, <span class="hljs-number">717445350</span>, <span class="hljs-number">720000000</span>, <span class="hljs-number">725594112</span>, <span class="hljs-number">729000000</span>, <span class="hljs-number">732421875</span>, <span class="hljs-number">737280000</span>, <span class="hljs-number">738112500</span>, <span class="hljs-number">746496000</span>, <span class="hljs-number">750000000</span>, <span class="hljs-number">754974720</span>, <span class="hljs-number">755827200</span>, <span class="hljs-number">759375000</span>, <span class="hljs-number">764411904</span>, <span class="hljs-number">765275040</span>, <span class="hljs-number">768000000</span>, <span class="hljs-number">774840978</span>, <span class="hljs-number">777600000</span>, <span class="hljs-number">781250000</span>, <span class="hljs-number">786432000</span>, <span class="hljs-number">787320000</span>, <span class="hljs-number">791015625</span>, <span class="hljs-number">796262400</span>, <span class="hljs-number">797161500</span>, <span class="hljs-number">800000000</span>, <span class="hljs-number">805306368</span>, <span class="hljs-number">806215680</span>, <span class="hljs-number">810000000</span>, <span class="hljs-number">816293376</span>, <span class="hljs-number">819200000</span>, <span class="hljs-number">820125000</span>, <span class="hljs-number">829440000</span>, <span class="hljs-number">838860800</span>, <span class="hljs-number">839808000</span>, <span class="hljs-number">843750000</span>, <span class="hljs-number">849346560</span>, <span class="hljs-number">850305600</span>, <span class="hljs-number">854296875</span>, <span class="hljs-number">859963392</span>, <span class="hljs-number">860934420</span>, <span class="hljs-number">864000000</span>, <span class="hljs-number">874800000</span>, <span class="hljs-number">878906250</span>, <span class="hljs-number">884736000</span>, <span class="hljs-number">885735000</span>, <span class="hljs-number">895795200</span>, <span class="hljs-number">900000000</span>, <span class="hljs-number">905969664</span>, <span class="hljs-number">906992640</span>, <span class="hljs-number">911250000</span>, <span class="hljs-number">918330048</span>, <span class="hljs-number">921600000</span>, <span class="hljs-number">922640625</span>, <span class="hljs-number">933120000</span>, <span class="hljs-number">937500000</span>, <span class="hljs-number">943718400</span>, <span class="hljs-number">944784000</span>, <span class="hljs-number">949218750</span>, <span class="hljs-number">955514880</span>, <span class="hljs-number">956593800</span>, <span class="hljs-number">960000000</span>, <span class="hljs-number">967458816</span>, <span class="hljs-number">972000000</span>, <span class="hljs-number">976562500</span>, <span class="hljs-number">983040000</span>, <span class="hljs-number">984150000</span>, <span class="hljs-number">995328000</span>, <span class="hljs-number">996451875</span>, <span class="hljs-number">1000000000</span>, <span class="hljs-number">1006632960</span>, <span class="hljs-number">1007769600</span>, <span class="hljs-number">1012500000</span>, <span class="hljs-number">1019215872</span>, <span class="hljs-number">1020366720</span>, <span class="hljs-number">1024000000</span>, <span class="hljs-number">1025156250</span>, <span class="hljs-number">1033121304</span>, <span class="hljs-number">1036800000</span>, <span class="hljs-number">1048576000</span>, <span class="hljs-number">1049760000</span>, <span class="hljs-number">1054687500</span>, <span class="hljs-number">1061683200</span>, <span class="hljs-number">1062882000</span>, <span class="hljs-number">1073741824</span>, <span class="hljs-number">1074954240</span>, <span class="hljs-number">1076168025</span>, <span class="hljs-number">1080000000</span>, <span class="hljs-number">1088391168</span>, <span class="hljs-number">1093500000</span>, <span class="hljs-number">1105920000</span>, <span class="hljs-number">1107168750</span>, <span class="hljs-number">1119744000</span>, <span class="hljs-number">1125000000</span>, <span class="hljs-number">1132462080</span>, <span class="hljs-number">1133740800</span>, <span class="hljs-number">1139062500</span>, <span class="hljs-number">1146617856</span>, <span class="hljs-number">1147912560</span>, <span class="hljs-number">1152000000</span>, <span class="hljs-number">1162261467</span>, <span class="hljs-number">1166400000</span>, <span class="hljs-number">1171875000</span>, <span class="hljs-number">1179648000</span>, <span class="hljs-number">1180980000</span>, <span class="hljs-number">1194393600</span>, <span class="hljs-number">1195742250</span>, <span class="hljs-number">1200000000</span>, <span class="hljs-number">1207959552</span>, <span class="hljs-number">1209323520</span>, <span class="hljs-number">1215000000</span>, <span class="hljs-number">1220703125</span>, <span class="hljs-number">1224440064</span>, <span class="hljs-number">1228800000</span>, <span class="hljs-number">1230187500</span>, <span class="hljs-number">1244160000</span>, <span class="hljs-number">1250000000</span>, <span class="hljs-number">1258291200</span>, <span class="hljs-number">1259712000</span>, <span class="hljs-number">1265625000</span>, <span class="hljs-number">1274019840</span>, <span class="hljs-number">1275458400</span>, <span class="hljs-number">1280000000</span>, <span class="hljs-number">1289945088</span>, <span class="hljs-number">1291401630</span>, <span class="hljs-number">1296000000</span>, <span class="hljs-number">1310720000</span>, <span class="hljs-number">1312200000</span>, <span class="hljs-number">1318359375</span>, <span class="hljs-number">1327104000</span>, <span class="hljs-number">1328602500</span>, <span class="hljs-number">1342177280</span>, <span class="hljs-number">1343692800</span>, <span class="hljs-number">1350000000</span>, <span class="hljs-number">1358954496</span>, <span class="hljs-number">1360488960</span>, <span class="hljs-number">1366875000</span>, <span class="hljs-number">1377495072</span>, <span class="hljs-number">1382400000</span>, <span class="hljs-number">1399680000</span>, <span class="hljs-number">1406250000</span>, <span class="hljs-number">1415577600</span>, <span class="hljs-number">1417176000</span>, <span class="hljs-number">1423828125</span>, <span class="hljs-number">1433272320</span>, <span class="hljs-number">1434890700</span>, <span class="hljs-number">1440000000</span>, <span class="hljs-number">1451188224</span>, <span class="hljs-number">1458000000</span>, <span class="hljs-number">1464843750</span>, <span class="hljs-number">1474560000</span>, <span class="hljs-number">1476225000</span>, <span class="hljs-number">1492992000</span>, <span class="hljs-number">1500000000</span>, <span class="hljs-number">1509949440</span>, <span class="hljs-number">1511654400</span>, <span class="hljs-number">1518750000</span>, <span class="hljs-number">1528823808</span>, <span class="hljs-number">1530550080</span>, <span class="hljs-number">1536000000</span>, <span class="hljs-number">1537734375</span>, <span class="hljs-number">1549681956</span>, <span class="hljs-number">1555200000</span>, <span class="hljs-number">1562500000</span>, <span class="hljs-number">1572864000</span>, <span class="hljs-number">1574640000</span>, <span class="hljs-number">1582031250</span>, <span class="hljs-number">1592524800</span>, <span class="hljs-number">1594323000</span>, <span class="hljs-number">1600000000</span>, <span class="hljs-number">1610612736</span>, <span class="hljs-number">1612431360</span>, <span class="hljs-number">1620000000</span>, <span class="hljs-number">1632586752</span>, <span class="hljs-number">1638400000</span>, <span class="hljs-number">1640250000</span>, <span class="hljs-number">1658880000</span>, <span class="hljs-number">1660753125</span>, <span class="hljs-number">1677721600</span>, <span class="hljs-number">1679616000</span>, <span class="hljs-number">1687500000</span>, <span class="hljs-number">1698693120</span>, <span class="hljs-number">1700611200</span>, <span class="hljs-number">1708593750</span>, <span class="hljs-number">1719926784</span>, <span class="hljs-number">1721868840</span>, <span class="hljs-number">1728000000</span>, <span class="hljs-number">1749600000</span>, <span class="hljs-number">1757812500</span>, <span class="hljs-number">1769472000</span>, <span class="hljs-number">1771470000</span>, <span class="hljs-number">1791590400</span>, <span class="hljs-number">1793613375</span>, <span class="hljs-number">1800000000</span>, <span class="hljs-number">1811939328</span>, <span class="hljs-number">1813985280</span>, <span class="hljs-number">1822500000</span>, <span class="hljs-number">1836660096</span>, <span class="hljs-number">1843200000</span>, <span class="hljs-number">1845281250</span>, <span class="hljs-number">1866240000</span>, <span class="hljs-number">1875000000</span>, <span class="hljs-number">1887436800</span>, <span class="hljs-number">1889568000</span>, <span class="hljs-number">1898437500</span>, <span class="hljs-number">1911029760</span>, <span class="hljs-number">1913187600</span>, <span class="hljs-number">1920000000</span>, <span class="hljs-number">1934917632</span>, <span class="hljs-number">1937102445</span>, <span class="hljs-number">1944000000</span>, <span class="hljs-number">1953125000</span>, <span class="hljs-number">1966080000</span>, <span class="hljs-number">1968300000</span>, <span class="hljs-number">1990656000</span>, <span class="hljs-number">1992903750</span>, <span class="hljs-number">2000000000</span>, <span class="hljs-number">2013265920</span>, <span class="hljs-number">2015539200</span>, <span class="hljs-number">2025000000</span>, <span class="hljs-number">2038431744</span>, <span class="hljs-number">2040733440</span>, <span class="hljs-number">2048000000</span>, <span class="hljs-number">2050312500</span>, <span class="hljs-number">2066242608</span>, <span class="hljs-number">2073600000</span>, <span class="hljs-number">2097152000</span>, <span class="hljs-number">2099520000</span>, <span class="hljs-number">2109375000</span>, <span class="hljs-number">2123366400</span>, <span class="hljs-number">2125764000</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>O(1)</p><h1 id="50-第一个只出现一次的字符位置"><a href="#50-第一个只出现一次的字符位置" class="headerlink" title="50. 第一个只出现一次的字符位置"></a>50. 第一个只出现一次的字符位置</h1><p><strong>描述</strong></p><p>在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）（从0开始计数）</p><p><strong>思路</strong></p><p>1、用indexOf和lastIndexOf来实现，若找到直接返回下标，若没找到返回-1，indexOf为最先出现的位置，lastIndexOf为最后一次出现的位置。</p><p>2、用Map，Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</p><ul><li>需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li><li>Map中常用的集合为HashMap集合、LinkedHashMap集合。</li></ul><p><strong>解法1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">FirstNotRepeatingChar</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;                    <span class="hljs-keyword">if</span>(str.indexOf(str.charAt(i)) != str.lastIndexOf(str.charAt(i)))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解法2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] charS = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> word : charS) &#123;<br>            <span class="hljs-keyword">if</span> (!map.containsKey(word)) &#123;<br>                map.put(word, <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(word, map.get(word) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> word : charS) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(word) == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> word;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a>51. 数组中的逆序对</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;<br>        merge(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            merge(nums, left, mid);<br>            merge(nums, mid + <span class="hljs-number">1</span>, right);<br>            mergeSort(nums, left, mid, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span>[] temparr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> left, temp2 = mid + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (temp1 &lt;= mid &amp;&amp; temp2 &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[temp1] &lt;= nums[temp2]) &#123;<br>                temparr[index++] = nums[temp1++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//用来统计逆序对的个数</span><br>                count += (mid - temp1 + <span class="hljs-number">1</span>);<br>                temparr[index++] = nums[temp2++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//把左边剩余的数移入数组</span><br>        <span class="hljs-keyword">while</span> (temp1 &lt;= mid) &#123;<br>            temparr[index++] = nums[temp1++];<br>        &#125;<br>        <span class="hljs-comment">//把右边剩余的数移入数组</span><br>        <span class="hljs-keyword">while</span> (temp2 &lt;= right) &#123;<br>            temparr[index++] = nums[temp2++];<br>        &#125;<br>        <span class="hljs-comment">//把新数组中的数覆盖nums数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; temparr.length; k++) &#123;<br>            nums[k + left] = temparr[k];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1614274007-rtFHbG-Picture2.png" alt="Picture2.png"></p><h1 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a>52. 两个链表的第一个公共节点</h1><p>输入两个链表，找出它们的第一个公共节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curA</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curB</span> <span class="hljs-operator">=</span> headB;<br><br>        <span class="hljs-keyword">while</span>(curA != curB) &#123;<br>            curA = curA == <span class="hljs-literal">null</span> ? headB : curA.next;<br>            curB = curB == <span class="hljs-literal">null</span> ? headA : curB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> curA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个对称拼接后，找相同的思想。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">0,9,1,2,4<br>3,2,4<br><br>A: 0,9,1,2,4,3,2,4<br>B: 3,2,4,0,9,1,2,4<br><br>same: 2,4<br></code></pre></td></tr></table></figure><h1 id="53-在排序数组中查找数字-I"><a href="#53-在排序数组中查找数字-I" class="headerlink" title="53. 在排序数组中查找数字-I"></a>53. 在排序数组中查找数字-I</h1><p>统计一个数字在排序数组中出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == target) &#123;<br>                <span class="hljs-keyword">if</span> (!map.containsKey(target))&#123;<br>                    map.put(target, <span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    map.put(target, map.get(target)+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(target)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> map.get(target);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>easy题没啥说的</p><h1 id="53-0～n-1中缺失的数字"><a href="#53-0～n-1中缺失的数字" class="headerlink" title="53. 0～n-1中缺失的数字"></a>53. 0～n-1中缺失的数字</h1><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">missingNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m] == m) l = m + <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果正常找到的话 l = 右子数组的开始元素</span><br>            <span class="hljs-keyword">else</span> r = m - <span class="hljs-number">1</span>; <span class="hljs-comment">// 没找到那就是让 r = 左子数组的末位元素，此时直接 r &lt; l 了退出循环了。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于有序的数组, 都应该想到用二分法搜索。</p><p>缺失的数字等于 “右子数组的首位元素” 对应的索引。</p><p>其实可以在循环内部就return的但这样不符合一个程序的执行，就没有出口了，所以我们要统计他的出口公式最后再return。</p><p>总结一下i &lt;= j时候的用法</p><p><code>while(i &lt;= j) 搜索的是闭区间 [i, j]，也就是说闭区间内的每一个元素都会被搜索，循环退出时 i = j + 1。while(i &lt; j) 搜索的是左闭右开区间 [i, j)，也就是说区间内除了 j 指向的每一个元素都会被搜索，循环退出时 i = j。你根据具体问题，先明确下希望搜索的范围再决定用哪种，有的用哪种都可以，有的只能用其中一种。比如这题，搜索范围是[0, n - 1]，也可以写成 [0, n)。明白了这个之后，想怎么用就怎么用了，比如我就喜欢用左闭右开区间。</code></p><h1 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54. 二叉搜索树的第k大节点"></a>54. 二叉搜索树的第k大节点</h1><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// clarification:  root == null?   k &lt;= 1?</span><br>        helper(root, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) helper(root.right, k);<br>        <br>        <span class="hljs-keyword">if</span> (++count == k) &#123;<br>            ans = root.val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) helper(root.left, k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="55-二叉树的深度-I"><a href="#55-二叉树的深度-I" class="headerlink" title="55. 二叉树的深度-I"></a>55. 二叉树的深度-I</h1><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nLeft</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nRight</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br>        <span class="hljs-keyword">return</span> nLeft &gt; nRight ? nLeft + <span class="hljs-number">1</span> : nRight + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="55-平衡二叉树"><a href="#55-平衡二叉树" class="headerlink" title="55. 平衡二叉树"></a>55. 平衡二叉树</h1><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nLeft</span> <span class="hljs-operator">=</span> dfs(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nRight</span> <span class="hljs-operator">=</span> dfs(root.right);<br>        <span class="hljs-keyword">if</span> (Math.abs(nLeft - nRight) &gt; <span class="hljs-number">1</span>) res = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> nLeft &gt; nRight ? nLeft + <span class="hljs-number">1</span> : nRight + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考 二叉树深度 这道题。不同的是条件变了。我需要时刻判断他的左右树高差距不能大于1。开头不用判断root是否为0，因为只要判断什么是错的就可以。</p><h1 id="56-数组中数字出现的次数-I（不会）"><a href="#56-数组中数字出现的次数-I（不会）" class="headerlink" title="56. 数组中数字出现的次数-I（不会）"></a>56. 数组中数字出现的次数-I（不会）</h1><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumbers(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-comment">// 首先先了解下异或运算 ^ ，异或运算也叫做无进位相加，比如 10 ^ 01 = 00。因为1+0=1，这时候当成没有进位，结果就是0。</span><br>        <span class="hljs-comment">// 异或运算满足交换律、结合律。a ^ b = b ^ a   (a ^ b) ^ c = a ^ (b ^ c)</span><br>        <span class="hljs-comment">// 相同的数字异或为0，0与任何数字异或，结果是它本身，所以全体数字异或后，z就等于两个只出现一次的数字异或值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            z ^= num;<br>        &#125;<br>        <span class="hljs-comment">// 此时z = x ^ y</span><br>        <span class="hljs-comment">// 因为 x和y不相同，所以z中至少有一位为1，否则就为0了。</span><br>        <span class="hljs-comment">// 现在我们寻找这个1。如果有多个1，寻找最低位就行。</span><br>        <span class="hljs-comment">// 这里定义了一个变量m，初始化为1，二进制为(0001)。然后如果最低位和z与运算。结果为0，说明z最低位就为0。</span><br>        <span class="hljs-comment">// m左移一位（乘2）变成2,2的二进制为(0010)。这里判断倒数第二位z和m与运算，等于0吗，等于继续左移，否则就停止。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> ((m &amp; z) == <span class="hljs-number">0</span>) &#123;<br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 此时m的二进制有一位是1，因为x和y不同，这里的不同就体现在了这个1位置上。</span><br>        <span class="hljs-comment">// x和y在这个1位置上肯定有一个是1，另外一个是0。否则都是1或者都是0，那么异或结果不就是0么。</span><br>        <span class="hljs-comment">// 这时候初始化一个x，一个y。x代表这一位上为0的出现一次的数字，y代表这一位上为1的出现一次的数字。</span><br>        <span class="hljs-comment">// 一个数字在这一位要么为0，要么为1。因为二进制嘛。所以其他的数字也会来凑热闹。</span><br>        <span class="hljs-comment">// 但是无妨，因为我们用的是异或，相同的数字出现两次就为0了。（用异或的性质）</span><br>        <span class="hljs-comment">// 比如：nums： 4        1       4       6</span><br>        <span class="hljs-comment">//            0100      0001    0100    0110</span><br>        <span class="hljs-comment">// 我们得到了m为1，也就是(0001)。最低位为0的数字有 4、 4、 6</span><br>        <span class="hljs-comment">// 最低位为1的数字有 0001.</span><br>        <span class="hljs-comment">// x = 4 ^ 4 ^ 6 = 6</span><br>        <span class="hljs-comment">// y = 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num: nums) &#123;<br>            <span class="hljs-keyword">if</span> ((num &amp; m) == <span class="hljs-number">0</span>) &#123;<br>                x ^= num;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                y ^= num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;x, y&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>位运算相加。不会。</p><p><img src="https://pic.leetcode-cn.com/1614836837-oygHyk-Picture2.png" alt="Picture2.png"></p><h1 id="56-数组中数字出现的次数-II"><a href="#56-数组中数字出现的次数-II" class="headerlink" title="56. 数组中数字出现的次数-II"></a>56. 数组中数字出现的次数-II</h1><h1 id="57-和为s的两个数字"><a href="#57-和为s的两个数字" class="headerlink" title="57. 和为s的两个数字"></a>57. 和为s的两个数字</h1><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">if</span> (nums[l] + nums[r] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nums[l], nums[r]&#125;;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[l] + nums[r] &gt; target) &#123;<br>                r--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[l] + nums[r] &lt; target) &#123;<br>                l++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到递增排序，就直接双指针和二分查找。</p><h1 id="57-和为s的连续正数序列"><a href="#57-和为s的连续正数序列" class="headerlink" title="57. 和为s的连续正数序列"></a>57. 和为s的连续正数序列</h1><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] findContinuousSequence(<span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, r = <span class="hljs-number">2</span>, s = <span class="hljs-number">3</span>;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-keyword">if</span>(s == target) &#123;<br>                <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r - l + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> l; k &lt;= r; k++)<br>                    ans[k - l] = k;<br>                res.add(ans);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s &gt;= target) &#123;<br>                s -= l;<br>                l++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r++;<br>                s += r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>][]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1611495306-LsrxgS-Picture2.png" alt="Picture2.png"></p><h1 id="58-翻转单词顺序-I"><a href="#58-翻转单词顺序-I" class="headerlink" title="58. 翻转单词顺序-I"></a>58. 翻转单词顺序-I</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        s = s.trim(); <span class="hljs-comment">// 删除首尾空格</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>, i = j;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>) i--; <span class="hljs-comment">// 搜索首个空格</span><br>            res.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 添加单词</span><br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) i--; <span class="hljs-comment">// 跳过单词间空格</span><br>            j = i; <span class="hljs-comment">// j 指向下个单词的尾字符</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim(); <span class="hljs-comment">// 转化为字符串并返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从后往前找，这样他就是反着的顺序。i+1的原因是我们找到非空才停止，j+1是因为左闭右开。</p><h1 id="58-左旋字符串-II"><a href="#58-左旋字符串-II" class="headerlink" title="58. 左旋字符串-II"></a>58. 左旋字符串-II</h1><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> s.substring(<span class="hljs-number">0</span>, n);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.substring(n, s.length());<br>        <span class="hljs-keyword">return</span> s2 + s1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是一个拼接字符串。</p><h1 id="59-滑动窗口的最大值-I"><a href="#59-滑动窗口的最大值-I" class="headerlink" title="59. 滑动窗口的最大值-I"></a>59. 滑动窗口的最大值-I</h1><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(!queue.isEmpty() &amp;&amp; i - queue.peek() &gt;= k) &#123;<br>                queue.poll();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()]) &#123;<br>                queue.pollLast();<br>            &#125;<br>            queue.offer(i);<br>            <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                res[j++] = nums[queue.peek()];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>审题！一定注意人家求的是当前窗口下的最大值是多少。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/12/hello-world/"/>
    <url>/2022/04/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
